<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="mysql入门, 阿培">
    <meta name="description" content="SQL概述SQL，一般发音为sequel，SQL的全称Structured Query Language),SQL用来和数据库打交道，完成和数据库的通信，SQL是一套标准。但是每一个数据库都有自己的特性别的数据库没有，当使用这个数据库特性相">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>mysql入门 | 阿培</title>
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">阿培</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">阿培</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        mysql入门
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/mysql/">
                                <span class="chip bg-color">mysql</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                数据库
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-06-21
                </div>
                

                

                

                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>SQL概述<br>SQL，一般发音为sequel，SQL的全称Structured Query Language),SQL用来和数据库打交道，完成和数据库的通信，SQL是一套标准。但是每一个数据库都有自己的特性别的数据库没有，当使用这个数据库特性相关的功能，这时SQL语句可能就不是标准了(90%以上的SQL都是通用的)</p>
<p>什么是数据库<br>数据库，通常是一个或一组文件，保存了一些符合特定规格的数据，数据库对应的英语单词是DataBase,简称DB，数据库软件称为数据库管理系统(DBMS)，全称为DataBase Management System,如：Oracle、SQL Server、MySQL、Sybase、Informix、 DB2、interbase 、PostgreSql</p>
<p>MySql概述<br>MySQL最初是由”MySQL AB”公司开发的一套关系型数据库管理系统(RDBMS-Relation Database Management System).MySQL不仅是最流行的开源数据库，而且是业界成长最快的数据库，每天有超过7万次的下载量，其应用范围从大型企业到专有的嵌入应用系统。<br>MySQL</p>
<p>查询建表语句：<br>show create table 表名;<br>show create table draw_company_result; </p>
<blockquote>
<p>CREATE TABLE <code>draw_company_result</code> (<br>  <code>draw_id</code> varchar(30) NOT NULL,<br>  <code>game_code</code> varchar(10) NOT NULL DEFAULT ‘’,<br>  <code>company</code> varchar(30) NOT NULL,<br>  <code>result</code> varchar(255) DEFAULT ‘’,<br>  <code>operator</code> varchar(255) DEFAULT NULL,<br>  <code>operatortime</code> datetime DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (<code>draw_id</code>,<code>game_code</code>,<code>company</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8</p>
</blockquote>
<p>查询表的单个字段<br>user openfire;<br>select username from ofUser;<br>select username, name, email from ofUser;</p>
<p>查询重命名表名，并不能修改真正的修改表名</p>
<p>mysql&gt; select username, encryptedPassword from ofUser;<br>+———-+————————————————–+<br>| username | encryptedPassword                                |<br>+———-+————————————————–+<br>| admin    | 61a46ea4fb839834cc6e88519e28a5e353a96d402957e094 |<br>| gang     | 269d01e7a82a1cd51642e1e574357bf30e4ad174f3f26bde |<br>| jia      | 248be0a8c9a505221bf7a0a7523521119cfaa2bfa288a106 |<br>| jian     | 65b416288a78bac5732531ff33565860e71a203d9974de4c |<br>| pei      | 4242b7cb67849778199f189d97010b24291c03d8cab70a41 |<br>+———-+————————————————–+<br>5 rows in set (0.00 sec)</p>
<p>mysql&gt; select username,encryptedPassword as passwd from ofUser;<br>+———-+————————————————–+<br>| username | passwd                                           |<br>+———-+————————————————–+<br>| admin    | 61a46ea4fb839834cc6e88519e28a5e353a96d402957e094 |<br>| gang     | 269d01e7a82a1cd51642e1e574357bf30e4ad174f3f26bde |<br>| jia      | 248be0a8c9a505221bf7a0a7523521119cfaa2bfa288a106 |<br>| jian     | 65b416288a78bac5732531ff33565860e71a203d9974de4c |<br>| pei      | 4242b7cb67849778199f189d97010b24291c03d8cab70a41 |<br>+———-+————————————————–+<br>5 rows in set (0.00 sec)<br>注意：可以写成 select username,encryptedPassword  passwd from ofUser;<br>省去as关键字也是可以的<br>注意：字符串用单引号</p>
<p>条件查询:<br>条件查询需要用到where语句，where必须放到from语句表的后面<br>支持如下运算符<br>运算符                      说明<br>=                          等于<br>&lt;&gt;或!=                    不等于<br>&lt;                          小于<br>&lt;=                          小于等于</p>
<blockquote>
<pre><code>                    大于</code></pre><p>=                        大于等于<br>between … and …       两个值之间,等同于&gt;= and &lt;=<br>is null                   为null(is not null 不为空)<br>and                          并且<br>or                          或者<br>in                        包含，相当于多个or(not in不在这个范围中)<br>not                       not可以取非，主要用在is 或者in中<br>like                      like 称为模糊查询，支持%或下划线匹配<br>str_to_date                将字符串转换日期<br>date_format                  格式化日期<br>format                      设置千分位<br>round                      四舍五入<br>rand()                      生成随机数<br>Ifnull                      可以将null转换成一个具体值</p>
</blockquote>
<p>mysql&gt; select username,name,creationDate as crtDate from ofUser where email=’123@qq.com’;<br>+———-+——+—————–+<br>| username | name | crtDate         |<br>+———-+——+—————–+<br>| gang     | gang | 001560644570688 |<br>+———-+——+—————–+<br>1 row in set (0.00 sec)</p>
<p>找出工资大于1800的员工，要求部门编号是20或者30的。</p>
<p>select<br>    empno,enmae,sal,deptno<br>from<br>    emp<br>where<br>    sal &gt; 1800 and (deptno = 20 or deptno =30);<br>    mysql&gt; SELECT EMPNO,ENAME,SAL,DEPTNO FROM EMP WHERE SAL&gt;1800 AND (DEPTNO =20 OR DEPTNO = 30);<br>    +——-+——-+———+——–+<br>    | EMPNO | ENAME | SAL     | DEPTNO |<br>    +——-+——-+———+——–+<br>    |  7566 | JONES | 2975.00 |     20 |<br>    |  7698 | BLAKE | 2850.00 |     30 |<br>    |  7782 | CLARK | 2450.00 |     20 |<br>    |  7788 | SCOTT | 3000.00 |     20 |<br>    |  7902 | FORD  | 3000.00 |     20 |<br>    +——-+——-+———+——–+<br>    5 rows in set (0.00 sec)</p>
<p>查找出某个字段对应的数据中T字母结尾的：<br>mysql&gt; select ENAME FROM EMP WHERE ENAME LIKE ‘%T’;<br>+——-+<br>| ENAME |<br>+——-+<br>| SCOTT |<br>+——-+<br>1 row in set (0.00 sec)</p>
<p>查找出某个字段对应的数据中第二个字母是A的：<br>mysql&gt; select ENAME FROM EMP WHERE ENAME LIKE ‘_A%’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| WARD   |<br>| MARTIN |<br>| JAMES  |<br>+——–+<br>3 rows in set (0.00 sec)</p>
<p>查找出某个字段对应的数据中里面含有A的：<br>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME LIKE ‘%A%’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| ALLEN  |<br>| WARD   |<br>| MARTIN |<br>| BLAKE  |<br>| CLARK  |<br>| ADAMS  |<br>| JAMES  |<br>+——–+<br>7 rows in set (0.00 sec)</p>
<p>注意：%代表任意多个字符，_代表任意单个字符</p>
<p>注意：Null为空，但不是空串</p>
<p>排序 order by<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p>
<p>默认升序排序<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL asc;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p>
<p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| KING   | 5000.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| SMITH  |  800.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)<br>DESC:     降序排序</p>
<p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC,ENAME ASC;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| KING   | 5000.00 |<br>| FORD   | 3000.00 |<br>| SCOTT  | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>| MARTIN | 1250.00 |<br>| WARD   | 1250.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| SMITH  |  800.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p>
<p>单一字段排序<br>排序采用order by子句，order by后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序，如果存在where子句，那么order by<br>必须放到where语句的后面</p>
<ul>
<li>按照薪水由小到大排序(系统默认由小到大)<br>mysql&gt; SELECT * FROM EMP ORDER BY SAL;</li>
</ul>
<p>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+<br>14 rows in set (0.00 sec)</p>
<p>使用字段的位置来排序<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY 2;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+</p>
<p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY 1;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| ADAMS  | 1100.00 |<br>| ALLEN  | 1600.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| FORD   | 3000.00 |<br>| JAMES  |  950.00 |<br>| JONES  | 2975.00 |<br>| KING   | 5000.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| SCOTT  | 3000.00 |<br>| SMITH  |  800.00 |<br>| TURNER | 1500.00 |<br>| WARD   | 1250.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p>
<p>数据处理函数/单行处理函数</p>
<p>Lower        转换小写<br>upper        转换大写<br>substr        取字串(substr(被截取的字符串，起始下标，截取的长度))<br>length        取长度<br>trim        去空格</p>
<p>将查询结果显示小写</p>
<p>mysql&gt; SELECT lower(ENAME) as ename from EMP;<br>+——–+<br>| ename  |<br>+——–+<br>| smith  |<br>| allen  |<br>| ward   |<br>| jones  |<br>| martin |<br>| blake  |<br>| clark  |<br>| scott  |<br>| king   |<br>| turner |<br>| adams  |<br>| james  |<br>| ford   |<br>| miller |<br>+——–+<br>14 rows in set (0.00 sec)</p>
<p>mysql&gt; SELECT upper(ENAME) as ename from EMP;<br>+——–+<br>| ename  |<br>+——–+<br>| SMITH  |<br>| ALLEN  |<br>| WARD   |<br>| JONES  |<br>| MARTIN |<br>| BLAKE  |<br>| CLARK  |<br>| SCOTT  |<br>| KING   |<br>| TURNER |<br>| ADAMS  |<br>| JAMES  |<br>| FORD   |<br>| MILLER |<br>+——–+<br>14 rows in set (0.00 sec)</p>
<p>mysql&gt; select username from ofUser;<br>+———-+<br>| username |<br>+———-+<br>| admin    |<br>| pei      |<br>| gang     |<br>| jian     |<br>| jia      |<br>+———-+<br>5 rows in set (0.00 sec)</p>
<p>mysql&gt; select upper(username) from ofUser;<br>+—————–+<br>| upper(username) |<br>+—————–+<br>| ADMIN           |<br>| PEI             |<br>| GANG            |<br>| JIAN            |<br>| JIA             |<br>+—————–+<br>5 rows in set (0.00 sec)</p>
<p>mysql&gt; select upper(username) as username from ofUser;<br>+———-+<br>| username |<br>+———-+<br>| ADMIN    |<br>| PEI      |<br>| GANG     |<br>| JIAN     |<br>| JIA      |<br>+———-+<br>5 rows in set (0.00 sec)</p>
<p>substr(args1,args2,args3)<br>args1参数为字段名，<br>args2参数为起始下标，<br>args3参数为截取的长度</p>
<p>查找表emp中字段ename中第二个字母为A的：<br>之前的方法：<br>    mysql&gt; SELECT ENAME FROM EMP WHERE ENAME LIKE ‘_A%’;<br>    +——–+<br>    | ENAME  |<br>    +——–+<br>    | WARD   |<br>    | MARTIN |<br>    | JAMES  |<br>    +——–+<br>    3 rows in set (0.00 sec)</p>
<p>substr()函数的方法：<br>    mysql&gt; SELECT ENAME FROM EMP WHERE substr(ENAME,2,1) = ‘A’;<br>    +——–+<br>    | ENAME  |<br>    +——–+<br>    | WARD   |<br>    | MARTIN |<br>    | JAMES  |<br>    +——–+<br>    3 rows in set (0.00 sec)</p>
<p>length(args1)</p>
<p>select length(ename) from emp;</p>
<p>trim  去除查询中输入的空格<br>mysql&gt; SELECT ENAME FROM EMP WHERE substr(ENAME,2,1) = ‘A’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| WARD   |<br>| MARTIN |<br>| JAMES  |<br>+——–+<br>3 rows in set (0.00 sec)</p>
<p>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME=’ SMITH ‘;<br>Empty set (0.00 sec)</p>
<p>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME = trim(‘ SMITH ‘);<br>+——-+<br>| ENAME |<br>+——-+<br>| SMITH |<br>+——-+<br>1 row in set (0.00 sec)</p>
<p>补助为空的显示为0<br>mysql&gt; SELECT ENAME,ifnull(comm,0) as comm from EMP;<br>+——–+———+<br>| ENAME  | comm    |<br>+——–+———+<br>| SMITH  |    0.00 |<br>| ALLEN  |  300.00 |<br>| WARD   |  500.00 |<br>| JONES  |    0.00 |<br>| MARTIN | 1400.00 |<br>| BLAKE  |    0.00 |<br>| CLARK  |    0.00 |<br>| SCOTT  |    0.00 |<br>| KING   |    0.00 |<br>| TURNER |    0.00 |<br>| ADAMS  |    0.00 |<br>| JAMES  |    0.00 |<br>| FORD   |    0.00 |<br>| MILLER |    0.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p>
<p>mysql&gt; SELECT ENAME,(SAL+ifnull(comm,0))*12 as yearsal from EMP;<br>+——–+———-+<br>| ENAME  | yearsal  |<br>+——–+———-+<br>| SMITH  |  9600.00 |<br>| ALLEN  | 22800.00 |<br>| WARD   | 21000.00 |<br>| JONES  | 35700.00 |<br>| MARTIN | 31800.00 |<br>| BLAKE  | 34200.00 |<br>| CLARK  | 29400.00 |<br>| SCOTT  | 36000.00 |<br>| KING   | 60000.00 |<br>| TURNER | 18000.00 |<br>| ADAMS  | 13200.00 |<br>| JAMES  | 11400.00 |<br>| FORD   | 36000.00 |<br>| MILLER | 15600.00 |<br>+——–+———-+<br>14 rows in set (0.00 sec)</p>
<p>0     先了解一下数据库中的数据类型：<br>    int            整数型<br>    varchar        可变长度字符串<br>    char        定长字符串<br>    date        日期类型<br>    double        浮点类型</p>
<ol>
<li><p>关于MYSQL中的日期处理<br> 1.1  每一个数据库处理日期的时候，采用的机制都是不同的，日期处理都有自己的一套机制。<br> 所有在实际的开发中，表中的字段定义为DATE类型，这种情况很少。因为一旦使用日期类型，那么java程序将不能够通用。在实际开发中，一般使用日期字符串来表示日期<br> 1.2  日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以还是需要掌握。</p>
<pre><code>     -     str_to_date
     -    date_format

 str_to_date:     该函数的作用是：将“日期字符串”转换成“日期类型”的数据 【varchar  ----&gt; date】
                 该函数的执行结果是DATE类型
                 该函数的使用格式：
                     str_to_date(&#39;日期字符串&#39;,&#39;日期格式&#39;)
                 关于MYSQL中的日期格式：
                         回顾java中的日期格式：
                             yyyy    年
                             MM        月
                             dd        日
                             HH        时
                             mm        分
                             ss        秒
                             SSS        毫秒

                 java中将字符串转换成日期类型：
                     SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
                     Date date = sdf.parse(&quot;1970-10-10&quot;);

                 MySQL的日期格式：
                     %Y          年
                     %m            月
                     %d            日
                     %H            时
                     %i            分
                     %s            秒</code></pre></li>
</ol>
<p>MYSQL默认的日期格式： %Y-%m-%d              </p>
<pre><code>        案例： 查询出1980-12-17入职的员工
                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE = &#39;1980-12-17&#39;;
                +-------+------------+
                | ENAME | HIREDATE   |
                +-------+------------+
                | SMITH | 1980-12-17 |
                +-------+------------+
                1 row in set (0.01 sec)

                等同如下SQL命令:
                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE = str_to_date(&#39;1980-12-17&#39;,&#39;%Y-%m-%d&#39;);
                +-------+------------+
                | ENAME | HIREDATE   |
                +-------+------------+
                | SMITH | 1980-12-17 |
                +-------+------------+
                1 row in set (0.00 sec)


                MYSQL默认的日期格式： %Y-%m-%d，以上的日期字符串&#39;1980-12-17&#39;正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。

                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE=&#39;12-17-1980&#39;;
                Empty set, 1 warning (0.00 sec)

                &#39;12-17-1980&#39;日期字符串和mysql默认的日期格式不同
                hiredate是date类型，&#39;12-17-1980&#39;是一个字符串varchar类型，类型不匹配.
                所以无法查询结果，并且有警告方法。

                纠正以上SQL语句的错误：
                select ENAME, HIREDATE from EMP where HIREDATE = str_to_date(&#39;12-17-1980&#39;,%d-%m-%Y);
                mysql&gt; select version();
                +-----------+
                | version() |
                +-----------+
                | 5.7.26    |
                +-----------+
                1 row in set (0.00 sec)

                mysql&gt; select ENAME, HIREDATE from EMP where HIREDATE = str_to_date(&#39;12-17-1980&#39;,%d-%m-%Y);
                ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;%d-%m-%Y)&#39; at line 1
                在5.7.26中没有测试通过


        3.6  案例：
            创建学生表: 【create 语句，以后详细讲】
            create table t_student(
                id int(10),
                name varchar(32),
                birth date
            );

            插入数据：【insert语句，以后详细讲】
            insert into t_student(id,name,birth) values(1,&#39;jack&#39;,&#39;1980-10-11&#39;);
            以上可以执行，因为&#39;1980-10-11&#39;虽然是一个varchar类型，但是由于格式和MYSQL数据库默认的日期格式相同，所以存在自动类型转换.

            mysql&gt;insert into t_student(id,name,birth) values(2,&#39;zhangsan&#39;,&#39;10-11-1970&#39;);
            ERROR 1292(22007):Incorrect date value:&#39;10-11-1970&#39; for column &#39;birth&#39; at row 1 以上发生错误：
                    第一：&#39;10-11-1970&#39;日期字符串的格式和mysql默认的格式不同
                    第二：&#39;10-11-1970&#39;是varchar类型，birth字段需要date类型，类型不匹配.
                    纠正以上错误：
                    insert into t_student(id,name,birth) values(2,&#39;zhangsan&#39;,str_to_date(&#39;10-11-1970&#39;,&#39;%m-%d-%Y&#39;));
    str_to_date函数通常使用在插入操作中，字段是date类型，不接收字符串varchar类型。
    需要通过该函数将varchar变成date再插入数据，才能成功。

date_format:
    该函数的作用是：将&quot;日期类型date&quot;转换成具有特定格式的日期字符串varchar【date---&gt;varchar】
    该函数的运算结果是:varchar类型【具备特定格式的】
    该函数的语法格式：
    date_format(日期类型数据,&#39;日期格式&#39;)

    回顾java中的日期格式化：
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            Date nowTime = new Date();
            String strTime = sdf.format(newTime);

        案例：查询员工的入职日期，以&#39;10-12-1980&#39;的格式显示到窗口中。
            mysql&gt; SELECT ENAME, date_format(hiredate,&#39;%m-%d-%Y&#39;) as HIREDATE  from EMP;
            +--------+------------+
            | ENAME  | HIREDATE   |
            +--------+------------+
            | SMITH  | 12-17-1980 |
            | ALLEN  | 02-20-1981 |
            | WARD   | 02-22-1981 |
            | JONES  | 04-02-1981 |
            | MARTIN | 09-28-1981 |
            | BLAKE  | 05-01-1981 |
            | CLARK  | 06-09-1981 |
            | SCOTT  | 04-19-1987 |
            | KING   | 11-17-1981 |
            | TURNER | 09-08-1981 |
            | ADAMS  | 05-23-1987 |
            | JAMES  | 12-03-1981 |
            | FORD   | 12-03-1981 |
            | MILLER | 01-23-1982 |
            +--------+------------+
            14 rows in set (0.00 sec)


        以下两个DQL语句的执行结果相同：
        select ename,hiredate from emp; 【hiredate自动转换成varchar类型，并且采用 %Y-%m-%d 格式】
            mysql&gt; SELECT ENAME, HIREDATE FROM EMP;
            +--------+------------+
            | ENAME  | HIREDATE   |
            +--------+------------+
            | SMITH  | 1980-12-17 |
            | ALLEN  | 1981-02-20 |
            | WARD   | 1981-02-22 |
            | JONES  | 1981-04-02 |
            | MARTIN | 1981-09-28 |
            | BLAKE  | 1981-05-01 |
            | CLARK  | 1981-06-09 |
            | SCOTT  | 1987-04-19 |
            | KING   | 1981-11-17 |
            | TURNER | 1981-09-08 |
            | ADAMS  | 1987-05-23 |
            | JAMES  | 1981-12-03 |
            | FORD   | 1981-12-03 |
            | MILLER | 1982-01-23 |
            +--------+------------+
            14 rows in set (0.00 sec)

        select ename,date_format(hiredate,&#39;%Y-%m-%d&#39;) as hiredate from emp;
        mysql&gt; SELECT ENAME,date_format(HIREDATE,&#39;%Y-%m-%d&#39;) as HIREDATE FROM EMP;
        +--------+------------+
        | ENAME  | HIREDATE   |
        +--------+------------+
        | SMITH  | 1980-12-17 |
        | ALLEN  | 1981-02-20 |
        | WARD   | 1981-02-22 |
        | JONES  | 1981-04-02 |
        | MARTIN | 1981-09-28 |
        | BLAKE  | 1981-05-01 |
        | CLARK  | 1981-06-09 |
        | SCOTT  | 1987-04-19 |
        | KING   | 1981-11-17 |
        | TURNER | 1981-09-08 |
        | ADAMS  | 1987-05-23 |
        | JAMES  | 1981-12-03 |
        | FORD   | 1981-12-03 |
        | MILLER | 1982-01-23 |
        +--------+------------+
        14 rows in set (0.00 sec)

        结论：date_format函数主要使用在查询操作中，客户需要日期以特定格式展示的时候，需要用到该函数。</code></pre><p>分组函数/聚合函数/多行处理函数<br>注意：分组函数不能直接使用在where子句中<br>count         取得记录数<br>sum            求和<br>avg            取平均<br>max            取最大的数<br>min            取最小的数<br>注意：分组函数自动忽略空值，不需要手动的加where条件排除控制<br>select count(*) from emp where xxx;符合条件的所有记录总数<br>select count(comm) from emp; comm这个字段中不为空的元素总数<br>注意：分组函数不能直接使用在where关键字后面</p>
<p>distinct关键字  去除重复记录<br>注意：distinct只能放到所有字段最前面<br>    mysql&gt; SELECT JOB FROM EMP;<br>    +———–+<br>    | JOB       |<br>    +———–+<br>    | CLERK     |<br>    | SALESMAN  |<br>    | SALESMAN  |<br>    | MANAGER   |<br>    | SALESMAN  |<br>    | MANAGER   |<br>    | MANAGER   |<br>    | ANALYST   |<br>    | PRESIDENT |<br>    | SALESMAN  |<br>    | CLERK     |<br>    | CLERK     |<br>    | ANALYST   |<br>    | CLERK     |<br>    +———–+<br>    14 rows in set (0.00 sec)</p>
<pre><code>mysql&gt; SELECT distinct JOB FROM EMP;
+-----------+
| JOB       |
+-----------+
| CLERK     |
| SALESMAN  |
| MANAGER   |
| ANALYST   |
| PRESIDENT |
+-----------+
5 rows in set (0.00 sec)

mysql&gt; SELECT DEPTNO,JOB FROM EMP;
+--------+-----------+
| DEPTNO | JOB       |
+--------+-----------+
|     20 | CLERK     |
|     30 | SALESMAN  |
|     30 | SALESMAN  |
|     20 | MANAGER   |
|     30 | SALESMAN  |
|     30 | MANAGER   |
|     20 | MANAGER   |
|     20 | ANALYST   |
|     10 | PRESIDENT |
|     30 | SALESMAN  |
|     20 | CLERK     |
|     30 | CLERK     |
|     20 | ANALYST   |
|     10 | CLERK     |
+--------+-----------+
14 rows in set (0.00 sec)

mysql&gt; SELECT distinct DEPTNO,JOB FROM EMP;
+--------+-----------+
| DEPTNO | JOB       |
+--------+-----------+
|     20 | CLERK     |
|     30 | SALESMAN  |
|     20 | MANAGER   |
|     30 | MANAGER   |
|     20 | ANALYST   |
|     10 | PRESIDENT |
|     30 | CLERK     |
|     10 | CLERK     |
+--------+-----------+
8 rows in set (0.00 sec)</code></pre><p>select count(distinct job) from emp;<br>    mysql&gt; SELECT count(distinct JOB) from EMP;<br>    +———————+<br>    | count(distinct JOB) |<br>    +———————+<br>    |                   5 |<br>    +———————+<br>    1 row in set (0.00 sec)</p>
<p>分组查询：<br>    分组查询主要涉及两个子句，分别是：group by和 having<br>    group by 分组查询<br>            order by 【表示通过哪个或者哪些字段进行排序】<br>            group by 【表示通过哪个或者哪些字段进行分组】<br>    2.2    案例：找出每个工作岗位的最高薪水 【先按照工作岗位分组，使用max求每一组的最高薪水】<br>        select<br>                max(sal)<br>        from<br>                emp<br>        group by<br>                job;<br>        mysql&gt; SELECT max(SAL) FROM EMP GROUP BY JOB;<br>        +———-+<br>        | max(SAL) |<br>        +———-+<br>        |  3000.00 |<br>        |  1300.00 |<br>        |  2975.00 |<br>        |  5000.00 |<br>        |  1600.00 |<br>        +———-+<br>        5 rows in set (0.00 sec)</p>
<pre><code>    以上的SQL语句表示，先按照job分组，然后对每一组使用max(sal)求最高薪水。
    以上查询结果是5条记录。

        工作岗位可以写到select后面吗？
        可以，因为正好工作岗位job也是5个不同的值。
        select 
                job,max(sal)
        from 
                emp
        group by
                job;

        mysql&gt; SELECT JOB,max(SAL) FROM EMP GROUP BY JOB;
        +-----------+----------+
        | JOB       | max(SAL) |
        +-----------+----------+
        | ANALYST   |  3000.00 |
        | CLERK     |  1300.00 |
        | MANAGER   |  2975.00 |
        | PRESIDENT |  5000.00 |
        | SALESMAN  |  1600.00 |
        +-----------+----------+
        5 rows in set (0.00 sec)

    ename可以编写到select后面吗？
            - mysql中，可以，语法在这方面比较松散，不严格，但是查询结果没有意义
            - oracle中，不可以，执行的时候报错。        
        select 
                ename,job,max(sal)
        from
                emp
        group by
                job;

        mysql&gt; select ENAME,JOB,MAX(SAL) FROM EMP GROUP BY JOB;
            ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;bjpowernode.EMP.ENAME&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
            mysql&gt; SELECT ENAME,JOB,max(SAL) from EMP group by JOB;
            ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;bjpowernode.EMP.ENAME&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by


    *重点：若一条SQL语句当中有group by子句，那么select关键子后面只能跟参与分组的字段和分组的函数。*


2.3 案例：计算每个部门的平均薪水【按照部门编号分组，对每一组求平均薪水】
    mysql&gt; select deptno,avg(sal) as avgsal from emp group by deptno;
    mysql&gt; SELECT DEPTNO,avg(SAL) as avgsal FROM EMP GROUP BY DEPTNO;
    +--------+-------------+
    | DEPTNO | avgsal      |
    +--------+-------------+
    |     10 | 3150.000000 |
    |     20 | 2220.833333 |
    |     30 | 1566.666667 |
    +--------+-------------+
    3 rows in set (0.00 sec)

    mysql&gt; SELECT * FROM DEPT;
    +--------+------------+-----------+
    | DEPTNO | DNAME      | LOC       |
    +--------+------------+-----------+
    |     10 | ACCOUNTING | NEW YOURK |
    |     20 | RESEARCH   | DALLAS    |
    |     30 | SALES      | CHICAGO   |
    |     40 | OPERATIONS | BOSTON    |
    +--------+------------+-----------+
    4 rows in set (0.00 sec)

    mysql&gt; SELECT * FROM EMP;
    +-------+--------+-----------+------+------------+---------+---------+--------+
    | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
    +-------+--------+-----------+------+------------+---------+---------+--------+
    |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
    |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
    |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
    |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
    |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
    |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
    |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |
    |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
    |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |
    |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
    |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
    |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
    |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
    |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |
    +-------+--------+-----------+------+------------+---------+---------+--------+


2.4 案例：计算不同部门中的不同岗位的最高薪水
    select deptno,job,max(sal) from emp group by deptno,job;   //deptno,job两个字段联合起来分组。
    mysql&gt; SELECT DEPTNO, JOB,max(SAL) from EMP group by DEPTNO,JOB;
    +--------+-----------+----------+
    | DEPTNO | JOB       | max(SAL) |
    +--------+-----------+----------+
    |     10 | CLERK     |  1300.00 |
    |     10 | PRESIDENT |  5000.00 |
    |     20 | ANALYST   |  3000.00 |
    |     20 | CLERK     |  1100.00 |
    |     20 | MANAGER   |  2975.00 |
    |     30 | CLERK     |   950.00 |
    |     30 | MANAGER   |  2850.00 |
    |     30 | SALESMAN  |  1600.00 |
    +--------+-----------+----------+
    8 rows in set (0.00 sec)



2.5 找出每个工作岗位的最高薪水，除MANAGER之外
    mysql&gt; select job,max(sal) from emp group by job;
        mysql&gt; SELECT JOB,max(SAL) from EMP group by JOB;
        +-----------+----------+
        | JOB       | max(SAL) |
        +-----------+----------+
        | ANALYST   |  3000.00 |
        | CLERK     |  1300.00 |
        | MANAGER   |  2975.00 |
        | PRESIDENT |  5000.00 |
        | SALESMAN  |  1600.00 |
        +-----------+----------+
        5 rows in set (0.00 sec)

    mysql&gt; select job,max(sal) from emp where job&lt;&gt;&#39;MANAGER&#39; group by job;
    mysql&gt; 
    mysql&gt; SELECT JOB,max(SAL) from EMP where JOB&lt;&gt;&#39;MANAGER&#39; GROUP BY JOB;
    +-----------+----------+
    | JOB       | max(SAL) |
    +-----------+----------+
    | ANALYST   |  3000.00 |
    | CLERK     |  1300.00 |
    | PRESIDENT |  5000.00 |
    | SALESMAN  |  1600.00 |
    +-----------+----------+
    4 rows in set (0.00 sec)

2.6 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.
    select job,avg(sal)  from emp group by job;

    select job,avg(sal) from emp where avg(sal)&gt;1500 group by job;
    ERROR 1111(HY00):Invalid user of group function
    where关键字后面不能使用分组函数.
    分组函数必须在分组完成后执行，而分组需要group by,而group by在where后面执行。

注意：下面这个SQL语句执行会报错误：Group function is not allowed here
    找出公司中哪些部门的平均薪水大于6000的列出来：
        select 
                department_id, avg(salary)
        from    
                employees
        where 
                avg(salary)&gt;6000
        group by department_id
        #having avg(salary) &gt;6000
        ;
    原因：
        sql语句的执行顺序为：
            from         子句
            where        子句
            group by     子句
            having         子句
            order by     子句
            select         子句
        首先得知道分组/聚合函数是对结果集运算的，当在where子句使用聚合函数时，此时根据group by分割结果集的子句还没有执行，此时只有from后的结果集。
        所以无法在where子句中使用聚合函数。</code></pre><ol start="3">
<li><p>having</p>
<pre><code>  having 和 where功能都是为了完成数据的过滤
  where和having后面都是添加条件
  *where  在group by之前完成过滤*
  *having 在group by之后完成过滤*
  案例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500
  select 
          job,avg(sal)
  from
          emp
  group by
          job
  having    
      avg(sal)&gt;1500;

  mysql&gt; SELECT JOB,avg(SAL) FROM EMP group by JOB having avg(SAL) &gt;1500;
  +-----------+-------------+
  | JOB       | avg(SAL)    |
  +-----------+-------------+
  | ANALYST   | 3000.000000 |
  | MANAGER   | 2758.333333 |
  | PRESIDENT | 5000.000000 |
  +-----------+-------------+
  3 rows in set (0.00 sec)</code></pre></li>
</ol>
<pre><code>    原则：
            尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。
            效率的问题</code></pre><ol start="4">
<li><p>一个完整的DQL语句的总结<br>  select</p>
<pre><code>      ...</code></pre><p>  from</p>
<pre><code>      ...</code></pre><p>  where</p>
<pre><code>      ...</code></pre><p>  group by</p>
<pre><code>      ...</code></pre><p>  having </p>
<pre><code>      ...</code></pre><p>  order by</p>
<pre><code>      ...</code></pre><p>  第一：以上的关键字顺序不能变，严格遵守<br>  第二：执行顺序</p>
<pre><code>      1.from       从某张表中检索数据
      2.where      经过某条件进行过滤
      3.group by      然后分组
      4.having     分组之后不满意再过滤
      5.select     查询出来
      6.order by   排序输出</code></pre></li>
</ol>
<p>连接查询<br>    1 什么是连接查询？<br>            - 查询的时候只从一张表检索数据，被称为单表查询<br>            - 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中<br>                这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，<br>                这种多表查询被称为连接查询或者叫做跨表查询。<br>    2 连接查询根据出现年代分类：<br>            - SQL92【1992】<br>            - SQL99【1999：更新的语法，主要掌握这种语法】<br>            DBA: DataBase Administrator【数据库管理员，薪水很高】<br>            老的DBA可能还在编写SQL92语法，所以SQL92语法也要会，起码能看懂。<br>    3 连接查询根据连接方式可以分为：<br>            - 内连接<br>                * 等值连接<br>                * 非等值连接<br>                * 自连接<br>            - 外链接<br>                * 左外连接（左连接）<br>                * 右外连接(右连接)<br>            - 全连接【不讲，使用很少】</p>
<pre><code>4 当多张表进行连接查询，若没有任何条件进行限制，会发生什么现象？
    案例：查询每一个员工所在的部门名称，要求最终显示员工名和对应的部门名。
    SELECT ENAME,DEPTNO FROM EMP;&lt;emp是员工表&gt;
    mysql&gt; SELECT ENAME,DEPTNO FROM EMP;
    +--------+--------+
    | ENAME  | DEPTNO |
    +--------+--------+
    | SMITH  |     20 |
    | ALLEN  |     30 |
    | WARD   |     30 |
    | JONES  |     20 |
    | MARTIN |     30 |
    | BLAKE  |     30 |
    | CLARK  |     20 |
    | SCOTT  |     20 |
    | KING   |     10 |
    | TURNER |     30 |
    | ADAMS  |     20 |
    | JAMES  |     30 |
    | FORD   |     20 |
    | MILLER |     10 |
    +--------+--------+
    14 rows in set (0.00 sec)

    SELECT DEPTNO,DNAME FROM DEPT;&lt;dept是部门表&gt;
    mysql&gt; SELECT DEPTNO,DNAME FROM DEPT;
    +--------+------------+
    | DEPTNO | DNAME      |
    +--------+------------+
    |     10 | ACCOUNTING |
    |     20 | RESEARCH   |
    |     30 | SALES      |
    |     40 | OPERATIONS |
    +--------+------------+
    4 rows in set (0.00 sec)

    主要分析：多张表连接查询，若没有任何条件限制，会发生什么？
    小知识点：在进行多表连接查询的时候，尽量给表起别名，这样效率高，可读性高。

    mysql&gt; select e.ENAME,d.DNAME from EMP e,DEPT d;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | ACCOUNTING |
    | SMITH  | RESEARCH   |
    | SMITH  | SALES      |
    | SMITH  | OPERATIONS |
    | ALLEN  | ACCOUNTING |
    | ALLEN  | RESEARCH   |
    | ALLEN  | SALES      |
    | ALLEN  | OPERATIONS |
    | WARD   | ACCOUNTING |
    | WARD   | RESEARCH   |
    | WARD   | SALES      |
    | WARD   | OPERATIONS |
    | JONES  | ACCOUNTING |
    | JONES  | RESEARCH   |
    | JONES  | SALES      |
    | JONES  | OPERATIONS |
    | MARTIN | ACCOUNTING |
    | MARTIN | RESEARCH   |
    | MARTIN | SALES      |
    | MARTIN | OPERATIONS |
    | BLAKE  | ACCOUNTING |
    | BLAKE  | RESEARCH   |
    | BLAKE  | SALES      |
    | BLAKE  | OPERATIONS |
    | CLARK  | ACCOUNTING |
    | CLARK  | RESEARCH   |
    | CLARK  | SALES      |
    | CLARK  | OPERATIONS |
    | SCOTT  | ACCOUNTING |
    | SCOTT  | RESEARCH   |
    | SCOTT  | SALES      |
    | SCOTT  | OPERATIONS |
    | KING   | ACCOUNTING |
    | KING   | RESEARCH   |
    | KING   | SALES      |
    | KING   | OPERATIONS |
    | TURNER | ACCOUNTING |
    | TURNER | RESEARCH   |
    | TURNER | SALES      |
    | TURNER | OPERATIONS |
    | ADAMS  | ACCOUNTING |
    | ADAMS  | RESEARCH   |
    | ADAMS  | SALES      |
    | ADAMS  | OPERATIONS |
    | JAMES  | ACCOUNTING |
    | JAMES  | RESEARCH   |
    | JAMES  | SALES      |
    | JAMES  | OPERATIONS |
    | FORD   | ACCOUNTING |
    | FORD   | RESEARCH   |
    | FORD   | SALES      |
    | FORD   | OPERATIONS |
    | MILLER | ACCOUNTING |
    | MILLER | RESEARCH   |
    | MILLER | SALES      |
    | MILLER | OPERATIONS |
    +--------+------------+
    56 rows in set (0.00 sec)

结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，这种现象被称为笛卡尔积现象。为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件。

5    案例：查询每一个员工所在的部门名称，要求最终显示员工名和对应的部门名。
    mysql&gt; SELECT ENAME,DEPTNO FROM EMP;   &lt;EMP是员工表&gt;
    +--------+--------+
    | ENAME  | DEPTNO |
    +--------+--------+
    | SMITH  |     20 |
    | ALLEN  |     30 |
    | WARD   |     30 |
    | JONES  |     20 |
    | MARTIN |     30 |
    | BLAKE  |     30 |
    | CLARK  |     20 |
    | SCOTT  |     20 |
    | KING   |     10 |
    | TURNER |     30 |
    | ADAMS  |     20 |
    | JAMES  |     30 |
    | FORD   |     20 |
    | MILLER |     10 |
    +--------+--------+
    14 rows in set (0.00 sec)


mysql&gt; SELECT DEPTNO,DNAME FROM DEPT;&lt;DEPT是部门表&gt;
    +--------+------------+
    | DEPTNO | DNAME      |
    +--------+------------+
    |     10 | ACCOUNTING |
    |     20 | RESEARCH   |
    |     30 | SALES      |
    |     40 | OPERATIONS |
    +--------+------------+
    4 rows in set (0.00 sec)


注意：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。
SQL92语法：内连接中的等值连接
mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e, DEPT d where e.DEPTNO = d.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    +--------+------------+
    14 rows in set (0.00 sec)

SQL99语法：内连接中的等值连接
SQL99语法的优点：表连接独立出来了，结构更清晰，对表连接不满意的话，可以再追加where进行过滤。
mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e join DEPT d on e.DEPTNO = d.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    +--------+------------+
    14 rows in set (0.00 sec)

mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e inner join DEPT d on e.DEPTNO = d.DEPTNO; //inner可以省略
mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e inner join DEPT d on e.DEPTNO = d.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    +--------+------------+
    14 rows in set (0.00 sec)


6. 案例：找出每一个员工对应的工资等级，要求显示员工名、工资等级。
mysql&gt; SELECT * FROM SALGRADE;
+-------+-------+-------+
| GRADE | LOSAL | HISAL |
+-------+-------+-------+
|     1 |   700 |  1200 |
|     2 |  1201 |  1400 |
|     3 |  1401 |  2000 |
|     4 |  2001 |  3000 |
|     5 |  3001 |  9999 |
+-------+-------+-------+
5 rows in set (0.00 sec)

mysql&gt; SELECT * FROM EMP;
+-------+--------+-----------+------+------------+---------+---------+--------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
+-------+--------+-----------+------+------------+---------+---------+--------+
|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |
+-------+--------+-----------+------+------------+---------+---------+--------+
14 rows in set (0.00 sec)

mysql&gt; SELECT * from EMP E, SALGRADE S WHERE E.SAL between S.LOSAL AND S.HISAL;
+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | GRADE | LOSAL | HISAL |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+
|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |     1 |   700 |  1200 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     3 |  1401 |  2000 |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     2 |  1201 |  1400 |
|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |     4 |  2001 |  3000 |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     2 |  1201 |  1400 |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |     4 |  2001 |  3000 |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |     4 |  2001 |  3000 |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |     4 |  2001 |  3000 |
|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |     5 |  3001 |  9999 |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     3 |  1401 |  2000 |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |     1 |   700 |  1200 |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |     1 |   700 |  1200 |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |     4 |  2001 |  3000 |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |     2 |  1201 |  1400 |
+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+
14 rows in set (0.00 sec)

mysql&gt; SELECT E.ENAME,E.SAL,S.GRADE from EMP E, SALGRADE S WHERE E.SAL between S.LOSAL AND S.HISAL;
+--------+---------+-------+
| ENAME  | SAL     | GRADE |
+--------+---------+-------+
| SMITH  |  800.00 |     1 |
| ALLEN  | 1600.00 |     3 |
| WARD   | 1250.00 |     2 |
| JONES  | 2975.00 |     4 |
| MARTIN | 1250.00 |     2 |
| BLAKE  | 2850.00 |     4 |
| CLARK  | 2450.00 |     4 |
| SCOTT  | 3000.00 |     4 |
| KING   | 5000.00 |     5 |
| TURNER | 1500.00 |     3 |
| ADAMS  | 1100.00 |     1 |
| JAMES  |  950.00 |     1 |
| FORD   | 3000.00 |     4 |
| MILLER | 1300.00 |     2 |
+--------+---------+-------+
14 rows in set (0.00 sec)

SQL99语法：内连接中的非等值连接
    SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e inner join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;//inner可以省略
    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e inner join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;
    +--------+---------+-------+
    | ENAME  | SAL     | GRADE |
    +--------+---------+-------+
    | SMITH  |  800.00 |     1 |
    | ALLEN  | 1600.00 |     3 |
    | WARD   | 1250.00 |     2 |
    | JONES  | 2975.00 |     4 |
    | MARTIN | 1250.00 |     2 |
    | BLAKE  | 2850.00 |     4 |
    | CLARK  | 2450.00 |     4 |
    | SCOTT  | 3000.00 |     4 |
    | KING   | 5000.00 |     5 |
    | TURNER | 1500.00 |     3 |
    | ADAMS  | 1100.00 |     1 |
    | JAMES  |  950.00 |     1 |
    | FORD   | 3000.00 |     4 |
    | MILLER | 1300.00 |     2 |
    +--------+---------+-------+
    14 rows in set (0.00 sec)

    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;
    +--------+---------+-------+
    | ENAME  | SAL     | GRADE |
    +--------+---------+-------+
    | SMITH  |  800.00 |     1 |
    | ALLEN  | 1600.00 |     3 |
    | WARD   | 1250.00 |     2 |
    | JONES  | 2975.00 |     4 |
    | MARTIN | 1250.00 |     2 |
    | BLAKE  | 2850.00 |     4 |
    | CLARK  | 2450.00 |     4 |
    | SCOTT  | 3000.00 |     4 |
    | KING   | 5000.00 |     5 |
    | TURNER | 1500.00 |     3 |
    | ADAMS  | 1100.00 |     1 |
    | JAMES  |  950.00 |     1 |
    | FORD   | 3000.00 |     4 |
    | MILLER | 1300.00 |     2 |
    +--------+---------+-------+
    14 rows in set (0.00 sec)

SQL92语法：内连接中的非等值连接
    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e, SALGRADE s where e.SAL between s.LOSAL and s.HISAL;
    +--------+---------+-------+
    | ENAME  | SAL     | GRADE |
    +--------+---------+-------+
    | SMITH  |  800.00 |     1 |
    | ALLEN  | 1600.00 |     3 |
    | WARD   | 1250.00 |     2 |
    | JONES  | 2975.00 |     4 |
    | MARTIN | 1250.00 |     2 |
    | BLAKE  | 2850.00 |     4 |
    | CLARK  | 2450.00 |     4 |
    | SCOTT  | 3000.00 |     4 |
    | KING   | 5000.00 |     5 |
    | TURNER | 1500.00 |     3 |
    | ADAMS  | 1100.00 |     1 |
    | JAMES  |  950.00 |     1 |
    | FORD   | 3000.00 |     4 |
    | MILLER | 1300.00 |     2 |
    +--------+---------+-------+
    14 rows in set (0.00 sec)


7.     案例：找出每一个员工的上级领导，要求显示员工名以及对应的领导名
    SQL92语法：内连接中的自连接
    select a.ename empname,b.ename leadername from emp a, emp b where a.mgr = b.empno;
    mysql&gt; SELECT * FROM EMP;
    +-------+--------+-----------+------+------------+---------+---------+--------+
    | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
    +-------+--------+-----------+------+------------+---------+---------+--------+
    |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
    |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
    |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
    |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
    |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
    |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
    |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |
    |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
    |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |
    |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
    |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
    |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
    |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
    |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |
    +-------+--------+-----------+------+------------+---------+---------+--------+
    14 rows in set (0.00 sec)
    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A,EMP B WHERE A.MGR = B.EMPNO;
    +---------+------------+
    | EMPNAME | LEADERNAME |
    +---------+------------+
    | SMITH   | FORD       |
    | ALLEN   | BLAKE      |
    | WARD    | BLAKE      |
    | JONES   | KING       |
    | MARTIN  | BLAKE      |
    | BLAKE   | KING       |
    | CLARK   | KING       |
    | SCOTT   | JONES      |
    | TURNER  | BLAKE      |
    | ADAMS   | SCOTT      |
    | JAMES   | BLAKE      |
    | FORD    | JONES      |
    | MILLER  | CLARK      |
    +---------+------------+
    13 rows in set (0.00 sec)

    SQL99语法：内连接中的自连接
    select a.ename empname,b.ename leadername from emp a inner *join* emp b *on* a.mgr=b.empno;//inner可以省略
    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A INNER JOIN EMP B ON A.MGR = B.EMPNO;
    +---------+------------+
    | EMPNAME | LEADERNAME |
    +---------+------------+
    | SMITH   | FORD       |
    | ALLEN   | BLAKE      |
    | WARD    | BLAKE      |
    | JONES   | KING       |
    | MARTIN  | BLAKE      |
    | BLAKE   | KING       |
    | CLARK   | KING       |
    | SCOTT   | JONES      |
    | TURNER  | BLAKE      |
    | ADAMS   | SCOTT      |
    | JAMES   | BLAKE      |
    | FORD    | JONES      |
    | MILLER  | CLARK      |
    +---------+------------+
    13 rows in set (0.00 sec)

    select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;
    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A JOIN EMP B ON A.MGR=B.EMPNO;
    +---------+------------+
    | EMPNAME | LEADERNAME |
    +---------+------------+
    | SMITH   | FORD       |
    | ALLEN   | BLAKE      |
    | WARD    | BLAKE      |
    | JONES   | KING       |
    | MARTIN  | BLAKE      |
    | BLAKE   | KING       |
    | CLARK   | KING       |
    | SCOTT   | JONES      |
    | TURNER  | BLAKE      |
    | ADAMS   | SCOTT      |
    | JAMES   | BLAKE      |
    | FORD    | JONES      |
    | MILLER  | CLARK      |
    +---------+------------+
    13 rows in set (0.00 sec)


8、案例：找出每一个员工对应的部门名称,要求显示所有部门
    内连接：
        A表和B表能够完全匹配的记录查询出来，被称为内连接
    外连接：
        A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，这种查询被称为外连接。
        外连接的查询结果条数 &gt;= 内连接的查询结果条数
    select e.ename, d.dname from emp e join dept d on e.deptno=d.deptno;
    mysql&gt; SELECT * FROM DEPT;
    +--------+------------+-----------+
    | DEPTNO | DNAME      | LOC       |
    +--------+------------+-----------+
    |     10 | ACCOUNTING | NEW YOURK |
    |     20 | RESEARCH   | DALLAS    |
    |     30 | SALES      | CHICAGO   |
    |     40 | OPERATIONS | BOSTON    |
    +--------+------------+-----------+
    4 rows in set (0.00 sec)
    有四个部门

    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    +--------+------------+
    14 rows in set (0.00 sec)
    14条记录只显示了三个部门



    SQL99语法：外连接中的右外连接[右外连接]
    select e.ename, d.dname from emp e right join dept d on e.deptno=d.deptno;
    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E RIGHT JOIN DEPT D ON E.DEPTNO=D.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    | NULL   | OPERATIONS |
    +--------+------------+
    15 rows in set (0.00 sec)
    15条记录显示了，所有4个部门

    select e.ename,d.dname from emp e right outer join dept d on e.deptno=d.deptno; //outer可以省略
    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E RIGHT OUTER JOIN DEPT D ON E.DEPTNO=D.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    | NULL   | OPERATIONS |
    +--------+------------+
    15 rows in set (0.00 sec)


    SQL99语法：外连接中的左外连接[左外连接]
    select e.ename, d.dname from dept d left join emp e on e.deptno=d.deptno;
    mysql&gt; SELECT E.ENAME,D.DNAME FROM DEPT D LEFT JOIN EMP E ON E.DEPTNO=D.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    | NULL   | OPERATIONS |
    +--------+------------+
    15 rows in set (0.00 sec)

    select e.ename,d.dname from dept d left outer join emp e on e.deptno=d.deptno; //outer可以省略
    mysql&gt; SELECT E.ENAME,D.DNAME FROM DEPT D LEFT OUTER JOIN EMP E ON E.DEPTNO=D.DEPTNO;
    +--------+------------+
    | ENAME  | DNAME      |
    +--------+------------+
    | SMITH  | RESEARCH   |
    | ALLEN  | SALES      |
    | WARD   | SALES      |
    | JONES  | RESEARCH   |
    | MARTIN | SALES      |
    | BLAKE  | SALES      |
    | CLARK  | RESEARCH   |
    | SCOTT  | RESEARCH   |
    | KING   | ACCOUNTING |
    | TURNER | SALES      |
    | ADAMS  | RESEARCH   |
    | JAMES  | SALES      |
    | FORD   | RESEARCH   |
    | MILLER | ACCOUNTING |
    | NULL   | OPERATIONS |
    +--------+------------+
    15 rows in set (0.00 sec)


    注意：任何一个右外连接都可以写成左外连接，任何一个左外连接也同样可以写成右外连接

为什么inner和outter可以省略，加上去有什么好处？
        -    可以省略，因为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right
            若存在，表示一定是一个外连接，其它都是内连接。
        -    加上去的好处是增强可读性。

9.    案例：找出每一个员工对应的领导名，要求显示所有的员工
        select A.ENAME EMPNAME,B.ENAME LEADERNAME from EMP A left join EMP B on A.mgr=B.empno;
        SELECT B.ENAME LEADERNAME, A.ENAME EMPNAME FROM EMP B RIGHT OUTER JOIN EMP A ON A.MGR=B.EMPNO;

    mysql&gt; SELECT B.ENAME LEADERNAME, A.ENAME EMPNAME FROM EMP B RIGHT OUTER JOIN EMP A ON A.MGR=B.EMPNO;
        +------------+---------+
        | LEADERNAME | EMPNAME |
        +------------+---------+
        | FORD       | SMITH   |
        | BLAKE      | ALLEN   |
        | BLAKE      | WARD    |
        | KING       | JONES   |
        | BLAKE      | MARTIN  |
        | KING       | BLAKE   |
        | KING       | CLARK   |
        | JONES      | SCOTT   |
        | NULL       | KING    |
        | BLAKE      | TURNER  |
        | SCOTT      | ADAMS   |
        | BLAKE      | JAMES   |
        | JONES      | FORD    |
        | CLARK      | MILLER  |
        +------------+---------+
        14 rows in set (0.00 sec)

        mysql&gt; select A.ENAME EMPNAME,B.ENAME LEADERNAME from EMP A left OUTER join EMP B on A.mgr=B.empno;
        +---------+------------+
        | EMPNAME | LEADERNAME |
        +---------+------------+
        | SMITH   | FORD       |
        | ALLEN   | BLAKE      |
        | WARD    | BLAKE      |
        | JONES   | KING       |
        | MARTIN  | BLAKE      |
        | BLAKE   | KING       |
        | CLARK   | KING       |
        | SCOTT   | JONES      |
        | KING    | NULL       |
        | TURNER  | BLAKE      |
        | ADAMS   | SCOTT      |
        | JAMES   | BLAKE      |
        | FORD    | JONES      |
        | MILLER  | CLARK      |
        +---------+------------+
        14 rows in set (0.01 sec)</code></pre><p>10    案例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级</p>
<pre><code>*多张表进行表连接的语法格式*
select 
        xxx
from
        a
join
        b
on
        条件
join
        c
on
        条件
原理：a和b表进行表连接



1    先找出每一个员工对应的部门名称，显示员工名、部门名
        mysql&gt; SELECT A.ENAME EMPNAME ,B.DNAME DEPTNAME FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO ;
        +---------+------------+
        | EMPNAME | DEPTNAME   |
        +---------+------------+
        | SMITH   | RESEARCH   |
        | ALLEN   | SALES      |
        | WARD    | SALES      |
        | JONES   | RESEARCH   |
        | MARTIN  | SALES      |
        | BLAKE   | SALES      |
        | CLARK   | RESEARCH   |
        | SCOTT   | RESEARCH   |
        | KING    | ACCOUNTING |
        | TURNER  | SALES      |
        | ADAMS   | RESEARCH   |
        | JAMES   | SALES      |
        | FORD    | RESEARCH   |
        | MILLER  | ACCOUNTING |
        +---------+------------+
        14 rows in set (0.00 sec)

mysql&gt; SELECT * FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO ;
+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+
| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO | DNAME      | LOC       |
+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+
|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    |
|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     30 | SALES      | CHICAGO   |
|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     30 | SALES      | CHICAGO   |
|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    |
|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     30 | SALES      | CHICAGO   |
|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |     30 | SALES      | CHICAGO   |
|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    |
|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    |
|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |     10 | ACCOUNTING | NEW YOURK |
|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     30 | SALES      | CHICAGO   |
|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    |
|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |     30 | SALES      | CHICAGO   |
|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    |
|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |     10 | ACCOUNTING | NEW YOURK |
+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+
14 rows in set (0.00 sec)


    mysql&gt; SELECT A.ENAME EMPNAME ,A.SAL EMPSAL ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL&gt;C.LOSAL AND A.SAL&lt;C.HISAL ;
    +---------+------------+-------+
    | EMPNAME | DEPTNAME   | GRADE |
    +---------+------------+-------+
    | SMITH   | RESEARCH   |     1 |
    | ALLEN   | SALES      |     3 |
    | WARD    | SALES      |     2 |
    | JONES   | RESEARCH   |     4 |
    | MARTIN  | SALES      |     2 |
    | BLAKE   | SALES      |     4 |
    | CLARK   | RESEARCH   |     4 |
    | KING    | ACCOUNTING |     5 |
    | TURNER  | SALES      |     3 |
    | ADAMS   | RESEARCH   |     1 |
    | JAMES   | SALES      |     1 |
    | MILLER  | ACCOUNTING |     2 |
    +---------+------------+-------+
    12 rows in set (0.00 sec

    mysql&gt; SELECT A.ENAME EMPNAME ,A.SAL EMPSAL ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL&gt;C.LOSAL AND A.SAL&lt;C.HISAL ;
        +---------+---------+------------+-------+
        | EMPNAME | EMPSAL  | DEPTNAME   | GRADE |
        +---------+---------+------------+-------+
        | SMITH   |  800.00 | RESEARCH   |     1 |
        | ALLEN   | 1600.00 | SALES      |     3 |
        | WARD    | 1250.00 | SALES      |     2 |
        | JONES   | 2975.00 | RESEARCH   |     4 |
        | MARTIN  | 1250.00 | SALES      |     2 |
        | BLAKE   | 2850.00 | SALES      |     4 |
        | CLARK   | 2450.00 | RESEARCH   |     4 |
        | KING    | 5000.00 | ACCOUNTING |     5 |
        | TURNER  | 1500.00 | SALES      |     3 |
        | ADAMS   | 1100.00 | RESEARCH   |     1 |
        | JAMES   |  950.00 | SALES      |     1 |
        | MILLER  | 1300.00 | ACCOUNTING |     2 |
        +---------+---------+------------+-------+
        12 rows in set (0.00 sec)

        mysql&gt; SELECT * FROM SALGRADE;
        +-------+-------+-------+
        | GRADE | LOSAL | HISAL |
        +-------+-------+-------+
        |     1 |   700 |  1200 |
        |     2 |  1201 |  1400 |
        |     3 |  1401 |  2000 |
        |     4 |  2001 |  3000 |
        |     5 |  3001 |  9999 |
        +-------+-------+-------+
        5 rows in set (0.00 sec)




    mysql&gt; SELECT A.ENAME EMPNAME ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL BETWEEN C.LOSAL AND HISAL ;
    +---------+------------+-------+
    | EMPNAME | DEPTNAME   | GRADE |
    +---------+------------+-------+
    | SMITH   | RESEARCH   |     1 |
    | ALLEN   | SALES      |     3 |
    | WARD    | SALES      |     2 |
    | JONES   | RESEARCH   |     4 |
    | MARTIN  | SALES      |     2 |
    | BLAKE   | SALES      |     4 |
    | CLARK   | RESEARCH   |     4 |
    | SCOTT   | RESEARCH   |     4 |
    | KING    | ACCOUNTING |     5 |
    | TURNER  | SALES      |     3 |
    | ADAMS   | RESEARCH   |     1 |
    | JAMES   | SALES      |     1 |
    | FORD    | RESEARCH   |     4 |
    | MILLER  | ACCOUNTING |     2 |
    +---------+------------+-------+
    14 rows in set (0.00 sec)</code></pre><p>子查询<br>子查询就是嵌套的select语句，可以理解为子查询是一张表<br>    在where语句中使用子查询，也就是在where语句中加入select语句<br>    1、什么是子查询？<br>        - select 语句嵌套select语句<br>    2、子查询可以出现在哪？<br>        select …(select)<br>        from…(select)<br>        where…(select)<br>    WHERE后面使用子查询<br>    3、案例：找出薪水比公司平均薪水高的员工，显示员工名和薪水</p>
<pre><code>select ENAME,SAL from EMP where SAL &gt;avg(SAL);
以上语句执行报错，分组函数不能直接使用在where后面
第一步： 找出公司的平均薪水
mysql&gt; select avg(SAL) from EMP;
+-------------+
| avg(SAL)    |
+-------------+
| 2073.214286 |
+-------------+
1 row in set (0.00 sec)
第二步：找出薪水大于平均薪水的员工信息：
mysql&gt; SELECT ENAME,SAL FROM EMP WHERE SAL &gt; (select avg(SAL) from EMP);
+-------+---------+
| ENAME | SAL     |
+-------+---------+
| JONES | 2975.00 |
| BLAKE | 2850.00 |
| CLARK | 2450.00 |
| SCOTT | 3000.00 |
| KING  | 5000.00 |
| FORD  | 3000.00 |
+-------+---------+
6 rows in set (0.00 sec)</code></pre><p>4.from后面使用子查询【小窍门：将查询语句当作临时表】<br>    案例：  找出每一个部门的平均薪水，并且要求显示平均薪水的薪水等级。<br>    第一步：找出每个部门的平均薪水<br>    select DEPTNO,avg(SAL) from EMP group by DEPTNO;<br>    mysql&gt; select DEPTNO,avg(SAL) avgsal from EMP group by DEPTNO;<br>    +——–+————-+<br>    | DEPTNO | avgsal      |<br>    +——–+————-+<br>    |     10 | 3150.000000 |<br>    |     20 | 2220.833333 |<br>    |     30 | 1566.666667 |<br>    +——–+————-+<br>    3 rows in set (0.00 sec)</p>
<pre><code>第二步：将上面查询结果当作临时表t,t表和salgrade s表进行连接，条件：t.avgsal between s.losal and s.hisal;
mysql&gt; select a.avgsal , b.GRADE from (select DEPTNO,avg(SAL) avgsal from EMP group by DEPTNO) a join SALGRADE b on a.avgsal between b.LOSAL and b.HISAL ;
+-------------+-------+
| avgsal      | GRADE |
+-------------+-------+
| 3150.000000 |     5 |
| 2220.833333 |     4 |
| 1566.666667 |     3 |
+-------------+-------+
3 rows in set (0.00 sec)</code></pre><p>5     在select后面使用子查询【了解】<br>    mysql&gt; SELECT E.ENAME,(SELECT D.DNAME FROM DEPT D WHERE E.DEPTNO=D.DEPTNO) AS DNAME FROM EMP E;<br>    +——–+————+<br>    | ENAME  | DNAME      |<br>    +——–+————+<br>    | SMITH  | RESEARCH   |<br>    | ALLEN  | SALES      |<br>    | WARD   | SALES      |<br>    | JONES  | RESEARCH   |<br>    | MARTIN | SALES      |<br>    | BLAKE  | SALES      |<br>    | CLARK  | RESEARCH   |<br>    | SCOTT  | RESEARCH   |<br>    | KING   | ACCOUNTING |<br>    | TURNER | SALES      |<br>    | ADAMS  | RESEARCH   |<br>    | JAMES  | SALES      |<br>    | FORD   | RESEARCH   |<br>    | MILLER | ACCOUNTING |<br>    +——–+————+<br>    14 rows in set (0.00 sec)</p>
<p>union</p>
<pre><code>mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB = &#39;MANAGER&#39; OR JOB=&#39;SALESMAN&#39;;
+--------+----------+
| ENAME  | JOB      |
+--------+----------+
| ALLEN  | SALESMAN |
| WARD   | SALESMAN |
| JONES  | MANAGER  |
| MARTIN | SALESMAN |
| BLAKE  | MANAGER  |
| CLARK  | MANAGER  |
| TURNER | SALESMAN |
+--------+----------+
7 rows in set (0.00 sec)


mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;MANAGER&#39;;
+-------+---------+
| ENAME | JOB     |
+-------+---------+
| JONES | MANAGER |
| BLAKE | MANAGER |
| CLARK | MANAGER |
+-------+---------+
3 rows in set (0.01 sec)

mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;SALESMAN&#39;;
+--------+----------+
| ENAME  | JOB      |
+--------+----------+
| ALLEN  | SALESMAN |
| WARD   | SALESMAN |
| MARTIN | SALESMAN |
| TURNER | SALESMAN |
+--------+----------+
4 rows in set (0.00 sec)


mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;MANAGER&#39; 
    -&gt; UNION
    -&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;SALESMAN&#39;;
+--------+----------+
| ENAME  | JOB      |
+--------+----------+
| JONES  | MANAGER  |
| BLAKE  | MANAGER  |
| CLARK  | MANAGER  |
| ALLEN  | SALESMAN |
| WARD   | SALESMAN |
| MARTIN | SALESMAN |
| TURNER | SALESMAN |
+--------+----------+
7 rows in set (0.00 sec)</code></pre><p>LIMIT<br>    1     limit用来获取一张表中的某部分数据<br>    2    limit只有在MYSQL数据库中存在，不通用，是MYSQL数据库管理系统的特色。</p>
<pre><code>3     案例：找出员工表前5条记录

    mysql&gt; SELECT ENAME FROM EMP limit 5;
    +--------+
    | ENAME  |
    +--------+
    | SMITH  |
    | ALLEN  |
    | WARD   |
    | JONES  |
    | MARTIN |
    +--------+
    5 rows in set (0.00 sec)
    以上SQL语句的&quot;limit 5&quot;中的5表示从表中记录下表0开始，取5条等同于下面的SQL语句：

    mysql&gt; select ENAME FROM EMP LIMIT 0,5;
    +--------+
    | ENAME  |
    +--------+
    | SMITH  |
    | ALLEN  |
    | WARD   |
    | JONES  |
    | MARTIN |
    +--------+
    5 rows in set (0.00 sec)
    LIMIT的使用语法格式：
        limit起始下标，长度
        起始下标没有指定，默认从0开始，0表示表中第一条记录。
4    案例：找出公司中工资排名在前5名的员工
    思路：按照工资降序排列取前5个
    mysql&gt; 
    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC;
    +--------+---------+
    | ENAME  | SAL     |
    +--------+---------+
    | KING   | 5000.00 |
    | SCOTT  | 3000.00 |
    | FORD   | 3000.00 |
    | JONES  | 2975.00 |
    | BLAKE  | 2850.00 |
    | CLARK  | 2450.00 |
    | ALLEN  | 1600.00 |
    | TURNER | 1500.00 |
    | MILLER | 1300.00 |
    | WARD   | 1250.00 |
    | MARTIN | 1250.00 |
    | ADAMS  | 1100.00 |
    | JAMES  |  950.00 |
    | SMITH  |  800.00 |
    +--------+---------+
    14 rows in set (0.01 sec)

    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 5;
    +-------+---------+
    | ENAME | SAL     |
    +-------+---------+
    | KING  | 5000.00 |
    | FORD  | 3000.00 |
    | SCOTT | 3000.00 |
    | JONES | 2975.00 |
    | BLAKE | 2850.00 |
    +-------+---------+
    5 rows in set (0.00 sec)
5     案例：找出工资排名【3-9】名的员工

    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 3,9;
    +--------+---------+
    | ENAME  | SAL     |
    +--------+---------+
    | JONES  | 2975.00 |
    | BLAKE  | 2850.00 |
    | CLARK  | 2450.00 |
    | ALLEN  | 1600.00 |
    | TURNER | 1500.00 |
    | MILLER | 1300.00 |
    | WARD   | 1250.00 |
    | MARTIN | 1250.00 |
    | ADAMS  | 1100.00 |
    +--------+---------+
    9 rows in set (0.00 sec)

    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 2,8;
    +--------+---------+
    | ENAME  | SAL     |
    +--------+---------+
    | SCOTT  | 3000.00 |
    | JONES  | 2975.00 |
    | BLAKE  | 2850.00 |
    | CLARK  | 2450.00 |
    | ALLEN  | 1600.00 |
    | TURNER | 1500.00 |
    | MILLER | 1300.00 |
    | WARD   | 1250.00 |
    +--------+---------+
    8 rows in set (0.00 sec)

6     MYSQL中通用的分页SQL语句：
    每页显示3条记录
    第一页：0,3
    第二页：3,3
    第三页：6,3
    第四页：9,3

    每页显示pageSize条记录
    第pageNo页：( pageNo - 1 ) * pageSize , pageSize

    SELECT 
        t.*
    FROM
        t
    ORDER BY
        t.x DESC/ASC
    LIMIT ( pageNo - 1 ) * pageSize , pageSize</code></pre><p>创建表 DDL()</p>
<ul>
<li><p>语法格式：<br>create table tableName(<br>   columnName dataType(length),<br>   columnName dataType(length),<br>);<br>set character_set_results=’utf-8’;</p>
<p>表：<br>   1    表格(table),用来存储数据，表格是一种结构化文件。<br>   2    表格行被称为记录(表中的数据)，表格列被称为字段。<br>   3    表格的字段属性包括：字段名称、字段数据类型、字段长度、字段约束</p>
<p>   4    创建表的语法：</p>
<pre><code>   CREATE TABLE tablename(
       columnname1 dataType(length),
       columnname2 dataType(length),
   );</code></pre><p>   5    关于MYSQL数据库中的数据类型？</p>
<pre><code>   -    VARCHAR
           * 可变长度字符串
           * VARCHAR(3) 表示存储的数据不能超过3个字符长度
   -    CHAR
           * 定长字符串
           * VARCHAR和CHAR对比：
               - 都是字符串类型
               - VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间，
                 但是在分配的时候需要执行相关的判断程序，效率较低
               - CHAR不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。
               - 若字段中的数据布局配伸缩性，建议采用CHAR类型存储
               - 若字段中的数据具备很强伸缩性，建议采用VARCHAR类型存储。
               * CHAR(3)：表示存储的数据不能超过3个字符长度
   -    INT
           * 整数型
           * INT(3) 表示最大可以存储999(老师课堂讲解有误)
           INT(3) 3表示的是可以显示的有效长度(添加补零功能后，比较明显)
               CREATE TABLE test01(
                   with_int_length int(3),
                   without_int_length int
               )
               insert into test01(with_int_length,without_int_length) values(1111,1111);
               insert into test01(with_int_length,without_int_length) values(11111,11111);
               commit;
               mysql&gt; select * from test01;
               +-----------------+--------------------+
               | with_int_length | without_int_length |
               +-----------------+--------------------+
               |            1111 |               1111 |
               |           11111 |              11111 |
               +-----------------+--------------------+
               2 rows in set (0.00 sec)

               CREATE TABLE test02 (
                 with_length int(3) ZEROFILL,
                 without_length int
               ) ENGINE=innodb, CHARSET=utf8

               insert into test02 (with_length, without_length) VALUE (11, 11);
               select * from test02;
               mysql&gt; select * from test02;
               +-------------+----------------+
               | with_length | without_length |
               +-------------+----------------+
               |         011 |             11 |
               +-------------+----------------+
               1 row in set (0.01 sec)
   -    BIGINT
           * 长整型
           * 对应Java程序中的long类型
   -     FLOAT
           * 浮点型单精度

   -    DOUBLE
           * 浮点型双精度
           * DOUBLE(7,2)   表示7个有效数字，2个小数位
   -    DATE
           * 日期类型
           * 在实际开发中为了通用，所以日期类型一般不使用，采用字符串代替日期比较多。
   -    BLOB
           *  Binary Large OBject 二进制大对象
           * 专门存储图片声音视频等数据
           *  数据库表中存储一个图片是很常见的，但是存储一个比较大的视频是很少见的。
           一般都是提供一个视频的链接地址
   -    CLOB
           * Character Large OBject 二进制大对象
           * 可以存储比较打的文本，4G+
   -    其它</code></pre></li>
</ul>
<p>6    创建表格[学生表]<br>        设计：建立学生信息表，字段包括：<br>                学号 【INT】<br>                姓名 【VARCHAR】<br>                性别 【CHAR】<br>                出生日期【DATA】<br>                邮箱地址【VARCHAR】</p>
<pre><code>        建表语句：    
        CREATE TABLE t_student(
            NO  INT(10),
            NAME VARCHAR(32),
            SEX  CHAR(1),
            BIRTH DATE,
            EMAIL VARCHAR(128)
        );
        注意：
            * 表格的名字最好以t_ 或者 tb1_开始，增强可读性
            * VARCHAR长度最好是2的倍数，方便存储中文

        删除表格：
            drop table t_student;【这种删除格式，若数据库没有这个表格，会报错】
            drop table if exists t_student;【最好采用这种方式删除，mysql数据库管理系统的特色语法】

        mysql&gt; desc t_student;
        +-------+--------------+------+-----+---------+-------+
        | Field | Type         | Null | Key | Default | Extra |
        +-------+--------------+------+-----+---------+-------+
        | NO    | int(10)      | YES  |     | NULL    |       |
        | NAME  | varchar(32)  | YES  |     | NULL    |       |
        | SEX   | char(1)      | YES  |     | NULL    |       |
        | BIRTH | date         | YES  |     | NULL    |       |
        | EMAIL | varchar(128) | YES  |     | NULL    |       |
        +-------+--------------+------+-----+---------+-------+
        5 rows in set (0.00 sec)

7.     向t_student表格中插入数据
    7.1 向表格插入数据必须使用insert语句，这属于DML语句
    7.2 DML语句包括：insert,update,delete【增删改表中的数据，和表结构无关】
    7.3    insert语句的语法格式：
        INSERT INTO tablename(columnname1,columnname2,columnname3,...) values(value1,value2,value3,...)字段和值必须一一对应，个数必须相同，数据类型必须一致
    7.4    向t_student表格中插入数据
        INSERT INTO t_student(NO,NAME,SEX,BIRTH,EMAIL) values(1,&#39;cntsp&#39;,&#39;m&#39;,&#39;1948-11-51&#39;,&#39;cntsp@beijingpowernode.com&#39;);
        INSERT INTO t_student(NO,NAME,SEX,BIRTH,EMAIL) values(2,&#39;zhongjie&#39;,&#39;m&#39;,&#39;1958-11-21&#39;,&#39;zhongjie@beijingpowernode.com&#39;);        
        mysql&gt; select * from t_student;
        +------+----------+------+------------+-------------------------------+
        | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |
        +------+----------+------+------------+-------------------------------+
        |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |
        |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |
        +------+----------+------+------------+-------------------------------+


    7.5    可以这样执行insert语句吗？
        INSERT INTO t_student(name,email) VALUES(&#39;wangwu&#39;,&#39;wangwu@bjpowernode.com&#39;);

        mysql&gt; INSERT INTO t_student(name,email) VALUES(&#39;wangwu&#39;,&#39;wangwu@bjpowernode.com&#39;);
        Query OK, 1 row affected (0.01 sec)

        mysql&gt; select * from t_student;
        +------+----------+------+------------+-------------------------------+
        | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |
        +------+----------+------+------------+-------------------------------+
        |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |
        |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |
        | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |
        +------+----------+------+------------+-------------------------------+
        3 rows in set (0.00 sec)
        默认情况下：当一张表被创建之后，没有指定约束的话，可以为NULL，并且没有指定任何默认值的话，默认值为NULL，这里的默认值NLL表示：若插入数据的时候没有给该字段指定任何数据，默认插入NULL值。
            我们可以再向NO,SEX,BIRTH字段中插入值吗？
            INSERT INTO t_student(NO,SEX,BIRTH) VALUES(3,&#39;m&#39;,&#39;1990-11-12&#39;);

            mysql&gt; INSERT INTO t_student(NO,SEX,BIRTH) VALUES(3,&#39;m&#39;,&#39;1990-11-12&#39;);
            Query OK, 1 row affected (0.01 sec)

            mysql&gt; select * from t_student;
            +------+----------+------+------------+-------------------------------+
            | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |
            +------+----------+------+------------+-------------------------------+
            |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |
            |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |
            | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |
            |    3 | NULL     | m    | 1990-11-12 | NULL                          |
            +------+----------+------+------------+-------------------------------+
            4 rows in set (0.00 sec)

            以上执行insert语句只能导致底层数据库表中新增一条记录。
            若希望NULL变成其它数据，需要使用UPDAT语句进行更新操作。
    7.6    INSERT语句中字段的名字可以省略吗？
            mysql&gt; INSERT INTO t_student VALUES(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1960-12-16&#39;,&#39;zhaoliu@163.com&#39;);
            Query OK, 1 row affected (0.01 sec)

            mysql&gt; select * from t_student;
            +------+----------+------+------------+-------------------------------+
            | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |
            +------+----------+------+------------+-------------------------------+
            |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |
            |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |
            | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |
            |    3 | NULL     | m    | 1990-11-12 | NULL                          |
            |    4 | zhaoliu  | m    | 1960-12-16 | zhaoliu@163.com               |
            +------+----------+------+------------+-------------------------------+
            5 rows in set (0.00 sec)

            INSERT INTO t_student VALUES(5,&#39;LTIANLI&#39;,&#39;m&#39;,&#39;1990-05-18&#39;);
            mysql&gt; INSERT INTO t_student VALUES(5,&#39;LTIANLI&#39;,&#39;m&#39;,&#39;1990-05-18&#39;);
            ERROR 1136 (21S01): Column count doesn&#39;t match value count at row 1

            结论：建立不要将前面的字段省略，如省略就表示将表中所有字段全部加上。省略之后程序不健壮，无法修改表结构，修改表结构，可能导致insert语句执行失败。

    7.7  插入中文试试？【在DOS窗口中】
            mysql&gt; show create table t_student;</code></pre><p>+———–+——————————————————————————————————————————————————————————————————————————–+<br>| Table     | Create Table                                                                                                                                                                                                                   |<br>+———–+——————————————————————————————————————————————————————————————————————————–+<br>| t_student | CREATE TABLE <code>t_student</code> (<br>  <code>NO</code> int(10) DEFAULT NULL,<br>  <code>NAME</code> varchar(32) DEFAULT NULL,<br>  <code>SEX</code> char(1) DEFAULT NULL,<br>  <code>BIRTH</code> date DEFAULT NULL,<br>  <code>EMAIL</code> varchar(128) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 |<br>+———–+——————————————————————————————————————————————————————————————————————————–+<br>1 row in set (0.00 sec)<br>            编码方式为：utf8<br>            DOS窗口操作数据库<br>            set character_set_result = ‘GBK’;<br>            插入失败，原因是DOS窗口是GBK的编码方式，但是数据库表只能接受UTF8<br>            怎么解决？<br>                使用MYSQL Front工具插入数据【MYSQL的客户端软件，在实际开发中使用较多】<br>                使用mysql front 工具插入数据成功，在DOS窗口中使用select语句查询的时候出现乱码，怎么解决？<br>                    修改查询结果集的显示编码方式，这里修改的不是DOS窗口的编码：<br>                    mysql&gt; set character_set_results = ‘GBK’;【临时有效，当前窗口有效】</p>
<pre><code>                查看MYSQL的相关字符编码方式：show variables like &#39;%char%&#39;;

8     关于创建表格的时候给字段添加默认值：
    drop table if exists t_student;
    create table t_student(
        no int(10),
        name varchar(32),
        sex char(1) default &#39;m&#39;
    );
    insert into t_student(no,name) values(1,&#39;jack&#39;);
    insert into t_student(no,name) values(2,&#39;lucy&#39;);
    commit;
    mysql&gt; select * from t_student;
    +------+------+------+
    | no   | name | sex  |
    +------+------+------+
    |    1 | jack | m    |
    |    2 | lucy | m    |
    +------+------+------+
    2 rows in set (0.00 sec)

    mysql&gt; desc t_student;
    +-------+-------------+------+-----+---------+-------+
    | Field | Type        | Null | Key | Default | Extra |
    +-------+-------------+------+-----+---------+-------+
    | no    | int(10)     | YES  |     | NULL    |       |
    | name  | varchar(32) | YES  |     | NULL    |       |
    | sex   | char(1)     | YES  |     | m       |       |
    +-------+-------------+------+-----+---------+-------+
    3 rows in set (0.00 sec)

    关于SQL脚本：
        你是怎么看SQL脚本的？
            - 该文件是一个普通的文本文件，后缀名.sql，被称为SQL脚本
            - 在SQL脚本中有大量的SQL语句，想批量的执行SQL语句，可以将这些SQL语句写入SQL脚本文件中，
            直接使用source执行这个脚本，可以执行大量的SQL语句。
            - 若项目中期就职，可能数据库表，以及表中的记录都已经准备好了，可能Team leader就给你一个SQL脚本，直接执行这个SQL脚本将底层数据库中的数据完成初始化，就可以开发了

    9     获取系统当前时间
        mysql&gt; select now()
            -&gt; ;
        +---------------------+
        | now()               |
        +---------------------+
        | 2019-06-22 15:55:37 |
        +---------------------+
        1 row in set (0.00 sec)

    创建表：机构表
        create table t_organization(
            code char(20),
            name varchar(32),
            createTime date
        );
        insert into t_organization(code,name,createTime) values(&#39;11111&#39;,&#39;国家外汇局&#39;,now());        
        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;河北省外汇局&#39;,now());
        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;河南省外汇局&#39;,now());
        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;山东省外汇局&#39;,now());


10    表的复制【快速复制】
        mysql&gt;create table EMP1 as select * from EMP; 
        mysql&gt; create table EMP1 as select * from EMP; 
        Query OK, 14 rows affected (0.01 sec)
        Records: 14  Duplicates: 0  Warnings: 0

        mysql&gt; show tables;
        +-----------------------+
        | Tables_in_bjpowernode |
        +-----------------------+
        | DEPT                  |
        | EMP                   |
        | EMP1                  |
        | SALGRADE              |
        | t_student             |
        +-----------------------+
        5 rows in set (0.00 sec)

        mysql&gt; select * from EMP1;
        +-------+--------+-----------+------+------------+---------+---------+--------+
        | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
        +-------+--------+-----------+------+------------+---------+---------+--------+
        |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
        |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
        |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
        |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
        |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
        |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
        |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |
        |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
        |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |
        |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
        |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
        |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
        |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
        |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |
        +-------+--------+-----------+------+------------+---------+---------+--------+
        14 rows in set (0.00 sec)
        mysql&gt; create table  EMP2 as select EMPNO,ENAME,SAL FROM EMP;
        Query OK, 14 rows affected (0.00 sec)
        Records: 14  Duplicates: 0  Warnings: 0

        mysql&gt; 
        mysql&gt; select * from EMP2;
        +-------+--------+---------+
        | EMPNO | ENAME  | SAL     |
        +-------+--------+---------+
        |  7396 | SMITH  |  800.00 |
        |  7499 | ALLEN  | 1600.00 |
        |  7521 | WARD   | 1250.00 |
        |  7566 | JONES  | 2975.00 |
        |  7654 | MARTIN | 1250.00 |
        |  7698 | BLAKE  | 2850.00 |
        |  7782 | CLARK  | 2450.00 |
        |  7788 | SCOTT  | 3000.00 |
        |  7839 | KING   | 5000.00 |
        |  7844 | TURNER | 1500.00 |
        |  7876 | ADAMS  | 1100.00 |
        |  7900 | JAMES  |  950.00 |
        |  7902 | FORD   | 3000.00 |
        |  7934 | MILLER | 1300.00 |
        +-------+--------+---------+
        14 rows in set (0.01 sec)
语法结构：
        CREATE TABLE tablename AS SELECT COLUMNNAME,... FROM tablename;

11    将查询结果插入到某张表中
    insert into EMP2 select * from EMP2 where sal=3000;

    mysql&gt; insert into EMP2 select * from EMP2 where sal=3000;
    Query OK, 2 rows affected (0.00 sec)
    Records: 2  Duplicates: 0  Warnings: 0

    mysql&gt; SELECT * FROM EMP2;
    +-------+--------+---------+
    | EMPNO | ENAME  | SAL     |
    +-------+--------+---------+
    |  7396 | SMITH  |  800.00 |
    |  7499 | ALLEN  | 1600.00 |
    |  7521 | WARD   | 1250.00 |
    |  7566 | JONES  | 2975.00 |
    |  7654 | MARTIN | 1250.00 |
    |  7698 | BLAKE  | 2850.00 |
    |  7782 | CLARK  | 2450.00 |
    |  7788 | SCOTT  | 3000.00 |
    |  7839 | KING   | 5000.00 |
    |  7844 | TURNER | 1500.00 |
    |  7876 | ADAMS  | 1100.00 |
    |  7900 | JAMES  |  950.00 |
    |  7902 | FORD   | 3000.00 |
    |  7934 | MILLER | 1300.00 |
    |  7788 | SCOTT  | 3000.00 |
    |  7902 | FORD   | 3000.00 |
    +-------+--------+---------+
    16 rows in set (0.00 sec)

12  增/删/改 表结构【DDL语句】

    drop table if exists t_student;
    create table t_student{
        NAME VARCHAR(10),
        SEX CHAR(1)
    };
    INSERT INTO t_student(NAME,SEX) values(&#39;JACK&#39;,&#39;M&#39;);
    INSERT INTO t_student(NAME,SEX) VALUES(&#39;MARY&#39;,&#39;F&#39;);
    commit;

    DROP TABLE IF EXISTS runoob_tb1;
    CREATE TABLE IF NOT EXISTS `runoob_tbl`(
       `runoob_id` INT UNSIGNED AUTO_INCREMENT,
       `runoob_title` VARCHAR(100) NOT NULL,
       `submission_date` DATE,
        PRIMARY KEY ( `runoob_id` )
        )ENGINE=InnoDB DEFAULT CHARSET=utf8;

    添加字段
        如：需求发生改变，需要向runoob_tbl中加入联系作者字段，字段名称为：author类型为varchar(100)
        alter table runoob_tbl add author varchar(100) not null default &#39;&#39;,ALGORITHM=INPLACE;


        给runoob_tbl表格添加一个作者字段
        alter table runoob_tbl add author varchar(100) not null default &#39;&#39;,ALGORITHM=INPLACE;
        mysql&gt; desc runoob_tbl;
        +-----------------+------------------+------+-----+---------+----------------+
        | Field           | Type             | Null | Key | Default | Extra          |
        +-----------------+------------------+------+-----+---------+----------------+
        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |
        | submission_date | date             | YES  |     | NULL    |                |
        | author          | varchar(100)     | NO   |     |         |                |
        +-----------------+------------------+------+-----+---------+----------------+
        4 rows in set (0.00 sec)


        将ru表格中的tel字段长度扩展到120个长度【改】
        ALTER TABLE runoob_tbl MODIFY author VARCHAR(120);

        mysql&gt; desc runoob_tbl;
        +-----------------+------------------+------+-----+---------+----------------+
        | Field           | Type             | Null | Key | Default | Extra          |
        +-----------------+------------------+------+-----+---------+----------------+
        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |
        | submission_date | date             | YES  |     | NULL    |                |
        | author          | varchar(100)     | NO   |     |         |                |
        +-----------------+------------------+------+-----+---------+----------------+
        4 rows in set (0.00 sec)

        mysql&gt; ALTER TABLE runoob_tbl MODIFY author VARCHAR(120);
        Query OK, 0 rows affected (0.04 sec)
        Records: 0  Duplicates: 0  Warnings: 0

        mysql&gt; desc runoob_tbl;
        +-----------------+------------------+------+-----+---------+----------------+
        | Field           | Type             | Null | Key | Default | Extra          |
        +-----------------+------------------+------+-----+---------+----------------+
        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |
        | submission_date | date             | YES  |     | NULL    |                |
        | author          | varchar(120)     | YES  |     | NULL    |                |
        +-----------------+------------------+------+-----+---------+----------------+
        4 rows in set (0.00 sec)

        将runoob_tbl 表格中的author字段删除【删】
        mysql&gt; desc runoob_tbl;
        +-----------------+------------------+------+-----+---------+----------------+
        | Field           | Type             | Null | Key | Default | Extra          |
        +-----------------+------------------+------+-----+---------+----------------+
        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |
        | submission_date | date             | YES  |     | NULL    |                |
        | author          | varchar(120)     | YES  |     | NULL    |                |
        +-----------------+------------------+------+-----+---------+----------------+
        4 rows in set (0.00 sec)

        mysql&gt; ALTER TABLE runoob_tbl DROP author;
        Query OK, 0 rows affected (0.01 sec)
        Records: 0  Duplicates: 0  Warnings: 0

        mysql&gt; desc runoob_tbl;
        +-----------------+------------------+------+-----+---------+----------------+
        | Field           | Type             | Null | Key | Default | Extra          |
        +-----------------+------------------+------+-----+---------+----------------+
        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |
        | submission_date | date             | YES  |     | NULL    |                |
        +-----------------+------------------+------+-----+---------+----------------+
        3 rows in set (0.01 sec)


13    增/删/改 表中的数据【insert, update,delete 属于DML语句】
    update
        update 语句的语法格式
                UPDATE tablename SET 字段名=字段值 ,字段名=字段值 where 条件;
                注意： update语句没有条件，会将一张表所有的数据都更新

        delete 语法格式：
                DELETE FROM tablename where 条件;
                注意： 若没有条件限制，会将这张表的数据全部删除


约束和非空约束
    1    什么是约束，为什么使用约束？
            -    约束对应的英语单词：constraint
            -    约束实际上就是表中数据的限制条件
            -    表的设计的时候加入约束的目的就是为了保证表中的记录完整和有效



    2    约束包括哪些呢？
            -    非空约束        (not null)
            -    唯一性约束        (unique)
            -    主键约束        (primary key)  简称 PK
            -    外键约束        (foreign key)     简称 FK
            -    检查约束        (MYSQL不支持，oracle支持)
    3    非空约束
            -    not null约束的字段，不能为NULL值，必须给定具体的数据
            -    创建表，给字段添加非空约束【创建用户表，用户名不能为空】

    4    唯一性约束
            - unique约束的字段具有唯一性，不可重复
            - 创建用户，保证邮箱地址唯一

            drop table if exists t_user;
            //列级约束
            create table t_user(
                id int(10),
                name varchar(32) not null,
                email varchar(128) unique
            );
            insert into t_user(id,name,email) values(1,&#39;jack&#39;,&#39;jack@bjpowernode.com&#39;);//成功

            insert into t_user(id,name,email) values(2,&#39;abc&#39;&#39;jack@bjpowernode.com&#39;);//失败
            EEROR 1062 (23000): Duplicate entry &#39;jack@bjpowernode.com&#39; for key &#39;emial&#39;

            insert into t_user(id,name) value(2,&#39;abc&#39;);//成功
            insert into t_user(id,name) values(3,&#39;def&#39;);//成功

            unique约束的字段不能重复，但是可以为NULL 

            drop table if exists t_user;
            //表级约束
            create table t_user{
                id int(10),
                name varchar(32) not null,
                email varcher(128),
                unique(email)
            };
            //表级约束给多个字段联合添加约束【一下程序表示name和email连个字段联合唯一】
            drop table if exists t_user;
            create table t_user(
                    id int(10),
                    name varchar(32) not null,
                    email varchar(128),
                    unique(name,email)
            );

            //表级约束还可以给约束起名字
            //为什么要起名字？因为以后要通过这个名字来删除这个约束
            drop table if exists t_user;
            create table t_user(
                id int(10),
                name varchar(32) not null,
                email varchar(128),
                constraint t_user_email_unique unique(email)
            );
            //查询约束的名字
            mysql&gt; use information_schema;
            Reading table information for completion of table and column names
            You can turn off this feature to get a quicker startup with -A

            Database changed
            mysql&gt; show tables;
            +---------------------------------------+
            | Tables_in_information_schema          |
            +---------------------------------------+
            | CHARACTER_SETS                        |
            | COLLATIONS                            |
            | COLLATION_CHARACTER_SET_APPLICABILITY |
            | COLUMNS                               |
            | COLUMN_PRIVILEGES                     |
            | ENGINES                               |
            | EVENTS                                |
            | FILES                                 |
            | GLOBAL_STATUS                         |
            | GLOBAL_VARIABLES                      |
            | KEY_COLUMN_USAGE                      |
            | OPTIMIZER_TRACE                       |
            | PARAMETERS                            |
            | PARTITIONS                            |
            | PLUGINS                               |
            | PROCESSLIST                           |
            | PROFILING                             |
            | REFERENTIAL_CONSTRAINTS               |
            | ROUTINES                              |
            | SCHEMATA                              |
            | SCHEMA_PRIVILEGES                     |
            | SESSION_STATUS                        |
            | SESSION_VARIABLES                     |
            | STATISTICS                            |
            | TABLES                                |
            | TABLESPACES                           |
            | TABLE_CONSTRAINTS                     |
            | TABLE_PRIVILEGES                      |
            | TRIGGERS                              |
            | USER_PRIVILEGES                       |
            | VIEWS                                 |
            | INNODB_LOCKS                          |
            | INNODB_TRX                            |
            | INNODB_SYS_DATAFILES                  |
            | INNODB_FT_CONFIG                      |
            | INNODB_SYS_VIRTUAL                    |
            | INNODB_CMP                            |
            | INNODB_FT_BEING_DELETED               |
            | INNODB_CMP_RESET                      |
            | INNODB_CMP_PER_INDEX                  |
            | INNODB_CMPMEM_RESET                   |
            | INNODB_FT_DELETED                     |
            | INNODB_BUFFER_PAGE_LRU                |
            | INNODB_LOCK_WAITS                     |
            | INNODB_TEMP_TABLE_INFO                |
            | INNODB_SYS_INDEXES                    |
            | INNODB_SYS_TABLES                     |
            | INNODB_SYS_FIELDS                     |
            | INNODB_CMP_PER_INDEX_RESET            |
            | INNODB_BUFFER_PAGE                    |
            | INNODB_FT_DEFAULT_STOPWORD            |
            | INNODB_FT_INDEX_TABLE                 |
            | INNODB_FT_INDEX_CACHE                 |
            | INNODB_SYS_TABLESPACES                |
            | INNODB_METRICS                        |
            | INNODB_SYS_FOREIGN_COLS               |
            | INNODB_CMPMEM                         |
            | INNODB_BUFFER_POOL_STATS              |
            | INNODB_SYS_COLUMNS                    |
            | INNODB_SYS_FOREIGN                    |
            | INNODB_SYS_TABLESTATS                 |
            +---------------------------------------+
            61 rows in set (0.00 sec)

            mysql&gt; desc COLLATIONs;
            +--------------------+-------------+------+-----+---------+-------+
            | Field              | Type        | Null | Key | Default | Extra |
            +--------------------+-------------+------+-----+---------+-------+
            | COLLATION_NAME     | varchar(32) | NO   |     |         |       |
            | CHARACTER_SET_NAME | varchar(32) | NO   |     |         |       |
            | ID                 | bigint(11)  | NO   |     | 0       |       |
            | IS_DEFAULT         | varchar(3)  | NO   |     |         |       |
            | IS_COMPILED        | varchar(3)  | NO   |     |         |       |
            | SORTLEN            | bigint(3)   | NO   |     | 0       |       |
            +--------------------+-------------+------+-----+---------+-------+
            6 rows in set (0.00 sec)

            mysql&gt; DESC TABLE_CONSTRAINTS;【该表格专门存储约束信息的】
            +--------------------+--------------+------+-----+---------+-------+
            | Field              | Type         | Null | Key | Default | Extra |
            +--------------------+--------------+------+-----+---------+-------+
            | CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |
            | CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |
            | CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |
            | TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |
            | TABLE_NAME         | varchar(64)  | NO   |     |         |       |
            | CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |
            +--------------------+--------------+------+-----+---------+-------+
            6 rows in set (0.00 sec)

            mysql&gt; select CONSTRAINT_NAME from TABLE_CONSTRAINTS where TABLE_NAME=&#39;t_user&#39;;

5    not null和unique可以联合使用吗？
        -    可以联合使用
        -    被not null unique 约束的字段，既不能为空，也不能重复
        -    例子：

6    主键约束-primary key  简称:PK
        6.1        主键涉及到的术语:
                    -    主键约束
                    -    主键字段
                    -    主键值
        6.2        以上的主键约束、主键字段、主键值的关系？
                - 表中某个字段添加主键约束之后
                该字段被称为主键字段，主键字段中
                出现的每一个数据能被称为主键值
        6.3        给某个字段添加主键约束之后，该字段不能重复，并且也不能为空
                效果和 not null unique  约束相同，但是本质不同，主键约束除了可以做到&quot;not null unique&quot;之外，主键字段还会默认添加&quot;索引-index&quot;

        6.4        一张表应该有主键字段，若没有，表示这张表是无效的。
                &quot;主键值&quot;是当前行数据的唯一标识。&quot;主键值&quot;是当前行数据的身份证号。
                即使表中的两行记录相关的数据是相同的，但是由于主键值不同，我们认为这是两行完全不同的数据。
        6.5        给一个字段添加主键约束，被称为单一主键。
                    //单一主键
                    //列级约束
                    DROP TABLE IF EXISTS t_user;
                    CREATE TABLE t_user(
                        id INT(5) UNSIGNED PRIMARY KEY,
                        name VARCHAR(20)
                    );
                    //单一主键
                    //表级约束
                    DROP TABLE IF EXISTS t_user;
                    CREATE TABLE t_user(
                        id INT(5) UNSIGNED,
                        name VARCHAR(20),
                        PRIMARY KEY(id)
                    ); 

                    //单一主键
                    //表级约束
                    //起名
                    DROP TABLE IF EXISTS t_user;
                    CREATE TABLE t_user(
                        id INT(3) UNSIGNED,
                        name VARCHAR(32),
                        email VARCHAR(40),
                        CONSTRAINT t_user_id_pk PRIMARY KEY(id)
                    );


        6.6        给多个字段联合添加一个主键约束，被称为复合主键。

                    //复合主键
                    //表级约束
                    //起名
                    DROP TABLE IF EXISTS t_user;
                    CREATE TABLE t_user(
                        id INT(2) UNSIGNED,
                        name VARCHAR(10),
                        CONSTRAINT t_user_id_pk PRIMARY KEY(id,name)
                    );
                    INSERT INTO t_user(id,name) values(10000,&#39;jack&#39;);
                    INSERT INTO t_user(id,name) values(10000,&#39;cntsp&#39;);
                    INSERT INTO t_user(id,name) values(5456,&#39;cntsp&#39;);
                    COMMIT;
                    SELECT * FROM t_user;

        6.7        无论是单一主键还是复合主键，一张表主键约束只能有一个。
        6.8        主键根据性质分类：
                -    自然主键
                    *     主键值若是一个自然数，这个自然数和当前表的业务没有任何关系，这种主键叫做自然主键
                -    业务主键
                    *    主键值若和当前表中业务紧密相关的，那么这种主键值被称为业务主键，当业务数据发生改变的时候，主键值通常受到影响。
                    所以业务主键使用较少。大部分都是使用自然主键

            6.9        在MYSQL数据库管理系统中提供了一个自增的数字，专们用来自动生成主键值。
                    主键值不需要用户维护，也不需要用户提供了，自动生成的，这个自增的数字默认从1开始，以1递增：
                    1,2,3,4,5,6,7,8.....

                    DROP TABLE IF EXISTS t_user;
                    CREATE TABLE t_user(
                        id INT(10) UNSIGNED PRIMARY KEY auto_increment,
                        name VARCHAR(32),
                        email VARCHAR(40)
                    );
                    INSERT INTO t_user(name,email) values(&#39;jack&#39;,&#39;123@qq.com&#39;);
                    INSERT INTO t_user(name,email) values(&#39;jack&#39;,&#39;123@qq.com&#39;);
                    COMMIT;

    7    外键约束foreign  key-简称FK
        7.1    外键涉及到的术语：
                -    外键约束
                -    外键字段
                -    外键值
        7.2    外键约束、外键字段、外键值之间的的关系？
                某个字段添加外键约束之后，该字段称为外键字段
                外键字段中的每一个数据都是外键值
        7.3    外键也分为：单一外键【给一个字段添加外键约束】和复合外键【给多个字段联合添加一个外键约束】

        7.4    一张表中可以有多个外键字段

        7.5    分析场景：
            请设计数据库表用来存储学生和班级信息，给出两种解决方案
            学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系
            第一种涉及方案：将学生信息和班级信息存储到一张表中。
            学生信息表t_student
            sno(pk)     sname        classno        cname
            ---------------------------------------------------------
            1            jack        100            北京海定区...高三1班
            2            lucy        100            北京海定区...高三1班
            3            zhangsan     100            北京海定区...高三1班
            4            ford        200            北京海定区...高三2班
            5            king        200            北京海定区...高三2班
            6            allen        300            北京海定区...高三3班
            7            lisi        300            北京海定区...高三3班

            以上设计的缺点：数据臃肿
            第二种解决方案：将学生信息和班级信息分开两张表存储，学生表 + 班级表
            学生表t_student
            sno(pk)        sname       classno(fk)
            -----------------------------------
            1            jack        100
            2            lucy        100
            3            zhangsan    100
            4            ford        200
            5            king        200
            6            allen        300
            7            lisi        300
            班级表t_class
            cno(pk)         cname
            ------------------------------------------------
            100                北京海淀区....高三1班
            200                北京海淀区....高三2班
            300                北京海淀区....高三3班

            结论：为了保证t_student表中的class字段中的数据必须来自于t_class表中cno字段中的数据，有必要给t_studnet
            表中的classno字段添加外键约束，classno字段被称为外键字段，该字段中的100 200 300被称为外键值。classno这里是一个单一外键字段
            注：    外键值可以为NULL
            注：    外键字段去引用一张表的某个字段的时候，被引用的字段必须具有unique约束。
            注：    有了外键引用之后，表分为父表和子表，以上父表是：班级表，子表是：学生表
            创建表先创建父表，再创建子表，删除数据的时候先删除子表中的数据，再删除父表中的数据，插入父表中的数据，再插入子表中的数据。
            -------------------------------------SQL文----------------------------------------------------------------
            DROP TABLE IF EXISTS t_student;
            DROP TABLE IF EXISTS t_class;
            CREATE TABLE t_class(
                    cno int(3) unsigned primary key,
                    cname varchar(120) not null unique
            );
            CREATE TABLE t_student(
                sno int(3) unsigned primary key,
                sname varchar(32) not null,
                classno int(3) unsigned,
                constraint t_student_classno_fk foreign key(classno) references t_class(cno)
            );
            insert into t_class(cno,cname) values(100,&#39;高三1班&#39;);
            insert into t_class(cno,cname) values(200,&#39;高三2班&#39;);
            insert into t_class(cno,cname) values(300,&#39;高三3班&#39;);

            insert into t_student(sno,sname,classno) values(1,&#39;jack&#39;,100);
            insert into t_student(sno,sname,classno) values(2,&#39;lucy&#39;,100);
            insert into t_student(sno,sname,classno) values(3,&#39;zhangsan&#39;,100);
            insert into t_student(sno,sname,classno) values(4,&#39;ford&#39;,200);
            insert into t_student(sno,sname,classno) values(5,&#39;king&#39;,200);
            insert into t_student(sno,sname,classno) values(6,&#39;allen&#39;,300);
            insert into t_student(sno,sname,classno) values(7,&#39;lisi&#39;,300);

            select * from t_student;
            select * from t_class;
            commit;
            insert into t_student(sno,sname,classno) values(8,&#39;lisi&#39;,500);
            -------------------------------------SQL文-------------------------------------------------------------------
            找出每个学生的班级名称

            mysql&gt; SELECT s.sname,c.cname from t_student s join t_class c on s.classno = c.cno;
            +----------+------------+
            | sname    | cname      |
            +----------+------------+
            | jack     | 高三1班    |
            | lucy     | 高三1班    |
            | zhangsan | 高三1班    |
            | ford     | 高三2班    |
            | king     | 高三2班    |
            | allen    | 高三3班    |
            | lisi     | 高三3班    |
            +----------+------------+
            7 rows in set (0.00 sec)

            重点：典型的一对多，在多的一方加外键

8    级联更新和级联删除
        -    添加级联更新和级联删除的时候要在外键约束后面添加

        -     在删除父表中数据的时候，级联删除子表中的数据
                * 删除外键约束
                    alter table t_student drop foreign key t_student_classno_fk;
                * 添加外键的约束
                    alert table t_student add 
                    constraint t_student_classno_fk
                    foreign key(classno) t_class(cno) on delete cascade;
        -    在更新父表中数据的时候，级联更新子表中的数据
                * 删除外键约束
                    alter table t_student drop foreign key t_student_classno_fk;
                * 添加外键的约束
                    alert table t_student add 
                    constraint t_student_classno_fk
                    foreign key(classno) t_class(cno) on update cascade ;

        -    以上的级联更新和级联删除谨慎使用，因为级联操作会将数据改变或者删除【数据无价】


15    存储引擎
    存储引擎的使用
        数据库中的各表均被(在创建表时)指定的存储引擎来处理。
        服务器可用的引擎依赖于以下因素：
            &gt; * MySQL的版本
            &gt; * 服务器在开发时如何被配置
            &gt; * 启动选项
为了了解当前服务器中有哪些存储引擎可用，可使用SHOW ENGINES语句：
mysql&gt; SHOW ENGINES\G;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)


15.2.1     MyISAM存储引擎
        &gt; * MyISAM    存储引擎是MySQL最常用的引擎
        &gt; * 它管理的表具有以下特征：
            -     使用三个文件表示每个表:
                    &gt; * 使用三个文件表示每个表：
                        * 格式文件 -存储表结构的定义(mytable.frm)
                        * 数据文件 -存储表行的内容(mytable.MYD)
                        * 索引文件 -存储表上索引(mytable.MYI)
                    -    灵活的AUTO_INCREMENT字段处理
                    -    可被转换为压缩、只读表来节省空间

15.2.2        InnoDB存储引擎
            &gt;    *     InnoDB存储引擎是MySQL的缺省引擎。
            &gt;    *     它管理的表具有以下主要特征：
                    -    每个InooDB表在数据库目录中以.frm格式文件表示
                    -    InnoDB表空间tablespace被用于存储表的内容
                    -    提供一组用来记录事务性活动的日志文件
                    -    用COMMIT(提交)、SAVEPOINT及ROLLBACK(回滚)支持事务处理
                    -    提供全ACID兼容
                    -    在MySQL服务器崩溃后提供自动恢复
                    -    多版本(MVCC)和行级锁定
                    -    支持外键及引用的完整性，包括级联删除和更新

            MEMORY存储引擎
                    *    使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得MEMORY存储引擎非常快
                    *    MEMORY存储引擎管理的表具有一下特征：
                        -    在数据库目录内，每个表均以.frm格式的文件表示
                        -    表数据及索引被存储在内存中
                        -    表级锁机制
                        -    不能包含TEXT或BLOB字段
                    *    MEMORY存储引擎以前被称为HEAP引擎。

        15.3        选择合适的存储引擎
                    *    MyISAM 表最适合于大量的数据读而少量数据更新的混合操作，MyISAM表的另一种使用情形是使用压缩的只读表。
                    *    如果查询中包含较多的数据更新操作，应使用InnoDB,其行级锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制。
                    *    可使用MEMORY存储引擎来存储非永久需要的数据，或者是能够从基于磁盘的表中重新生成的数据。


    事务：
            1    什么是事务？
                    -    事务对应的英语但是：Transaction
                    -    事务：一个最小的不可再分的工作单元。
                    -    通常一个事务对应一个完整的业务。 【例如：银行账户转账业务，该业务就是一个最小的工作单元】
                    -    而一个完整的业务需要批量的DML语句(insert,update,delete)共同联合完成。
                    -    事务只和DML语句有关系，或者说DML语句才有事务
                    -    以上所描述的&quot;批量的DML语句&quot;共有多少条DML语句，这个和业务逻辑有关系
                    业务逻辑不同DML语句的个数不同。

            2.    关于银行账户转账操作，账户转账是一个完整的业务，最小的单元，不可再分。也就是说银行账户转账是一个事务。
                    t_act 账户表
                    actno        balance
                    -----------------------------------------
                    act-001        50000.0
                    act-002        10000.0

                    执行转账操作(10000):
                        update     t_act set balance=40000.0    where actno=&#39;act-001&#39;;
                        update  t_act set balance=20000.0    where actno=&#39;act-002&#39;;
                        以上的两条DML语句要求必须同时成功或者同时失败，最小单元，不可再分。当第一条DML语句执行成功之后，并不能将底层数据库中第一个账户的数据修改。只是将操作记录一下，这个记录是在内存中完成的，当第二条DML语句执行失败，情况所有的历史操作记录。要完成以上的功能，必须借助事务。

        3    事务的四个特性：
                -    原子性(A)【Atomicity,或称不可分割性】
                        * 事务是最小的工作单元，不可再分
                -    一致性(C)【Consistency】
                        *  事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败

                -    隔离性(I)【isolation】
                        *    事务A和事务B之间具有隔离
                -    持久性(D)【Durablity】
                        *    是事务的保证，事务终结的标志【内存中的数据持久到硬盘文件中】

        4    关于一些术语：
                -    开启事务: Start Transaction
                -    事务结束：End Transaction
                -    提交事务: Commit Transacton
                -    回滚事务: Rollback Transaction

        5    和事务有关的两条重要的SQL语句【TCL】
                commit:      提交     成功的结束，将所有的DML语句操作历史记录和底层硬盘文件中的数据来一次同步。
                rollback:    回滚    失败的结束，将所有的DML语句操作历史记录全部清空

        6    事务开启的标志是什么？事务结束的标志是什么？
                -    开启的标志
                -    结束的标志

        7    重点：
                在事务进行过程中，未结束之前，DML语句是不会更改底层数据库文件中的数据。只是将历史操作记录一下，在内存中完成记录。
                只有在事务结束的时候，而且是成功的结束的时候才会修改底层硬盘文件中的数据。

    8    在MYSQL数据库管理系统中，事务的提交和回滚的演示
        -    在MYSQL数据库管理系统中，默认情况下，事务是自动提交的，也就是说，只要执行一条DML语句，开启了事务，并且提交了事务。
        -    这种自动提交机制是可以关闭的: 【关闭的第一种方式】
            start transaction;     手动开启事务
            DML语句...
            DML语句...
            DML语句...
            commit;             手动提交事务【事务成功的结束】

            start transaction;    手动开启事务
            DML语句...
            DML语句...
            DML语句...
            DML语句...
            DML语句...
            rollback;    手动回滚事务【事务失败的结束】


            -    如果禁用自动提交，事务可以跨越多条语句。
            -    在这种情况下，事务可以用COMMIT和ROLLBACK语句来显式地提交或回滚。
    *    自动提交模式下可以通过服务器变量AUTOCOMMIT来控制
    例如：
        关闭自动提交模式
        mysql&gt;SET AUTOCOMMIT = OFF;
        或
        mysql&gt;SET SESSION AUTOCOMMIT = OFF;

        打开自动提交模式
        mysql&gt;SET AUTOCOMMIT = ON;
        或
        mysql&gt;SET SESSION AUTOCOMMIT = ON;

        只对当前事务有效
        mysql&gt;show variables like &#39;%auto%&#39;;查看变量状态

9    事务四个特性之一：隔离性(isolation)    
        9.1    事务A和事务B之间具有一定的隔离性
        9.2    隔离性有隔离级别(4个)：
                -    read uncommitted 读未提交
                -    read committed   读已提交
                -   repeatable read  可重复性
                -    serializable     串行化
        9.3    read uncommitted 读未提交
            -    事务A和事务B，事务A未提交的数据，事务B可以读取到
            -    这里读取到的数据可以叫做&quot;脏数据&quot;或者叫做“Dirty Read”
            -    这种隔离级别是最低级别，这种级别一般都是在理论上存在，数据库默认的隔离级别一般都是高于该隔离界别的。
        9.4    read committed 读已提交
            -    事务A和事务B，事务A提交的数据，事务B才能读取到。
            -    这种隔离级别高于上面的读未提交
            -    换句话说：对方事务提交之后的数据，我当前事务才能过读取到。
            -    这种隔离级别可以避免脏数据。
            -    这种隔离界别会导致：“不可重复读取”
            -    Oracle数据库管理系统默认的隔离级别就是：读已提交
        9.5    repeatable read 可重复读
            -    事务A和事务B，事务A提交之后的数据，事务B读取不到。
            -    事务B是可重复读取数据的
            -    这种隔离级别高于读取数据的。
            -    换句话说：对方提交之后的数据我还是读取不到.
            -    这种隔离级别可以避免“不可重复读取”，达到可重复读取
            -    MYSQL数据库管理系统默认的隔离级别就是：可重复读
            -    虽然可以达到“可重复读”的效果，但是会导致：“幻象读”
        9.6    serializable  串行化
            -    事务A和事务B，事务A在操作数据库表中数据的时候，事务B只能排队等待。
            -    这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好。
            -    这种隔离级别可以避免“幻象读”，每一次读取的都是数据库表中真实记录。
            -    事务A和事务B不再并发。

10.        隔离级别与一致性问题的关系
        隔离级别        脏读取        不可重复读取    

        设置事务的隔离级别：
            第一种方式：修改my.ini配置文件
            可选值：
                -    READ-UNCOMMITTED
                -    READ-COMMITTED
                -    REPEATABLE-READ
                -    SERIALIZABLE
                ----------------my.ini----------------
                [mysqld]
                transaction-ioslation = READ-COMMITTED


            第二种方式：使用命令动态设置事务的隔离级别
            &gt;    *     隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句
            &gt;    *    语法模式为： SET|GLOBAL|SESSION|TRANSACTION|ISOLATIONLEVEL &lt;isolation-level&gt;
            其中的&lt;isolation-level&gt;可以是：
                -    READ-UNCOMMITTED
                -    READ-COMMITTED
                -    REPEATABLE-READ
                -    SERIALIZABLE
            例如：SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

    隔离级别的作用范围：
            事务隔离级别的作用范围分为两种：
                -    全局及：对所有的会话有效
                -    会话级：只对当前的会话有效
            &gt;*    例如：设置会话级隔离级别为READ COMMITTED；
                SET TRANACTION ISOLATION LEVEL READCOMMITTED;
                或者：
                SET SESSION TRANACTION ISOLATION LEVEL READ COMMITTED;
                设置全局级隔离级别为READ COMMITTED
                SET GLOBAL TRANACTION ISOLATION LEVEL READ COMMITTED;


        16.4.6  查看隔离级别
                服务器变量tx_isolation(包含会话级和全局级两个变量)中保存着当前的会话隔离级别。
                为了查看当前隔离级别，可访问tx_isolation变量；
                    -    查看会话级的当前隔离级别；
                    mysql&gt; SELECT @@tx_isolation;
                    或：
                    mysql&gt; SELECT @@session.tx_isolation;
                    查看全局级的当前隔离级别；
                    mysql&gt;SELECT @@global.tx_isolation

        12    并发事务与隔离级别示例
            12.1    读未提交     read uncommitted</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level read uncommitted;<br>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;<br>start transaction;                                                                            start transacton;<br>insert into t_user(name) values(‘wangwu’);                                                    select * from t_user;</p>
<pre><code>                                                                                select * from t_us
    12.2    可重复读     read committed</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level read committed;<br>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;</p>
<p>start transaction;                                                                            start transacton;</p>
<p>insert into t_user(name) values(‘ford’);                                                    select * from t_user;</p>
<p>commit;                                                                                        select * from t_user;</p>
<pre><code>        12.3    可重复读     repeatable read</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level repeatable read;<br>select @@tx_isolation;</p>
<hr>
<p>|@@tx_isolation |<br>+—————+<br>|READ-COMMITTED |</p>
<p>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;</p>
<p>start transaction;                                                                            start transacton;</p>
<p>select * from t_user;                                                                       select * from t_user;</p>
<p>insert into t_user(name) values(‘cntsp’);                                                    select * from t_user;</p>
<p>commit;                                                                                        select * from t_user;</p>
<pre><code>索引：
    1    什么是索引？
            -    索引对应的英语单词是：index
            -    索引相当于一本字典的目录，索引的作用是提高程序的检索【查询】效率。
    2    主键自动添加索引，所以能够通过主键查询尽量通过主键查询，效率较高。
    3    索引和表相同，都是一个对象，表是存储在硬盘文件中的，那么索引是表的一部分，索引也是存储在硬盘文件中。
    4    在MYSQL数据库管理系统中，对表中记录进行检索的时候，通常包括几种检索方式：
        第一种方式：全表扫描【效率较低】
                假设有一张表：emp员工表
                select * from emp where ename=&#39;KING&#39;;
                若ename字段上没有添加索引，那么在通过ename字段过滤数据的时候
                ename字段会被全表扫描

                假设有一张表：dept部门表
                select * from dept where dname=&#39;ACCOUNTING&#39;;
                若dname字段上没有索引，那么在通过dname字段过滤数据的时候，dname字段会被全部扫描

        第二种方式：通过索引进行检索【提高查询效率】

5.    一张表中有多个字段，每一个字段都是可以添加索引的。
6.    什么情况下适合给表中的某个字段添加索引呢？
        -    该字段数据量庞大
        -    该字段很少的DML操作【DML操作很多的话，索引也是需要不断的维护，效率反而降低】
        -    该字段经常出现在where子句中

        索引原理
            索引被用来快速找出在一个列某一特定值的行，没有索引，MySQL不得不首先以第一条记录开始，然后读完整个表知道它找出相关的行。表越大，花费时间越多，对于一个有序字段，可以运用二分查找(BinarySearch)，这就是为什么性能能得到本质上的提高。MYISAM和INNODB都是B+Tree作为索引结构。
            (主键：unique都会默认的添加索引)

    7    怎么创建索引?
        create index dept_dname index on dept(dname);
        create unique index dept_dname_index on dept(dname);//添加unique表示dept表中的dname字段添加一个唯一性约束

    8    删除索引
        drop     index dept_dname_index on dept;

19    DBA命令
    19.1    新建命令
            CREATE USER username IDENTIFIED BY &#39;password&#39;;
            说明username --你将创建的用户名，password --该用户的登录密码：密码可以为空，如果为空则该用户可以不需要密码登录服务器
    192.    授权
            命令详解
            mysql&gt;grant all privileges on dbname.tbname to username@&#39;loginip&#39; identified by &#39;passwd&#39; with grant option;
            dbname=*  表示所有数据库
            taname=*  表示所有表

    19    导出
            导出整个数据库
            在windows 的DOS命令窗口中执行：mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123
            导出指定库下的指定表
            在window的dos命令窗口中执行：mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p123

    19.4.2    导入
            mysql&gt;source D:\bjpowernode.sql</code></pre><p>数据库设计三范式：<br>        1、 数据库设计三范式：<br>            设计数据库表的时候所依据的规范，共三个规范</p>
<pre><code>        第一范式：
            要求有主键，并且要求每一个字段原子性不可再分
            数据库表中不能出现重复记录，每个字段是原子性的不能再分
            不符合第一范式的示例
            ------------------------------------------------------------
            学生编号        学生姓名            联系方式
            ------------------------------------------------------------
            1001            张三                zs@gamil.com.13599999999
            ------------------------------------------------------------
            1002            李四                ls@gmail.com.13699999999
            ------------------------------------------------------------
            1001            王五                ww@163.com.134888888888
            ------------------------------------------------------------
            存在的问题：
                ** 最后一条记录和第一条重复(不唯一，没有主键) **
                ** 联系方式字段可以再分，不是原子性的 **
            修改后为：
            --------------------------------------------------------------------
            学生编号        学生姓名            邮箱地址            电话号码
            --------------------------------------------------------------------
            1001            张三                zs@gamil.com        13599999999
            --------------------------------------------------------------------
            1002            李四                ls@gmail.com        13699999999
            --------------------------------------------------------------------
            1003            王五                ww@163.com          134888888888
            --------------------------------------------------------------------
            **关于第一范式,每一行必须唯一，也就是每个表必须有主键，这是我们数据库涉及的最基本要求，主要通常采用数值型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定，如联系方式，为了开发上的便利可能就采用一个字段了**

        第二范式：
            要求所有非主键字段完全依赖主键，不能产生部分依赖
            第二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖
            示例：

            --------------------------------------------------------------------
            学生编号        学生姓名            教师编号            电话号码
            --------------------------------------------------------------------
            1001            张三                001                    王老师
            --------------------------------------------------------------------
            1002            李四                002                    赵老师
            --------------------------------------------------------------------
            1003            王五                001                  王老师
            --------------------------------------------------------------------
            1001            张三                002                    赵老师
            --------------------------------------------------------------------

            确定主键：
            --------------------------------------------------------------------
            学生编号(PK)        教师编号(PK)        学生姓名        教师姓名
            --------------------------------------------------------------------
            1001                001                    张三            王老师
            --------------------------------------------------------------------
            1002                002                    李四            赵老师
            --------------------------------------------------------------------
            1003                001                    王五            王老师
            --------------------------------------------------------------------
            1001                002                    张三            赵老师
            --------------------------------------------------------------------
            以上虽然确定了主键，但此表会出现大量的沉余，主要涉及到的沉余字段为“学生姓名”和“教师姓名”，出现沉余的
            原因在于，学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部门依赖了主键的一个字段教师编号，这就是第二范式部分依赖。
            解决方案如下：
            学生信息表：
            ------------------------------------------------
            学生编号(PK)            学生姓名
            ------------------------------------------------
            1001                    张三
            ------------------------------------------------
            1002                    李四
            ------------------------------------------------
            1003                    王五
            ------------------------------------------------

            教师信息表
            ------------------------------------------------
            教师编号(PK)            教师姓名
            ------------------------------------------------
            001                        王老师
            ------------------------------------------------
            002                        赵老师
            ------------------------------------------------

            教师和学生的关系表
            -------------------------------------------------------------------------
            学生编号(PK) fk-&gt;学生表的学生编号        教师编号(PK)fk-&gt;教师表的教师编号
            -------------------------------------------------------------------------
            1001                                        001
            -------------------------------------------------------------------------
            1002                                        002
            -------------------------------------------------------------------------
            1003                                        001
            -------------------------------------------------------------------------
            1001                                        002
            -------------------------------------------------------------------------
            如果一个表是单一主键，那么它就是复合第二范式，部分依赖和主键有关系
            以上是一种典型的“多对多”的涉及


        第三范式：
            所有非主键字段和主键字段之间不能产生传递依赖
            建立在第二范式基础上的，非主键字段不能传递依赖与主键字段(不要产生传递依赖)
            --------------------------------------------------------------------------
            学生编号(PK)         学生姓名        班级编号            班级名称
            --------------------------------------------------------------------------
            1001                张三            01                    一年一班
            --------------------------------------------------------------------------
            1002                李四            02                    一年二班
            --------------------------------------------------------------------------
            1003                王五            03                    一年三班
            --------------------------------------------------------------------------
            1004                赵六            03                    一年三班
            --------------------------------------------------------------------------
            从上表可以看出，班级名称字段存在沉余，因为班级名称字段没有直接依赖于主键，班级名称字段依赖与班级编号，
            班级编号依赖于学生编号，那么这就是传递依赖，解决的办法是将沉余字段单独拿出来建立表，如：
            学生信息表：
            -----------------------------------------------------
            学生编号(PK)            学生姓名        班级编号(FK)
            -----------------------------------------------------
            1001                    张三            01
            -----------------------------------------------------
            1002                    李四            02
            -----------------------------------------------------
            1003                    王五            03
            -----------------------------------------------------
            1004                    赵六            03
            -----------------------------------------------------
            班级信息表
            -----------------------------------------------------
            班级编号(PK)                班级名称
            -----------------------------------------------------
            01                            一年一班
            02                            一年二班
            -----------------------------------------------------
            03                            一年三班
            -----------------------------------------------------
            以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一对一


    2、 几个比较经典的范式：
        一对一：
                第一种方案：    分两张表存储，共享主键
                                t_husband
                                hno(pk)    hname
                                --------------------
                                1            张三
                                2            王五
                                3            赵六
                                --------------------
                                t_wife
                                wno(pk) wname 【wno同时也是fk，引用t_husband中的hno】
                                -----------------------------------
                                3        a
                                2        b
                                1        c
                                ----------------------------------
                第二种方案：    分两张表存储，外键唯一

                                t_husband
                                hno(pk)    hname    wifeno
                                ----------------------------------
                                1            张三    100
                                2            王五    300
                                3            赵六    200
                                ----------------------------------
                                t_wife
                                wno(pk) wname 【wno同时也是fk，引用t_husband中的hno】
                                -----------------------------------
                                100        a
                                300     b
                                200        c
                                ----------------------------------


        一对多：分两张表存储，在多的一方添加外键，这个外键字段引用一对一放中的主键字段
        多对多：分三张表存储，在学生表中存储学生信息，在课程表中存储学生和课程信息

6    在实际开发中是怎样的？
        数据库设计尽量遵循三范式，
        但是还是根据实际情况进行取舍
        有时可能会拿沉余换速度
        最终目的要满足客户需求</code></pre>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://cntsp.github.io" rel="external nofollow noreferrer">阿培</a>
                </span>
            </div>

            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://cntsp.github.io" target="_blank">阿培</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/mysql/">
                                    <span class="chip bg-color">mysql</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/06/25/mysql%E4%BA%8B%E5%8A%A1/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="mysql事务">
                        
                        <span class="card-title">mysql事务</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深入学习MySQL事务：ACID特性的实现原理事务是MySQL等关系型数据库区别与NoSQL的中重要方面，是保证数据一致性的重要手段，本文将首先介绍MySQL事务相关的基础概念，然后介绍事务的ACID特性，并分析其实现原理
一    基础概
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-06-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/mysql/">
                        <span class="chip bg-color">mysql</span>
                    </a>
                    
                    <a href="/tags/transcation/">
                        <span class="chip bg-color">transcation</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/05/18/python-module-str-bytes/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="python-module-str-bytes">
                        
                        <span class="card-title">python-module-str-bytes</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python3 bytes和str的不同Python3 最重要的新特性之一是对字符串和二进制数据流做了明确区分。文本总是Unicode,由str类型表示，二进制数据则由bytes类型表示。Python3 不会以任意隐式的方式混用str和by
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-05-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/python%E5%9F%BA%E7%A1%80/" class="post-category">
                                    python基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/python/">
                        <span class="chip bg-color">python</span>
                    </a>
                    
                    <a href="/tags/str/">
                        <span class="chip bg-color">str</span>
                    </a>
                    
                    <a href="/tags/bytes/">
                        <span class="chip bg-color">bytes</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">年份</span>
            <a href="https://cntsp.github.io" target="_blank">阿培</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/cntsp" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1909873483@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1909873483" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1909873483" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
