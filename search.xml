<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSI七层模型与TCP/IP四层结构的区别/联系</title>
      <link href="/2019/12/11/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%81%94%E7%B3%BB/"/>
      <url>/2019/12/11/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一-OSI模型"><a href="#一-OSI模型" class="headerlink" title="一  OSI模型"></a>一  OSI模型</h2><p><strong>开放式系统互联模型(Open System Interconnection Model，缩写：OSI；简称为OSI模型)是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互联为网络的标准框架。定义于ISO/IEC 7498-1。</strong></p><p>OSI将计算机网络体系结构划分为以下七层：</p><ul><li><p>第七层：应用层</p><ul><li>应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3.HTML.等。</li></ul></li></ul><ul><li><p>第六层：表达层</p><ul><li>表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</li></ul></li><li><p>第五层：会话层</p><ul><li>会话层（Session Layer）负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</li></ul></li><li><p>第四层：传输层</p><ul><li>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</li></ul></li><li><p>第三层：网络层</p><ul><li>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络数据。例如:互联网协议（IP）等。</li></ul></li><li><p>第二层：数据链路层：</p><ul><li>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E8%A8%8A%E6%A1%86" target="_blank" rel="noopener">信息框</a>（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</li><li>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</li></ul></li><li><p>第一层：物理层</p><ul><li>物理层（Physical Layer）在局部局域网上传送<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%B8%A7" target="_blank" rel="noopener">数据帧</a>（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</li></ul></li></ul><h2 id="二-OSI七层和TCP-IP四层的关系"><a href="#二-OSI七层和TCP-IP四层的关系" class="headerlink" title="二  OSI七层和TCP/IP四层的关系"></a>二  OSI七层和TCP/IP四层的关系</h2><p>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p><p>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</p><table>    <tr><th>OSI七层网络模型</th><th>TCP/IP四层概念模型</th><th>对应网络协议</th></tr>    <tr><td>应用层(Application)</td><td rowspan="3">应用层</td><td>HTTP、TFTP、FTP、NFS、SMTP</td></tr>    <tr><td>表示层(Presentation)</td><td>Telnet、Rlogin、SNMP、Gopher</td></tr>    <tr><td>会话层(Session)</td><td>SMTP、DNS</td></tr>    <tr><td>传输层(Transport)</td><td>传输层</td><td>TCP、UDP</td></tr>    <tr><td>网络层(Network)</td><td>网络层</td><td>IP、ICMP、ARP、RARP、AKP、UUCP</td></tr>    <tr><td>数据链路层(Data Link)</td><td rowspan="2">数据链路层</td><td>FDDI、Ethernet、Arpanet、PDN</td></tr>    <tr><td>物理层(Physical)</td><td>IEEE802.1A  IEEE802.2到IEEE802.11</td></tr></table><p><strong>OSI七层和TCP/IP的区别</strong></p><ul><li>TCP/IP他是一个协议簇；而OSI（开放系统互联）则是一个模型，且TCP/IP的开发时间在OSI之前。</li><li>TCP/IP是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能；OSi则指定了哪个功能是属于哪一层的。</li><li>TCP/IP是五层(TCP/IP模型中把一两层独立开)结构，而OSI是七层结构。OSI的最高三层在TCP中用应用层表示。</li></ul><h2 id="三-TCP-IP参考模型概述"><a href="#三-TCP-IP参考模型概述" class="headerlink" title="三  TCP/IP参考模型概述"></a>三  TCP/IP参考模型概述</h2><p>ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员自己开发的TCP/IP协议栈获得了更为广泛的应用。如下图，是TCP/IP参考模型和OSI参考模型的对比示意图。</p><p><img src="https://cntsp.github.io/medias/contents/57.png" alt=""></p><p><strong>3.1 TCP/IP参考模型的层次结构</strong></p><p>TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。</p><p>最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。TCP/IP参考模型分为四个层次：应用层、传输层、网络互连层和主机到网络层。如下图所示。</p><p><img src="https://cntsp.github.io/medias/contents/58.png" alt=""></p><h2 id="四-TCP-IP四层功能概述"><a href="#四-TCP-IP四层功能概述" class="headerlink" title="四  TCP/IP四层功能概述"></a>四  TCP/IP四层功能概述</h2><p>在TCP/IP参考模型中，去掉了OSI参考模型中的会话层和表示层（这两层的功能被合并到应用层实现）。同时将OSI参考模型中的数据链路层和物理层合并为主机到网络层。下面，分别介绍各层的主要功能。</p><p><strong>4.1 主机到网络层</strong></p><p>网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，</p><p>然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。　</p><p><strong>4.2 网络互连层</strong></p><p>网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</p><p><strong>4.3 传输层</strong></p><p>在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。</p><p><strong>4.4 应用层</strong></p><p>TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　　<br>应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本链接协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。</p><h2 id="五-TCP-IP报文格式"><a href="#五-TCP-IP报文格式" class="headerlink" title="五  TCP/IP报文格式"></a>五  TCP/IP报文格式</h2><p><strong>5.1 IP报文格式</strong></p><p>IP协议是TCP/IP协议族中最为核心的协议。它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。</p><p>在局域网环境，IP协议往往被封装在以太网帧中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如下图所示：</p><p><img src="https://cntsp.github.io/medias/contents/59.png" alt=""></p><p><strong>分析：</strong>　　　</p><ul><li><p>版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。　　 　　　　</p></li><li><p>报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。　　　　　　　　</p></li><li><p>服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。 当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。 实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</p></li><li><p>总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。　　 　</p></li><li><p>标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。　　　</p></li><li><p>标志位字段：占3比特。标志一份数据报是否要求分段。　　 　　　　</p></li><li><p>段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据包开始的位置.</p></li><li><p>生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。　　 　　　　</p></li><li><p>协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。　　 　　　</p></li><li><p>头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。　　 　</p></li><li><p>源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。　　 　　　　</p></li><li><p>可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</p></li></ul><p><strong>5.2 TCP数据段格式</strong></p><p>TCP是一种可靠的、面向连接的字节流服务。源主机在传送数据前需要先和目标主机建立连接。然后，在此连接上，被编号的数据段按序收发。同时，要求对每个数据段进行确认，保证了可靠性。</p><p>如果在指定的时间内没有收到目标主机对所发数据段的确认，源主机将再次发送该数据段。</p><p><img src="https://cntsp.github.io/medias/contents/60.png" alt=""></p><p><strong>分析：</strong></p><ul><li><p>源、目标端口号字段：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。 　　　　</p></li><li><p>顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。　　 　　　　</p></li><li><p>确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。　　 　　　　</p></li><li><p>头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。　　 　　　　</p></li><li><p>标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：</p><ul><li>URG：紧急指针（urgent pointer）有效。　</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文段交给应用层。</li><li>RST：重建连接。　　 　　　</li><li>SYN：发起一个连接。FIN：释放一个连接。　　 　　　　</li></ul></li><li><p>窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。</p></li><li><p>TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。</p></li><li><p>紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p></li><li><p>选项字段：占32比特。可能包括”窗口扩大因子”、”时间戳”等选项。</p></li></ul><p><strong>5.3 UDP数据段格式</strong></p><p>UDP是一种不可靠的、无连接的数据报服务。源主机在传送数据前不需要和目标主机建立连接。数据被冠以源、目标端口号等UDP报头字段后直接发往目的主机。这时，每个数据段的可靠性依靠上层协议来保证。在传送数据较少、较小的情况下，UDP比TCP更加高效。</p><p><img src="https://cntsp.github.io/medias/contents/61.png" alt=""></p><p><strong>分析：</strong></p><ul><li>源、目标端口号字段：占16比特,作用与TCP数据段中的端口号字段相同,用来标识源端和目标端的应用进程。</li><li>长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。　　</li><li>校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。</li></ul><p><strong>5.4 套接字</strong></p><p>在每个TCP、UDP数据段中都包含源端口和目标端口字段。有时，我们把一个IP地址和一个端口号合称为一个套接字（Socket），而一个套接字对（Socket pair）可以唯一地确定互连网络中每个TCP连接的双方（客户IP地址、客户端口号、服务器IP地址、服务器端口号）。</p><p><img src="https://cntsp.github.io/medias/contents/62.png" alt=""></p><p>注意：不同的应用层协议可能基于不同的传输层协议，如FTP、TELNET、SMTP协议基于可靠的TCP协议。TFTP、SNMP、RIP基于不可靠的UDP协议。同时，有些应用层协议占用了两个不同的端口号，如FTP的20、21端口，SNMP的161、162端口。这些应用层协议在不同的端口提供不同的功能。如FTP的21端口用来侦听用户的连接请求，而20端口用来传送用户的文件数据。再如，SNMP的161端口用于SNMP管理进程获取SNMP代理的数据，而162端口用于SNMP代理主动向SNMP管理进程发送数据。还有一些协议使用了传输层的不同协议提供的服务。如DNS协议同时使用了TCP 53端口和UDP 53端口。DNS协议在UDP的53端口提供<a href="https://cloud.tencent.com/product/cns?from=10680" target="_blank" rel="noopener">域名解析</a>服务，在TCP的53端口提供DNS区域文件传输服务。</p><p>附加一张经典图：</p><p><img src="https://cntsp.github.io/medias/contents/56.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI模型 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java连接器与MySql版本对应问题</title>
      <link href="/2019/12/11/java%E8%BF%9E%E6%8E%A5%E5%99%A8%E4%B8%8EMySql%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E9%97%AE%E9%A2%98/"/>
      <url>/2019/12/11/java%E8%BF%9E%E6%8E%A5%E5%99%A8%E4%B8%8EMySql%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="两种版本的MySQL-Connector-J"><a href="#两种版本的MySQL-Connector-J" class="headerlink" title="两种版本的MySQL Connector / J"></a>两种版本的MySQL Connector / J</h2><ul><li>Connector / J 5.1是Type 4纯Java JDBC驱动程序，符合JDBC 3.0、4.0、4.1和4.2规范。 它与MySQL的所有功能（包括5.6、5.7和8.0）兼容。 Connector / J 5.1提供了易于开发的功能，包括使用驱动程序管理器自动注册，标准化的有效性检查，分类的SQLException，对大量更新计数的支持，对<code>java.time</code>包中本地和偏移日期时间变体的支持，对JDBC-4.x XML处理，支持每个连接客户端信息，并支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=en&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://dev.mysql.com/doc/refman/5.7/en/char.html&xid=17259,15700021,15700186,15700191,15700256,15700259,15700262,15700265,15700271,15700283&usg=ALkJrhidBX6xMyvP2jTatsze-hCZ2wxt9g" target="_blank" rel="noopener"><code>NCHAR</code></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=en&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://dev.mysql.com/doc/refman/5.7/en/char.html&xid=17259,15700021,15700186,15700191,15700256,15700259,15700262,15700265,15700271,15700283&usg=ALkJrhidBX6xMyvP2jTatsze-hCZ2wxt9g" target="_blank" rel="noopener"><code>NVARCHAR</code></a>和<code>NCLOB</code>数据类型。</li><li>Connector / J 8.0是用于Java 8平台的Type 4纯Java JDBC 4.2驱动程序。 它提供与MySQL 5.6、5.7和8.0的所有功能的兼容性。 有关详细信息，请参见《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=en&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=https://dev.mysql.com/doc/connector-j/8.0/en/&xid=17259,15700021,15700186,15700191,15700256,15700259,15700262,15700265,15700271,15700283&usg=ALkJrhiG8_9Ej1VKMHIDlit16mRnMWC11Q" target="_blank" rel="noopener">MySQL Connector / J 8.0开发人员指南</a> 》。</li></ul><p>下表总结了可用的Connector / J版本，以及不同版本的JDBC，MySQL Server和Java的兼容性信息，以及每种Connector / J版本的支持状态：</p><p><strong>表2.1 Connector / J 版本摘要</strong></p><p><img src="https://cntsp.github.io/medias/contents/55.png" alt=""></p><p>问题：在跟随着  <strong>Kubernetes权威指南 第4版.pdf</strong>   学习过程中，1.3节中的一个 java 的demo实例中，通过yaml创建了Web App容器和MySQL容器，Web App容器需要访问MySQL容器。下面我把这两个服务的yaml文件pose出来：</p><p>mysql的deployment和service的yaml文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> mysql<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> mysql  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> mysql    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql        <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">3306</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MYSQL_ROOT_PASSWORD          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3306</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> mysql</code></pre><p>Web APP的deployment和service的yaml文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>     <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb          <span class="token key atrule">image</span><span class="token punctuation">:</span> kubeguide/tomcat<span class="token punctuation">-</span>app<span class="token punctuation">:</span>v1          <span class="token key atrule">ports</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb</code></pre><p>但是在kubectl create -f  这两个文件后，查看其中的一个 Pod 日志发现报错信息：</p><pre class=" language-shell"><code class="language-shell">[root@k8s-master test]# kubectl logs myweb-6557d8b869-xk9m911-Dec-2019 06:05:00.070 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version:        Apache Tomcat/8.0.3511-Dec-2019 06:05:00.071 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          May 11 2016 21:57:08 UTC11-Dec-2019 06:05:00.071 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server number:         8.0.35.011-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux11-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            3.10.0-1062.4.1.el7.x86_6411-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd6411-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/lib/jvm/java-7-openjdk-amd64/jre11-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           1.7.0_101-b0011-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation11-Dec-2019 06:05:00.072 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /usr/local/tomcat11-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /usr/local/tomcat11-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties11-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager11-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=204811-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.endorsed.dirs=/usr/local/tomcat/endorsed11-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/usr/local/tomcat11-Dec-2019 06:05:00.073 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/usr/local/tomcat11-Dec-2019 06:05:00.074 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/usr/local/tomcat/temp11-Dec-2019 06:05:00.074 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent Loaded APR based Apache Tomcat Native library 1.2.7 using APR version 1.5.1.11-Dec-2019 06:05:00.074 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].11-Dec-2019 06:05:00.078 INFO [main] org.apache.catalina.core.AprLifecycleListener.initializeSSL OpenSSL successfully initialized (OpenSSL 1.0.2h  3 May 2016)11-Dec-2019 06:05:00.179 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler ["http-apr-8080"]11-Dec-2019 06:05:00.192 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler ["ajp-apr-8009"]11-Dec-2019 06:05:00.195 INFO [main] org.apache.catalina.startup.Catalina.load Initialization processed in 575 ms11-Dec-2019 06:05:00.222 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service Catalina11-Dec-2019 06:05:00.222 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet Engine: Apache Tomcat/8.0.3511-Dec-2019 06:05:00.231 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/ROOT11-Dec-2019 06:05:00.563 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/ROOT has finished in 332 ms11-Dec-2019 06:05:00.563 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/docs11-Dec-2019 06:05:00.586 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/docs has finished in 23 ms11-Dec-2019 06:05:00.586 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/examples11-Dec-2019 06:05:00.915 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/examples has finished in 329 ms11-Dec-2019 06:05:00.915 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/host-manager11-Dec-2019 06:05:00.956 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/host-manager has finished in 41 ms11-Dec-2019 06:05:00.957 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/manager11-Dec-2019 06:05:00.979 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/manager has finished in 23 ms11-Dec-2019 06:05:00.980 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/demo11-Dec-2019 06:05:01.134 INFO [localhost-startStop-1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.11-Dec-2019 06:05:01.139 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/demo has finished in 159 ms11-Dec-2019 06:05:01.143 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-apr-8080"]11-Dec-2019 06:05:01.155 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["ajp-apr-8009"]11-Dec-2019 06:05:01.156 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 961 msConnecting to database...com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:526)    at com.mysql.jdbc.Util.handleNewInstance(Util.java:404)    at com.mysql.jdbc.Util.getInstance(Util.java:387)    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:919)    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:898)    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:887)    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:862)    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2331)    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2084)    at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:795)    at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:44)    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:526)    at com.mysql.jdbc.Util.handleNewInstance(Util.java:404)    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:400)    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:327)    at java.sql.DriverManager.getConnection(DriverManager.java:571)    at java.sql.DriverManager.getConnection(DriverManager.java:215)    at org.apache.jsp.index_jsp._jspService(index_jsp.java:133)    at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)    at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)    at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:438)    at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396)    at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340)    at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292)    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212)    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502)    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141)    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)    at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:616)    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:528)    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1099)    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:672)    at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2508)    at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2497)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)    at java.lang.Thread.run(Thread.java:745)Caused by: java.lang.NullPointerException    at com.mysql.jdbc.ConnectionImpl.getServerCharset(ConnectionImpl.java:3004)    at com.mysql.jdbc.MysqlIO.sendConnectionAttributes(MysqlIO.java:1908)    at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1837)    at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1207)    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2254)    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2285)    ... 40 moreGoodbye!</code></pre><p>查看了Web APP 的pod项目程序里面用的连接器是mysql-connector-java-5.1.37.jar，java环境是JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/jre，后端的数据库是 mysql  Ver 8.0.18 for Linux on x86_64 (MySQL Community Server - GPL)，由于后端数据库为社区版8.0.18，最新版的，连接器不支持。造成连接不上数据库，我们把mysql的yaml中 image: mysql   修改为： image: mysql:5.7 或者 mysql:5.6</p><pre><code>[root@k8s-master test]# kubectl logs myweb-6557d8b869-c9t5z11-Dec-2019 06:31:54.876 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version:        Apache Tomcat/8.0.3511-Dec-2019 06:31:54.877 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          May 11 2016 21:57:08 UTC11-Dec-2019 06:31:54.877 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server number:         8.0.35.011-Dec-2019 06:31:54.877 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux11-Dec-2019 06:31:54.877 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            3.10.0-862.el7.x86_6411-Dec-2019 06:31:54.877 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd6411-Dec-2019 06:31:54.877 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/lib/jvm/java-7-openjdk-amd64/jre11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           1.7.0_101-b0011-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /usr/local/tomcat11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /usr/local/tomcat11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=204811-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.endorsed.dirs=/usr/local/tomcat/endorsed11-Dec-2019 06:31:54.878 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/usr/local/tomcat11-Dec-2019 06:31:54.879 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/usr/local/tomcat11-Dec-2019 06:31:54.879 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/usr/local/tomcat/temp11-Dec-2019 06:31:54.879 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent Loaded APR based Apache Tomcat Native library 1.2.7 using APR version 1.5.1.11-Dec-2019 06:31:54.879 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].11-Dec-2019 06:31:54.882 INFO [main] org.apache.catalina.core.AprLifecycleListener.initializeSSL OpenSSL successfully initialized (OpenSSL 1.0.2h  3 May 2016)11-Dec-2019 06:31:54.971 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;http-apr-8080&quot;]11-Dec-2019 06:31:54.981 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;ajp-apr-8009&quot;]11-Dec-2019 06:31:54.983 INFO [main] org.apache.catalina.startup.Catalina.load Initialization processed in 507 ms11-Dec-2019 06:31:55.008 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service Catalina11-Dec-2019 06:31:55.008 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet Engine: Apache Tomcat/8.0.3511-Dec-2019 06:31:55.018 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/ROOT11-Dec-2019 06:31:55.329 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/ROOT has finished in 311 ms11-Dec-2019 06:31:55.329 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/docs11-Dec-2019 06:31:55.349 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/docs has finished in 19 ms11-Dec-2019 06:31:55.349 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/examples11-Dec-2019 06:31:55.635 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/examples has finished in 286 ms11-Dec-2019 06:31:55.635 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/host-manager11-Dec-2019 06:31:55.659 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/host-manager has finished in 24 ms11-Dec-2019 06:31:55.659 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/manager11-Dec-2019 06:31:55.679 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/manager has finished in 20 ms11-Dec-2019 06:31:55.680 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory /usr/local/tomcat/webapps/demo11-Dec-2019 06:31:55.818 INFO [localhost-startStop-1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.11-Dec-2019 06:31:55.823 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory /usr/local/tomcat/webapps/demo has finished in 143 ms11-Dec-2019 06:31:55.828 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8080&quot;]11-Dec-2019 06:31:55.838 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]11-Dec-2019 06:31:55.844 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 860 msConnecting to database...Database created successfully...table created successfully...demo records inserted successfully...find recordfind recordfind recordfind recordfind recordfind recordGoodbye!Connecting to database...Goodbye!Connecting to database...find recordfind recordfind recordfind recordfind recordfind recordfind recordGoodbye!</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java连接器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群中证书时间</title>
      <link href="/2019/12/09/%E9%9B%86%E7%BE%A4%E4%B8%AD%E8%AF%81%E4%B9%A6%E6%97%B6%E9%97%B4/"/>
      <url>/2019/12/09/%E9%9B%86%E7%BE%A4%E4%B8%AD%E8%AF%81%E4%B9%A6%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p><strong>证书时间查看过程</strong></p><pre class=" language-shell"><code class="language-shell">[root@k8s-master kibana]# cd /etc/kubernetes/pki/[root@k8s-master pki]# lsapiserver.crt              apiserver-etcd-client.key  apiserver-kubelet-client.crt  ca.crt  etcd                front-proxy-ca.key      front-proxy-client.key  sa.pubapiserver-etcd-client.crt  apiserver.key              apiserver-kubelet-client.key  ca.key  front-proxy-ca.crt  front-proxy-client.crt  sa.key[root@k8s-master pki]# openssl x509 -in ca.crt -text -nooutCertificate:    Data:        Version: 3 (0x2)        Serial Number: 0 (0x0)    Signature Algorithm: sha256WithRSAEncryption        Issuer: CN=kubernetes        Validity            Not Before: Nov 23 06:21:35 2019 GMT            Not After : Nov 20 06:21:35 2029 GMT        Subject: CN=kubernetes        Subject Public Key Info:            Public Key Algorithm: rsaEncryption                Public-Key: (2048 bit)                Modulus:                    00:ba:a3:a3:9e:35:c2:93:59:e3:62:32:4b:85:17:                    50:eb:69:7e:0c:52:df:bb:c5:a3:de:43:da:84:28:                    92:dc:e3:13:d8:59:7a:d9:1d:84:35:77:27:6e:b6:                    39:58:7d:b3:2b:04:51:8d:29:ff:de:c0:f8:4f:03:                    7b:1e:39:2a:77:e6:a8:00:19:76:51:b7:86:ae:d3:                    e6:c1:87:b7:1f:f3:3f:cd:70:56:cf:61:c5:fe:12:                    72:10:88:46:cb:42:52:b3:b1:90:4a:f0:56:2b:bc:                    14:eb:0d:fa:d1:0f:b2:dd:d3:80:96:98:6c:5c:f7:                    f3:3a:4a:d0:df:3b:eb:d2:e2:c0:b6:95:99:03:1c:                    6f:4e:ff:9f:69:36:ba:f6:e2:a2:7e:d2:ea:79:44:                    56:54:bb:c9:0e:9f:a2:e1:1a:a1:25:0b:52:b1:26:                    e7:ae:40:f2:6b:b6:86:5a:22:49:23:48:95:b4:01:                    25:5f:3f:9a:5c:e8:a7:84:1d:29:1c:6f:7d:8b:76:                    4b:7b:aa:a9:89:68:7a:76:1d:58:e3:c0:00:2a:56:                    cc:99:fc:92:45:31:04:ef:31:26:bc:c4:88:61:e6:                    50:e5:f3:ef:90:a6:17:97:e5:80:e4:0f:b6:07:9d:                    99:62:5a:29:e8:24:bc:64:ac:97:b4:e9:db:c2:af:                    ef:9d                Exponent: 65537 (0x10001)        X509v3 extensions:            X509v3 Key Usage: critical                Digital Signature, Key Encipherment, Certificate Sign            X509v3 Basic Constraints: critical                CA:TRUE    Signature Algorithm: sha256WithRSAEncryption         b7:e9:3f:a8:d6:5a:d0:9d:94:07:c2:05:75:78:f5:e2:e5:20:         55:11:c9:59:ac:36:cd:7a:b8:2c:50:41:b3:90:2c:d1:cc:a7:         ed:d6:a1:92:ec:ca:5d:b1:92:ac:06:92:bb:8b:a0:6d:a8:a5:         62:f9:69:be:c5:9d:89:59:26:96:bd:40:9d:76:89:ce:b0:79:         ed:2e:bd:be:f4:1c:b4:5f:73:c5:b6:12:9f:9b:96:05:3c:9e:         ae:73:30:59:27:94:74:bd:9c:49:39:3d:f1:64:ab:84:f7:65:         3c:59:75:26:d7:7b:0c:4f:51:19:7e:34:b5:d5:56:08:cd:70:         50:dd:3e:9b:f4:b2:b9:de:ac:b8:4b:ee:a5:98:60:61:07:10:         dc:64:03:ad:0e:9e:cd:0a:21:93:19:43:36:9b:43:85:69:5e:         19:af:08:b8:4f:76:67:55:2f:d1:9b:b1:97:2a:3d:05:99:0f:         da:36:dd:a7:c3:1e:1c:4d:4e:0d:ef:06:75:ff:f0:85:66:f0:         d3:b9:6b:94:0f:f6:2c:73:44:15:60:1b:39:ac:86:bd:b2:e7:         f5:dd:6a:a9:b7:d8:57:d5:66:cd:51:d4:15:11:cd:e7:70:92:         ab:2c:ab:24:4a:82:1a:9e:3e:97:4b:43:39:c8:9a:32:5c:49:         0d:db:19:c2[root@k8s-master pki]# openssl x509 -in ca.crt -text -noout |grep GMT            Not Before: Nov 23 06:21:35 2019 GMT            Not After : Nov 20 06:21:35 2029 GMT[root@k8s-master pki]# openssl x509 -in apiserver -text -noout |grep GMTapiserver.crt                 apiserver-etcd-client.crt     apiserver-etcd-client.key     apiserver.key                 apiserver-kubelet-client.crt  apiserver-kubelet-client.key[root@k8s-master pki]# openssl x509 -in apiserver.crt -text -noout |grep GMT            Not Before: Nov 23 06:21:35 2019 GMT            Not After : Nov 22 06:21:36 2020 GMT[root@k8s-master pki]# openssl x509 -in  apiserver-etcd-client.crt -text -noout |grep GMT            Not Before: Nov 23 06:21:37 2019 GMT            Not After : Nov 22 06:21:38 2020 GMT## 通过修改kubeadm 源码，是各个组件证书有效期达到十年期限</code></pre><p><strong>通过上面的操作发现ca证书的年限最高十年，其它组件证书的有效期为一年，下面我们通过修改kubeadm源码，让各个组件有效期也为十年</strong></p><p><strong>1、go 环境部署</strong></p><pre class=" language-shell"><code class="language-shell">[root@k8s-master data]# wget https://dl.google.com/go/go1.12.5.linux-amd64.tar.gz--2019-12-09 19:45:42--  https://dl.google.com/go/go1.12.5.linux-amd64.tar.gz正在解析主机 dl.google.com (dl.google.com)... 172.217.161.174, 2404:6800:4005:80f::200e正在连接 dl.google.com (dl.google.com)|172.217.161.174|:443... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：120074076 (115M) [application/octet-stream]正在保存至: “go1.12.5.linux-amd64.tar.gz”100%[=====================================================================================================================================================>] 120,074,076 3.29MB/s 用时 35s    2019-12-09 19:46:22 (3.28 MB/s) - 已保存 “go1.12.5.linux-amd64.tar.gz” [120074076/120074076])[root@k8s-master data]# lsgo1.13.5.linux-amd64.tar.gz  nginx.file[root@k8s-master data]# tar -zxf go1.13.5.linux-amd64.tar.gz -C  /usr/local/[root@k8s-master data]# cd /usr/local/go[root@k8s-master go]# lsapi  AUTHORS  bin  CONTRIBUTING.md  CONTRIBUTORS  doc  favicon.ico  lib  LICENSE  misc  PATENTS  pkg  README.md  robots.txt  SECURITY.md  src  test  VERSION[root@k8s-master go]# cd /etc/profile.d/[root@k8s-master profile.d]# vim go.sh    export PATH=$PATH:/usr/local/go/bin[root@k8s-master profile.d]# source go.sh [root@k8s-master profile.d]# go versiongo version go1.12.5 linux/amd64</code></pre><p><strong>2、下载源码</strong></p><pre class=" language-shell"><code class="language-shell">cd /data && git clone https://github.com/kubernetes/kubernetes.gitgit checkout -b remotes/origin/release-1.15.1 v1.15.1</code></pre><p><strong>3、修改kubeadm源码包更新证书策略</strong></p><pre class=" language-shell"><code class="language-shell">vim staging/src/k8s.io/client-go/util/cert/cert.go   # kubeadm 1.14 版本之前vim cmd/kubeadm/app/util/pkiutil/pki_helpers.go  # kubeadm 1.14 至今    const duration3650d = time.Hour * 24 * 365 * 10    NotAfter:    time.Now().Add(duration3650d).UTC(),make WHAT=cmd/kubeadm GOFLAGS=-vcp _output/bin/kubeadm /root/kubeadm-new</code></pre><p><strong>4、更新kubeadm</strong></p><pre class=" language-shell"><code class="language-shell"># 将 kubeadm 进行替换cp /usr/bin/kubeadm /usr/bin/kubeadm.oldcp /root/kubeadm-new /usr/bin/kbueadmchmod a+x /usr/bin/kubeadm</code></pre><p><strong>5、更新各节点证书至 Master 节点</strong></p><pre class=" language-shell"><code class="language-shell">[root@k8s-master root]# cp -r /etc/kubernetes/pki /etc/kubernetes/pki.old[root@k8s-master root]# kubeadm alpha certs renew all --config=/usr/local/install-k8s/core/kubeadm-config.yaml[root@k8s-master root]# cd /etc/kubernetes/pki/[root@k8s-master pki]# openssl x509 -in apiserver.crt -text -noout |grep GMT</code></pre><pre class=" language-shell"><code class="language-shell"># 第三步修改 pki_helpers.go文件，两个地方，一个新增一个变量内容，一个更新这个变量内容源文件部分内容// NewSignedCert creates a signed certificate using the given CA certificate and keyfunc NewSignedCert(cfg *certutil.Config, key crypto.Signer, caCert *x509.Certificate, caKey crypto.Signer) (*x509.Certificate, error) {            serial, err := cryptorand.Int(cryptorand.Reader, new(big.Int).SetInt64(math.MaxInt64))        if err != nil {                return nil, err        }        if len(cfg.CommonName) == 0 {                return nil, errors.New("must specify a CommonName")        }        if len(cfg.Usages) == 0 {                return nil, errors.New("must specify at least one ExtKeyUsage")        }        certTmpl := x509.Certificate{                Subject: pkix.Name{                        CommonName:   cfg.CommonName,                        Organization: cfg.Organization,                },                DNSNames:     cfg.AltNames.DNSNames,                IPAddresses:  cfg.AltNames.IPs,                SerialNumber: serial,                NotBefore:    caCert.NotBefore,                NotAfter:     time.Now().Add(kubeadmconstants.CertificateValidity).UTC(),                KeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,                ExtKeyUsage:  cfg.Usages,# 源文件修改对应后的内容## 553行下新增下面一行const duration3650d = time.Hour * 24 * 365 * 10   # 新增内容## 575行修改为下面的这行 把 kubeadmconstants.CertificateValidity 替换为 duration3650dNotAfter:     time.Now().Add(duration3650d).UTC(),  # 修改内容</code></pre><pre class=" language-shell"><code class="language-shell"># 重新生成证书的过程出错了，暂时没有解决[root@k8s-master kubernetes]# kubeadm alpha certs renew all --config=/usr/local/install-k8s/core/kubeadm-config.yamlW1209 23:37:01.036404  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewedW1209 23:37:01.261703  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate for serving the Kubernetes API renewedW1209 23:37:01.567656  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate the apiserver uses to access etcd renewedW1209 23:37:01.993097  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate for the API server to connect to kubelet renewedW1209 23:37:02.339585  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate embedded in the kubeconfig file for the controller manager to use renewedW1209 23:37:02.801822  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate for liveness probes to healtcheck etcd renewedW1209 23:37:03.290392  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate for etcd nodes to communicate with each other renewedW1209 23:37:03.698894  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate for serving etcd renewedW1209 23:37:04.050365  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate for the front proxy client renewedW1209 23:37:04.625243  131629 strict.go:47] unknown configuration schema.GroupVersionKind{Group:"kubeproxy.config.k8s.io", Version:"v1alpha1", Kind:"kubeProxyConfiguration"} for scheme definitions in "k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/scheme/scheme.go:31" and "k8s.io/kubernetes/cmd/kubeadm/app/componentconfigs/scheme.go:28"[config] WARNING: Ignored YAML document with GroupVersionKind kubeproxy.config.k8s.io/v1alpha1, Kind=kubeProxyConfigurationcertificate embedded in the kubeconfig file for the scheduler manager to use renewed</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署EFK平台</title>
      <link href="/2019/12/08/%E9%83%A8%E7%BD%B2EFK%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/12/08/%E9%83%A8%E7%BD%B2EFK%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="添加-Google-incubator仓库"><a href="#添加-Google-incubator仓库" class="headerlink" title="添加 Google incubator仓库"></a>添加 Google incubator仓库</h2><pre class=" language-shell"><code class="language-shell">helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator</code></pre><h2 id="部署-Elasticsearch"><a href="#部署-Elasticsearch" class="headerlink" title="部署 Elasticsearch"></a>部署 Elasticsearch</h2><pre class=" language-shell"><code class="language-shell">kubectl create namespace efk[root@k8s-master efk]# helm fetch incubator/elasticsearch[root@k8s-master efk]# tar -zxf elasticsearch-1.10.2.tgz && cd elasticsearch[root@k8s-master elasticsearch]# helm install --name els1 --namespace=efk -f values.yaml incubator/elasticsearch[root@k8s-master ~]# kubectl get svc -n efkNAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGEels1-elasticsearch-client      ClusterIP   10.109.173.247   <none>        9200/TCP   40mels1-elasticsearch-discovery   ClusterIP   None             <none>        9300/TCP   40mkubectl run cirror-$RANDOM --rm -it --image=cirros -- /bin/sh   curl 10.109.173.247:9200/_cat/nodes</code></pre><h2 id="部署-Fluentd"><a href="#部署-Fluentd" class="headerlink" title="部署 Fluentd"></a>部署 Fluentd</h2><pre class=" language-shell"><code class="language-shell">[root@k8s-master efk]# pwd/usr/local/install-k8s/efk[root@k8s-master efk]# helm fetch stable/fluentd-elasticsearch[root@k8s-master efk]# tar -zxf fluentd-elasticsearch-2.0.7.tgz[root@k8s-master efk]# cd fluentd-elasticsearch[root@k8s-master fluentd-elasticsearch]# cat values.yaml |grep host    host: 'elasticsearch-client'    # 修改为其中 Elasticsearch 访问地址 host: '10.109.173.247'helm install --name flu1 --namespace=efk -f values.yaml stable/fluentd-elasticsearch</code></pre><h2 id="部署-Kibana"><a href="#部署-Kibana" class="headerlink" title="部署 Kibana"></a>部署 Kibana</h2><pre class=" language-shell"><code class="language-shell">helm fetch stable/kibana --version 0.14.8helm install --name kib1 --namespace=efk -f values.yaml stable/kibana --version 0.14.8</code></pre><p>实验记录</p><pre class=" language-shell"><code class="language-shell">[root@k8s-master elasticsearch]# helm list --namespace=efkNAME    REVISION    UPDATED                     STATUS      CHART                   APP VERSION    NAMESPACEels1    1           Mon Dec  9 15:35:52 2019    DEPLOYED    elasticsearch-1.10.2    6.4.2          efk      [root@k8s-master elasticsearch]# helm delete els1release "els1" deleted[root@k8s-master elasticsearch]# helm install --name els1 --namespace=efk -f values.yaml incubator/elasticsearchError: a release named els1 already exists.Run: helm ls --all els1; to check the status of the releaseOr run: helm del --purge els1; to delete it[root@k8s-master elasticsearch]# helm ls --all els1NAME    REVISION    UPDATED                     STATUS     CHART                   APP VERSION    NAMESPACEels1    1           Mon Dec  9 15:35:52 2019    DELETED    elasticsearch-1.10.2    6.4.2          efk      [root@k8s-master elasticsearch]# helm del --purge els1release "els1" deleted[root@k8s-master elasticsearch]# helm install --name els1 --namespace=efk -f values.yaml incubator/elasticsearchNAME:   els1LAST DEPLOYED: Mon Dec  9 17:16:30 2019NAMESPACE: efkSTATUS: DEPLOYEDRESOURCES:==> v1/ConfigMapNAME                DATA  AGEels1-elasticsearch  4     0s==> v1/Pod(related)NAME                                        READY  STATUS    RESTARTS  AGEels1-elasticsearch-client-844687f9f8-w6jfj  0/1    Init:0/1  0         0sels1-elasticsearch-client-844687f9f8-xb29p  0/1    Pending   0         0sels1-elasticsearch-data-0                   0/1    Init:0/2  0         0sels1-elasticsearch-master-0                 0/1    Init:0/2  0         0s==> v1/ServiceNAME                          TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)   AGEels1-elasticsearch-client     ClusterIP  10.109.173.247  <none>       9200/TCP  0sels1-elasticsearch-discovery  ClusterIP  None            <none>       9300/TCP  0s==> v1beta1/DeploymentNAME                       READY  UP-TO-DATE  AVAILABLE  AGEels1-elasticsearch-client  0/2    2           0          0s==> v1beta1/StatefulSetNAME                       READY  AGEels1-elasticsearch-data    0/2    0sels1-elasticsearch-master  0/3    0sNOTES:The elasticsearch cluster has been installed.***Please note that this chart has been deprecated and moved to stable.Going forward please use the stable version of this chart.***Elasticsearch can be accessed:  * Within your cluster, at the following DNS name at port 9200:    els1-elasticsearch-client.efk.svc  * From outside the cluster, run these commands in the same shell:    export POD_NAME=$(kubectl get pods --namespace efk -l "app=elasticsearch,component=client,release=els1" -o jsonpath="{.items[0].metadata.name}")    echo "Visit http://127.0.0.1:9200 to use Elasticsearch"    kubectl port-forward --namespace efk $POD_NAME 9200:9200[root@k8s-master elasticsearch]# kubectl get pod -n efkNAME                                         READY   STATUS    RESTARTS   AGEels1-elasticsearch-client-844687f9f8-w6jfj   0/1     Running   0          66sels1-elasticsearch-client-844687f9f8-xb29p   0/1     Running   0          66sels1-elasticsearch-data-0                    0/1     Running   0          66sels1-elasticsearch-master-0                  0/1     Running   0          66s[root@k8s-master elasticsearch]# kubectl get pod -n efkNAME                                         READY   STATUS    RESTARTS   AGEels1-elasticsearch-client-844687f9f8-w6jfj   0/1     Running   0          2m29sels1-elasticsearch-client-844687f9f8-xb29p   0/1     Running   0          2m29sels1-elasticsearch-data-0                    1/1     Running   0          2m29sels1-elasticsearch-data-1                    0/1     Running   0          54sels1-elasticsearch-master-0                  1/1     Running   0          2m29sels1-elasticsearch-master-1                  0/1     Running   0          54s[root@k8s-master elasticsearch]# kubectl get pod -n efkNAME                                         READY   STATUS    RESTARTS   AGEels1-elasticsearch-client-844687f9f8-w6jfj   1/1     Running   0          28mels1-elasticsearch-client-844687f9f8-xb29p   1/1     Running   0          28mels1-elasticsearch-data-0                    1/1     Running   0          28mels1-elasticsearch-data-1                    1/1     Running   0          27mels1-elasticsearch-master-0                  1/1     Running   0          28mels1-elasticsearch-master-1                  1/1     Running   0          27mels1-elasticsearch-master-2                  1/1     Running   0          26m[root@k8s-master elasticsearch]# kubectl get pod -n efk -o wideNAME                                         READY   STATUS    RESTARTS   AGE   IP            NODE        NOMINATED NODE   READINESS GATESels1-elasticsearch-client-844687f9f8-w6jfj   1/1     Running   0          29m   10.244.3.60   k8s-node2   <none>           <none>els1-elasticsearch-client-844687f9f8-xb29p   1/1     Running   0          29m   10.244.1.70   k8s-node1   <none>           <none>els1-elasticsearch-data-0                    1/1     Running   0          29m   10.244.3.61   k8s-node2   <none>           <none>els1-elasticsearch-data-1                    1/1     Running   0          27m   10.244.1.71   k8s-node1   <none>           <none>els1-elasticsearch-master-0                  1/1     Running   0          29m   10.244.3.62   k8s-node2   <none>           <none>els1-elasticsearch-master-1                  1/1     Running   0          27m   10.244.1.72   k8s-node1   <none>           <none>els1-elasticsearch-master-2                  1/1     Running   0          26m   10.244.3.63   k8s-node2   <none>           <none>[root@k8s-master elasticsearch]# kubectl get svc -n efkNAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGEels1-elasticsearch-client      ClusterIP   10.109.173.247   <none>        9200/TCP   32mels1-elasticsearch-discovery   ClusterIP   None             <none>        9300/TCP   32m[root@k8s-master elasticsearch]# kubectl run cirror-$RANDOM --rm -it --image=cirros -- /bin/shkubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.If you don't see a command prompt, try pressing enter./ #  curl  10.109.173.247:9200/_cat/nodes10.244.1.71  8 87 1 0.27 0.27 0.37 di - els1-elasticsearch-data-110.244.1.70 32 87 1 0.27 0.27 0.37 i  - els1-elasticsearch-client-844687f9f8-xb29p10.244.3.63 31 49 1 0.19 0.25 0.20 mi - els1-elasticsearch-master-210.244.3.61  7 49 1 0.19 0.25 0.20 di - els1-elasticsearch-data-010.244.3.62 33 49 1 0.19 0.25 0.20 mi - els1-elasticsearch-master-010.244.3.60 32 49 1 0.19 0.25 0.20 i  - els1-elasticsearch-client-844687f9f8-w6jfj10.244.1.72 28 87 1 0.27 0.27 0.37 mi * els1-elasticsearch-master-1[root@k8s-master fluentd-elasticsearch]# cat values.yaml |grep host  host: '10.109.173.247'    # to the docker logs for pods in the /var/log/containers directory on the host.    # The Kubernetes kubelet makes a symbolic link to this file on the host machine    # The /var/log directory on the host is mapped to the /var/log directory in the container        host ${hostname}        host ${hostname}        host ${hostname}      host "#{ENV['OUTPUT_HOST']}"[root@k8s-master fluentd-elasticsearch]# pwd/usr/local/install-k8s/efk/fluentd-elasticsearch[root@k8s-master fluentd-elasticsearch]# cd ..[root@k8s-master efk]# lselasticsearch  elasticsearch-1.10.2.tgz  fluentd-elasticsearch  fluentd-elasticsearch-2.0.7.tgz[root@k8s-master efk]# pwd/usr/local/install-k8s/efk[root@k8s-master efk]# cd fluentd-elasticsearch[root@k8s-master fluentd-elasticsearch]# lsChart.yaml  OWNERS  README.md  templates  values.yaml[root@k8s-master fluentd-elasticsearch]# cat values.yaml |grep host  host: '10.109.173.247'    # to the docker logs for pods in the /var/log/containers directory on the host.    # The Kubernetes kubelet makes a symbolic link to this file on the host machine    # The /var/log directory on the host is mapped to the /var/log directory in the container        host ${hostname}        host ${hostname}        host ${hostname}      host "#{ENV['OUTPUT_HOST']}"[root@k8s-master fluentd-elasticsearch]# kubectl get pod -n efk -o wideNAME                                         READY   STATUS    RESTARTS   AGE    IP            NODE        NOMINATED NODE   READINESS GATESels1-elasticsearch-client-844687f9f8-w6jfj   1/1     Running   0          114m   10.244.3.60   k8s-node2   <none>           <none>els1-elasticsearch-client-844687f9f8-xb29p   1/1     Running   0          114m   10.244.1.70   k8s-node1   <none>           <none>els1-elasticsearch-data-0                    1/1     Running   0          114m   10.244.3.61   k8s-node2   <none>           <none>els1-elasticsearch-data-1                    1/1     Running   0          112m   10.244.1.71   k8s-node1   <none>           <none>els1-elasticsearch-master-0                  1/1     Running   0          114m   10.244.3.62   k8s-node2   <none>           <none>els1-elasticsearch-master-1                  1/1     Running   0          112m   10.244.1.72   k8s-node1   <none>           <none>els1-elasticsearch-master-2                  1/1     Running   0          111m   10.244.3.63   k8s-node2   <none>           <none>[root@k8s-master fluentd-elasticsearch]# lsChart.yaml  OWNERS  README.md  templates  values.yaml[root@k8s-master fluentd-elasticsearch]# helm install --name flu1 --namespace=efk -f values.yaml stable/fluentd-elasticsearchNAME:   flu1LAST DEPLOYED: Mon Dec  9 19:11:27 2019NAMESPACE: efkSTATUS: DEPLOYEDRESOURCES:==> v1/ClusterRoleNAME                        AGEflu1-fluentd-elasticsearch  0s==> v1/ClusterRoleBindingNAME                        AGEflu1-fluentd-elasticsearch  0s==> v1/ConfigMapNAME                        DATA  AGEflu1-fluentd-elasticsearch  6     0s==> v1/DaemonSetNAME                        DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE  NODE SELECTOR  AGEflu1-fluentd-elasticsearch  2        2        0      2           0          <none>         0s==> v1/Pod(related)NAME                              READY  STATUS             RESTARTS  AGEflu1-fluentd-elasticsearch-7gl5c  0/1    ContainerCreating  0         0sflu1-fluentd-elasticsearch-ffzqx  0/1    ContainerCreating  0         0s==> v1/ServiceAccountNAME                        SECRETS  AGEflu1-fluentd-elasticsearch  1        0sNOTES:1. To verify that Fluentd has started, run:  kubectl --namespace=efk get pods -l "app.kubernetes.io/name=fluentd-elasticsearch,app.kubernetes.io/instance=flu1"THIS APPLICATION CAPTURES ALL CONSOLE OUTPUT AND FORWARDS IT TO elasticsearch . Anything that might be identifying,including things like IP addresses, container images, and object names will NOT be anonymized.[root@k8s-master fluentd-elasticsearch]# kubectl get pod -n efk -o wideNAME                                         READY   STATUS              RESTARTS   AGE    IP            NODE        NOMINATED NODE   READINESS GATESels1-elasticsearch-client-844687f9f8-w6jfj   1/1     Running             0          115m   10.244.3.60   k8s-node2   <none>           <none>els1-elasticsearch-client-844687f9f8-xb29p   1/1     Running             0          115m   10.244.1.70   k8s-node1   <none>           <none>els1-elasticsearch-data-0                    1/1     Running             0          115m   10.244.3.61   k8s-node2   <none>           <none>els1-elasticsearch-data-1                    1/1     Running             0          113m   10.244.1.71   k8s-node1   <none>           <none>els1-elasticsearch-master-0                  1/1     Running             0          115m   10.244.3.62   k8s-node2   <none>           <none>els1-elasticsearch-master-1                  1/1     Running             0          113m   10.244.1.72   k8s-node1   <none>           <none>els1-elasticsearch-master-2                  1/1     Running             0          112m   10.244.3.63   k8s-node2   <none>           <none>flu1-fluentd-elasticsearch-7gl5c             0/1     ContainerCreating   0          6s     <none>        k8s-node1   <none>           <none>flu1-fluentd-elasticsearch-ffzqx             0/1     ContainerCreating   0          6s     <none>        k8s-node2   <none>           <none>[root@k8s-master fluentd-elasticsearch]# kubectl get pod -n efk -o wideNAME                                         READY   STATUS              RESTARTS   AGE    IP            NODE        NOMINATED NODE   READINESS GATESels1-elasticsearch-client-844687f9f8-w6jfj   1/1     Running             0          115m   10.244.3.60   k8s-node2   <none>           <none>els1-elasticsearch-client-844687f9f8-xb29p   1/1     Running             0          115m   10.244.1.70   k8s-node1   <none>           <none>els1-elasticsearch-data-0                    1/1     Running             0          115m   10.244.3.61   k8s-node2   <none>           <none>els1-elasticsearch-data-1                    1/1     Running             0          113m   10.244.1.71   k8s-node1   <none>           <none>els1-elasticsearch-master-0                  1/1     Running             0          115m   10.244.3.62   k8s-node2   <none>           <none>els1-elasticsearch-master-1                  1/1     Running             0          113m   10.244.1.72   k8s-node1   <none>           <none>els1-elasticsearch-master-2                  1/1     Running             0          112m   10.244.3.63   k8s-node2   <none>           <none>flu1-fluentd-elasticsearch-7gl5c             0/1     ContainerCreating   0          12s    <none>        k8s-node1   <none>           <none>flu1-fluentd-elasticsearch-ffzqx             0/1     ContainerCreating   0          12s    <none>        k8s-node2   <none>           <none>[root@k8s-master fluentd-elasticsearch]# kubectl get pod -n efk -wNAME                                         READY   STATUS              RESTARTS   AGEels1-elasticsearch-client-844687f9f8-w6jfj   1/1     Running             0          115mels1-elasticsearch-client-844687f9f8-xb29p   1/1     Running             0          115mels1-elasticsearch-data-0                    1/1     Running             0          115mels1-elasticsearch-data-1                    1/1     Running             0          113mels1-elasticsearch-master-0                  1/1     Running             0          115mels1-elasticsearch-master-1                  1/1     Running             0          113mels1-elasticsearch-master-2                  1/1     Running             0          112mflu1-fluentd-elasticsearch-7gl5c             1/1     Running             0          26sflu1-fluentd-elasticsearch-ffzqx             0/1     ContainerCreating   0          26sflu1-fluentd-elasticsearch-ffzqx             1/1     Running             0          28s[root@k8s-master fluentd-elasticsearch]# [root@k8s-master fluentd-elasticsearch]# [root@k8s-master fluentd-elasticsearch]# lsChart.yaml  OWNERS  README.md  templates  values.yaml[root@k8s-master fluentd-elasticsearch]# cd ..[root@k8s-master efk]# lselasticsearch  elasticsearch-1.10.2.tgz  fluentd-elasticsearch  fluentd-elasticsearch-2.0.7.tgz[root@k8s-master efk]# helm fetch stable/kibana --version 0.14.8[root@k8s-master efk]# lselasticsearch  elasticsearch-1.10.2.tgz  fluentd-elasticsearch  fluentd-elasticsearch-2.0.7.tgz  kibana-0.14.8.tgz[root@k8s-master efk]# tar -zxf kibana-0.14.8.tgz tar: kibana/Chart.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/values.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/NOTES.txt：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/_helpers.tpl：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/configmap-dashboardimport.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/configmap.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/deployment.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/ingress.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/templates/service.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/.helmignore：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/OWNERS：不可信的旧时间戳 1970-01-01 08:00:00tar: kibana/README.md：不可信的旧时间戳 1970-01-01 08:00:00[root@k8s-master efk]# lselasticsearch  elasticsearch-1.10.2.tgz  fluentd-elasticsearch  fluentd-elasticsearch-2.0.7.tgz  kibana  kibana-0.14.8.tgz[root@k8s-master efk]# cd kibana[root@k8s-master kibana]# lsChart.yaml  OWNERS  README.md  templates  values.yaml[root@k8s-master kibana]# cat values.yaml |grep tag  tag: "6.4.2"[root@k8s-master kibana]# cat values.yaml |grep elasticsearch.url    elasticsearch.url: http://elasticsearch:9200[root@k8s-master ~]# kubectl get svc -n efkNAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGEels1-elasticsearch-client      ClusterIP   10.109.173.247   <none>        9200/TCP   40mels1-elasticsearch-discovery   ClusterIP   None             <none>        9300/TCP   40m## 把kibana中values.yaml链接elasticsearch的地址修改为： http://10.109.173.247:9200[root@k8s-master kibana]# cat values.yaml |grep repository  repository: "docker.elastic.co/kibana/kibana-oss"[root@k8s-master kibana]# cat values.yaml |grep tag  tag: "6.4.2"[root@k8s-master kibana]# helm install --name kib1 --namespace=efk -f values.yaml stable/kibana --version 0.14.8NAME:   kib1LAST DEPLOYED: Mon Dec  9 19:24:10 2019NAMESPACE: efkSTATUS: DEPLOYEDRESOURCES:==> v1/ConfigMapNAME         DATA  AGEkib1-kibana  1     0s==> v1/Pod(related)NAME                         READY  STATUS             RESTARTS  AGEkib1-kibana-6c49f68cf-q5b9r  0/1    ContainerCreating  0         0s==> v1/ServiceNAME         TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)  AGEkib1-kibana  ClusterIP  10.99.129.252  <none>       443/TCP  0s==> v1beta1/DeploymentNAME         READY  UP-TO-DATE  AVAILABLE  AGEkib1-kibana  0/1    1           0          0sNOTES:To verify that kib1-kibana has started, run:  kubectl --namespace=efk get pods -l "app=kibana"Kibana can be accessed:  * From outside the cluster, run these commands in the same shell:    export POD_NAME=$(kubectl get pods --namespace efk -l "app=kibana,release=kib1" -o jsonpath="{.items[0].metadata.name}")    echo "Visit http://127.0.0.1:5601 to use Kibana"    kubectl port-forward --namespace efk $POD_NAME 5601:5601[root@k8s-master kibana]# kubectl get svc -n efkNAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGEels1-elasticsearch-client      ClusterIP   10.109.173.247   <none>        9200/TCP   128mels1-elasticsearch-discovery   ClusterIP   None             <none>        9300/TCP   128mkib1-kibana                    ClusterIP   10.99.129.252    <none>        443/TCP    33s</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署prometheus</title>
      <link href="/2019/12/08/%E9%83%A8%E7%BD%B2prometheus/"/>
      <url>/2019/12/08/%E9%83%A8%E7%BD%B2prometheus/</url>
      
        <content type="html"><![CDATA[<h2 id="相关地址信息"><a href="#相关地址信息" class="headerlink" title="相关地址信息"></a>相关地址信息</h2><p>Prometheus github地址：<a href="https://github.com/coreos/kube-prometheus" target="_blank" rel="noopener">https://github.com/coreos/kube-prometheus</a></p><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><ul><li>MetricServer: 是kubernetes集群资源使用情况的聚合器，收集数据给kubernetes集群内使用，如kubectl、hpa、scheduler等。</li><li>PrometheusOperator: 是一个系统监测和警报工具箱，用来存储监控数据。</li><li>NodeExporter: 用于各node的关键度量指标状态数据。</li><li>KubeStateMetrics: 收集kubernetes集群内资源对象数据，指定告警规则。</li><li>Prometheus：采用pull方式收集apiserver,scheduler,controller-manager,kubelet组件数据，通过http协议传输。</li><li>Grafana: 是可视化数据统计和监控平台。</li></ul><h2 id="构建记录"><a href="#构建记录" class="headerlink" title="构建记录"></a>构建记录</h2><pre class=" language-shell"><code class="language-shell">git clone https://github.com/coreos/kube-prometheus.gitcd /root/kube-prometheus/manifests</code></pre><p><strong>修改 grafana-service.yaml文件，使用 nodeport 方式访问grafana:</strong></p><pre class=" language-yaml"><code class="language-yaml">vim grafana<span class="token punctuation">-</span>service.yaml<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> grafana  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> monitoring<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token comment" spellcheck="true"># 添加内容</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">3000</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> http    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30100   </span><span class="token comment" spellcheck="true"># 添加内容</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> grafana</code></pre><p><strong>修改 prometheus-service.yaml , 改为nodePort</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">prometheus</span><span class="token punctuation">:</span> k8s  <span class="token key atrule">name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>k8s  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> monitoring<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort           <span class="token comment" spellcheck="true"># 新增</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> web    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30200         </span><span class="token comment" spellcheck="true"># 新增</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> prometheus    <span class="token key atrule">prometheus</span><span class="token punctuation">:</span> k8s  <span class="token key atrule">sessionAffinity</span><span class="token punctuation">:</span> ClientIP</code></pre><p><strong>修改 alertmanager-service.yaml，改为 nodePort</strong></p><pre class=" language-yaml"><code class="language-yaml">vim alertmanager<span class="token punctuation">-</span>service.yaml<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">alertmanager</span><span class="token punctuation">:</span> main  <span class="token key atrule">name</span><span class="token punctuation">:</span> alertmanager<span class="token punctuation">-</span>main  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> monitoring<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9093</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> web    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30300</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">alertmanager</span><span class="token punctuation">:</span> main    <span class="token key atrule">app</span><span class="token punctuation">:</span> alertmanager  <span class="token key atrule">sessionAffinity</span><span class="token punctuation">:</span> ClientIP</code></pre><h2 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h2><p><strong>Horizontal Pod Autoscaling 可以根据 CPU 利用率自动伸缩一个 Replication Controller、 Deployment 或者 Replica Set 中的 Pod 数量</strong></p><!-- 为了演示Horizontal Pod Autoscaler,我们将使用一个基于php-apache镜像的定制Docker镜像。在[这里](https://k8smeetup.github.io/docs/user-guide/horizontal-pod-autoscaling/image/Dockerfile)您可以查看完整的Dockerfile定义。镜像中包括一个[index.php](https://k8smeetup.github.io/docs/user-guide/horizotal-pod-autoscaling/image/index.php)页面，其中包含了一些可以运行CPU密集计算任务的代码--><pre class=" language-shell"><code class="language-shell">kubectl run php-apache --image=gcr.io/google_containers/hpa-example -- requests=cpu=200m --expose --port=80</code></pre><p><strong>创建 HPA 控制器</strong>  相关的算法的详情请参阅<a href="">这篇文档</a></p><pre class=" language-shell"><code class="language-shell">kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10</code></pre><p><strong>增加负载，查看负载节点数目</strong></p><pre class=" language-shell"><code class="language-shell">$ kubectl run -i --tty load-generator --image=busybox /bin/sh$ while true; do wget -q -O- http://php-apache.default.svc.cluster.local; done</code></pre><h2 id="资源限制-Pod"><a href="#资源限制-Pod" class="headerlink" title="资源限制  - Pod"></a>资源限制  - Pod</h2><p><strong>kubernetes 对资源的限制实际上是通过cgroup 来控制的，cgroup是容器的一组用来控制内核如何运行进程的相关属性集合。针对内存、CPU和各种设备都有对应的cgroup</strong></p><p><strong>默认情况下，Pod运行没有CPU和内存的限额。这以为着系统中的任何Pod将能过像执行该Pod所在的节点一样，消耗足够多的CPU和内存。一般会针对某些应用的pod资源进行资源限制，这个资源限制是通过resources 的requests和limits来实现</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> xxxx    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always    <span class="token key atrule">name</span><span class="token punctuation">:</span> auth    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token key atrule">limits</span><span class="token punctuation">:</span>        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"4"</span>        <span class="token key atrule">memory</span><span class="token punctuation">:</span> 2Gi      <span class="token key atrule">requests</span><span class="token punctuation">:</span>        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 250m        <span class="token key atrule">memory</span><span class="token punctuation">:</span> 250Mi</code></pre><p><strong>requests要分分配的资源，limits为最高请求的资源值。可以简单理解为初始值和最大值</strong></p><h2 id="资源限制-名称空间"><a href="#资源限制-名称空间" class="headerlink" title="资源限制 -名称空间"></a>资源限制 -名称空间</h2><p><strong>I、计算资源配额</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ResourceQuota<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> compute<span class="token punctuation">-</span>resources  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> spark<span class="token punctuation">-</span>cluster<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">hard</span><span class="token punctuation">:</span>    <span class="token key atrule">pods</span><span class="token punctuation">:</span> <span class="token string">"20"</span>    <span class="token key atrule">requests.cpu</span><span class="token punctuation">:</span> <span class="token string">"20"</span>    <span class="token key atrule">requests.memory</span><span class="token punctuation">:</span> 100Gi    <span class="token key atrule">limits.cpu</span><span class="token punctuation">:</span> <span class="token string">"40"</span>    <span class="token key atrule">limits.memory</span><span class="token punctuation">:</span> 200Gi</code></pre><p><strong>II、配置对象数量配额限制</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ResourceQuota<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> object<span class="token punctuation">-</span>counts  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> spark<span class="token punctuation">-</span>cluster<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">hard</span><span class="token punctuation">:</span>    <span class="token key atrule">configmaps</span><span class="token punctuation">:</span> <span class="token string">"10"</span>    <span class="token key atrule">persistentvolumeclaims</span><span class="token punctuation">:</span> <span class="token string">"4"</span>    <span class="token key atrule">replicationcontrollers</span><span class="token punctuation">:</span> <span class="token string">"20"</span>    <span class="token key atrule">secrets</span><span class="token punctuation">:</span> <span class="token string">"10"</span>    <span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token string">"10"</span>    <span class="token key atrule">services.loadbalancers</span><span class="token punctuation">:</span> <span class="token string">"2"</span></code></pre><p><strong>III、配置CPU 和 内存 LimitRange</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> LimitRange<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mem<span class="token punctuation">-</span>limit<span class="token punctuation">-</span>range<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">limits</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">default</span><span class="token punctuation">:</span>    <span class="token key atrule">memory</span><span class="token punctuation">:</span> 50Gi    <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">5</span>  <span class="token key atrule">defaultRequest</span><span class="token punctuation">:</span>    <span class="token key atrule">memory</span><span class="token punctuation">:</span> 1Gi    <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> Container  </code></pre><ul><li><strong><code>default</code> 即 limit 值</strong></li><li><strong><code>defaultRequest</code> 即request值</strong></li></ul><pre class=" language-shell"><code class="language-shell"># 下面开始创建prometheus# Update the namespace and CRDs, and then wait for them to be availble before creating the remaining resources$ cd /usr/local/install-k8s/plugin/prometheus/kube-prometheus$ kubectl apply -f manifests/setup$ kubectl apply -f manifests/[root@k8s-master kube-prometheus]# kubectl get pod -n monitoringNAME                                  READY   STATUS    RESTARTS   AGEalertmanager-main-0                   2/2     Running   0          3malertmanager-main-1                   2/2     Running   0          3malertmanager-main-2                   2/2     Running   0          3mgrafana-77978cbbdc-cpjgg              1/1     Running   0          3m5skube-state-metrics-7f6d7b46b4-j4658   3/3     Running   0          3m6snode-exporter-hkvwt                   2/2     Running   0          3m5snode-exporter-w24ck                   2/2     Running   0          3m5snode-exporter-w2ppc                   2/2     Running   0          3m5sprometheus-adapter-68698bc948-6sxdj   1/1     Running   0          3m5sprometheus-k8s-0                      3/3     Running   1          2m49sprometheus-k8s-1                      3/3     Running   1          2m49sprometheus-operator-6685db5c6-qwpq4   1/1     Running   0          3m18s[root@k8s-master kube-prometheus]# kubectl get namespacesNAME              STATUS   AGEdefault           Active   14dingress-nginx     Active   8dkube-node-lease   Active   14dkube-public       Active   14dkube-system       Active   14dmonitoring        Active   27m[root@k8s-master kube-prometheus]# kubectl get svc -n monitoringNAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGEalertmanager-main       NodePort    10.101.14.181    <none>        9093:30300/TCP               3m58salertmanager-operated   ClusterIP   None             <none>        9093/TCP,9094/TCP,9094/UDP   3m52sgrafana                 NodePort    10.96.206.146    <none>        3000:30100/TCP               3m58skube-state-metrics      ClusterIP   None             <none>        8443/TCP,9443/TCP            3m58snode-exporter           ClusterIP   None             <none>        9100/TCP                     3m58sprometheus-adapter      ClusterIP   10.106.155.187   <none>        443/TCP                      3m57sprometheus-k8s          NodePort    10.104.145.175   <none>        9090:30200/TCP               3m57sprometheus-operated     ClusterIP   None             <none>        9090/TCP                     3m41sprometheus-operator     ClusterIP   None             <none>        8080/TCP                     4m11s</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master kube-prometheus<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get deployment -n monitoring -o wide</span>NAME                  READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS                                                     IMAGES                                                                                                                 SELECTORgrafana               1/1     1            1           12h   grafana                                                        grafana/grafana:6.4.3                                                                                                  app<span class="token operator">=</span>grafanakube-state-metrics    1/1     1            1           12h   kube-rbac-proxy-main,kube-rbac-proxy-self,kube-state-metrics   quay.io/coreos/kube-rbac-proxy:v0.4.1,quay.io/coreos/kube-rbac-proxy:v0.4.1,quay.io/coreos/kube-state-metrics:v1.8.0   app<span class="token operator">=</span>kube-state-metricsprometheus-adapter    1/1     1            1           12h   prometheus-adapter                                             quay.io/coreos/k8s-prometheus-adapter-amd64:v0.5.0                                                                     name<span class="token operator">=</span>prometheus-adapterprometheus-operator   1/1     1            1           12h   prometheus-operator                                            quay.io/coreos/prometheus-operator:v0.34.0                                                                             app.kubernetes.io/component<span class="token operator">=</span>controller,app.kubernetes.io/name<span class="token operator">=</span>prometheus-operator<span class="token punctuation">[</span>root@k8s-master kube-prometheus<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc -n monitoring -o wide</span>NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>                      AGE   SELECTORalertmanager-main       NodePort    10.101.14.181    <span class="token operator">&lt;</span>none<span class="token operator">></span>        9093:30300/TCP               12h   alertmanager<span class="token operator">=</span>main,app<span class="token operator">=</span>alertmanageralertmanager-operated   ClusterIP   None             <span class="token operator">&lt;</span>none<span class="token operator">></span>        9093/TCP,9094/TCP,9094/UDP   12h   app<span class="token operator">=</span>alertmanagergrafana                 NodePort    10.96.206.146    <span class="token operator">&lt;</span>none<span class="token operator">></span>        3000:30100/TCP               12h   app<span class="token operator">=</span>grafanakube-state-metrics      ClusterIP   None             <span class="token operator">&lt;</span>none<span class="token operator">></span>        8443/TCP,9443/TCP            12h   app<span class="token operator">=</span>kube-state-metricsnode-exporter           ClusterIP   None             <span class="token operator">&lt;</span>none<span class="token operator">></span>        9100/TCP                     12h   app<span class="token operator">=</span>node-exporterprometheus-adapter      ClusterIP   10.106.155.187   <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP                      12h   name<span class="token operator">=</span>prometheus-adapterprometheus-k8s          NodePort    10.104.145.175   <span class="token operator">&lt;</span>none<span class="token operator">></span>        9090:30200/TCP               12h   app<span class="token operator">=</span>prometheus,prometheus<span class="token operator">=</span>k8sprometheus-operated     ClusterIP   None             <span class="token operator">&lt;</span>none<span class="token operator">></span>        9090/TCP                     12h   app<span class="token operator">=</span>prometheusprometheus-operator     ClusterIP   None             <span class="token operator">&lt;</span>none<span class="token operator">></span>        8080/TCP                     12h   app.kubernetes.io/component<span class="token operator">=</span>controller,app.kubernetes.io/name<span class="token operator">=</span>prometheus-operator<span class="token punctuation">[</span>root@k8s-master kube-prometheus<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get rs -n monitoring -o wide</span>NAME                            DESIRED   CURRENT   READY   AGE   CONTAINERS                                                     IMAGES                                                                                                                 SELECTORgrafana-77978cbbdc              1         1         1       12h   grafana                                                        grafana/grafana:6.4.3                                                                                                  app<span class="token operator">=</span>grafana,pod-template-hash<span class="token operator">=</span>77978cbbdckube-state-metrics-7f6d7b46b4   1         1         1       12h   kube-rbac-proxy-main,kube-rbac-proxy-self,kube-state-metrics   quay.io/coreos/kube-rbac-proxy:v0.4.1,quay.io/coreos/kube-rbac-proxy:v0.4.1,quay.io/coreos/kube-state-metrics:v1.8.0   app<span class="token operator">=</span>kube-state-metrics,pod-template-hash<span class="token operator">=</span>7f6d7b46b4prometheus-adapter-68698bc948   1         1         1       12h   prometheus-adapter                                             quay.io/coreos/k8s-prometheus-adapter-amd64:v0.5.0                                                                     name<span class="token operator">=</span>prometheus-adapter,pod-template-hash<span class="token operator">=</span>68698bc948prometheus-operator-6685db5c6   1         1         1       12h   prometheus-operator                                            quay.io/coreos/prometheus-operator:v0.34.0                                                                             app.kubernetes.io/component<span class="token operator">=</span>controller,app.kubernetes.io/name<span class="token operator">=</span>prometheus-operator,pod-template-hash<span class="token operator">=</span>6685db5c6<span class="token punctuation">[</span>root@k8s-master kube-prometheus<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n monitoring -o wide</span>NAME                                  READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATESalertmanager-main-0                   2/2     Running   0          12h   10.244.3.54    k8s-node2    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>alertmanager-main-1                   2/2     Running   0          12h   10.244.1.66    k8s-node1    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>alertmanager-main-2                   2/2     Running   0          12h   10.244.3.55    k8s-node2    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>grafana-77978cbbdc-cpjgg              1/1     Running   0          12h   10.244.3.53    k8s-node2    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>kube-state-metrics-7f6d7b46b4-j4658   3/3     Running   0          12h   10.244.3.52    k8s-node2    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>node-exporter-hkvwt                   2/2     Running   0          12h   192.168.1.85   k8s-master   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>node-exporter-w24ck                   2/2     Running   0          12h   192.168.1.38   k8s-node1    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>node-exporter-w2ppc                   2/2     Running   0          12h   192.168.1.86   k8s-node2    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>prometheus-adapter-68698bc948-6sxdj   1/1     Running   0          12h   10.244.1.65    k8s-node1    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>prometheus-k8s-0                      3/3     Running   1          12h   10.244.3.56    k8s-node2    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>prometheus-k8s-1                      3/3     Running   1          12h   10.244.1.67    k8s-node1    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>prometheus-operator-6685db5c6-qwpq4   1/1     Running   0          12h   10.244.1.64    k8s-node1    <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></code></pre><h2 id="访问prometheus"><a href="#访问prometheus" class="headerlink" title="访问prometheus"></a>访问prometheus</h2><p><strong>prometheus 对应的nodeport端口为30200，访问： <a href="http://k8s-master:30200或者http://k8s-node1:302200或者http://k8s-node2:30200" target="_blank" rel="noopener">http://k8s-master:30200或者http://k8s-node1:302200或者http://k8s-node2:30200</a></strong></p><p><img src="https://cntsp.github.io/medias/contents/28.png" alt=""></p><p><strong>通过访问 <a href="http://k8s-master:30200/target" target="_blank" rel="noopener">http://k8s-master:30200/target</a> 可以看出prometheus 已经成功连接上 k8s 的apiserver</strong></p><p><img src="https://cntsp.github.io/medias/contents/29.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/30.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/31.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/32.png" alt=""></p><p><strong>查看 service-discovery</strong></p><p><img src="https://cntsp.github.io/medias/contents/33.png" alt=""></p><p><strong>Prometheus 自己的指标</strong></p><p><img src="https://cntsp.github.io/medias/contents/34.png" alt=""></p><p><strong>prometheus 的 WEB 界面上提供了基本的查询k8s集群中每个POD 的CPU 使用情况，查询条件如下：</strong></p><pre class=" language-shell"><code class="language-shell">sum by (pod_name)( rate(container_cpu_usage_seconds_total{image!="", pod_name!=""}[1m] ) )</code></pre><p><img src="https://cntsp.github.io/medias/contents/35.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/36.png" alt=""></p><p><strong>上述的查询有出现数据，说明 node-exporter 往 prometheus 中写数据正常了，接下来我们就可以部署grafana 组件，实现更友好的 webui 展示数据了</strong></p><h2 id="访问grafana"><a href="#访问grafana" class="headerlink" title="访问grafana"></a>访问grafana</h2><p><strong>查看 grafana SVC服务暴露的端口号:</strong></p><pre class=" language-shell"><code class="language-shell">[root@k8s-master kube-prometheus]# kubectl get svc  -n monitoring |grep grafanagrafana                 NodePort    10.96.206.146    <none>        3000:30100/TCP               44m</code></pre><p><strong>如上可以看到 grafana 对外的端口是30100,浏览器输入：<a href="http://k8s-master:30100" target="_blank" rel="noopener">http://k8s-master:30100</a> 或 <a href="http://k8s-node1:30100" target="_blank" rel="noopener">http://k8s-node1:30100</a> 或者 <a href="http://k8s-node2:30100" target="_blank" rel="noopener">http://k8s-node2:30100</a>  用户名/密码： admin/admin</strong></p><p><img src="https://cntsp.github.io/medias/contents/37.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/38.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/39.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/40.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/41.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/42.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/43.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/44.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/45.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/46.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/47.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/48.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/49.png" alt=""></p><p>​                    <img src="https://cntsp.github.io/medias/contents/50.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/51.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/52.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/53.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/54.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> prometheus </tag>
            
            <tag> 容器监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helm部署metrics-server</title>
      <link href="/2019/12/08/helm%E9%83%A8%E7%BD%B2metrics-server/"/>
      <url>/2019/12/08/helm%E9%83%A8%E7%BD%B2metrics-server/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>helm部署dashboard</title>
      <link href="/2019/12/07/helm%E9%83%A8%E7%BD%B2dashboard/"/>
      <url>/2019/12/07/helm%E9%83%A8%E7%BD%B2dashboard/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Helm-部署-dashboard"><a href="#使用-Helm-部署-dashboard" class="headerlink" title="使用 Helm 部署 dashboard"></a>使用 Helm 部署 dashboard</h2><p><strong>之前我们对于kubernetes集群的所有操作都是通过命令行工具kubectl完成的。为了提供更丰富的用户体验，kubernetes还开发了一个基于Web 的Dashboard，用户可以用kubernetes dashboard 部署容器化的应用、监控应用的状态、执行故障排查任务以及管理kubernetes的各种资源。</strong></p><p><strong>在Kubernetes Dashboard 中可以查看集群中应用的运行状态，也能够创建和修改各种kubernetes资源，比如Deployment、Job、DeamonSet 等。用户可以 Scale Up/Down Deployment、执行 Rolling Update、重启某个Pod 或者通过向导部署新的应用。Dashboard 能显示集群中各个资源的状态以及日志信息。(虽然dashboard也提供了kubectl的绝大部分功能，但是界面太简陋，我们更倾向于rancher)</strong></p><p><strong>kubernetes-dashboard.yaml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">image</span><span class="token punctuation">:</span>  <span class="token key atrule">repository</span><span class="token punctuation">:</span> k8s.gcr.io/kubernetes<span class="token punctuation">-</span>dashboard<span class="token punctuation">-</span>amd64  <span class="token key atrule">tag</span><span class="token punctuation">:</span> v1.10.1<span class="token key atrule">ingress</span><span class="token punctuation">:</span>  <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hosts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> k8s.frognew.com  <span class="token key atrule">annotationss</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/ssl-redirect</span><span class="token punctuation">:</span> <span class="token string">"true"</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/backend-protocol</span><span class="token punctuation">:</span> <span class="token string">"HTTPS"</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">secretName</span><span class="token punctuation">:</span> frognew<span class="token punctuation">-</span>com<span class="token punctuation">-</span>tls<span class="token punctuation">-</span>secret      <span class="token key atrule">hosts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> k8s.frognew.com<span class="token key atrule">rbac</span><span class="token punctuation">:</span>  <span class="token key atrule">clusterAdminRole</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><pre class=" language-shell"><code class="language-shell">helm install stable/kubernetes-dashboard \-n kubernetes-dashboard \--namespace kube-system \-f kubernetes-dashboard.yaml</code></pre><pre class=" language-bash"><code class="language-bash">kubectl -n kube-system get secret <span class="token operator">|</span> <span class="token function">grep</span> kubernetes-dashboard-tokenkubernetes </code></pre><pre class=" language-shell"><code class="language-shell"># 操作过程[root@k8s-master dashboard]# helm fetch stable/kubernetes-dashboard [root@k8s-master dashboard]# helm search dashboardNAME                           CHART VERSION    APP VERSION    DESCRIPTION                                                 stable/kubernetes-dashboard    1.10.1           1.10.1         General-purpose web UI for Kubernetes clusters              stable/jasperreports           7.0.1            7.2.0          The JasperReports server can be used as a stand-alone or ...stable/kube-ops-view           1.1.1            19.9.0         Kubernetes Operational View - read-only system dashboard ...stable/uchiwa                  1.0.0            0.22           Dashboard for the Sensu monitoring framework                stable/weave-cloud             0.3.7            1.4.0          Weave Cloud is a add-on to Kubernetes which provides Cont...stable/weave-scope             1.1.7            1.11.6         A Helm chart for the Weave Scope cluster visualizer.        [root@k8s-master dashboard]# helm repo listNAME      URL                                             stable    https://kubernetes-charts.storage.googleapis.comlocal     http://127.0.0.1:8879/charts                    [root@k8s-master dashboard]# lskubernetes-dashboard-1.10.1.tgz[root@k8s-master dashboard]# tar -zxf kubernetes-dashboard-1.10.1.tgz tar: kubernetes-dashboard/Chart.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/values.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/NOTES.txt：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/_helpers.tpl：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/clusterrole-readonly.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/deployment.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/ingress.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/networkpolicy.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/pdb.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/role.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/rolebinding.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/secret.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/serviceaccount.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/templates/svc.yaml：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/.helmignore：不可信的旧时间戳 1970-01-01 08:00:00tar: kubernetes-dashboard/README.md：不可信的旧时间戳 1970-01-01 08:00:00[root@k8s-master dashboard]# lskubernetes-dashboard  kubernetes-dashboard-1.10.1.tgz[root@k8s-master dashboard]# cd kubernetes-dashboard[root@k8s-master kubernetes-dashboard]# lsChart.yaml  README.md  templates  values.yaml[root@k8s-master kubernetes-dashboard]# vim kubernetes-dashboard.yamlimage:  repository: k8s.gcr.io/kubernetes-dashboard-amd64  tag: v1.10.1ingress:  enabled: true  hosts:    - k8s.frognew.com  annotationss:    nginx.ingress.kubernetes.io/ssl-redirect: "true"    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"  tls:    - secretName: frognew-com-tls-secret      hosts:      - k8s.frognew.comrbac:  clusterAdminRole: true[root@k8s-master kubernetes-dashboard]# lsChart.yaml  kubernetes-dashboard.yaml  README.md  templates  values.yaml[root@k8s-master kubernetes-dashboard]# helm install . -n kubernetes-dashboard --namespace kube-system -f kubernetes-dashboard.yaml NAME:   kubernetes-dashboardLAST DEPLOYED: Sat Dec  7 22:17:49 2019NAMESPACE: kube-systemSTATUS: DEPLOYEDRESOURCES:==> v1/ClusterRoleBindingNAME                  AGEkubernetes-dashboard  0s==> v1/DeploymentNAME                  READY  UP-TO-DATE  AVAILABLE  AGEkubernetes-dashboard  0/1    1           0          0s==> v1/Pod(related)NAME                                   READY  STATUS             RESTARTS  AGEkubernetes-dashboard-77f54dc48f-jvtns  0/1    ContainerCreating  0         0s==> v1/SecretNAME                  TYPE    DATA  AGEkubernetes-dashboard  Opaque  0     0s==> v1/ServiceNAME                  TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)  AGEkubernetes-dashboard  ClusterIP  10.108.213.51  <none>       443/TCP  0s==> v1/ServiceAccountNAME                  SECRETS  AGEkubernetes-dashboard  1        0s==> v1beta1/IngressNAME                  HOSTS            ADDRESS  PORTS  AGEkubernetes-dashboard  k8s.frognew.com  80, 443  0sNOTES:************************************************************************************ PLEASE BE PATIENT: kubernetes-dashboard may take a few minutes to install ************************************************************************************From outside the cluster, the server URL(s) are:     https://k8s.frognew.com[root@k8s-master kubernetes-dashboard]# kubectl get pod -n kube-systemNAME                                    READY   STATUS    RESTARTS   AGEcoredns-5c98db65d4-pxl78                1/1     Running   0          14dcoredns-5c98db65d4-vdtsr                1/1     Running   0          14detcd-k8s-master                         1/1     Running   0          14dkube-apiserver-k8s-master               1/1     Running   0          14dkube-controller-manager-k8s-master      1/1     Running   0          14dkube-flannel-ds-amd64-852cl             1/1     Running   0          14dkube-flannel-ds-amd64-p5h64             1/1     Running   0          14dkube-flannel-ds-amd64-rglvq             1/1     Running   0          12dkube-proxy-6sp4j                        1/1     Running   0          14dkube-proxy-hbnkf                        1/1     Running   0          12dkube-proxy-ttjcn                        1/1     Running   0          14dkube-scheduler-k8s-master               1/1     Running   0          14dkubernetes-dashboard-77f54dc48f-jvtns   1/1     Running   0          26stiller-deploy-58565b5464-8vrfb          1/1     Running   0          7h50m[root@k8s-master kubernetes-dashboard]# kubectl get svc -n kube-systemNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGEkube-dns               ClusterIP   10.96.0.10       <none>        53/UDP,53/TCP,9153/TCP   14dkubernetes-dashboard   ClusterIP   10.108.213.51    <none>        443/TCP                  115stiller-deploy          ClusterIP   10.102.235.237   <none>        44134/TCP                7h51m[root@k8s-master kubernetes-dashboard]# lsChart.yaml  kubernetes-dashboard.yaml  README.md  templates  values.yaml[root@k8s-master kubernetes-dashboard]# cat kubernetes-dashboard.yaml image:  repository: k8s.gcr.io/kubernetes-dashboard-amd64  tag: v1.10.1ingress:  enabled: true  hosts:    - k8s.frognew.com  annotationss:    nginx.ingress.kubernetes.io/ssl-redirect: "true"    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"  tls:    - secretName: frognew-com-tls-secret      hosts:      - k8s.frognew.comrbac:  clusterAdminRole: true[root@k8s-master kubernetes-dashboard]# kubectl get ingress -n kube-systemNAME                   HOSTS             ADDRESS       PORTS     AGEkubernetes-dashboard   k8s.frognew.com   10.109.8.33   80, 443   2m51s[root@k8s-master kubernetes-dashboard]# kubectl get svc -n kube-systemNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGEkube-dns               ClusterIP   10.96.0.10       <none>        53/UDP,53/TCP,9153/TCP   14dkubernetes-dashboard   ClusterIP   10.108.213.51    <none>        443/TCP                  3m39stiller-deploy          ClusterIP   10.102.235.237   <none>        44134/TCP                7h53m[root@k8s-master kubernetes-dashboard]# kubectl get deployment -n kube-systemNAME                   READY   UP-TO-DATE   AVAILABLE   AGEcoredns                2/2     2            2           14dkubernetes-dashboard   1/1     1            1           3m50stiller-deploy          1/1     1            1           7h53m[root@k8s-master kubernetes-dashboard]# kubectl get deployment -n kube-system -o wideNAME                   READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS             IMAGES                                          SELECTORcoredns                2/2     2            2           14d     coredns                k8s.gcr.io/coredns:1.3.1                        k8s-app=kube-dnskubernetes-dashboard   1/1     1            1           3m58s   kubernetes-dashboard   k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1   app=kubernetes-dashboard,release=kubernetes-dashboardtiller-deploy          1/1     1            1           7h53m   tiller                 gcr.io/kubernetes-helm/tiller:v2.13.1           app=helm,name=tiller[root@k8s-master kubernetes-dashboard]# kubectl get pod  -n kube-system -o wideNAME                                    READY   STATUS    RESTARTS   AGE     IP             NODE         NOMINATED NODE   READINESS GATEScoredns-5c98db65d4-pxl78                1/1     Running   0          14d     10.244.0.2     k8s-master   <none>           <none>coredns-5c98db65d4-vdtsr                1/1     Running   0          14d     10.244.0.3     k8s-master   <none>           <none>etcd-k8s-master                         1/1     Running   0          14d     192.168.1.85   k8s-master   <none>           <none>kube-apiserver-k8s-master               1/1     Running   0          14d     192.168.1.85   k8s-master   <none>           <none>kube-controller-manager-k8s-master      1/1     Running   0          14d     192.168.1.85   k8s-master   <none>           <none>kube-flannel-ds-amd64-852cl             1/1     Running   0          14d     192.168.1.85   k8s-master   <none>           <none>kube-flannel-ds-amd64-p5h64             1/1     Running   0          14d     192.168.1.38   k8s-node1    <none>           <none>kube-flannel-ds-amd64-rglvq             1/1     Running   0          12d     192.168.1.86   k8s-node2    <none>           <none>kube-proxy-6sp4j                        1/1     Running   0          14d     192.168.1.85   k8s-master   <none>           <none>kube-proxy-hbnkf                        1/1     Running   0          12d     192.168.1.86   k8s-node2    <none>           <none>kube-proxy-ttjcn                        1/1     Running   0          14d     192.168.1.38   k8s-node1    <none>           <none>kube-scheduler-k8s-master               1/1     Running   0          14d     192.168.1.85   k8s-master   <none>           <none>kubernetes-dashboard-77f54dc48f-jvtns   1/1     Running   0          4m8s    10.244.1.60    k8s-node1    <none>           <none>tiller-deploy-58565b5464-8vrfb          1/1     Running   0          7h54m   10.244.1.57    k8s-node1    <none>           <none>[root@k8s-master kubernetes-dashboard]# kubectl get svc -n kube-systemNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGEkube-dns               ClusterIP   10.96.0.10       <none>        53/UDP,53/TCP,9153/TCP   14dkubernetes-dashboard   ClusterIP   10.108.213.51    <none>        443/TCP                  6m33stiller-deploy          ClusterIP   10.102.235.237   <none>        44134/TCP                7h56m[root@k8s-master kubernetes-dashboard]# kubectl edit svc kubernetes-dashboard -n kube-systemservice/kubernetes-dashboard edited[root@k8s-master kubernetes-dashboard]# kubectl get svc -n kube-systemNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGEkube-dns               ClusterIP   10.96.0.10       <none>        53/UDP,53/TCP,9153/TCP   14dkubernetes-dashboard   NodePort    10.108.213.51    <none>        443:31417/TCP            9m46stiller-deploy          ClusterIP   10.102.235.237   <none>        44134/TCP                7h59m[root@k8s-master kubernetes-dashboard]# kubectl get svc -n kube-systemNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGEkube-dns               ClusterIP   10.96.0.10       <none>        53/UDP,53/TCP,9153/TCP   14dkubernetes-dashboard   NodePort    10.108.213.51    <none>        443:31417/TCP            9m59stiller-deploy          ClusterIP   10.102.235.237   <none>        44134/TCP                7h59m[root@k8s-master kubernetes-dashboard]# kubectl get ingress -n kube-systemNAME                   HOSTS             ADDRESS       PORTS     AGEkubernetes-dashboard   k8s.frognew.com   10.109.8.33   80, 443   10m[root@k8s-master kubernetes-dashboard]# lsChart.yaml  kubernetes-dashboard.yaml  README.md  templates  values.yaml[root@k8s-master kubernetes-dashboard]# cat kubernetes-dashboard.yaml image:  repository: k8s.gcr.io/kubernetes-dashboard-amd64  tag: v1.10.1ingress:  enabled: true  hosts:    - k8s.frognew.com  annotationss:    nginx.ingress.kubernetes.io/ssl-redirect: "true"    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"  tls:    - secretName: frognew-com-tls-secret      hosts:      - k8s.frognew.comrbac:  clusterAdminRole: true[root@k8s-master kubernetes-dashboard]# kubectl get secret -n  kube-systemNAME                                             TYPE                                  DATA   AGEattachdetach-controller-token-lr85z              kubernetes.io/service-account-token   3      14dbootstrap-signer-token-lqklw                     kubernetes.io/service-account-token   3      14dbootstrap-token-28wdcv                           bootstrap.kubernetes.io/token         6      12dbootstrap-token-5q91af                           bootstrap.kubernetes.io/token         4      14dbootstrap-token-abcdef                           bootstrap.kubernetes.io/token         6      14dbootstrap-token-uw6dfy                           bootstrap.kubernetes.io/token         6      13dcertificate-controller-token-ncc46               kubernetes.io/service-account-token   3      14dclusterrole-aggregation-controller-token-wl29h   kubernetes.io/service-account-token   3      14dcoredns-token-xwkxz                              kubernetes.io/service-account-token   3      14dcronjob-controller-token-5vd7t                   kubernetes.io/service-account-token   3      14ddaemon-set-controller-token-7hp2n                kubernetes.io/service-account-token   3      14ddefault-token-nf2rq                              kubernetes.io/service-account-token   3      14ddeployment-controller-token-gx8q7                kubernetes.io/service-account-token   3      14ddisruption-controller-token-gm6m2                kubernetes.io/service-account-token   3      14dendpoint-controller-token-5wthb                  kubernetes.io/service-account-token   3      14dexpand-controller-token-mpxwh                    kubernetes.io/service-account-token   3      14dflannel-token-mz7br                              kubernetes.io/service-account-token   3      14dgeneric-garbage-collector-token-9zsbr            kubernetes.io/service-account-token   3      14dhorizontal-pod-autoscaler-token-hlk95            kubernetes.io/service-account-token   3      14djob-controller-token-j4kc8                       kubernetes.io/service-account-token   3      14dkube-proxy-token-nx78p                           kubernetes.io/service-account-token   3      14dkubeadm-certs                                    Opaque                                8      14dkubernetes-dashboard                             Opaque                                0      31mkubernetes-dashboard-key-holder                  Opaque                                2      30mkubernetes-dashboard-token-sfk4h                 kubernetes.io/service-account-token   3      31mnamespace-controller-token-4dh92                 kubernetes.io/service-account-token   3      14dnode-controller-token-8fh9x                      kubernetes.io/service-account-token   3      14dpersistent-volume-binder-token-w4hsl             kubernetes.io/service-account-token   3      14dpod-garbage-collector-token-ktnq8                kubernetes.io/service-account-token   3      14dpv-protection-controller-token-wrpk7             kubernetes.io/service-account-token   3      14dpvc-protection-controller-token-fg2s8            kubernetes.io/service-account-token   3      14dreplicaset-controller-token-c8kvp                kubernetes.io/service-account-token   3      14dreplication-controller-token-t8nv5               kubernetes.io/service-account-token   3      14dresourcequota-controller-token-q7q65             kubernetes.io/service-account-token   3      14dservice-account-controller-token-jdp6f           kubernetes.io/service-account-token   3      14dservice-controller-token-44bsm                   kubernetes.io/service-account-token   3      14dstatefulset-controller-token-cd7hf               kubernetes.io/service-account-token   3      14dtiller-token-4zv2h                               kubernetes.io/service-account-token   3      8htoken-cleaner-token-hv8mb                        kubernetes.io/service-account-token   3      14dttl-controller-token-vml2r                       kubernetes.io/service-account-token   3      14d[root@k8s-master kubernetes-dashboard]# kubectl describe secret kubernetes-dashboard-token-sfk4h -n kube-systemName:         kubernetes-dashboard-token-sfk4hNamespace:    kube-systemLabels:       <none>Annotations:  kubernetes.io/service-account.name: kubernetes-dashboard              kubernetes.io/service-account.uid: c3491009-8247-471c-a2ec-c91ddf3e71b9Type:  kubernetes.io/service-account-tokenData====ca.crt:     1025 bytesnamespace:  11 bytestoken:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJlcm5ldGVzLWRhc2hib2FyZC10b2tlbi1zZms0aCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImMzNDkxMDA5LTgyNDctNDcxYy1hMmVjLWM5MWRkZjNlNzFiOSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTprdWJlcm5ldGVzLWRhc2hib2FyZCJ9.Ug4DVwjxJVP_MlPj27s0n4UD4us27w6XLsYzLv0Neq4Sa06NgtpiUauN-cFNjPrrQJITbQ6_rsyaA8TN0-uWcz1UMY0riiOXZ6FHed1kmGj109IIgpWazgR_Ue5vhFR2jUbh7XhW1ElB9CaOCcqhkwDVwitb7TMXelA3AuVZGcatVjGc4aeYpAqHFBcI4TWB2C2ekPJqrAY-MUOo-ra-TPJ-wBsvtqq497uLpGGI3VrUyGHNRegq7lASxHvZWMCc939WkPw1D24ysIaHsdN6BBPxDyU8BwixDJhtdX5evbJkQTCmunYKMIcYK0PoVNRAj4AInvjJwU5c4wOM48rx7Q</code></pre><p>kubernetes-dashboard   NodePort    10.108.213.51    <none>        443:31417/TCP            9m59s</p><p><strong>通过火狐浏览器访问dashboard： <a href="http://k8s-master:31417" target="_blank" rel="noopener">http://k8s-master:31417</a></strong></p><p><img src="https://cntsp.github.io/medias/contents/27.png" alt=""></p><h3 id="Dashboard界面结构介绍-待续"><a href="#Dashboard界面结构介绍-待续" class="headerlink" title="Dashboard界面结构介绍(待续)"></a>Dashboard界面结构介绍(待续)</h3><h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><h4 id="部署Deployment"><a href="#部署Deployment" class="headerlink" title="部署Deployment"></a>部署Deployment</h4><h4 id="在线操作"><a href="#在线操作" class="headerlink" title="在线操作"></a>在线操作</h4><h4 id="查看资源详细信息"><a href="#查看资源详细信息" class="headerlink" title="查看资源详细信息"></a>查看资源详细信息</h4>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuberntes </tag>
            
            <tag> dashboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署-Helm</title>
      <link href="/2019/12/06/kubernetes-%E9%83%A8%E7%BD%B2Helm/"/>
      <url>/2019/12/06/kubernetes-%E9%83%A8%E7%BD%B2Helm/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Helm"><a href="#什么是Helm" class="headerlink" title="什么是Helm"></a>什么是Helm</h2><p><strong>在没使用 helm 之前，向kubernetes 部署应用，我们要依次部署 deployment、svc等，步骤较繁琐。况且随着项目微服务化，复杂的应用在容器中部署以及管理显得较为复杂，helm通过打包的方式，支持发布的版本管理和控制，很大程度上简化了kubernetes应用的部署和管理</strong></p><p><strong>Helm 本质上就是让 k8s 的应用管理(Deployment,SVC等)可配置，能动态生成。通过动态生成k8s资源清单文件(deployment.yaml,service.yaml)。然后调用 kuberctl 自动执行k8s资源部署</strong></p><p><strong>Helm 是官方提供的类似与 YUM 的包管理器，是部署环境的流程封装。Helm 有两个重要的概念： chart 和 release</strong></p><ul><li><strong>chart 是创建一个应用的信息集合，包括各种kubernetes对象的配置模板、参数定义、依赖关系、文档说明等。chart是应用部署的自包含逻辑单元。可以将chart想象成apt、yum中的软件安装包</strong></li><li><strong>release 是chart的运行实例，代表了一个正在运行的应用。当chart被安装到kubernetes集群，就生成一个release。chart能够多次安装到同一个集群，每次安装都是一个release</strong></li></ul><p><strong>Helm是包管理工具，这里的包就是指的 chart。Helm 能够：</strong></p><ul><li>从零创建新 chart</li><li>与存储chart的仓库交互，拉取、保存和更新chart</li><li>在kubernetes 集群中安装和卸载 release</li><li>更新、回滚和测试release</li></ul><h2 id="Helm架构"><a href="#Helm架构" class="headerlink" title="Helm架构"></a>Helm架构</h2><p><strong>Helm 包含两个组件：Helm客户端和Tiller服务器，如下图：</strong></p><p><img src="./images/01.png" alt=""></p><p><strong>Helm 客户端是终端用户使用的命令行工具，用户可以：</strong></p><ul><li>在本地开发chart</li><li>管理chart仓库</li><li>与 Tiller 服务器交互</li><li>在远程 kubernetes 集群上安装 chart</li><li>查看 release 信息</li><li>升级或卸载已有的release</li></ul><p><strong>Tiller 服务器运行在 kubernetes 集群中，它会处理 Helm 客户端的请求，与 kubernetes API Server交互。Tiller 服务器负责：</strong></p><ul><li>监听来自 Helm 客户端的请求</li><li>通过chart 构建 release</li><li>在 kubernetes 中安装 chart，并跟踪 release 的状态</li><li>通过 API Server升级或卸载已有的release</li></ul><h2 id="安装-Helm"><a href="#安装-Helm" class="headerlink" title="安装 Helm"></a>安装 Helm</h2><p>本节我们将依次安装Helm 客户端和 Tiller 服务器</p><h3 id="Helm-客户端"><a href="#Helm-客户端" class="headerlink" title="Helm 客户端"></a>Helm 客户端</h3><p>越来越多的公司和团队开始使用Helm这个Kubernetes的包管理器，我们也将使用Helm安装kubernetes的常用组件。helm由客户端命令行工具和服务端tiller组成，Helm的安装十分简单。下载helm命令行工具到master 节点即k8s-master 的/usr/local/bin/下，这里下载的2.13.1版本：</p><pre class=" language-shell"><code class="language-shell">ntpdate ntp1.aliyun.comwget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gztar -zxvf helm-v2.13.1.linux-amd64.tar.gzcd linux-amd64/cp helm /usr/local/bin</code></pre><p>为了安装服务端tiller，还需要在这台机器上配置好kubectl 工具和kubeconfig文件，确保kubectl工具可以在这台机器上访问apiserver且正常使用。这里的k8s-master节点是已经配置好了kubectl这个工具</p><p><strong>因为kubernetes APIServer 开启了RBAC访问控制，所以需要创建tiller 使用的service account: tiller并分配合适的角色给它。详细内容可以查看helm文档中的<a href="https://docs.helm.sh/usring_helm/#role-based-access-control" target="_blank" rel="noopener">Role-based Access Control</a>。这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建 rbac-config.yaml文件：</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> tiller  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> tiller<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> tiller    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system</code></pre><pre class=" language-shell"><code class="language-shell">kubectl create -f rbac-config.yaml</code></pre><pre class=" language-shell"><code class="language-shell">helm init --service-account tiller --skip-refresh</code></pre><h3 id="tiller-默认被部署在k8s集群中的kube-system-这个namespace下"><a href="#tiller-默认被部署在k8s集群中的kube-system-这个namespace下" class="headerlink" title="tiller 默认被部署在k8s集群中的kube-system 这个namespace下"></a>tiller 默认被部署在k8s集群中的kube-system 这个namespace下</h3><pre class=" language-shell"><code class="language-shell">[root@k8s-master helm]# kubectl get svc -n kube-systemNAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGEkube-dns        ClusterIP   10.96.0.10       <none>        53/UDP,53/TCP,9153/TCP   14dtiller-deploy   ClusterIP   10.102.235.237   <none>        44134/TCP                81s[root@k8s-master helm]# kubectl get deployment -n kube-systemNAME            READY   UP-TO-DATE   AVAILABLE   AGEcoredns         2/2     2            2           14dtiller-deploy   1/1     1            1           55s[root@k8s-master helm]# kubectl get rs -n kube-systemNAME                       DESIRED   CURRENT   READY   AGEcoredns-5c98db65d4         2         2         2       14dtiller-deploy-58565b5464   1         1         1       112s[root@k8s-master helm]# kubectl get pod -n kube-systemNAME                                 READY   STATUS    RESTARTS   AGEcoredns-5c98db65d4-pxl78             1/1     Running   0          14dcoredns-5c98db65d4-vdtsr             1/1     Running   0          14detcd-k8s-master                      1/1     Running   0          14dkube-apiserver-k8s-master            1/1     Running   0          14dkube-controller-manager-k8s-master   1/1     Running   0          14dkube-flannel-ds-amd64-852cl          1/1     Running   0          14dkube-flannel-ds-amd64-p5h64          1/1     Running   0          14dkube-flannel-ds-amd64-rglvq          1/1     Running   0          12dkube-proxy-6sp4j                     1/1     Running   0          14dkube-proxy-hbnkf                     1/1     Running   0          12dkube-proxy-ttjcn                     1/1     Running   0          14dkube-scheduler-k8s-master            1/1     Running   0          14dtiller-deploy-58565b5464-8vrfb       1/1     Running   0          65s[root@k8s-master helm]# helm versionClient: &version.Version{SemVer:"v2.13.1", GitCommit:"618447cbf203d147601b4b9bd7f8c37a5d39fbb4", GitTreeState:"clean"}Server: &version.Version{SemVer:"v2.13.1", GitCommit:"618447cbf203d147601b4b9bd7f8c37a5d39fbb4", GitTreeState:"clean"}</code></pre><h2 id="Helm-自定义模板"><a href="#Helm-自定义模板" class="headerlink" title="Helm 自定义模板"></a>Helm 自定义模板</h2><pre class=" language-shell"><code class="language-shell"># 创建文件夹$ mkdir ./hello-world$ cd ./hello-world</code></pre><pre class=" language-shell"><code class="language-shell"># 创建自描述文件 Chart.yaml ，这个文件必须有 name 和 version 定义$ cat << 'EOF' >./Chart.yamlname: hello-worldversion: 1.0.0EOF</code></pre><pre class=" language-shell"><code class="language-shell"># 创建模板文件，用于生成kubernetes 资源清单 (manifests)$ mkdir ./templates$ cat << 'EOF' >./templates/deployment.yamlapiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: hello-worldspec:  replicas: 1  template:    metadata:      labels:        app: hello-world    spec:      containers:        - name: hello-world          image: harbor.bwingame8.com/library/myapp:v1          ports:            - containerPort: 80              protocol: TCPEOF$ cat << 'EOF' > ./templates/service.yamlapiVersion: v1kind: Servicemetadata:  name: hello-worldspec:  type: NodePort  ports:  - port: 80    targetPort: 80    protocol: TCP  selector:    app: hello-worldEOF</code></pre><pre class=" language-shell"><code class="language-shell"># 使用命令 helm install RELATIVE_PATH_TO_CHART 创建一次Release$ helm install .</code></pre><pre class=" language-shell"><code class="language-shell"># 列出已经部署的 Release$ helm ls# 查询一个特定的 Release 的状态$ helm status RELEASE_NAME# 移除所有与这个 Release 相关的 kubernetes 资源$ helm delete cautious-shrimp # helm rollback RELEASE_NAME REVISION_NUMBER$ helm rollback cautious-shrimp 1# 使用 helm delete --purge RELEASE_NAME 移除所有者与指定 Release 相关的 kubernetes 资源和所有这个Release 的记录$ helm delete --purge cautious-shrimp$ helm ls --deleted</code></pre><pre class=" language-shell"><code class="language-shell"># 配置体现在配置文件 values.yaml$ cat << 'EOF' > ./values.yamlimage:  repository: harbor.bwingame8.com/library/myapp  tag: 'v3'EOF# 这个文件中定义的值，在模板文件中可以通过 .Values对象访问到$ cat << 'EOF' > ./templates/deployment.yamlapiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: hello-worldspec:  replicas: 1  template:    metadata:      labels:        app: hello-world    spec:      containers:        - name: hello-world          image: {{ .Values.images.repository }}:{{ .Values.image.tag }}          ports:            - containerPort: 80              protocol: TCPEOF# 在 values.yaml 中的值可以被部署 release 时用到的参数 --values YAML_FILE_PATH 或 --set key1=value1, key2=value2 覆盖掉$ helm install --set image.tag='latest' .# 升级版本helm upgrade -f values.yaml test .</code></pre><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><pre class=" language-shell"><code class="language-shell"># 使用模板动态生成 k8s 资源清单，非常需要能提前预览生成的结果# 使用 --dry-run --debug 选项来打印出生成的清单文件内容，而不执行部署helm install . --dry-run --debug --set image.tag=latest</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> helm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-集群安全-准入控制</title>
      <link href="/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h2><p><strong>准入控制是API Server的插件集合，通过添加不同的插件，实现额外的准入控制规则。甚至于API Server的一些主要的功能都需要通过Admission Controllers实现，比如ServiceAccount</strong></p><p><strong>官方文档上有一份针对不同版本的准入控制器推荐列表，其中最新的1.14 的推荐列表是：</strong></p><pre class=" language-shell"><code class="language-shell">NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota</code></pre><p><strong>列举几个插件的功能：</strong></p><ul><li><strong>NamespaceLifecycle：防止不存在的namespace上创建对象，防止删除系统预置 namespace,删除namespace时，连带删除它的所有资源对象。</strong></li><li><strong>LimitRanger： 确保请求的资源不会超过资源所在Namespace的LimitRange的限制。</strong></li><li><strong>ServiceAccount：实现了自动化添加ServiceAccount。</strong></li><li><strong>ResourceQuota：确保请求的资源不会超时资源的ResourceQuota限制。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 准入控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-集群安全-鉴权</title>
      <link href="/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E9%89%B4%E6%9D%83/"/>
      <url>/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E9%89%B4%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><p><strong>上面认证过程，只是确认通信的双方都确认了对方是可信的，可以相互通信。而鉴权是确定请求方有哪些资源的权限。API Server目前支持以下几种授权策略（通过 API Server 的启动参数 ”–authorization-mode“设置）</strong></p><ul><li><strong>AlwaysDeny：表示拒绝所有的请求，一般用于测试</strong></li><li><strong>AlwaysAllow：允许接收所有请求，如果集群不需要授权流程，则可以采用该策略</strong></li><li><strong>ABAC（Attribute-Based Access Control）：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</strong></li><li><strong>Webbook：通过调用外部 REST 服务对用户进行授权</strong></li><li><strong>RBAC（Role-Based Access Control）：基于角色的访问控制，现行默认规则</strong></li></ul><h2 id="RBAC-授权模式"><a href="#RBAC-授权模式" class="headerlink" title="RBAC 授权模式"></a>RBAC 授权模式</h2><p><strong>RBAC（Role-Based Access Control）基于角色的访问控制，在kubernetes 1.5中引入，现行版本称为默认标准。相对于其它访问控制方式，拥有以下优势：</strong></p><ul><li><strong>对集群中的资源和非资源均拥有完整的覆盖</strong></li><li><strong>整个RBAC完全由几个API 对象完成，同其它API对象一样，可以用kubectl或API 进行操作</strong></li><li><strong>可以在运行时进行调整，无需重启API Server</strong></li></ul><p><strong>I、RBAC 的 API 资源对象说明</strong></p><p><strong>RBAC 引入了4个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding，4中对象类型均可以通过kubectl 与 API 操作</strong></p><p>​    <img src="./images/01.png" alt=""></p><p><strong>需要注意的是Kubernetes 并不会提供用户管理，那么User、Group、ServiceAccount 指定的用户又是从哪里来的呢？kubernetes组件（kubectl、kube-proxy）或是其他自定义的用户在向 CA申请证书时，需要提供一个证书请求文件</strong></p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"CN"</span><span class="token operator">:</span> <span class="token string">"admin"</span><span class="token punctuation">,</span>    <span class="token property">"hosts"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"key"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"algo"</span><span class="token operator">:</span> <span class="token string">"rsa"</span><span class="token punctuation">,</span>        <span class="token property">"size"</span><span class="token operator">:</span> <span class="token number">2048</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"names"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"C"</span><span class="token operator">:</span> <span class="token string">"CN"</span><span class="token punctuation">;</span>            <span class="token property">"ST"</span><span class="token operator">:</span> <span class="token string">"HangZhou"</span><span class="token punctuation">,</span>            <span class="token property">"L"</span><span class="token operator">:</span> <span class="token string">"XS"</span><span class="token punctuation">,</span>            <span class="token property">"O"</span><span class="token operator">:</span> <span class="token string">"system:masters"</span><span class="token punctuation">,</span>            <span class="token property">"OU"</span><span class="token operator">:</span> <span class="token string">"System"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p><strong>API Server会把客户端证书的<code>CN</code>字段作为User,把<code>names.Oz</code>字段作为Group</strong></p><p><strong>Kubelet 使用TLS Bootstaping 认证时，API Server 可以使用 Bootstrap Tokens 或者 Token authentication file 验证 = token,无论哪一种，Kubernetes都会为token绑定一个默认的User和Group</strong></p><p><strong>Pod 使用 ServerAccount认证时，service-account-token 中的JWT会保存 User信息</strong></p><p><strong>有了用户信息，再创建一对角色/角色绑定(集群角色/集群角色绑定)资源对象，就可以完成权限绑定了</strong></p><h2 id="Role-and-ClusterRole"><a href="#Role-and-ClusterRole" class="headerlink" title="Role and ClusterRole"></a>Role and ClusterRole</h2><p><strong>在 RBAC API 中，Role表示一组规则权限，权限只会增加 (累加权限，不存在一个资源一开始就有很多权限而通过 RBAC 对其进行减少的操作；Role可以定义在一个namespace中，如果想要跨namespace则可以创建ClusterRole</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>reader<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># "" indicates the core API group</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods"</span><span class="token punctuation">]</span>  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token string">"watch"</span><span class="token punctuation">,</span><span class="token string">"list"</span><span class="token punctuation">]</span></code></pre><p><strong>ClusterRole 具有与Role 相同的权限角色控制能力，不同的是ClusterRole是集群级别的，ClusterRole可以用于</strong></p><ul><li><strong>集群级别的资源控制（例如 node 访问权限）</strong></li><li><strong>非资源类型 endpoints（例如 <code>/healthz</code> 访问）</strong></li><li><strong>所有命名空间资源控制（例如pods）</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># "namespace" omitted since ClusterRole are not namespaced</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>reader<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"secrets"</span><span class="token punctuation">]</span>  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token string">"watch"</span><span class="token punctuation">,</span><span class="token string">"list"</span><span class="token punctuation">]</span></code></pre><h2 id="RoleBinding-and-ClusterRoleBinding"><a href="#RoleBinding-and-ClusterRoleBinding" class="headerlink" title="RoleBinding and ClusterRoleBinding"></a>RoleBinding and ClusterRoleBinding</h2><p><strong>RoleBinding 可以将角色中定义的权限授予用户或用户组，RoleBinding 包含一组权限列表（subjects），权限列表包含有不同形式的待授予权限资源类型（users,groups,or service accounts）;RoleBinding 同样包含对被Bind 的Role引用；RoleBinding 适用于某个命名空间内授权，而 ClusterRoleBinding 适用于集群范围内的授权</strong></p><p><strong>将default 命令空间的 <code>pod-reader</code> Role 授予 jane 用户，此后jane 用户在default 命名空间中具有 <code>pod-reader</code>的权限</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>pods  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User  <span class="token key atrule">name</span><span class="token punctuation">:</span> jane  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>reader  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre><p><strong>RoleBinding 同样可以引用ClusterRole 来对当前namespace 内用户、用户组或ServiceAccount进行授权，这种操作允许集群管理员在整个集群内定义一些通用的ClusterRole,然后在不同的namespace中使用RoleBinding来引用</strong></p><p><strong>例如，以下RoleBinding 引用了一个ClusterRole,这个ClusterRole 具有整个集群内对secrets的访问权限；但是其授权用户<code>dave</code>只能访问development空间中的secrets（因为RoleBinding 定义在development命名空间）</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># This role binding allows "dave" to read secrets in the "development" namespace.</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>secrets  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> development <span class="token comment" spellcheck="true"># This only grants permissions within the "development' namespace</span><span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> User  <span class="token key atrule">name</span><span class="token punctuation">:</span> dave  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>reader  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre><p><strong>使用ClusterRoleBinding 可以对整个集群中的所有命名空间资源权限进行授权；以下ClusterRoleBinding 样例展示了授权manager组内所有用户在全部命名空间中对secrets进行访问</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># This cluster role binding allows anyone in the "manager" group to read secrets in any namespace</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> read<span class="token punctuation">-</span>secrets<span class="token punctuation">-</span>global<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> Group  <span class="token key atrule">name</span><span class="token punctuation">:</span> manager  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>reader  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io</code></pre><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>Kubernetes 集群内一些资源一般以其名称字符串来表示，这些字符串一般会在 API 的URL地址中出现；同时某些资源也会包含子资源，例如logs资源就属于pods的子资源，API中URL样例如下：</p><pre class=" language-shell"><code class="language-shell">GET /api/v1/namespaces/{namespace}/pods/{name}/log</code></pre><p><strong>如果要在RBAC授权模型中控制这些子资源的访问权限，可以通过/分隔符来实现，以下是一个定义pods资源logs访问权限的Role定义样例</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>and<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>logs<span class="token punctuation">-</span>reader<span class="token key atrule">rules</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">]</span>  <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"pods"</span><span class="token punctuation">,</span><span class="token string">"pods/log"</span><span class="token punctuation">]</span>  <span class="token key atrule">verbs</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token string">"list"</span><span class="token punctuation">]</span></code></pre><h2 id="to-Subjects"><a href="#to-Subjects" class="headerlink" title="to Subjects"></a>to Subjects</h2><p><strong>RoleBinding 和 ClusterRoleBinding 可以将Role绑定到Subjects;Subjects可以是groups、users、或者service accounts</strong></p><p><strong>Subjects 中Users 使用字符串表示，它可以是一个普通的名字字符串，如 “alice”;也可以是email格式的邮箱地址，例如”<a href="mailto:pangminghuang@163.com" target="_blank" rel="noopener">pangminghuang@163.com</a>“;甚至是一组字符串形式的数字ID。但是Users的前缀system:是系统保留的，集群管理员应该确保普通用户不会使用这个前缀格式。</strong></p><p><strong>Groups 书写格式与Users相同，都为一个字符串，并且没有特定的格式要求；同样system:前缀为系统保留</strong></p><h2 id="实践：创建一个用户只能管理dev空间"><a href="#实践：创建一个用户只能管理dev空间" class="headerlink" title="实践：创建一个用户只能管理dev空间"></a>实践：创建一个用户只能管理dev空间</h2><pre class=" language-shell"><code class="language-shell">{    "CN":"devuser",    "hosts":[],    "key": {        "algo": "rsa",        "size": 2048    },    "names": [        {            "C": "CN",            "ST": "BeiJing",            "L": "BeiJing",            "O": "k8s",            "OU": "System"        }    ]}# 下载证书生成工具wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64mv cfssl_linux-amd64 /usr/local/bin/cfsslwget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64mv cfssljson_linux-amd64 /usr/local/bin/cfssljsonwget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfocfssl gencert -ca=ca.crt -ca-key=ca.key -profile=kubernetes /root/devuser-csr.json | cfssljson -bare devuser# 设置集群参数export KUBE_APISERVER="https://192.168.1.85:6433"kubectl config set-cluster kubernetes \--certificate-authority=/etc/kubernetes/ssl/ca.pem \--embed-certs=true \--server=${KUBE_APISERVER} \--kubeconfig=devuser.kubeconfig# 设置客户端认证参数kubectl config set-credentials devuser \--client-certificate=/etc/kubernetes/ssl/devuser.pem \--client-key=/etc/kubernetes/ssl/devuser-key.pem \--embed-certs=true \--kubeconfig=devuser.kubeconfig# 设置上下文参数kubectl config set-context kubernetes \--cluster=kubernetes \--user=devuser \--namespace=dev \--kubeconfig=devuser.kubeconfig# 设置默认上下文kubectl config user-content kubernetes --kubeconfig=devuser.kubeconfigcp -f ./devuser.kubeconfig  /root/.kube/configkubectl create rolebinding devuser-admin-binding --clusterrole=admin --user=devuser --namespace=dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-集群安全-认证</title>
      <link href="/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E8%AE%A4%E8%AF%81/"/>
      <url>/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><ul><li><strong>HTTP Token 认证： 通过一个 Token 来识别合法用户</strong><ul><li><strong>HTTP Token 的认证是用一个很长的特殊编码方式的并且难以被模仿的字符串-Token来表达客户的一种方式。Token 是一个很长的很复杂的字符串，每一个Token对应的一个用户名存储在 API Server 能访问的文件中，当客户端发起 API 调用请求时，需要在HTTP Header 里放入Token</strong></li></ul></li><li><strong>HTTP Base认证： 通过 用户名+密码的方式认证</strong><ul><li>*<em>用户名+密码 ：用 BASE64 算法进行编码后的字符串放在 HTTP Request 中的 Header Authorization 域里发送给服务端，服务端收到后进行编码，获取用户名及密码 *</em></li></ul></li><li>*<em>最严格的 HTTPS 证书认证： 基于 CA 根证书签名的客户端身份认证方式 *</em></li></ul><p><strong>I、HTTPS证书认证</strong></p><p><img src="https://cntsp.github.io/medias/contents/24.png" alt=""></p><p><strong>II、需要认证的节点</strong></p><p><img src="https://cntsp.github.io/medias/contents/25.png" alt=""></p><p><strong>两种类型</strong></p><ul><li><strong>Kubernetes 组件对 API Server 的访问： kubectl、Controller Manager、Scheduler、kubelet、kube-proxy</strong></li><li><strong>Kubernetes 管理的 Pod 对容器的访问： Pod (dashborad 也是以Pod的形式运行)</strong></li></ul><p><strong>安全性说明</strong></p><ul><li><strong>Controller Manager、Scheduler 与 API Server 在同一台机器，所以直接使用 API Server的非安全端口访问，<code>--insecure-bind-address=127.0.0.1</code></strong></li><li><strong>kubectl、kubelet、kube-proxy 访问 API Server 就都需要证书进行 HTTPS 双向认证</strong></li></ul><p><strong>证书颁发</strong></p><ul><li><strong>手动签发： 通过 k8s 集群的跟 ca 进行签发 HTTPS 证书</strong></li><li><strong>自动签发: kubelet 首次访问 API Server 时，使用 token 做认证，通过后， Controller Manger 会为kubelet生成一个证书，以后的访问都是用证书做认证了</strong></li></ul><p><strong>III、kubeconfig</strong></p><p><strong>kubeconfig文件包含集群参数 （CA证书、API Server地址），客户端参数(上面生成的证书和私钥)，集群context信息（集群名称、用户名）。Kubernetes组件通过启动时指定不同的kubeconfig文件可以切换到不同的集群中</strong></p><p><strong>IV、ServiceAccount</strong></p><p><strong>Pod中的容器访问API Server。因为Pod的创建、销毁是动态的，所以要为它手动生成证书就不可行了。Kubernetes使用了Service Account解决了Pod访问API Server 的认证问题</strong></p><p><strong>V、Secret 与 SA 的关系</strong></p><p><strong>Kubernetes 设计了一种资源对象叫做 Secret，分为两类： 一种是用于 ServiceAccount 的 service-account-token。 另一种是用于保护用户自定义保密信息的Opaque。ServiceAccount 中用到了包含三个部分：Token、ca.crt、namespace。</strong></p><ul><li><strong>token：是使用 API Server 私钥签名的JWT。用于访问API Server时，Server端认证</strong></li><li><strong>ca.crt： 根证书，用于Client端验证API Server发送的证书</strong></li><li><strong>namespace：标识这个service-account-token的作用域空间</strong></li></ul><!--Json web token (JWT),是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准([ (RFC 7519)])。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录(SSO)登录。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便从资源服务器获取资源，也可以增减一些额外的其它业务逻辑所必须的声明信息，该token 也可直接被用于认证，也可被加密--><pre class=" language-shell"><code class="language-shell">[root@k8s-master ~]# kubectl get secret --all-namespaces |grep default-tokendefault           default-token-vvwlp                              kubernetes.io/service-account-token   3      12dingress-nginx     default-token-zx9m6                              kubernetes.io/service-account-token   3      5d23hkube-node-lease   default-token-4bpp6                              kubernetes.io/service-account-token   3      12dkube-public       default-token-2mfsg                              kubernetes.io/service-account-token   3      12dkube-system       default-token-nf2rq                              kubernetes.io/service-account-token   3      12d[root@k8s-master ~]# kubectl describe secret default-token-nf2rq -n kube-systemName:         default-token-nf2rqNamespace:    kube-systemLabels:       <none>Annotations:  kubernetes.io/service-account.name: default              kubernetes.io/service-account.uid: 9fb76ef1-d8a3-42df-a4fe-1acb68c03200Type:  kubernetes.io/service-account-tokenData====ca.crt:     1025 bytesnamespace:  11 bytestoken:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkZWZhdWx0LXRva2VuLW5mMnJxIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImRlZmF1bHQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI5ZmI3NmVmMS1kOGEzLTQyZGYtYTRmZS0xYWNiNjhjMDMyMDAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06ZGVmYXVsdCJ9.iMzky7PF0U6bX0QuVVTY1JzfTo-xVLWVycnE5ks84eV1vYvSswdxl1y8qDPopSSwikGLG1Upxc6KUQ08XO7jqRKUQM_7qvJAfoHOxc_5sScdIFsJJEkp9JhQz4vaRgFPP69a3b_7cas2hgBcQQax3HyyTN2MLFiPtBJ9v96BJoowVmPf1xiIVEHd_VwZE6EePscZEwvK8d6Hvv65uJtPGX-KDIwx6fgariV0xnu41BtoOAha7AD-SrCqClgTISz4EtC6QCNTF76onsnXgygpEr1not0XZvOBsVp5UY1xcJTLGhNmxvLpTMuIXQjVI2eBdwclkVBtBPdESYjS-ku2MA</code></pre><p><strong>默认情况下，每个namespace都会有一个ServiceAccount，如果Pod在创建时没有指定ServiceAccount,就会使用Pod所属的namespace的ServiceAccount</strong></p><!-- 默认挂载目录：/run/secrets/kubernetes.io/serviceaccount/--><p><strong>总结</strong></p><hr><p><img src="https://cntsp.github.io/medias/contents/26.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-集群安全-机制说明</title>
      <link href="/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/12/06/Kubernetes-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8-%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="机制说明"><a href="#机制说明" class="headerlink" title="机制说明"></a>机制说明</h2><p><strong>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中介，也是外部控制的入口。所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。 Kubernetes 使用了认证 (Authentication)、鉴权(Authorization)、准入控制(Admission Control) 三步来保证API Server 的安全</strong></p><p><img src="https://cntsp.github.io/medias/contents/23.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 集群安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker部署rancher1.6</title>
      <link href="/2019/12/06/docker%E9%83%A8%E7%BD%B2rancher1-6/"/>
      <url>/2019/12/06/docker%E9%83%A8%E7%BD%B2rancher1-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos7系统部署rancher1-6-28版本"><a href="#Centos7系统部署rancher1-6-28版本" class="headerlink" title="Centos7系统部署rancher1.6.28版本"></a>Centos7系统部署rancher1.6.28版本</h2><h3 id="首先安装docker"><a href="#首先安装docker" class="headerlink" title="首先安装docker"></a>首先安装docker</h3><p>如果想要安装指定版本的docker，请移步<a href="https://cntsp.github.io/2019/11/14/centos7%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2docker-ce/">安装指定版本docker</a></p><p>本次操作安装默认版本的docker(1.13.1):</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> docker</code></pre><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p><strong>单机部署，不使用外置的数据库</strong></p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld.servicedocker pull rancher/server:v1.6.26docker run --name rancher --restart<span class="token operator">=</span>unless-stopped  -d -p 8080:8080 rancher/server:v1.6.26</code></pre><p>访问rancher UI界面：</p><pre class=" language-bash"><code class="language-bash">http://IP:8080</code></pre><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>单机部署，使用外置的数据库</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 关闭防火墙</span>systemctl stop firewalld.service<span class="token comment" spellcheck="true"># 下载mariadb镜像tag为10.1</span>docker pull mariadb:10.1<span class="token comment" spellcheck="true"># 下载rancher/server的镜像tag为v1.6.28</span>docker pull rancher/server:v1.6.28<span class="token comment" spellcheck="true"># 启动数据库容器，名字为mariadb2,root密码为nihaoma</span>docker run -d --name maridb2 -p 3306:3306 -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>nihaoma  mariadb:10.1 <span class="token comment" spellcheck="true"># 进入mariadb2数据库容器</span>docker <span class="token function">exec</span> -it mariadb2 /bin/bash<span class="token comment" spellcheck="true"># 进入数据库</span>mysql -uroot -pnihaoma<span class="token operator">></span> CREATE DATABASE IF NOT EXISTS cattle COLLATE <span class="token operator">=</span> <span class="token string">'utf8_general_ci'</span> CHARACTER SET <span class="token operator">=</span> <span class="token string">'utf8'</span><span class="token punctuation">;</span><span class="token operator">></span> GRANT ALL ON cattle.* TO <span class="token string">'cattle'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'cattle'</span><span class="token punctuation">;</span><span class="token operator">></span> FLUSH PRIVILEGES<span class="token punctuation">;</span><span class="token operator">></span> EXIT<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 启动rancher/server容器连接外置的数据库容器</span>docker run --name rancher2 --restart<span class="token operator">=</span>unless-stopped -d -p 18080:8080 rancher/server:v1.6.28 \--db-host xxx.xxx.xxx.xxx --db-port 3306 --db-user cattle --db-pass cattle --db-name cattle</code></pre><p>如果出现链接不到数据库的情况，请重启一下docker服务</p><pre class=" language-bash"><code class="language-bash">systemctl restart docker.service</code></pre><pre class=" language-bash"><code class="language-bash">http://IP:8080</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> rancher1.6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-固定节点</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E5%9B%BA%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E5%9B%BA%E5%AE%9A%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="指定调度节点"><a href="#指定调度节点" class="headerlink" title="指定调度节点"></a>指定调度节点</h2><p><strong>I、Pod.spec.nodeName 将 Pod 直接调度到指定的Node节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">7</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeName</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>node1      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p><strong>II、Pod.spec.nodeSelector: 通过kubernetes 的 label-selector 机制选择节点，由调度器调度策略匹配label，而后调度Pod到目标节点，该匹配规则属于强制约束</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">disk</span><span class="token punctuation">:</span> ssd      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 固定节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-污点</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%B1%A1%E7%82%B9/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%B1%A1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Tain-和-Toleration"><a href="#Tain-和-Toleration" class="headerlink" title="Tain 和  Toleration"></a>Tain 和  Toleration</h2><p><strong>节点亲和性，是 pod 的一种属性（偏好或硬性要求），它使 pod 被吸引到一类特定的节点。Taint 则相反，它使节点能够排斥一类特定的pod</strong></p><p><strong>Taint 和 toleration 相互配合，可以用来避免 pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个taint，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。如果将 toleration 应用与pod上，则表示这些 pod 可以 （但不要求）被调度到具有匹配 taint 的节点上</strong></p><h2 id="污点-Taint"><a href="#污点-Taint" class="headerlink" title="污点(Taint)"></a>污点(Taint)</h2><p><strong>I、污点（Taint）的组成</strong></p><p><strong>使用 <code>kubectl taint</code> 命令可以给某个Node节点设置污点，Node 被设置上污点之后就和Pod 之间存在了一种相斥的关系，可以让Node拒绝Pod的调度执行，甚至将Node已经存在的Pod驱逐出去</strong></p><p><strong>每个污点的组成如下：</strong></p><pre class=" language-yaml"><code class="language-yaml">key=value<span class="token punctuation">:</span>effect</code></pre><p><strong>每个污点有一个Key和value作为污点的标签，其中value可以为空，effect描述污点的作用。当前taint effect 支持如下三个选项：</strong></p><ul><li><code>NoSchedule</code>: <strong>表示K8S将不会将Pod调度到具有该污点的Node上</strong></li><li><code>PreferNoSchedule</code>:<strong>表示k8s将尽量避免Pod调度到具有该污点的Node上</strong></li><li><code>NoExecute</code>:<strong>表示k8s将不会将Pod调度到具有该污点的Node上，同时会将Node上已经存在的Pod驱逐出去</strong></li></ul><p><strong>II、污点的设置、查看和去除</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置污点</span>kubectl taint nodes node1 key1<span class="token operator">=</span>value1:NoSchedule<span class="token comment" spellcheck="true"># 节点说明中，查找 Taints 字段</span>kubectl describe pod pod-name<span class="token comment" spellcheck="true"># 去除污点</span>kubectl taint nodes node1 key1:NoSchedule-</code></pre><h2 id="容忍（Tolerations）"><a href="#容忍（Tolerations）" class="headerlink" title="容忍（Tolerations）"></a>容忍（Tolerations）</h2><p><strong>设置了污点的Node将根据 taint 的effect: NoSchedule、PreferNoSchedule、NoExecute和Pod之间产生互斥的关系，Pod将在一定程度上不会被调度到Node上。但我们可以在Pod上设置容忍(Toleration)，意思是设置了容忍的Pod将可以容忍污点的存在，可以被调度到存在污点的Node上</strong></p><p><strong>pod.spec.tolerations</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key1"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>  <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span>  <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">3600</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key1"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>  <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoExecute"</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key2"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span></code></pre><ul><li><strong>其中 key,value,effect 要与 Node上设置的 taint 保持一致</strong></li><li><strong>operator 的值为Exists将会忽略 value 值</strong></li><li><strong>tolerationsSeconds</strong>：<strong>用于描述当Pod需要被驱逐时可以在Pod上继续保留运行的时间</strong></li></ul><p><strong>I、当不指定 key 值时，表示容忍所有的污点key:</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span></code></pre><p><strong>II、当不指定effect值时，表示容忍所有的污点作用</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span></code></pre><p><strong>III、有多个Master存在时，防止资源浪费，可以如下设置</strong></p><pre class=" language-bash"><code class="language-bash">kubectl taint nodes Node-Name node-role.kubernetes.io/master<span class="token operator">=</span>:PreferNoSchedule</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> taint </tag>
            
            <tag> toleration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-调度亲和性</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E4%BA%B2%E5%92%8C%E6%80%A7/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E4%BA%B2%E5%92%8C%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="节点的亲和性"><a href="#节点的亲和性" class="headerlink" title="节点的亲和性"></a>节点的亲和性</h2><p><strong>pod.spec.nodeAffinity</strong></p><ul><li><strong>preferredDuringSchedulinglgnoredDuringExecution:软策略</strong></li><li><strong>requireDuringSchedulinglgnoredDuringExecution:硬策略</strong></li></ul><p><strong>requiredDuringSchedulinglgnoredDuringExecution</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> affinity  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname            <span class="token key atrule">operator</span><span class="token punctuation">:</span> NotIn            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>node2</code></pre><p><strong>preferredDuringSchedulingIgnoredDuringExecution</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> affinity1  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">preference</span><span class="token punctuation">:</span>          <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>node3</code></pre><h2 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: affinity  labels:    app: node-affinity-podspec:  containers:  - name: with-node-affinity    image: harbor.bwingame8.com/library/myapp:v1  affinity:    nodeAffinity:      requiredDuringSchedulingIgnoredDuringExecution:        nodeSelectorTerms:        - matchExpressions:          - key: kubernetes.io/hostname            operator: NotIn            values:            - k8s-node2      preferredDuringSchedulingIgnoredDuringExecution:      - weight: 1        preference:          matchExpressions:          - key: <span class="token function">source</span>            operator: In            values:            - k8s-node2</code></pre><p><strong>键值运算关系</strong></p><ul><li><strong>In: label的值在某个列表中</strong></li><li><strong>NotIn:label的值不在某个列表中</strong></li><li><strong>Gt: label的值大于某个值</strong></li><li><strong>Lt: label的值小于某个值</strong></li><li><strong>Exists：某个label存在</strong></li><li><strong>DoesNotExist：某个label不存在</strong></li></ul><!--如果`nodeSeletorTerms`下面有多个选项的话，满足任何一个条件就可以了；如果`matchExpressions`有多个选项的话，则必须同时满足这些条件才能正常调度 POD--><h2 id="Pod-亲和性"><a href="#Pod-亲和性" class="headerlink" title="Pod 亲和性"></a>Pod 亲和性</h2><p><strong>pod.spec.affinity.podAffinity/podAntiAffinity</strong></p><ul><li><strong>preferredDuringSchedulingIgnoredDuringExecution: 软策略</strong></li><li><strong>requiredDuringSchedulingIgnoredDuringExecution:硬策略</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">podAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app          <span class="token key atrule">operator</span><span class="token punctuation">:</span> In          <span class="token key atrule">values</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> pod<span class="token punctuation">-</span><span class="token number">1</span>        <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">podAffinityTerm</span><span class="token punctuation">:</span>          <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app              <span class="token key atrule">operator</span><span class="token punctuation">:</span> In              <span class="token key atrule">values</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> pod<span class="token punctuation">-</span><span class="token number">2</span>          <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname</code></pre><p><strong>亲和性/反亲和性调度策略比较如下：</strong></p><table>    <tr><th>调度策略</th><th>匹配标签</th><th>操作符</th><th>拓扑域支持</th><th>调度目</th</tr>    <tr><td>nodeAffinity</td><td>主机</td><td>In,NotIn,Exists,DoesNotExist,Gt,Lt</td><td>否</td><td>指定主机</td></tr>    <tr><td>podAffinity</td><td>POD</td><td>In,NotIn,Exists,DoesNotExist</td><td>是</td><td>POD与指定POD同一拓扑域</td></tr>    <tr><td>podAnitAffinity</td><td>POD</td><td>In,NotIn,Exists,DoesNotExist</td><td>是</td><td>POD与指定POD不再同一个拓扑域</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 亲和性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-调度说明</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Scheduler 是kubernetes的调度器，主要的任务是把定义的Pod分配到集群的节点上。听起来非常简单，单有很多要考虑的问题</strong></p><ul><li><strong>公平：如何保证每个节点都能被分配资源</strong></li><li><strong>资源高效利用：集群所有资源最大化被使用</strong></li><li><strong>效率：调度的性能要好，能够尽快地对大批量的Pod 完成调度工作</strong></li><li><strong>灵活：允许用户根据自己的需求控制调度的逻辑</strong></li></ul><p><strong>Scheduler 是作为单独的程序运行的，启动之后会一直监听API Server，获取 <code>PodSpec.Nodename</code>为空的pod,对每个pod都会创建一个binding,表明该Pod应该放到哪个节点上</strong></p><h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><p><strong>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程为<code>predicate</code>；然后对通过的几点按照优先级排序，这个是<code>priority</code>;最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误</strong></p><p><strong>Predicate 有一系列的算法可以使用：</strong></p><ul><li><code>PodFitsResources</code>:<strong>节点上剩余的资源是否大于pod请求的资源</strong></li><li><code>PodFitHost</code>:<strong>如果pod指定了NodeName,检查节点名称是否和NodeName匹配</strong></li><li><code>PodFitsHostPorts</code>:<strong>节点上已经使用的port是否和pod申请的port冲突</strong></li><li><code>PodSelectorMatches</code>: <strong>过滤掉和pod指定的label不匹配的节点</strong></li><li><code>NoDiskConflict</code>:<strong>已经mount的volume和pod指定的volume不冲突，除非它们都是只读</strong></li></ul><p><strong>如果在predicate过程中没有合适的节点，pod会一直在<code>pending</code>状态，不断重试调度，直到有节点满足条件。经过这个步骤，如果有多个节点满足条件，就继续priorities过程：安装优先级大小对节点排序</strong></p><ul><li><code>LeastRequestedPriority</code>：<strong>通过计算CPU和Memory使用率越接近，权重越高。这个应该和上面的一起使用，不应该单独使用</strong></li><li><code>ImageLocalityPriority</code>:<strong>倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高</strong></li></ul><p><strong>通过算法对所有的优先级项目和权重进行计算，得出最终的结果</strong></p><h2 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h2><p><strong>除了kubernetes自带的调度器，你也可以编写自己的调度器。通过<code>spec:schedulername</code>参数指定调度器的名字，可以为pod选择某个调度器进行调度。比如下面的pod选择<code>my.scheduler</code>进行调度，而不是默认的<code>default.scheduler</code>;</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> annotation<span class="token punctuation">-</span>second<span class="token punctuation">-</span>scheduler  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> multischeduler<span class="token punctuation">-</span>example<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedulername</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>scheduler  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>with<span class="token punctuation">-</span>second<span class="token punctuation">-</span>annotation<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> gcr.io/google_containers/pause<span class="token punctuation">:</span><span class="token number">2.0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 调度器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-pvc-pvc</title>
      <link href="/2019/12/01/kubernetes-persistent-volume/"/>
      <url>/2019/12/01/kubernetes-persistent-volume/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong><code>PersistentVolume</code>（PV）</strong></p><p><strong>是由管理员设置的存储，它是集群中的一部分。就像节点是集群中的资源一样，PV也是集群中的资源。PV是Volume之类的卷插件，但具有独立于使用PV的Pod的生命周期。此 API 对象包含存储实现的细节，即NFS、iSCSI或特定于云供应商的存储系统</strong></p><p><strong><code>PersistentVolumeClaim</code> （PVC）</strong></p><p><strong>是用户存储的请求。它与Pod相似。Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源(CPU和内存)。声明可以请求特定的大小和访问模式(例如，可以以读/写一次或只读多次模式挂载)</strong></p><p><strong>静态pv</strong></p><p><strong>集群管理员创建一些PV。它们带有可供集群用户使用的实际存储的细节。它们存在与Kubernetes API中，可用于消费</strong></p><p><strong>动态</strong></p><p><strong>当管理员创建的静态PV都不匹配用户的<code>PersistentVolumeClaim</code>时，集群可能会尝试动态地为PVC创建卷。此配置基于<code>StorageClasses</code>:   PVC必须请求[存储类]，并且管理员必须创建并配置该类才能进行动态创建。声明该类为<code>&quot;&quot;</code>可以有效地禁用其动态配置</strong></p><p><strong>要启用基于存储级别的动态存储配置，集群管理员需要启用API server 上的<code>DefaultStorageClass</code>[准入控制器]。例如，通过确保<code>DefaultStorageClass</code>位于 API server 组件的<code>--admission-control</code>标志，使用逗号分割的有序值列表中，可以完成此操作</strong></p><p><strong>绑定</strong></p><p><strong>master中的控制环路监视新的PVC，寻找匹配的PV（如果可能），并将它们绑定在一起。如果为新的PVC动态调配PV，则该环路将始终将该PV绑定到PVC。否则，用户总会得到他们所请求的存储，但是容量可能超出要求的数量。一旦PV和PVC绑定后，<code>PersistentVolumeClaim</code>绑定是排他性的，不管它们是如何绑定的。PVC跟PV绑定是一对一的映射</strong></p><h2 id="持久化卷声明的保护"><a href="#持久化卷声明的保护" class="headerlink" title="持久化卷声明的保护"></a>持久化卷声明的保护</h2><p><strong>PVC保护的目的是确保由Pod正在使用的PVC不会从系统中移除，因为如果被移除的话可能会导致数据丢失</strong></p><!--注意： 当 pod 状态为 `Pending` 并且 pod 已经分配给节点或 pod 为 `Running` 状态时，PVC处于活动状态 --><p><strong>当启用PVC包含alpha功能时，如果用户删除了一个Pod正在使用的PVC，则该PVC不会被立即删除。PVC的删除将被推迟，直到PVC不再被任何pod使用</strong></p><p><strong>持久化卷类型</strong></p><p><code>PersistenVolume</code>类型以插件形式实现。Kubernetes目前支持以下插件类型：</p><ul><li>GCEPersistentDisk AWSElasticBlockStore AzureFile AzureDisk FC(Fibre Channel)</li><li>FlexVolume Flocker NFS iSCSI RBD(Ceph Block Device) CephFS</li><li>Cinder(OpenStack block storage) Glusterfs VsphereVolume Quobyte Volumes</li><li>HostPath VMware Photom Portworx Volumes ScaleIO Volumes StorageOS</li></ul><p><strong>持久卷演示代码</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv0003<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 5Gi  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> slow  <span class="token key atrule">mountOptions</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> hard    <span class="token punctuation">-</span> nfsvers=4.1  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /tmp    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.17.0.2</code></pre><h2 id="PV-访问模式"><a href="#PV-访问模式" class="headerlink" title="PV 访问模式"></a>PV 访问模式</h2><p><code>PersistentVolume</code>可以以资源提供者支持的任何方式挂载到主机上。如下表表示，供应商具有不同的功能，每个PV的访问模式都将设置为该卷支持的特定模式。例如，NFS可以支持多个读/写客户端，但特定的NFS PV可能以只读方式导出到服务器上。每个PV都有一套自己的用来描述特定功能的访问模式</p><ul><li>ReadWriteOne – 该卷可以被单个节点以读/写模式挂载</li><li>ReadOnlyMany– 该卷可以被多个节点以只读模式挂载</li><li>ReadWriteMany– 该卷可以被多个节点以读/写模式挂载</li></ul><p><strong>在命令行中，访问模式缩写为：</strong></p><ul><li><strong>RWO - ReadWriteOnce</strong></li><li><strong>ROX - ReadOnlyMany</strong></li><li><strong>RWX- ReadWriteMany</strong></li></ul><!-- 一个卷一次只能使用一种访问模式挂载，即使它支持很多访问模式。例如， GCEPersistentDisk 可以由单个节点作为 ReadWriteOnce 模式挂载，或由多个节点以 ReadOnlyMany 模式挂载，但不能同时挂载 --><table>    <tr><th>Volume 插件</th><th>ReadWriteOnce</th><th>ReadOnlyMany</th><th>ReadWriteMany</th></tr>    <tr><td>AWSElasticBlockStoreAWSElasticBlockStore</td><td>√</td><td>-</td><td>-</td</tr>    <tr><td>AzureFile</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>AzureDisk</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>CephFS</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>Cinder</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>FC</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>FlexVolume</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>Flocker</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>GCEPersistentDisk</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>Glusterfs</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>HostPath</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>iSCSI</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>PhotonPersistentDisk</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>Quobyte</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>NFS</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>RBD</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>VsphereVolume</td><td>√</td><td>-</td><td>-(当Pod并列时有效)</td></tr>    <tr><td>PorworxVolume</td><td>√</td><td>-</td><td>√</td></tr>    <tr><td>ScaleIO</td><td>√</td><td>√</td><td>-</td></tr></table><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><ul><li><strong>Retain（保留）– 手动回收</strong></li><li><strong>Recycle（回收）–基本擦除(<code>rm -rf /thevolume/*</code>) 最新版的服务已经不支持该回收策略了</strong></li><li><strong>Delete（删除）– 关联的存储资产（例如AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder卷)将被删除</strong></li><li><strong>当前，只有 NFS 和HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk和Cinder卷支持删除策略</strong></li></ul><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>卷可以处于以下的某种状态:</p><ul><li><p><strong>Available(可用) – 一块空闲资源还没有被任何声明绑定</strong></p></li><li><p><strong>Bound(已绑定)– 卷已经被声明绑定</strong></p></li><li><p><strong>Released（已释放）–声明被删除，但是资源还未被集群重新声明</strong></p></li><li><p><strong>Faild(失败) – 该卷的自动回收失败</strong></p></li></ul><p>*<em>命令行会显示绑定到 PV 的 PVC 的名称 *</em></p><h2 id="持久化演示说明-NFS"><a href="#持久化演示说明-NFS" class="headerlink" title="持久化演示说明 - NFS"></a>持久化演示说明 - NFS</h2><p><strong>I、安装 NFS 服务器</strong></p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y nfs-common nfs-utils rpcbind<span class="token function">mkdir</span> /nfsdata<span class="token function">chmod</span> 666 /nfsdata<span class="token function">chown</span> nfsnobody /nfsdata<span class="token function">cat</span> /etc/exports    /nfsdata *<span class="token punctuation">(</span>rw,no_root_squash,no_all_squash,sync<span class="token punctuation">)</span>systemctl start rpcbindsystemctl start nfs</code></pre><p><strong>II、部署 PV</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfspv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassNmae</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/nfs    <span class="token key atrule">server</span><span class="token punctuation">:</span> 10.66.66.10</code></pre><p><strong>III、创建服务并使用 PVC</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> web  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> web        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> www    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"nfs"</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi</code></pre><h2 id="关于StatefulSet"><a href="#关于StatefulSet" class="headerlink" title="关于StatefulSet"></a>关于StatefulSet</h2><ul><li><strong>匹配 Pod name（网络标识）的模式为：(statefulset名称)-(序号),比如上面的示例： web-0,web-1,web-2</strong></li><li><strong>StatefulSet为每一个Pod副本创建了一个DNS域名，这个域名的格式为：$(podname).(headless server name),也就意味着服务间是通过Pod域名来通信而非Pod IP,因为当Pod所在Node发生故障时，Pod会被漂移到其它Node上，Pod IP会发生变化，但是Pod域名不会有变化</strong></li><li><strong>StatefulSet 使用 Headless 服务来控制Pod的域名，这个域名的FQDN为：(servicename).(namespace).svc.cluster.local,其中,“cluster.local”指的是集群的域名</strong></li><li><strong>根据 volumeClaimTemplates，为每个 Pod创建一个pvc,pvc的命名规则匹配模式：（volumeClaimTemplates.name)-(pod_name),比如上面的volumeMounts.name=www,Pod name=web-[0-2],因此创建出来的PVC是www-web-0、www-web-1、www-web-2</strong></li><li><span style="color: red;"><strong>删除 Pod 不会删除其pvc，手动删除pvc将自动释放pv</strong></span></li></ul><p><strong>StatefulSet的启停顺序:</strong></p><ul><li><strong>有序部署： 部署StatefulSet时，如果有多个Pod副本，它们会被顺序地创建(从0到N-1)并且，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态</strong></li><li><strong>有序删除：当Pod被删除时，它们被终止的顺序是N-1到0</strong></li><li><strong>有序扩展：当对Pod执行扩展操作时，与部署一样，它前面的Pod必须都处于Running和Ready状态</strong></li></ul><p><strong>StatefulSet使用场景：</strong></p><ul><li><strong>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现。</strong></li><li><strong>稳定的网络标识符，即Pod重新调度后其Podname和Hostname不变。</strong></li><li><strong>有序部署，有序扩展，基于 init containers来实现。</strong></li><li><strong>有序收缩</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-volume</title>
      <link href="/2019/12/01/kubernetes-volume/"/>
      <url>/2019/12/01/kubernetes-volume/</url>
      
        <content type="html"><![CDATA[<p><strong>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet会重启它，但是容器中的文件将丢失–容器以干净的状态(镜像最初的状态)重新启动。其次，在<code>Pod</code>中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes中的<code>Volume</code>抽象就很好的解决了这些问题</strong></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Kubernetes中的卷有明确的寿命 <code>--</code> 与封装它的Pod相同。所以，卷的生命比Pod中的所有容器都长，当这个容器重启时数据仍然得以保存。当然 Pod 不再存在时，卷也将不复存在。也许更重要的是，<code>Kubernetes</code>支持多种类型的卷，Pod可以同时使用任意数量的卷</strong></p><h2 id="卷的类型"><a href="#卷的类型" class="headerlink" title="卷的类型"></a>卷的类型</h2><p><strong>Kubernetes 支持一下类型的卷：</strong></p><ul><li><code>awsElasticBlockStore</code> <code>azureFile</code> <code>cephfs</code> <code>csi</code> <code>downwardAPI</code> `emptyDir``</li><li><code>fc</code> <code>flocker</code> <code>gcePersistentDisk</code> <code>gitRepo</code> <code>glusterfs</code> <code>hostPath</code> <code>iscsi</code> <code>local</code> <code>nfs</code></li><li><code>persistentVolumeClaim</code> <code>projected</code> <code>portworxVolume</code> <code>quobyte</code> <code>rbd</code> <code>scaleIO</code> <code>secret</code></li><li><code>storageos</code> <code>vsphereVolume</code></li></ul><p><strong>emptyDir</strong></p><p>当Pod被分配给节点时，首先创建 <code>emptyDir</code> 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中容器可以读取和写入 <code>emptyDir</code> 卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时， <code>emptyDir</code> 中的数据将被永久删除</p><!-- 注意： 容器崩溃不会从节点中移除 pod ，因此 `emptyDir` 卷中的数据在容器崩溃时是安全的 --><p><code>emptyDir</code> 的用法有：</p><ul><li>暂存空间，例如用于基于磁盘的合并排序</li><li>用作长时间计算崩溃恢复时的检查点</li><li>web服务器容器提供数据时，保存内容管理器容器提取的文件</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pd<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/test<span class="token punctuation">-</span>webserver    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /cache      <span class="token key atrule">name</span><span class="token punctuation">:</span> cache<span class="token punctuation">-</span>volume  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cache<span class="token punctuation">-</span>volume    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><p><strong><code>hostPath</code> 卷将主机节点的文件系统中的文件或目录挂载到集群中</strong></p><p><code>hostPath</code> 的用途如下：</p><ul><li>运行需要访问 Docker 内部的容器： 使用 <code>/var/lib/docker</code>的 <code>hostPath</code></li><li>在容器中运行cAdvisor；使用 <code>/dev/cgroups</code>的 <code>hostPath</code></li></ul><p>除了所需的 <code>path</code> 属性之外，用户还可以为<code>hostPath</code>卷指定 <code>type</code></p><hr><table>    <tr><th>值</th><th>行为</th></tr>    <tr><td></td><td>空字符串(默认)用于向后兼容，这意味着在挂载hostPath 卷之前不会执行任何检查。</td></tr>    <tr><td>DirectoryOrCreate</td><td>如果在给定的路径上没有任何东西存在，那么将根据需要在那里创建一个空目录，权限设置为0755，与kubelet具有相同的组和所有权</td></tr>    <tr><td>Directory</td><td>给定的路径下必须存在目录</td></tr>    <tr><td>FileOrCreate</td><td>如果在给定的路径上没有任何东西存在，那么会根据需要创建在那里创建一个空文件，权限设置为0644，与Kubelete具有相同的组和所有权。</td></tr>    <tr><td>File</td><td>给定的路径下必须存在文件</td></tr>    <tr><td>Socket</td><td>给定的路径下必须存在 UNIX 套接字 </td></tr>    <tr><td>CharDevice</td><td>给定的路径下必须存在字符设备</td></tr>    <tr><td>BlockDevice</td><td>给定的路径下必须存在块设备</td></tr></table><p>使用这种卷类型是请注意，因为：</p><ul><li>由于每个节点上的文件都不同，具有相同配置(例如从podTemplate创建的)的 pod 在不同节点上的行为可能会有所不同</li><li>当Kubernetes 按照计划添加资源感知调度时，将无法考虑 <code>hostPath</code> 使用的资源</li><li>在底层主机上创建的文件或目录只能由 root 写入。您需要在特权容器以 root 身份运行进程，或修改主机上的文件权限以便写入 <code>hostPath</code> 卷</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pd<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/test<span class="token punctuation">-</span>webserver    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /test<span class="token punctuation">-</span>pd      <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>volume  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>volume    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># directory location on host</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data      <span class="token comment" spellcheck="true"># this field is optional</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> Directory</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> volume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-secret</title>
      <link href="/2019/12/01/kubernetes-secret/"/>
      <url>/2019/12/01/kubernetes-secret/</url>
      
        <content type="html"><![CDATA[<h2 id="Secret-存在意义"><a href="#Secret-存在意义" class="headerlink" title="Secret 存在意义"></a>Secret 存在意义</h2><p><strong>Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用</strong></p><p>Secret有三种类型：</p><ul><li><strong>Service Account: 用来访问Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount 目录中</strong></li><li><strong>Opaque: base64编码格式的Secret,用来存储密码、密钥等</strong></li><li><strong>kubernetes.io/dockerconfigjson:用来存储私有docker registry的认证信息</strong></li></ul><h3 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h3><p><strong>Service Account 用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount 目录中</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system</span>NAME                                 READY   STATUS    RESTARTS   AGEcoredns-5c98db65d4-pxl78             1/1     Running   0          8dcoredns-5c98db65d4-vdtsr             1/1     Running   0          8detcd-k8s-master                      1/1     Running   0          8dkube-apiserver-k8s-master            1/1     Running   0          8dkube-controller-manager-k8s-master   1/1     Running   0          8dkube-flannel-ds-amd64-852cl          1/1     Running   0          8dkube-flannel-ds-amd64-p5h64          1/1     Running   0          8dkube-flannel-ds-amd64-rglvq          1/1     Running   0          6d18hkube-proxy-6sp4j                     1/1     Running   0          8dkube-proxy-hbnkf                     1/1     Running   0          6d18hkube-proxy-ttjcn                     1/1     Running   0          8dkube-scheduler-k8s-master            1/1     Running   0          8d<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec kube-proxy-ttjcn -it -n kube-system -- /bin/sh</span><span class="token comment" spellcheck="true"># cd /run/secrets</span><span class="token comment" spellcheck="true"># ls</span>kubernetes.io<span class="token comment" spellcheck="true"># cd kubernetes.io</span><span class="token comment" spellcheck="true"># cd serviceaccount  </span><span class="token comment" spellcheck="true"># ls</span>ca.crt    namespace  token<span class="token comment" spellcheck="true"># cat ca.crt      </span>-----BEGIN CERTIFICATE-----MIICyDCCAbCgAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJlcm5ldGVzMB4XDTE5MTEyMzA2MjEzNVoXDTI5MTEyMDA2MjEzNVowFTETMBEGA1UEAxMKa3ViZXJuZXRlczCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALqjo541wpNZ42IyS4UXUOtpfgxS37vFo95D2oQoktzjE9hZetkdhDV3J262OVh9sysEUY0p/97A+E8Dex45KnfmqAAZdlG3hq7T5sGHtx/zP81wVs9hxf4SchCIRstCUrOxkErwViu8FOsN+tEPst3TgJaYbFz38zpK0N8769LiwLaVmQMcb07/n2k2uvbion7S6nlEVlS7yQ6fouEaoSULUrEm565A8mu2hloiSSNIlbQBJV8/mlzop4QdKRxvfYt2S3uqqYloenYdWOPAACpWzJn8kkUxBO8xJrzEiGHmUOXz75CmF5flgOQPtgedmWJaKegkvGSsl7Tp28Kv750CAwEAAaMjMCEwDgYDVR0PAQH/BAQDAgKkMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBALfpP6jWWtCdlAfCBXV49eLlIFURyVmsNs16uCxQQbOQLNHMp+3WoZLsyl2xkqwGkruLoG2opWL5ab7FnYlZJpa9QJ12ic6wee0uvb70HLRfc8W2Ep+blgU8nq5zMFknlHS9nEk5PfFkq4T3ZTxZdSbXewxPURl+NLXVVgjNcFDdPpv0srnerLhL7qWYYGEHENxkA60Ons0KIZMZQzabQ4VpXhmvCLhPdmdVL9GbsZcqPQWZD9o23afDHhxNTg3vBnX/8IVm8NO5a5QP9ixzRBVgGzmshr2y5/Xdaqm32FfVZs1R1BURzedwkqssqyRKghqePpdLQznImjJcSQ3bGcI<span class="token operator">=</span>-----END CERTIFICATE-----<span class="token comment" spellcheck="true"># cat token</span>eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJlLXByb3h5LXRva2VuLW54NzhwIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6Imt1YmUtcHJveHkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzZmViYjlhOC0yOTU2LTRjMzEtODU1Mi01Mzc2ZTMxOGE3NWIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06a3ViZS1wcm94eSJ9.xy-rX7AKuPzS6Z2ecFZRy32FHFJuR5WZZ5ziWEhG64rXV5Hcy9gA1ptatwLxQmGGkYFVZ5rEDTcNRGsM1ADHQKFjFhf5TpsXEUfk3U67JtnWUC_KDB8G2P1cBN7s6O1JKYVn-uWGq0LTcxoR62TpMgCFdLKR38CXIR-ItUTmpGVVKlhWgg3pIvvbQgFWOwpHxBM8Ce-Er8J6uhKuPvXfhO28K0ppf0OZFihWPhVs-BLAI855F7UC8dhi0_db10w_zmeaa_EcMRddrs0FYnup_kubevTc7geUOzAetMCfkON4EJv91xVtHVOctpdi2wX4WmhNs9mbuJhBqJPGkp-24Q<span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># ls    </span>ca.crt    namespace  token<span class="token comment" spellcheck="true"># cat namespace     </span>kube-system<span class="token comment" spellcheck="true"># </span></code></pre><h2 id="Opaque-Secret"><a href="#Opaque-Secret" class="headerlink" title="Opaque Secret"></a>Opaque Secret</h2><p><strong>I、创建说明</strong></p><p><strong>Opaque类型的数据是一个map类型，要求value是base65编码格式</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo -n "admin" |base64</span>YWRtaW4<span class="token operator">=</span><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo -n "adbdfes" | base64</span>YWRiZGZlcw<span class="token operator">==</span></code></pre><p><strong>secrets.yaml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">password</span><span class="token punctuation">:</span> YWRiZGZlcw==  <span class="token key atrule">username</span><span class="token punctuation">:</span> YWRtaW4=</code></pre><p><strong>II、使用方式</strong></p><p><strong>1. 将Secret 挂载到 Volume中</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>test  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>test<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets    <span class="token key atrule">secret</span><span class="token punctuation">:</span>      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> mysecret  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">name</span><span class="token punctuation">:</span> db    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/secrets"</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p><strong>2、将 Secret 导出到环境变量中</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>deployment    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">1</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> TEST_USER          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret              <span class="token key atrule">key</span><span class="token punctuation">:</span> username         <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> TEST_PASSWORD           <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>             <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>               <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret               <span class="token key atrule">key</span><span class="token punctuation">:</span> password</code></pre><h2 id="Kubernetes-io-dockerconfigjson"><a href="#Kubernetes-io-dockerconfigjson" class="headerlink" title="Kubernetes.io/dockerconfigjson"></a>Kubernetes.io/dockerconfigjson</h2><p><strong>使用 Kuberctl 创建 docker registry 认证的secret</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create secret docker-registry myregistrykey --docker-server<span class="token operator">=</span>DOCKER_REGISTRY_SERVER --docker-username<span class="token operator">=</span>DOCKER_USER --docker-password<span class="token operator">=</span>DOCKER_PASSWORD --docker-email<span class="token operator">=</span>DOCKER_EMAIL secret <span class="token string">"myregistrykey"</span> created</code></pre><p>*<em>在创建 Pod 的时候，通过 <code>imagePullSecrets</code> 来引用刚创建的<code>myregistrykey</code> *</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> foo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo      <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1   <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myregistrykey</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> secret </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-configMap</title>
      <link href="/2019/12/01/kubenetes-configMap/"/>
      <url>/2019/12/01/kubenetes-configMap/</url>
      
        <content type="html"><![CDATA[<h2 id="configMap-描述信息"><a href="#configMap-描述信息" class="headerlink" title="configMap 描述信息"></a>configMap 描述信息</h2><p><strong>ConfigMap 功能在 Kubernetes1.2版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象</strong></p><h2 id="ConfigMap-的创建"><a href="#ConfigMap-的创建" class="headerlink" title="ConfigMap 的创建"></a>ConfigMap 的创建</h2><p>I、使用目录创建</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/root/yaml/ceshi/configmap/config/docs/user-guide/configmap/kubectl<span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat game.properties </span>enemies<span class="token operator">=</span>alienslives<span class="token operator">=</span>3enemies.cheat<span class="token operator">=</span>trueenemies.cheat.level<span class="token operator">=</span>noGoodRottensecret.code.passphrase<span class="token operator">=</span>UUDDLRLRBABASsecret.code.allowed<span class="token operator">=</span>truesecret.code.lives<span class="token operator">=</span>30<span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat ui.properties </span>color.good<span class="token operator">=</span>purplecolor.bad<span class="token operator">=</span>yellowallow.textmode<span class="token operator">=</span>truehow.nice.to.look<span class="token operator">=</span>fairlyNice$ kubectl create configmap game-config --from-file<span class="token operator">=</span>docs/user-guide/configmap/kubectl</code></pre><p><strong><code>--from-file</code>  指定在目录下的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容</strong></p><p><strong>II 使用文件创建</strong></p><p><strong>只要指定为一个文件就可以从单个文件中创建 ConfigMap</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create configmap game-config-2 --from-file<span class="token operator">=</span>docs/user-\ guide/configmap/kubectl/game.properties$ kubectl get configmaps game-config-2 -o yaml</code></pre><p><strong><code>--from-file</code>这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，就跟指定整个目录是一样的</strong></p><p><strong>III、使用字面值创建</strong></p><p><strong>使用文字值创建，利用 <code>--from-literal</code>参数传递配置信息，该参数可以使用多次，格式如下</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create configmap special-config --from-literal<span class="token operator">=</span>special.how<span class="token operator">=</span>very --from-literal<span class="token operator">=</span>special.type<span class="token operator">=</span>charm</code></pre><h2 id="Pod中使用-ConfigMap"><a href="#Pod中使用-ConfigMap" class="headerlink" title="Pod中使用 ConfigMap"></a>Pod中使用 ConfigMap</h2><p><strong>I、使用 ConfigMap 来替代环境变量</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">log_level</span><span class="token punctuation">:</span> INFO</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> hubor.bwinagme8.com/library/myapp<span class="token punctuation">:</span>v1      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"env"</span><span class="token punctuation">]</span>      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_TYPE_KEY          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type      <span class="token key atrule">envForm</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">configMapRef</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>config  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><p><strong>II 用 ConfigMap 设置命令行参数</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod55<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)"</span><span class="token punctuation">]</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config            <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how       <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_TYPE_KEY         <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>           <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>             <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config             <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type   <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never </code></pre><p>*<em>III、通过数据卷插件使用 ConfigMap *</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><p><strong>在数据卷里面使用这个ConfigMap,有不同的选项。最基本的就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"cat /etc/config/special.how"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/config  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><h2 id="ConfigMap-的热更新"><a href="#ConfigMap-的热更新" class="headerlink" title="ConfigMap 的热更新"></a>ConfigMap 的热更新</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">log_level</span><span class="token punctuation">:</span> INFO<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/config      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume          <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>config</code></pre><pre class=" language-bash"><code class="language-bash">$ kubectl <span class="token function">exec</span> `kubectl get pods -l run<span class="token operator">=</span>my-nginx -o<span class="token operator">=</span>name<span class="token operator">|</span><span class="token function">cut</span> -d <span class="token string">"/"</span> -f2` <span class="token function">cat</span> /etc/config/log_levelINFO</code></pre><p><strong>修改 ConfigMap</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl edit configmap log-config</code></pre><p><strong>修改<code>log_level</code>的值为<code>DEBUG</code>等待大概10秒钟时间，再次查看环境变量的值</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl <span class="token function">exec</span> `kubectl get pods -l run<span class="token operator">=</span>my-nginx -o<span class="token operator">=</span>name<span class="token operator">|</span><span class="token function">cut</span> -d <span class="token string">"/"</span> -f2` <span class="token function">cat</span> /etc/config/log_level</code></pre><!--!!! 特别注意 configMap 如果以 ENV 的方式挂载至容器，修改 configMap 并不会实现热更新--><p>*<em>ConfigMap 更新后滚动更新Pod *</em></p><p>更新 ConfigMap 目前并不会触发相关Pod的滚动更新，可以通过修改pod annotations 的方式强制触发滚动更新</p><pre class=" language-bash"><code class="language-bash">$ kubectl patch deployment my-nginx --patch <span class="token string">'{"spec":{"template":{"metadata":{"annotations":{"version/config": "20190411"}}}}}'</span></code></pre><p>这个例子里我们在<code>.spec.template.metadata.annotations</code>中添加<code>version/config</code>,每次通过修改<code>version/config</code>来触发滚动更新</p><p><strong>！！！ 更新 ConfigMap 后：</strong></p><ul><li><strong>使用该 ConfigMap 挂载的 Env 不会同步更新</strong></li><li><strong>使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间(实测大概10秒) 才能同步更新</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> configmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-Ingress</title>
      <link href="/2019/11/29/kubernetes-Ingress/"/>
      <url>/2019/11/29/kubernetes-Ingress/</url>
      
        <content type="html"><![CDATA[<p><strong>Ingress-Nginx github 地址</strong><a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx</a></p><p><strong>Ingress-Nginx 官方网站：</strong><a href="https://kubernetes.github.io/ingress-nginx" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx</a></p><p><img src="https://cntsp.github.io/medias/contents/22.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/21.png" alt=""></p><h2 id="部署-Ingress-Nginx"><a href="#部署-Ingress-Nginx" class="headerlink" title="部署 Ingress-Nginx"></a>部署 Ingress-Nginx</h2><pre class=" language-bash"><code class="language-bash">kubectl apply -f mandatory.yamlkubectl apply -f service-nodeport.yaml</code></pre><h2 id="Ingress-HTTP-代理访问"><a href="#Ingress-HTTP-代理访问" class="headerlink" title="Ingress HTTP 代理访问"></a>Ingress HTTP 代理访问</h2><p><strong>deployment、Service、Ingress Yaml文件</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-dmspec:  replicas: 2  template:    metadata:      labels:        name: nginx    spec:      containers:        - name: nginx          image: harbor.bwingame8.com/library/myapp:v1          imagePullPolicy: IfNotPresent          ports:            - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-svcspec:  ports:    - port: 80      targetPort: 80      protocol: TCP  selector:    name: nginx---apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-testspec:  rules:    - host: www1.bwingame8.com      http:        paths:        - path: /          backend:            serviceName: nginx-svc            servicePort: 80</code></pre><h2 id="Ingress-HTTPS-代理访问"><a href="#Ingress-HTTPS-代理访问" class="headerlink" title="Ingress HTTPS 代理访问"></a>Ingress HTTPS 代理访问</h2><p><strong>创建证书，以及 cert 存储方式</strong></p><pre class=" language-bash"><code class="language-bash">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="token string">"/CN=nginxsvc/0=nginxsvc"</span>kubectl create secret tls tls-secret --key tls.key --cert tls.crt</code></pre><p>deployment、Service、Ingress Yaml文件</p><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-testspec:  tls:    - hosts:      - www3.bwingame8.com      secretName: tls-secret  rules:    - host: www3.bwingame8.com      http:        paths:        - path: /          backend:            serviceName: svc-3            servicePort: 80</code></pre><h2 id="Nginx-进行-BasicAuth"><a href="#Nginx-进行-BasicAuth" class="headerlink" title="Nginx 进行 BasicAuth"></a>Nginx 进行 BasicAuth</h2><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> httpdhtpasswd -c auth fookubectl create secret generic basic-auth --from-file<span class="token operator">=</span>auth</code></pre><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: ingress-width-auth  annotations:    nginx.ingress.kubernetes.io/auth-type: basic    nginx.ingress.kubernetes.io/auth-secret: basic-auth    nginx.ingress.kubernetes.io/auth-realm: <span class="token string">'Authentication Required - foo'</span>spec:  rules:  - host: www4.bwingame8.com    http:      paths:      - path: /        backend:          serviceName: nginx-svc          servicePort: 80</code></pre><h2 id="Nginx-进行重写"><a href="#Nginx-进行重写" class="headerlink" title="Nginx 进行重写"></a>Nginx 进行重写</h2><table>    <tr><th>名称</th><th>描述</th><th>值</th></tr>    <tr><td>nginx.ingress.kubernetes.io/rewrite-target</td><td>必须重定向流量的目标URL</td><td>串</td></tr>    <tr><td>nginx.ingress.kubernetes.io/ssl-redirect</td><td>指示位置部分是否仅可访问SSL(当Ingress包含证书时默认为True)</td><td>布尔</td></tr>    <tr><td>nginx.ingress.kubernetes.io/force-ssl-redirect</td><td>即使Ingress未启用TLS，也强制重定向到HTTPS</td><td>布尔</td></tr>    <tr><td>nginx.ingress.kubernetes.io/app-root</td><td>定义Controller必须重定向的应用程序根，如果它在'/'上下文中</td><td>串</td></tr>    <tr><td>nginx.ingress.kubernetes.io/use-regex</td><td>指示Ingress上定义的路径是否使用正则表达式</td><td>布尔</td></tr></table><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-test  annotations:    nginx.ingress.kubernetes.io/rewrite-target: https://www3.bwingame8.com:31306/hostname.htmlspec:  rules:  - host: www3.bwingame8.com    http:      paths:      - path: /        backend:          serviceName: nginx-svc          servicePort: 80</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> ingress-nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Service</title>
      <link href="/2019/11/29/Kubernetes-Service/"/>
      <url>/2019/11/29/Kubernetes-Service/</url>
      
        <content type="html"><![CDATA[<h2 id="Service-的概念"><a href="#Service-的概念" class="headerlink" title="Service 的概念"></a>Service 的概念</h2><p><strong>Kubernetes service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 – 通常称为微服务。这一组 <code>Pod</code> 能够被<code>Service</code>访问到，通常是通过<code>Lable Selector</code></strong></p><p><img src="https://cntsp.github.io/medias/contents/14.png" alt=""></p><p><strong>Service能够提供负载均衡的能力，但是在使用上有以下限制：</strong></p><ul><li><strong>只提供4层负载均衡能力，而没有7层功能，但有时我们可能需要更多的匹配规则来转发请求，这点上4层负载均衡是不支持的</strong></li></ul><h2 id="Service-的类型"><a href="#Service-的类型" class="headerlink" title="Service 的类型"></a>Service 的类型</h2><p><strong>Service 在 K8s中有以下四种类型</strong></p><ul><li><strong>ClusterIp: 默认类型，自动分配一个仅Cluster内部可以访问的虚拟IP</strong></li><li><strong>NodePort: 在 ClusterIP基础上为Service 在每台机器上绑定一个端口，这样就可以通过<NodeIP>:</strong></li><li><strong>LoadBalancer:在NodePort的基础上，借助cloud provider创建一个外部负载均衡器，并将请求转发到<NodeIP>:NodePort</strong></li><li><strong>ExternalName: 把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有kubernetes1.7或更高版本的kube-dns才支持</strong></li></ul><p><img src="https://cntsp.github.io/medias/contents/15.png" alt=""></p><h2 id="VIP-和-Service-代理"><a href="#VIP-和-Service-代理" class="headerlink" title="VIP 和 Service 代理"></a>VIP 和 Service 代理</h2><p><strong>在 Kubernetes 集群中，每个 Node 运行一个 <code>kube-proxy</code>进程。<code>kube-proxy</code> 负责为 <code>Service</code>实现了一种VIP（虚拟IP）的形式，而不是 <code>ExternalName</code>的形式。在 Kubernetes v1.0 版本，代理完全在userspace。在Kubernetes v1.1版本，新增了 iptables 代理，但并不是默认的运行模式。从Kubernetes v1.2起，默认就是iptables代理。在Kubernetes v1.8.0-beta.0中，添加了ipvs代理</strong></p><p><strong>在kubernetes 1.14版本中开始默认使用 ipvs 代理</strong></p><p><strong>在 kubernetes v1.0 版本， <code>Service</code>是”4层”（TCP/UDP over IP）概念。在kubernetes v1.1版本，新增了 <code>Ingress</code> API(beta版)，用来表示“7层”(HTTP)服务</strong></p><p><strong>！为何不使用 round-robin DNS?</strong>（DNS缓存问题）</p><h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><p><img src="https://cntsp.github.io/medias/contents/16.png" alt=""></p><p><img src="https://cntsp.github.io/medias/contents/17.png" alt=""></p><h2>III、ipvs 代理模式</h2><p><strong>这种模式，kube-proxy会监视kubernetes <code>Service</code>对象和<code>Endpoints</code>，调用<code>netlink</code>接口以响应地创建 ipvs 规则并定期与Kubernetes <code>Service</code>对象和<code>Endpoints</code>对象同步ipvs规则，以确保ipvs状态与期望一致。访问服务时，流量将被重定向到其中一个后端Pod</strong></p><p>与iptables类似，ipvs于netfilter的hook功能，但使用哈希表作为底层数据结构并在内核空间中工作。这意味着ipvs可以更快地重定向流量，并且在同步代理规则时具有更好的性能。此外，ipvs为负载均衡算法提供了更好选项，例如：</p><ul><li><strong><code>rr</code>:  轮询调度</strong></li><li><strong><code>lc</code>:  最小连接数</strong></li><li><strong><code>dh</code>:  目标哈希</strong></li><li><strong><code>sh</code>:源哈希</strong></li><li><strong><code>sed</code>: 最短期望延迟</strong></li><li><strong><code>nq</code>: 不排队调度</strong></li></ul><!--注意： ipvs 模式假定在运行 kube-proxy 之前在节点上都已经安装了 IPVS 内核模块。当kube-proxy 以 ipvs 代理模式启动时，kube-proxy 将验证节点上是否安装了 IPVS 模块，如果未安装，则 kube-proxy 将回退到 iptables 代理模式--><p><img src="https://cntsp.github.io/medias/contents/18.png" alt=""></p><h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p><strong>clusterIP 主要在每个node节点使用iptables，将发向clusterIP对应端口的数据，转发到kube-proxy中。然后kube-proxy自己内部实现有负载均衡的方法，并可以查询到这个service下对应的pod的地址和端口，进而把数据转发给对应的pod的地址和端口</strong></p><p><img src="https://cntsp.github.io/medias/contents/19.png" alt=""></p><p><strong>为了实现图上的功能，主要需要以下几个组件协同工作：</strong></p><ul><li><strong>apiserver用户通过kubectl命令向apiserver发送创建service的命令，apiserver接收到请求后将数据存储到etcd中</strong></li><li><strong>kube-proxy kubernetes的每个节点中都有一个叫做kube-proxy的进程，这个进程负责感知service，pod的变化，并将变化的信息写入本地的iptables规则中</strong></li><li><strong>iptables 使用NAT等技术将virtualIP的流量转至endpoint中</strong></li></ul><p><strong>创建 myapp-deploy.yaml 文件</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> vim myapp-deploy.yamlapiVersion: apps/v1kind: Deploymentmetadata:  name: myapp-deploy  namespace: defaultspec:  replicas: 3  selector:    matchLabels:      app: myapp      release: stabel  template:    metadata:      labels:        app: myapp        release: stabel        env: <span class="token function">test</span>    spec:      containers:      - name: myapp        image: ikubernetes/myapp:v2        imagePullPolicy: ifNotPresent        ports:        - name: http          containerPort: 80</code></pre><p><strong>创建 Service 信息</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master root<span class="token punctuation">]</span>vim myapp-service.yamlapiVersion: v1kind: Servicemetadata:  name: myapp  namespace: defaultspec:  type: ClusterIP  selector:    app: myapp    release:  stabel  ports:  - name: http    port: 80    targetPort: 80</code></pre><h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p><strong>有时不需要或不想要负载均衡，以及单独的Service IP。遇到这种情况，可以通过指定ClusterIP(spec.clusterIP)的值为“None”来创建Headless Service。这类 Service并不会分配ClusterIP，kube-proxy不会处理他们，而且平台也不会为它们进行负载均衡和路由。</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim myapp-svc-headless.yaml</span>apiVersion: v1kind: Servicemetadata:  name: myapp-headless  namespace: defaultspec:  selector:    app: myapp  clusterIP: <span class="token string">"None"</span>  ports:  - port: 80    targetPort: 80<span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># dig -t A myapp-headless.default.svc.cluster.local.</span>@10.96.0.10</code></pre><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><strong>nodePort 的原理在于在node上开了一个端口,将向该端口的流量导入到kube-proxy，然后由kube-proxy进一步到给对应的Pod</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Servicemetadata:  name: myapp  namespace: defaultspec:  type: NodePort  selector:    app: myapp    release: stabel  ports:  - name: http    port: 80    targetPort: 80</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEkubernetes   ClusterIP   10.96.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          6d6htsgj-svc     NodePort    10.109.255.35   <span class="token operator">&lt;</span>none<span class="token operator">></span>        8080:30000/TCP   2d11h<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                               READY   STATUS    RESTARTS   AGEtsgj-deployment-855476f755-5l4qk   1/1     Running   0          34htsgj-deployment-855476f755-7rj8f   1/1     Running   0          34htsgj-deployment-855476f755-crkrn   1/1     Running   0          34h<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save |grep tsgj-svc</span>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SERVICES <span class="token operator">!</span> -s 10.244.0.0/16 -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-MARK-MASQ-A KUBE-SERVICES -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-SVC-X5UEB5AP7D73JSAI<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SVC-X5UEB5AP7D73JSAI</span>:KUBE-SVC-X5UEB5AP7D73JSAI - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SERVICES -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-ACY2NRHQXCLYF447-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-K7BRQOSBPSECSMB6-A KUBE-SVC-X5UEB5AP7D73JSAI -j KUBE-SEP-UBOJ6DEUKSFU7YBC<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-ACY2NRHQXCLYF447</span>:KUBE-SEP-ACY2NRHQXCLYF447 - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-ACY2NRHQXCLYF447 -s 10.244.1.36/32 -j KUBE-MARK-MASQ-A KUBE-SEP-ACY2NRHQXCLYF447 -p tcp -m tcp -j DNAT --to-destination 10.244.1.36:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-ACY2NRHQXCLYF447<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-K7BRQOSBPSECSMB6</span>:KUBE-SEP-K7BRQOSBPSECSMB6 - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-K7BRQOSBPSECSMB6 -s 10.244.1.37/32 -j KUBE-MARK-MASQ-A KUBE-SEP-K7BRQOSBPSECSMB6 -p tcp -m tcp -j DNAT --to-destination 10.244.1.37:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-K7BRQOSBPSECSMB6<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-UBOJ6DEUKSFU7YBC</span>:KUBE-SEP-UBOJ6DEUKSFU7YBC - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-UBOJ6DEUKSFU7YBC -s 10.244.3.24/32 -j KUBE-MARK-MASQ-A KUBE-SEP-UBOJ6DEUKSFU7YBC -p tcp -m tcp -j DNAT --to-destination 10.244.3.24:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -j KUBE-SEP-UBOJ6DEUKSFU7YBC</code></pre><h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><p>iptables  -t nat</p><h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><strong>loadBalancer 和 nodePort 其实是同一种方式。区别在于loadBalancer 比 nodePort多了以步，就是可以调用cloud provider 去创建LB来向节点导流</strong></p><p><img src="https://cntsp.github.io/medias/contents/20.png" alt=""></p><h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h2><p><strong>这种类型的 Service 通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容(例如：<code>harbor.bwingame8.com</code>)。ExternalName Service 是 Service 的特例，它没有selector，也没有定义任何的端口和 Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务。</strong></p><pre class=" language-bash"><code class="language-bash">kind: ServiceapiVersion: v1metadata:  name: my-service-1  namespace: defaultspec:  type: ExternalName  externalName: my.database.example.com</code></pre><p><strong>当查询主机 my-service.defalut.svc.cluster.local(SVC_NAME.NAMESPACE.svc.cluster.local)时，集群的DNS服务将返回一个值my.database.example.com的CNAME 记录。访问这个服务的工作方式和其它的相同，唯一不同的是重定向发生在DNS层，而且不会进行代理或转发</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-Daemonset-控制器</title>
      <link href="/2019/11/28/kubenetes-Daemonset-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/28/kubenetes-Daemonset-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-DaemonSet"><a href="#什么是-DaemonSet" class="headerlink" title="什么是 DaemonSet"></a>什么是 DaemonSet</h2><p>DaemonSet 确保全部(或者一些)Node上运行一个Pod的副本。当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod。</p><p>DaemonSet 的典型应用场景有：</p><p>（1）运行集群存储daemon，例如在每个Node上运行  glusterd、ceph。</p><p>（2）在每个Node上运行日志收集 daemon，例如 fluentd、logstash。</p><p>   (3)  在每个Node上运行监控 daemon，例如Prometheus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> daemonset<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1</code></pre><p>下面我们通过 kube-flannel-ds  这个 daemonset 来学习一下 DaemonSet。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel<span class="token punctuation">-</span>ds<span class="token punctuation">-</span>amd64  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">tier</span><span class="token punctuation">:</span> node    <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> node        <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">affinity</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>          <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>            <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> beta.kubernetes.io/os                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                      <span class="token punctuation">-</span> linux                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> beta.kubernetes.io/arch                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                      <span class="token punctuation">-</span> amd64      <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists        <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> flannel      <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install<span class="token punctuation">-</span>cni        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/coreos/flannel<span class="token punctuation">:</span>v0.11.0<span class="token punctuation">-</span>amd64        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> cp        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span>f        <span class="token punctuation">-</span> /etc/kube<span class="token punctuation">-</span>flannel/cni<span class="token punctuation">-</span>conf.json        <span class="token punctuation">-</span> /etc/cni/net.d/10<span class="token punctuation">-</span>flannel.conflist        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cni          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/cni/net.d        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/kube<span class="token punctuation">-</span>flannel/      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/coreos/flannel<span class="token punctuation">:</span>v0.11.0<span class="token punctuation">-</span>amd64        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> /opt/bin/flanneld        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>ip<span class="token punctuation">-</span>masq        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kube<span class="token punctuation">-</span>subnet<span class="token punctuation">-</span>mgr        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>iface=em1        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"50Mi"</span>          <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"50Mi"</span>        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>          <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>          <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>            <span class="token key atrule">add</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"NET_ADMIN"</span><span class="token punctuation">]</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAME          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAMESPACE          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /run/flannel        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/kube<span class="token punctuation">-</span>flannel/      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /run/flannel        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cni          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /etc/cni/net.d        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel<span class="token punctuation">-</span>cfg</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制器 </tag>
            
            <tag> kubenetes </tag>
            
            <tag> Daemonset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-JobCronJob-控制器</title>
      <link href="/2019/11/28/kubenetes-JobCronJob-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/28/kubenetes-JobCronJob-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</strong></p><p>特殊说明</p><ul><li><strong>spec.template 格式同Pod</strong></li><li><strong>RestartPolicy仅支持Never或OnFailure</strong></li><li><strong>单个Pod时，默认Pod成功运行后Job即结束</strong></li><li><strong><code>.spec.completions</code> 标志Job结束需要成功运行的Pod个数，默认为1</strong></li><li><strong><code>.spec.parallelism</code> 标志并行运行的Pod的个数，默认为1</strong></li><li><strong><code>spec.activeDeadlineSeconds</code> 标志这失败Pod的重试最大时间，超过这个时间不会继续重试</strong></li></ul><p><strong>Example</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      name<span class="token punctuation">:</span>pi    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pi        <span class="token key atrule">image</span><span class="token punctuation">:</span> perl        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"perl"</span><span class="token punctuation">,</span> <span class="token string">"-Mbignum=bpi"</span><span class="token punctuation">,</span> <span class="token string">"-wle"</span><span class="token punctuation">,</span> <span class="token string">"print bpi(2000)"</span><span class="token punctuation">]</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><!-- 查看日志，可以显示出答应的 2000 位 Π 值 --><h2 id="CronJob-Spec"><a href="#CronJob-Spec" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h2><ul><li>spec.template格式同Pod</li><li>RestartPolicy仅支持Nerver或OnFailure</li><li>单个Pod时，默认Pod成功运行后Job即结束</li><li><code>.spec.completions</code>标志Job结束需要成功运行的Pod的个数，默认为1</li><li><code>.spec.parallelism</code>标志并运行的Pod的个数，默认为1</li><li><code>spec.activeDeadlineSeconds</code>标志失败Pod的重试最大时间，超过这个时间不会继续重试</li></ul><h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p><strong>Cron Job管理基于时间的Job,即：</strong></p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p>使用条件： 当前使用的 Kubernetes 集群（&gt;=1.8版本）（对CronJob）</p><p>典型的用法如下所示：</p><ul><li>在给定的时间点调度Job运行</li><li>周期性运行的Job，例如：数据库备份、发送邮件</li></ul><h2 id="CronJob-Spec-1"><a href="#CronJob-Spec-1" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h2><ul><li><p><strong><code>.spec.schedule</code>:调度，必须字段，指定任务运行周期，格式同Cron</strong></p></li><li><p><strong><code>.spec.jobTemplate</code>：Job模板，必须自动，指定需要运行的任务，格式同Job</strong></p></li><li><p><strong><code>.spec.startingDeadlineSeconds</code>: 启动Job的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的Job将被认为是失败的。如果没有指定，则没有期限</strong></p></li><li><p><strong><code>.spec.concurrencyPolicy</code>:并发策略，该字段也是可选的。它制定了如果处理被 Cron Job创建的JOb的并发执行，只允许下面策略中的一种：</strong></p><ul><li><p><code>Allow</code>(默认)：允许并发运行Job</p></li><li><p><code>Forbid</code>: 禁止并发运行，如果前一个还没有完成，则直接跳过个</p></li><li><p><code>Replace</code>：取消当前正在运行的 Job,用一个新的来替换</p></li></ul><p><strong>注意，当前策略只能应用于同一个Cron Job创建的Job。如果存在多个Cron Job,它们创建的Job之间总是允许并发运行。</strong></p></li><li><p><strong><code>.spec.suspend</code>：挂起，该字段也是可选的。如果设置为<code>true</code>，后续所有执行都会被挂起。它对已经开始执行的Job不起作用。默认值为<code>false</code></strong>。</p></li><li><p><strong><code>.spec.successfulJobsHistoryLimit</code>和<code>.spec.failedJobsHistoryLimit</code>:历史限制，是可以选的字段。它们制定了可以保留多少完成和失败的Job。默认情况下，他们分别设置为<code>3</code>和<code>1</code>.设置限制的值为<code>0</code>,相关类型的Job完成后将不会被保留。</strong></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJobmetadata：  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"*/1 * * * *"</span>  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">template</span><span class="token punctuation">:</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>          <span class="token key atrule">containers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello            <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox            <span class="token key atrule">args</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> /bin/sh            <span class="token punctuation">-</span> <span class="token punctuation">-</span>c            <span class="token punctuation">-</span> date; echo Hello from the Kubernetes cluster          <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure</code></pre><pre class=" language-shell"><code class="language-shell">[root@k8s-master ceshi]# kubectl get cronjobNAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGEhello   */1 * * * *   False     0        34s             74s[root@k8s-master ceshi]# kubectl get jobNAME               COMPLETIONS   DURATION   AGEhello-1574992740   1/1           7s         74shello-1574992800   1/1           6s         14s[root@k8s-master ceshi]# kubectl get podNAME                               READY   STATUS      RESTARTS   AGEdaemonset-example-dkw6c            1/1     Running     0          12hdaemonset-example-zhqwq            1/1     Running     0          12hhello-1574992740-b6hhs             0/1     Completed   0          117shello-1574992800-7tcnv             0/1     Completed   0          57s[root@k8s-master ceshi]# kubectl logs hello-1574992740-b6hhsFri Nov 29 01:59:12 UTC 2019Hello from the Kubernetes cluster[root@k8s-master ceshi]# kubectl delete cronjob hellocronjob.batch "hello" deleted[root@k8s-master ceshi]# kubectl get cronjobNo resources found.[root@k8s-master ceshi]# kubectl get podNAME                               READY   STATUS    RESTARTS   AGEdaemonset-example-dkw6c            1/1     Running   0          12hdaemonset-example-zhqwq            1/1     Running   0          12h# 注意，删除 cronjob 的时候不会自动删除job，这些 job 可以用 kubectl delete job来删除$ kubectl delete cronjob hello</code></pre><h2 id="CrondJob本身的一些限制"><a href="#CrondJob本身的一些限制" class="headerlink" title="CrondJob本身的一些限制"></a>CrondJob本身的一些限制</h2><p><strong>创建Job操作应该是幂等的</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制器 </tag>
            
            <tag> kubenetes </tag>
            
            <tag> JobCronJob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-Deployment控制器</title>
      <link href="/2019/11/26/kubernetes-Deployment-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/26/kubernetes-Deployment-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RS-与-RC-与-Deployment-关联"><a href="#RS-与-RC-与-Deployment-关联" class="headerlink" title="RS 与 RC 与 Deployment 关联"></a>RS 与 RC 与 Deployment 关联</h2><p><strong>RC （ReplicationController）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替换；而如果异常多出来的容器也会自动回收</strong></p><p><strong>Kubernetes 官方建议使用 RS （ReplicaSet）替代 RC (ReplicationController) 进行部署，RS跟RC没有本质的不同，只是名字不一样，并且RS支持集合式的selector</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicaSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend      <span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>nginxv1          <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1          <span class="token key atrule">env</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GET_HOSTS_FROM            <span class="token key atrule">value</span><span class="token punctuation">:</span> dns          <span class="token key atrule">ports</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><h2 id="RS-与-Deployment-的关联"><a href="#RS-与-Deployment-的关联" class="headerlink" title="RS 与 Deployment 的关联"></a>RS 与 Deployment 的关联</h2><p><img src="./images/13.png" alt="RS-Deployment"></p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><strong>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</strong></p><ul><li><strong>定义Deployment创建Pod和ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容缩容</strong></li><li><strong>暂停和继续Deployment</strong></li></ul><p><strong>I 部署一个简单的Nginx应用</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><pre class=" language-bash"><code class="language-bash">kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record<span class="token comment" spellcheck="true">## --record参数可以记录命令，我们可以很方便的查看每次 revision 的变化</span></code></pre><p><strong>II 扩容</strong></p><pre class=" language-bash"><code class="language-bash">kubectl scale deployment nginx-deployment --replicas 10</code></pre><p><strong>III、如果集群支持horizontal pod autoscaling的话，还可以为Deployment设置自动扩展</strong></p><pre class=" language-bash"><code class="language-bash">kubectl autoscale deployment nginx-deployment --min-10 --max<span class="token operator">=</span>15 --cpu<span class="token operator">=</span>percent<span class="token operator">=</span>80</code></pre><p><strong>IV、更新镜像也比较简单</strong></p><pre class=" language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/nginx-deployment nginx<span class="token operator">=</span>nginx:1.9.1</code></pre><p><strong>V、回滚</strong></p><pre class=" language-bash"><code class="language-bash">kubectl rollout undo deployment/nginx-deployment</code></pre><h2 id="更新-Deployment"><a href="#更新-Deployment" class="headerlink" title="更新 Deployment"></a>更新 Deployment</h2><!--注意：Deployment 的 rollout 当且仅当 Deployment 的pod template（例如： spec.template）中的label更新或者镜像更改时被触发。其它更新，例如扩容Deployment 不会触发--><h2 id="Deployment-更新策略"><a href="#Deployment-更新策略" class="headerlink" title="Deployment 更新策略"></a>Deployment 更新策略</h2><p>Deployment 可以保证在升级时只有一定数量的 Pod 是down的。默认的，它会确保至少有比期望的Pod数量少一个是up状态(最多一个不可用)</p><p>Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的Pod数量多一个的Pod是up的(最多一个surge)</p><p>现在最新的Kubernetes版本中，将从1-1变成25%-25%</p><pre class=" language-bash"><code class="language-bash">$ kubectl describe deployment</code></pre><h2 id="Rollover（多个rollout并行）"><a href="#Rollover（多个rollout并行）" class="headerlink" title="Rollover（多个rollout并行）"></a>Rollover（多个rollout并行）</h2><p><strong>假如您创建了一个有5个 nginx:1.7.9 replica的Deployment，但是当还只有3个nginx:1.7.9的replica创建出来的时候您就开始更新含有5个nginx:1.9.1replica的Deployment。这种情况下，Deployment会立即杀掉已经创建的3个nginx:1.7.9的Pod,并开始创建nginx:1.9.1的Pod。它不会等到所有的5个nginx:1.7.9的Pod都创建完成后才开始改变航道。</strong></p><h2 id="回退Deployment"><a href="#回退Deployment" class="headerlink" title="回退Deployment"></a>回退Deployment</h2><!--只要 Deployment 的rollout 被触发就会创建一个 revision。也就是说当且仅当 Deployment 的 Pod template（如`.spec.template`）被更改，例如更新 template 中的 label 和容器镜像时，就会创建出一个新的 revision。其它的更新，比如扩容 Deployment 不会创建 revision --因此我们可以很方便的手动或者自动扩容。这意味着当您回退到历史revision时，只有 Deployment 中的 Pod template 部分才会回退 --><pre class=" language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/nginx-deployment nginx<span class="token operator">=</span>nginx:1.9.1kubectl rollout status deployments nginx-deploymentkubectl get podskubectl rollout <span class="token function">history</span> deployment/nginx-deploymentkubectl rollout undo deployment/nginx-deploymentkubectl rollout undo deployment/nginx-deployment --to-revison<span class="token operator">=</span>2  <span class="token comment" spellcheck="true">## 可以使用 --revision参数指定某个历史版本</span>kubectl rollout pause deployment/nginx-deployment  <span class="token comment" spellcheck="true">## 暂停 deployment 的更新</span></code></pre><p><strong>您可以用kubectl rollout status 命令查看 Deployment 是否完成。如果rollout 成功完成，kubectl rollout status 将返回一个0值的 Exit Code</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl rollout status deploy/nginxWaiting <span class="token keyword">for</span> rollout to finish: 2 of 3 updated replicas are available<span class="token punctuation">..</span>.deployment <span class="token string">"nginx"</span> successfully rolled out$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0</code></pre><h2 id="清理-Policy"><a href="#清理-Policy" class="headerlink" title="清理 Policy"></a>清理 Policy</h2><p><strong>您可以通过设置<code>.spec.revisonHistoryLimit</code>项来指定 deployment 最多保留多少revision历史记录。默认会保留所有的 revision；如果将该项设置为0，Deployment就不允许回退了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 控制器 </tag>
            
            <tag> deployment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Pod-控制器</title>
      <link href="/2019/11/25/Kubernetes-Pod-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/25/Kubernetes-Pod-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是控制器"><a href="#什么是控制器" class="headerlink" title="什么是控制器"></a>什么是控制器</h2><p>Kubernetes 中内建了很多controller(控制器)，这些相当于一个状态机，用来控制 Pod 的具体状态和行为</p><h2 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h2><ul><li><strong>ReplicationController 和 ReplicaSet</strong></li><li><strong>Deployment</strong></li><li><strong>DaemonSet</strong></li><li><strong>StateFulSet</strong></li><li><strong>Job/Cronjob</strong></li><li><strong>Horizontal Pod Autoscaling</strong></li></ul><p><strong>ReplicationController 和 ReplicaSet</strong></p><p><strong>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；</strong></p><p><strong>在新版本的Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController. ReplicaSet跟 ReplicationController 没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector；</strong></p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><strong>Deployment为 Pod 和 ReplicaSet 提供了一个声明式定义(declarative)方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</strong></p><ul><li><strong>定义 Deployment 来创建 Pod 和 ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容和缩容</strong></li><li><strong>暂停和继续 Deployment</strong></li></ul><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p><strong>DaemonSet 确保全部 (或者一些) Node上运行一个 Pod 的副本，当有 Node 加入集群时，也会为他们新增一个Pod,当有Node从集群移除时，这些 Pod 也会被撤回收，删除 DaemonSet 将会删除它创建的所有Pod</strong></p><ul><li>运行集群存储daemon，例如在每个Node上运行glusterd、ceph</li><li>在每个Node上运行日志收集daemon,例如fluentd、logstash</li><li>在每个Node上运行监控daemon，例如Promethus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond</li></ul><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><ul><li>job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</li></ul><h2 id="Cronjob"><a href="#Cronjob" class="headerlink" title="Cronjob"></a>Cronjob</h2><p>cronjob 管理基于时间的job,即：</p><ul><li>在给定时间点只运行一次</li><li>周期地在给定时间点运行</li></ul><p>使用前提条件：<strong>当前使用的kubernetes集群，版本&gt;=1.8(对Cronjob)。对于先前版本的集群，版本&lt;1.8，启动APIServer时，通过传递选项 –runtime-config=batch/v2alpha1=true 可以开启batch/v2alpha1 API</strong></p><p>典型用法如下所示：</p><ul><li>在给定的时间点调度job运行</li><li>创建周期性运行的job，例如：数据库备份、发送邮件</li></ul><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 作为 Controller  为 Pod 提供唯一的标识。它可以保证部署和scale的顺序</p><p>StatefulSet是为了解决有状态服务的问题(对应Deployment和ReplicaSets是为无状态服务而设计)，其应用场景包括：</p><ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后器PodName和HostName不变，基于Headless Service（即没有Cluster IP的 Service）来实现</li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义好的顺序依次进行(即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态)，基于init containers来实现</li><li>有序收缩，有序删除(即从N-1到0)</li></ul><h2 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h2><p>应用的资源使用率通常都有高峰和低估的时候，如果削峰填谷，提高集群的整体资源利用率，让service中的Pod个数自动调整呢？这就有来与Horizontal Pod Autoscaling了，顾名思义，使 Pod 水平缩放</p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> 控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-pod-探测</title>
      <link href="/2019/11/25/Kubernetes-pod-%E6%8E%A2%E6%B5%8B/"/>
      <url>/2019/11/25/Kubernetes-pod-%E6%8E%A2%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="init-模板"><a href="#init-模板" class="headerlink" title="init 模板"></a>init 模板</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: myapp-pod  labels:    app: myappspec:  containers:  - name: myapp-container    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'echo The app is running &amp;&amp; sleep 3600'</span><span class="token punctuation">]</span>  initContainers:  - name: init-myservice    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'until nslookup myservice; do echo waiting for myservice; sleep 2;done;'</span><span class="token punctuation">]</span>  - name: init-mydb    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span><span class="token punctuation">]</span></code></pre><pre class=" language-bash"><code class="language-bash">kind: ServiceapiVersion: v1metadata:  name: myservicespec:  ports:    - protocol: TCP      port: 80      targetPort: 19376--kind: ServiceapiVersion: v1metadata:  name: mydbspec:  ports:    - protocol: TCP      port: 80      targetPort: 19377</code></pre><h2 id="检测探针-就绪检测"><a href="#检测探针-就绪检测" class="headerlink" title="检测探针-就绪检测"></a>检测探针-就绪检测</h2><p><strong>readinessProbe-httpget</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: readiness-httpget-pod  namespace: defaultspec:  containers:  - name: readiness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    readinessProbe:      httpGet:        port: 80        path: /index1.html      initialDelaySeconds: 1      periodSecond: 3</code></pre><h2 id="检测探针-存活检测"><a href="#检测探针-存活检测" class="headerlink" title="检测探针-存活检测"></a>检测探针-存活检测</h2><p><strong>livenessProbe-exec</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-exec-pod  namespace: defaultspec:  containers:  - name: liveness-exec-container    image: harbor.bwingame8.com/library/busybox:v1    imagePullPolicy: IfNotPresent    command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"touch /tmp/live ; sleep 60; rm -rf /tmp/live; sleep 3600"</span><span class="token punctuation">]</span>    livenessProbe:      exec:        command: <span class="token punctuation">[</span><span class="token string">"test"</span>,<span class="token string">"-e"</span>,<span class="token string">"/tmp/live"</span><span class="token punctuation">]</span>      initialDelaySeconds: 1      periodSeconds: 3</code></pre><p><strong>livenessProbe-httpget</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    livenessProbe:      httpGet:        port: http        path: /index.html      initialDelaySeconds: 1      periodSeconds: 3      timeoutSeconds: 10</code></pre><p><strong>livenessProbe-tcp</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: probe-tcpspec:  containers:  - name: nginx    image: harbor.bwingame8.com/library/myapp:v1    livenessProbe:      initialDelaySeconds: 5      timeoutSeconds: 1      tcpSocket:        port: 80</code></pre><h2 id="检测探针-就绪-存活检测"><a href="#检测探针-就绪-存活检测" class="headerlink" title="检测探针-就绪+存活检测"></a>检测探针-就绪+存活检测</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    readinessProbe:      httpGet:        port: 80        path: /index1.html      initialDelaySeconds: 1      periodSecond: 3    livenessProbe:      httpGet:        port: http        path: /index.html      initialDelaySeconds: 1      periodSeconds: 3      timeoutSeconds: 10</code></pre><p><strong>用户通过 Liveness 探测可以告诉 kubernetes 什么时候通过重启容器实现自愈；Readiness 探测则是告诉 kubernetes 什么时候可以将容器加入到 Service 负载均衡池中，对外客户端提供服务</strong></p><p><strong>存活检测：如果不是存活状态，那么重启Pod.</strong></p><p><strong>就绪检测： 如果不是就绪状态，那么Pod的状态不是READY</strong></p><h2 id="启动、退出动作"><a href="#启动、退出动作" class="headerlink" title="启动、退出动作"></a>启动、退出动作</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: lifecycle-demospec:  containers:  - name: lifecycle-demo-container    image: nginx    lifecycle:      postStart:        exec:          command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"echo hello from the postStart handler > /usr/share/message"</span><span class="token punctuation">]</span>      preStop:        exec:          command: <span class="token punctuation">[</span><span class="token string">"/usr/sbin/nginx"</span>, <span class="token string">"-s"</span>, <span class="token string">"quit"</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> 探测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中常用字段</title>
      <link href="/2019/11/24/k8s%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5/"/>
      <url>/2019/11/24/k8s%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>必须存在的属性</strong></p><table>     <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>version</td><td>String</td><td>这里是指的是K8S API的版本，目前基本上是v1,可以用kubectl api-version命令查询</td></tr>    <tr><td>king</td><td>String</td><td>这里指的是yaml文件定义的资源类型和角色，比如： Pod</td></tr>    <tr><td>metadata</td><td>Object</td><td>元数据对象，固定值就写metadata</td></tr>    <tr><td>metadata.name</td><td>String</td><td>元数据对象的名字，这里由我们编写，比如命名Pod的名字</td></tr>    <tr><td>metadata.namespace</td><td>String</td><td>元数据对象的命名空间，由我们自身定义</td></tr>    <tr><td>Spec</td><td>Object</td><td>详细定义对象，固定值就写Spec</td></tr>    <tr><td>spec.containers[]</td><td>list</td><td>这里是Spec对象的容器列表定义，是个列表</td> </tr>    <tr><td>spec.containers[].name</td><td>String</td><td>这里定义容器的名字</td></tr>    <tr><td>spec.containers[].image</td><td>String</td><td>这里定义要用到的镜像名称</td></tr></table><p><strong>主要的对象</strong></p><table>    <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>spec.containers[].name</td><td>String</td><td>定义容器的名字</td></tr>    <tr><td>spec.containers[].image</td><td>String</td><td>定义要用到的镜像名称</td></tr>    <tr><td>spec.containers[].imagePullPolicy</td><td>String</td><td>定义镜像拉取策略，有Always、Never、ifNotPrent三个值可选(1) Always:意思是每次都尝试重新拉取镜像（2）Never:表示仅使用本地镜像（3）ifNotPresent:如果本地有镜像就使用本地镜像，没有就拉取在线镜像。上面三个值都没有设置的话，默认是Always</td></tr>    <tr><td>spec.containers[].command[]</td><td>List</td><td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令。</td></tr>    <tr><td>spec.containers[].args[]</td><td>List</td><td>指定容器启动命令参数，因为是数组可以指定多个。</td></tr>    <tr><td>spec.containers[].workingDir</td><td>String</td><td>指定容器的工作目录</td></tr>    <tr><td>spec.containers[].volumeMounts[]</td><td>List</td><td>指定容器内部的存储卷配置</td></tr>    <tr><td>spec.containers[].volumeMounts[].name</td><td>String</td><td>指定可以被容器挂载的存储卷的名称</td></tr>    <tr><td>spec.containers[].volumeMounts[].mountPath</td><td>String</td><td>指定可以被容器挂载的存储卷的路径</td></tr>    <tr><td>spec.containers[].volumeMounts[].readOnly</td><td>String</td><td>设置存储卷路径的读写模式，ture或者false,默认为读写模式</td></tr>    <tr><td>spec.containers[].ports[]</td><td>List</td><td>指定容器需要用到的端口列表</td</tr>    <tr><td>spec.containers[].ports[].name</td><td>String</td><td>指定端口名称</td></tr>    <tr><td>spec.containers[].ports[].containerPort</td><td>String</td><td>指定容器需要监听的端口号</td></tr>    <tr><td>spec.containers[].ports[].hostPort</td><td>String</td><td>指定容器所在主机需要监听的端口号，默认跟上面containerPort相同，注意设置了hostPort同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同，这样会冲突)</td></tr>    <tr><td>spec.containers[].ports[].protocol</td><td>String/td><td>指定端口协议，支持TCP和UDP，默认值为TCP</td></tr>    <tr><td>spec.containers[].env[]</td><td>List</td><td>指定容器运行前需设置的环境变量列表</td></tr>    <tr><td>spec.containers[].env[].name</td><td>String</td><td>指定环境变量名称</td></tr>       <tr><td>spec.containers[].env[].value</td><td>String</td><td>指定环境变量值</td></tr>    <tr><td>spec.containers[].resources</td><td>Object</td><td>指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td></tr>    <tr><td>spec.containers[].resources.limits</td><td>Object</td><td>指定设置容器运行时资源的运行上限</td></tr>    <tr><td>spec.containers[].resources.cpu</td><td>String</td><td>指定CPU的限制，单位为core数，将用于docker run --cpu-shares参数(这里前面文章Pod资源限制有讲过)</td></tr>    <tr><td>spec.containers[].resources.limits.memory</td><td>String</td><td>指定MEM内存的限制，单位为MIB、GiB</td></tr>    <tr><td>spec.containers[].resources.requests</td><td>Object</td><td>指定容器启动和调度时的限制设置</td></tr>    <tr><td>spec.containers[].resources.requests.cpu</td><td>String</td><td>CPU请求数，单位为core数，容器启动时初始可用数量</td></tr>    <tr><td>spec.containers[].resources.request.memory</td><td>String</td><td>内存请求，单位MIB、GiB,容器启动的初始化可用数量</td></tr></table><p><strong>额外的参数项</strong></p><table>    <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>spec.restartPoliy</td><td>String</td><td>定义Pod的重启策略，可选值为Always、OnFailure，默认值为Always。1 Always： Pod一旦终止运行，则无论容器是如何终止的，kubelet服务都将重启该Pod.2 OnFailure：只有Pod以非零退出码终止时，kubelet才会重启该容器。如果容器正常结束(退出码为0)，则kubelet将不会重启它。3.Never: Pod终止后，kubelet将退出码报告给Master，不会重启该Pod</td></tr>    <tr><td>spec.nodeSelector</td><td>Object</td><td>定义Node的Label过滤标签，以key:value格式指定</td></tr>    <tr><td>spec.imagePullSecrets</td><td>Object</td><td>定义pull镜像时使用secret名称，以name:secretkey格式指定</td></tr>    <tr><td>spec.hostNetwork</td><td>Boolean</td><td>定义是否使用主机网络模式，默认值为false.设置true表示使用宿主机网络，不适用docker网桥，同时设置了true将无法在同一台宿主机上启动第二个副本。</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 字段属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yaml语法</title>
      <link href="/2019/11/24/Yaml%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/11/24/Yaml%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><p><strong>是一个可读性高，用来表达数据序列的格式。YAML 的意思其实是： 仍是一种标记语言，但为了强调这种语言以数据作为中心，而不是以标记语言为重点</strong></p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>缩进时不允许使用Tab键，只允许使用空格</li><li>缩进的空格数据目不重要，只要相同层级的元素左侧对齐即可</li><li># 标识注释，从这个字符一直到行尾，都会被解释器忽略</li></ul><h1 id="YAML支持的数据结构"><a href="#YAML支持的数据结构" class="headerlink" title="YAML支持的数据结构"></a>YAML支持的数据结构</h1><ul><li>对象：键值对的集合，又称为映射(mapping)/哈希(hashes)/字典(dictionary)</li><li>数组：一组按次序排列的值，又称为序列(sequence)/列表(list)</li><li>纯量(scalars)：单个的、不可再分的值</li></ul><h2 id="对象类型：对象的一组键值对，使用冒号结构表示"><a href="#对象类型：对象的一组键值对，使用冒号结构表示" class="headerlink" title="对象类型：对象的一组键值对，使用冒号结构表示"></a>对象类型：对象的一组键值对，使用冒号结构表示</h2><pre class=" language-bash"><code class="language-bash">name: Steveage: 18</code></pre><h2 id="Yaml也允许另一种写法，将所有键值对写成一个行内对象"><a href="#Yaml也允许另一种写法，将所有键值对写成一个行内对象" class="headerlink" title="Yaml也允许另一种写法，将所有键值对写成一个行内对象"></a>Yaml也允许另一种写法，将所有键值对写成一个行内对象</h2><pre class=" language-bash"><code class="language-bash">hash: <span class="token punctuation">{</span> name: Steve, age: 18 <span class="token punctuation">}</span></code></pre><h2 id="数组类型：一组连词线开头的行，构成一个数组"><a href="#数组类型：一组连词线开头的行，构成一个数组" class="headerlink" title="数组类型：一组连词线开头的行，构成一个数组"></a>数组类型：一组连词线开头的行，构成一个数组</h2><pre class=" language-bash"><code class="language-bash">animal- Cat- Dog</code></pre><h2 id="数组也可以采用行内表示法"><a href="#数组也可以采用行内表示法" class="headerlink" title="数组也可以采用行内表示法"></a>数组也可以采用行内表示法</h2><pre class=" language-bash"><code class="language-bash">animal: <span class="token punctuation">[</span>Cat, Dog<span class="token punctuation">]</span></code></pre><h2 id="符合结构：对象和数组可以结合使用，形成符合结构"><a href="#符合结构：对象和数组可以结合使用，形成符合结构" class="headerlink" title="符合结构：对象和数组可以结合使用，形成符合结构"></a>符合结构：对象和数组可以结合使用，形成符合结构</h2><pre class=" language-bash"><code class="language-bash">1 languages:2 - Ruby3 - Perl4 - Python5 websites:6 YAML: yaml.org7 Ruby: ruby-lang.org8 Python: python.org9 Perl: user.perl.org</code></pre><h2 id="纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量"><a href="#纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量" class="headerlink" title="纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量"></a>纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量</h2><pre class=" language-bash"><code class="language-bash">1 字符串 布尔值 整数 浮点数 Null2 时间 日期数值直接以字面量的形式表示number: 12.30布尔值用true和false表示isSet: <span class="token boolean">true</span>null用 ~ 表示parent: ~时间采用 ISO8601模式iso8601: 2001-12-14t21:59:43.10-05:00日期采用符合 iso8601 格式的年、月】日表示date: 1976-07-31YAML 允许使用两个感叹号，强制转换数据类型e: <span class="token operator">!</span><span class="token operator">!</span>str 123f: <span class="token operator">!</span><span class="token operator">!</span>str ture</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串默认不适用引号表示</p><pre class=" language-bash"><code class="language-bash">str: 这是一行字符串</code></pre><p>如果字符串之中包含空格或特殊字符，需要放在引号之中</p><pre class=" language-bash"><code class="language-bash">str: <span class="token string">'内容： 字符串'</span></code></pre><p>单引号和双引号都可以使用，双引号不会对特殊字符转义</p><pre class=" language-bash"><code class="language-bash">s1: <span class="token string">'内容\n字符串'</span>s2: <span class="token string">"内容\n字符串"</span></code></pre><p>单引号之中如果还有单引号，必须连续使用两个单引号转义</p><pre class=" language-bash"><code class="language-bash">str: <span class="token string">'labor'</span><span class="token string">'s day'</span></code></pre><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会转为空格</p><pre class=" language-bash"><code class="language-bash">str: 这是一段  多行  字符串</code></pre><p>多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行</p><pre class=" language-bash"><code class="language-bash">this: <span class="token operator">|</span>FooBarthat:<span class="token operator">></span>FooBar</code></pre><p><strong>+</strong> 表示保留文字块末尾的换行， <strong>-</strong> 表示删除字符串末尾的换行</p><pre class=" language-bash"><code class="language-bash">s1: <span class="token operator">|</span>  Foos2: <span class="token operator">|</span>+  Foos3: <span class="token operator">|</span>-  Foo</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> yaml语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm搭建k8s三节点集群</title>
      <link href="/2019/11/24/kubeadm%E6%90%AD%E5%BB%BAk8s%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/"/>
      <url>/2019/11/24/kubeadm%E6%90%AD%E5%BB%BAk8s%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubeadm-部署3节点kubernetes-1-15-墙外环境"><a href="#Kubeadm-部署3节点kubernetes-1-15-墙外环境" class="headerlink" title="Kubeadm 部署3节点kubernetes 1.15(墙外环境)"></a>Kubeadm 部署3节点kubernetes 1.15(墙外环境)</h2><p>国内环境请参考：<br>(k8s第一步：)[<a href="https://www.cnblogs.com/fanqisoft/p/11498049.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/11498049.html]</a><br>(k8s第二步：)[<a href="https://www.cnblogs.com/fanqisoft/p/11498217.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/11498217.html]</a><br>kubeadm是Kubernetes官方提供的用于快速安装Kubernetes集群的工具，伴随Kubernetes每个版本的发布都会同步更新，kubeadm会对集群配置方面的一些实践做调整，通过实验kubeadm可以学习到Kubernetes官方在集群配置上一些新的最佳实践。<br>已经发布的Kubernetes 1.15中，kubeadm对HA集群的配置已经达到beta可用，说明kubeadm距离生产环境中可用的距离越来越近了。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>三节点分别对应设置系统主机名</p><pre class=" language-bash"><code class="language-bash">hostnamectl set-hostname k8s-masterhostnamectl set-hostname k8s-node1hostnamectl set-hostname k8s-node2</code></pre><p>三节点都添加hosts解析</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">>></span> /etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF192.168.1.85   k8s-master192.168.1.38   k8s-node1192.168.1.119  k8s-node2EOF</span></code></pre><p>三节点都安装依赖包</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token function">wget</span> vim net-tools <span class="token function">git</span></code></pre><p>三节点都设置防火墙为Iptables 并设置空规则</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld <span class="token operator">&amp;&amp;</span> systemctl disable firewalldyum -y <span class="token function">install</span> iptables-services <span class="token operator">&amp;&amp;</span> systemctl start iptables <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> iptables <span class="token operator">&amp;&amp;</span> iptables -F <span class="token operator">&amp;&amp;</span> <span class="token function">service</span> iptalbes save</code></pre><p>三节点都关闭swap虚拟内存和禁用SELINUX</p><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'/ swap / s/^\(.*\)$/#\1/g'</span> /etc/fstabsetenforce 0 <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'s/^SELINUX=.*/SELINUX=disabled/g'</span>  /etc/selinux/config</code></pre><p>三节点都调整内核参数，对于k8s</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/sysctl.d/kubernetes.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOFnet.bridge.bridge-nf-call-iptables=1    # 将桥接的IPv4流量传递到iptables的链中net.bridge.bridge-nf-call-ip6tables=1   # 将桥接的IPv4流量传递到iptables的链中net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它vm.overcommit_memory=1 # 不检查物理内存是否够用vm.panic_on_oom=0 # 开启 OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1   # 禁用ipv6net.netfilter.nf_conntrack_max=2310720EOF</span>执行下面命令让上面的文件生效sysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><p>三节点都设置rsyslogd和systemd journald</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /var/log/journal <span class="token comment" spellcheck="true"># 持久化保存日志的目录</span><span class="token function">mkdir</span> /etc/systemd/journald.conf.d<span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/journald.conf.d/99-prophet.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Journal]# 持久化保存到磁盘Storage=persistent# 压缩历史日志Compress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000# 最大占用空间 10GSystemMaxUse=10G# 单日志文件最大 200MSystemMaxFileSize=200M# 日志保存时间 2 周MaxRetentionSec=2week# 不将日志转发到 syslogForwardToSyslog=noEOF</span>重启 systemd-journald 服务systemctl restart systemd-journald</code></pre><p>我的三节点是远程机房，不宜重启，暂时没有升级内核为4.44.还是3.10内核，由于自己测试环境，自己玩就没有做升级内核的操作，对于在虚拟机上搭建的集群，可以升级内核，按照下面的操作进行，设置后，需要重启。重启后使用uname -r查看内核版本。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>----升级系统内核为4.44Centos7.x系统自带的3.10.x内核存在一些Bugs,导致运行的Docker、Kubernetes不稳定，例如：rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="token comment" spellcheck="true"># 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次</span>yum --enablerepo<span class="token operator">=</span>elrepo-kernel <span class="token function">install</span> -y kernel-lt<span class="token comment" spellcheck="true"># 设置开机从新内核启动</span>grub2-set-default <span class="token string">"CentOS Linux (4.4.202-1.el7.elrepo.x86_64) 7 (Core)"</span><span class="token comment" spellcheck="true"># 重启后安装内核源文件</span>yum --enablerepo<span class="token operator">=</span>elrepo-kernel <span class="token function">install</span> kernel-lt-devel-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span> kernel-lt-headers-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span>----<span class="token operator">></span></code></pre><p>kube-proxy(主要解决SVC与POD之间的调度关系)开启ipvs(负载均衡能力更强)的前置条件<br>为了使用ipvs，而不是iptables来进行路由规则的创建,需要安装一些ipvs的依赖<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> ipset ipvsadm</code></pre><p>三节点都执行，由于ipvs已经加入到了内核的主干，所以为kube-proxy开启ipvs的前提需要加载以下的内核模块：</p><pre class=" language-bash"><code class="language-bash">modprobe br_netfilter<span class="token function">cat</span> <span class="token operator">></span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&lt;&lt;</span><span class="token string">EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF</span><span class="token function">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> lsmod <span class="token operator">|</span> <span class="token function">grep</span> -e ip_vs -e nf_conntrack_ipv4</code></pre><p>上面脚本创建了的/etc/sysconfig/modules/ipvs.modules文件，保证在节点重启后能自动加载所需模块。 使用lsmod | grep -e ip_vs -e nf_conntrack_ipv4命令查看是否已经正确加载所需的内核模块。<br>要确保各个节点上已经安装了ipset软件包 yum -y install ipset ,为了便于查看ipvs的代理规则，最好还要确认是否安装了管理工具ipvsadm, yum -y install ipvsadm。<br>如果以上前提条件如果不满足，则即使kube-proxy的配置开启了ipvs模式，也会退回到iptables模式。<br>三节点都安装Docker<br>Kubernetes从1.6开始使用CRI(Container Runtime Interface)容器运行时接口。默认的容器运行时仍然是Docker，使用的是kubelet中内置dockershim CRI实现<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo--查看最新的docker版本，以k8s-master节点为例：--<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum list docker-ce.x86_64  --showduplicates |sort -r</span></code></pre><p>Kubernetes 1.15当前支持的docker版本列表是1.13.1, 17.03, 17.06, 17.09, 18.06, 18.09,这里在各节点安装docker的18.09.7版本。</p><pre class=" language-bash"><code class="language-bash">yum makecache fastyum <span class="token function">install</span> -y --setopt<span class="token operator">=</span>obsoletes<span class="token operator">=</span>0 \  docker-ce-18.09.7-3.el7 systemctl start docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><p>确认一下iptables filter表中FOWARD链的默认策略(pllicy)为ACCEPT。<br>三节点都执行(以k8s-node1为例：)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables -nvL</span>----省略--------Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT 0 packets, 0 bytes<span class="token punctuation">)</span> pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token function">source</span>               destination             0     0 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0               0     0 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED    0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  docker0 <span class="token operator">!</span>docker0  0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0    ----省略--------</code></pre><p>三节点都修改docker cgroup driver为systemd<br>根据文档CRI installation中的内容，对于使用systemd作为init system的Linux的发行版，使用systemd作为docker的cgroup driver可以确保服务器节点在资源紧张的情况更加稳定，因此这里修改各个节点上docker的cgroup driver为systemd。<br>创建或修改/etc/docker/daemon.json：    </p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/docker/daemon.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "exec-opts": ["native.cgroupdriver=systemd"]}EOF</span><span class="token function">mkdir</span> -p /etc/systemd/system/docker.service.d/</code></pre><p>三节点都重新加载docker配置文件，启动docker,设置开机自启动:</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reload <span class="token operator">&amp;&amp;</span> systemctl restart docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><p>可以查看docker安装信息,以k8s-node1为例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker info</span></code></pre><h2 id="第二步kubeadm安装部署K8S"><a href="#第二步kubeadm安装部署K8S" class="headerlink" title="第二步kubeadm安装部署K8S"></a>第二步kubeadm安装部署K8S</h2><p>使用Kubeadm部署Kubernetes<br>安装kubeadm和kubelet<br>三节点上都安装kubeadm 和kubelet,由于墙外环境，不需要修改官方K8S的yum源，就是用GOOGLE k8s.gcr源。墙内环境，需要用阿里云的yum源，或者指定自己搭建的企业级DOCKER Registry仓库harbor(要保证仓库中你已经上传这些组件的镜像哦)，在初始化的时候kubeadm init需要加入–image参数，或者在配置文件kubeadmin-config.yaml指定需要安装组件阿里云镜像的来源地址。</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo<span class="token punctuation">[</span>kubernetes<span class="token punctuation">]</span>name<span class="token operator">=</span>Kubernetesbaseurl<span class="token operator">=</span>https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled<span class="token operator">=</span>1gpgcheck<span class="token operator">=</span>1repo_gpgcheck<span class="token operator">=</span>1gpgkey<span class="token operator">=</span>https://packages.cloud.google.com/yum/doc/yum-key.gpg        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOF</code></pre><p>测试地址<a href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64是否可用，如果不可用需要科学上网。" target="_blank" rel="noopener">https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64是否可用，如果不可用需要科学上网。</a><br>由于我们墙外环境，所以就不存在科学上网了，哈哈哈<br>(我们省略这部，测试也没关系，会访问网页内容滴)</p><pre class=" language-bash"><code class="language-bash">curl https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</code></pre><p>三节点都安装kubelet-1.15.1、kubeadm-1.15.1、kubectl-1.15.1</p><pre class=" language-bash"><code class="language-bash">yum makecache fastyum <span class="token function">install</span> -y kubelet-1.15.1 kubeadm-1.15.1 kubectl-1.15.1</code></pre><p>从安装结果可以看出还安装了cri-tools, kubernetes-cni, socat三个依赖：</p><blockquote><ul><li>官方从Kubernetes 1.14开始将cni依赖升级到了0.7.5版本</li><li>socat是kubelet的依赖</li><li>cri-tools是CRI(Container Runtime Interface)容器运行时接口的命令行工具</li></ul></blockquote><p>由于kubelet需要和容器接口交互，启动我们的容器，而我们的k8s通过kubeadm安装出来以后都是以Pod的方式存在，也就是底层以容器的方式运行，所以kubelet一定要开机自启的，否则重启后我们k8s集群可能起不来。<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> kubelet.service</code></pre><p>初始化主节点k8s-master<br>使用 kubeadm config print init-defaults 可以打印集群初始化默认的使用的配置看一下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> <span class="token function">cd</span> /usr/local/install-k8s/core<span class="token punctuation">[</span>root@k8s-master core<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm config print init-defaults</span>apiVersion: kubeadm.k8s.io/v1beta2bootstrapTokens:- groups:  - system:bootstrappers:kubeadm:default-node-token  token: abcdef.0123456789abcdef  ttl: 24h0m0s  usages:  - signing  - authenticationkind: InitConfigurationlocalAPIEndpoint:  advertiseAddress: 1.2.3.4     <span class="token comment" spellcheck="true"># 默认为1.2.3.4修改为本机内网IP  192.168.1.85</span>  bindPort: 6443nodeRegistration:  criSocket: /var/run/dockershim.sock  name: k8s-master               taints:  - effect: NoSchedule    <span class="token comment" spellcheck="true"># master节点不负责pod的调度，也就是master节点不充当work节点的角色</span>    key: node-role.kubernetes.io/master---apiServer:  timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta2certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: <span class="token punctuation">{</span><span class="token punctuation">}</span>dns:  type: CoreDNSetcd:  local:    dataDir: /var/lib/etcdimageRepository: k8s.gcr.io      <span class="token comment" spellcheck="true"># 默认安装镜像组件拉取的镜像源仓库地址</span>kind: ClusterConfigurationkubernetesVersion: v1.16.0    <span class="token comment" spellcheck="true"># 注意：生成配置文件和我们要安装的k8s版本不同，需要为v1.15.1</span>networking:  dnsDomain: cluster.local  podSubnet: <span class="token string">"10.244.0.0/16"</span>      <span class="token comment" spellcheck="true"># 新增pod的网段,默认的配置文件是没有这个pod子网的，我们新增它，如果不新增，需要在初始化指定pod的子网段</span>  serviceSubnet: 10.96.0.0/12               <span class="token comment" spellcheck="true"># SVC的子网</span>scheduler: <span class="token punctuation">{</span><span class="token punctuation">}</span>---                                              <span class="token comment" spellcheck="true">#以下为新增修改为ipvs模式</span>apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: kubeProxyConfigurationfeatureGates:  SupportIPVSProxyMode: <span class="token boolean">true</span>mode: ipvs</code></pre><p>k8s-master1上执行，生成kubeadm初始化配置文件kubeadm-config.yaml</p><pre class=" language-bash"><code class="language-bash">kubeadm config print init-defaults <span class="token operator">></span> kubeadm-config.yaml</code></pre><p>使用上面生成配置文件在master节点上进行初始化，这个kubeadm-init.log日志记录着node节点加入集群中的方式，不过也可以通过命令找到这个加入集群方式的</p><pre class=" language-bash"><code class="language-bash">kubeadm init --config<span class="token operator">=</span>kubeadm-config.yaml --experimental-upload-certs <span class="token operator">|</span> <span class="token function">tee</span> kubeadm-init.log</code></pre><p>使用指定的yaml文件进行初始化安装，自动颁发证书(v1.13后支持)把所有的信息都写入到 kubeadm-init.log中，其中<strong style="color: red">–experimental-upload-certs </strong>这个参数在最新版中已经被弃用了，官方推荐使用 <strong>–upload-certs </strong>替代，<a href="https://v1-15.docs.kubernetes.io/docs/setup/release/notes/" target="_blank" rel="noopener">官方公告：</a>。</p><p>上面记录了完成的初始化输出的内容，根据输出的内容基本上可以看出手动初始化安装一个Kubernetes集群所需要的关键步骤。 其中有以下关键内容：</p><blockquote><ul><li>init：指定版本进行初始化操作</li><li>preflight：初始化前的检查和下载所需要的 Docker 镜像文件</li><li>kubelet-start：生成 kubelet 的配置文件 var/lib/kubelet/config.yaml，没有这个文件 kubelet 无法启动，所以初始化之前的 kubelet 实际上启动不会成功</li><li>certificates：生成 Kubernetes 使用的证书，存放在 /etc/kubernetes/pki 目录中</li><li>kubeconfig：生成 KubeConfig 文件，存放在 /etc/kubernetes 目录中，组件之间通信需要使用对应文件</li><li>control-plane：使用 /etc/kubernetes/manifest 目录下的 YAML 文件，安装 Master 组件</li><li>etcd：使用 /etc/kubernetes/manifest/etcd.yaml 安装 Etcd 服务</li><li>wait-control-plane：等待 control-plan 部署的 Master 组件启动</li><li>apiclient：检查 Master 组件服务状态。</li><li>uploadconfig：更新配置</li><li>kubelet：使用 configMap 配置 kubelet</li><li>patchnode：更新 CNI 信息到 Node 上，通过注释的方式记录</li><li>mark-control-plane：为当前节点打标签，打了角色 Master，和不可调度标签，这样默认就不会使用 Master 节点来运行 Pod</li><li>bootstrap-token：生成 token 记录下来，后边使用 kubeadm join 往集群中添加节点时会用到</li><li>addons：安装附加组件 CoreDNS 和 kube-proxy</li></ul></blockquote><p>初始化完成后需要的工作，还是k8s-master1节点上<br>在当前的用户(我用的root)的Home目录下创建.kube目录(这个目录中保存我们的连接配置，kubectl和kubeApi进行https通讯，所以有一些缓存需要保存以及一些认证文件)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$HOME</span>/.kube  </code></pre><p>拷贝集群管理员的配置文件到这个目录下</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token variable">$HOME</span>/.kube/config  </code></pre><p>授予权限(所有者 所有组授予当前的用户)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token variable">$HOME</span>/.kube/config        </code></pre><p>查看 k8s 节点状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node</span>NAME         STATUS     ROLES    AGE     VERSIONk8s-master   NotReady   master   7m46s   v1.15.1</code></pre><p>此时主节点状态为NotReady，因为我们k8s集群要求一个扁平化的网络存在，由于我们还没构建flanneld网络插件。<br>下载flannel yaml文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> <span class="token function">cd</span> /usr/local/install-k8s/plugin/flannel<span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span> <span class="token function">wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>创建flannel</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl create -f kube-flannel.yml </span><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system # -n 命名空间  </span></code></pre><p>此时查看node状态应该为Ready状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node</span>NAME         STATUS   ROLES    AGE   VERSIONk8s-master   Ready    master   23m   v1.15.1</code></pre><p>查看一下集群状态，确认个组件都处于healthy状态：</p><pre class=" language-bash"><code class="language-bash">kubectl get cs<span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><p>获得 join命令参数方式有两种：<br>​    1 在我们上面kubeadm init初始化的那个kubeadm-init.log日志中也可以找到。</p><p>​    2 k8s-master 节点上执行下面命令。</p><pre class=" language-bash"><code class="language-bash">kubeadm token create --print-join-command</code></pre><p>在k8s-node1和k8s-node2上分别执行加入节点的命令：</p><pre class=" language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 192.168.1.85:6443 --token abcdef.0123456789abcdef \    --discovery-token-ca-cert-hash sha256:d3a817068b75095f3616f5dd029ee40960ab851a48162fc5e4a0808b8d786ad2 </code></pre><p>在k8s-master节点上查看：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system -o wide  # 可以在wide加入-w参数</span></code></pre><p>此时查看node节点应该有3个，但子节点状态为notReady，等待子节点的flannel初始化完成即可。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span></code></pre><p>*如果子节点执行加入主节点的命令报错的话，可以尝试执行kubeadm reset命令后重试</p><p>移除node节点以及之后的重新加入：</p><p>k8s-master节点上执行：</p><pre class=" language-bash"><code class="language-bash">kubectl delete node k8s-node2</code></pre><p>在k8s-node2节点上执行：</p><pre class=" language-bash"><code class="language-bash">kubeadm reset <span class="token function">ifconfig</span> cni0 downip <span class="token function">link</span> delete cni0<span class="token function">ifconfig</span> flannel.1 downip <span class="token function">link</span> delete flannel.1<span class="token function">rm</span> -rf /var/lib/cni/</code></pre><p>重新是node节点加入集群<br>如果我们忘记了Master节点的token，可以使用下面的命令来看：</p><pre class=" language-bash"><code class="language-bash">kubeadm token list<span class="token punctuation">[</span>root@k8s-master core<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm token list</span>TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION                                           EXTRA GROUPS5q91af.st35qitumttcwp7e   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-11-23T16:22:16+08:00   <span class="token operator">&lt;</span>none<span class="token operator">></span>                   Proxy <span class="token keyword">for</span> managing TTL <span class="token keyword">for</span> the kubeadm-certs secret   <span class="token operator">&lt;</span>none<span class="token operator">></span>abcdef.0123456789abcdef   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-11-24T14:22:16+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                system:bootstrappers:kubeadm:default-node-tokenuw6dfy.cye0w06s06dms8q8   4h          2019-11-25T17:59:15+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                system:bootstrapp</code></pre><p>默认情况下，token的有效期是24小时，如果token已经过期的话，可以使用以下命令重新生成：</p><pre class=" language-bash"><code class="language-bash">kubeadm token create</code></pre><p>如果你找不到–discovery-token-ca-cert-hash的值，可以使用以下命令生成：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master<span class="token punctuation">]</span> ~$ openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt <span class="token operator">|</span> openssl rsa -pubin -outform der 2<span class="token operator">></span>/dev/null <span class="token operator">|</span> openssl dgst -sha256 -hex <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.* //'</span>7845e6615fcae889eedd6fe55174d904ddd4d3ca5257f04c4438cc67cf06ba58</code></pre><p>除了上面通过两次命令找token和hash，也可以直接一次性执行如下命令来获取:</p><pre class=" language-bash"><code class="language-bash">kubeadm token create --print-join-command </code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> docker </tag>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7-yum安装lnmp环境</title>
      <link href="/2019/11/14/yum%E5%AE%89%E8%A3%85lnmp%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/11/14/yum%E5%AE%89%E8%A3%85lnmp%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="yum安装nginx-php-mysql，搭建lnmp环境"><a href="#yum安装nginx-php-mysql，搭建lnmp环境" class="headerlink" title="yum安装nginx\php\mysql，搭建lnmp环境"></a>yum安装nginx\php\mysql，搭建lnmp环境</h1><p>yum升级</p><pre class=" language-bash"><code class="language-bash">yum update</code></pre><p>yum安装nginx最新源</p><pre class=" language-basj"><code class="language-basj">yum localinstall http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmyum repolist enabled | grep "nginx*" </code></pre><p>安装nginx</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> nginx</code></pre><p>启动nginx</p><pre class=" language-bash"><code class="language-bash">systemctl  start  nginx</code></pre><p>检查开机自动是否设置成功</p><pre class=" language-bash"><code class="language-bash">systemctl list-dependencies <span class="token operator">|</span> <span class="token function">grep</span> nginx</code></pre><p>浏览器中输入公网ip,检测是否安装成功<br><a href="http://xxx.yyy.com" target="_blank" rel="noopener">http://xxx.yyy.com</a></p><h1 id="使用yum安装mysql5-7"><a href="#使用yum安装mysql5-7" class="headerlink" title="使用yum安装mysql5.7"></a>使用yum安装mysql5.7</h1><p>安装mysql源</p><pre class=" language-bash"><code class="language-bash">yum -y localinstall  http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpmyum repolist enabled <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"mysql.*-community.*"</span></code></pre><p>安装mysql</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> mysql-community-server <span class="token function">install</span> mysql-community-devel</code></pre><p>启动mysql</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld start</code></pre><p>检查mysql启动是否正常</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld status 或者 <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> mysql</code></pre><p>设置mysqld服务开机自启动</p><pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> mysqld.service</code></pre><p>检查mysqld开机自启动是否设置成功</p><pre class=" language-bash"><code class="language-bash">systemctl list-dependencies <span class="token operator">|</span> <span class="token function">grep</span> mysqld</code></pre><p>mysql5.7以后的争强了安全机制, 所以使用yum安装,启动会系统会自动生成一个随机的密码,修改mysql密码<br>查看mysql的随机密码</p><pre class=" language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">'temporary password'</span> /var/log/mysqld.log</code></pre><p>使用查询得到的随机密码在终端登录</p><pre class=" language-bash"><code class="language-bash">mysql -u root -p    更改密码<span class="token punctuation">(</span>mysql文档规定,密码必须包括大小写字母数字加特殊符号<span class="token operator">></span>8位<span class="token punctuation">)</span>ALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'Yourpassword'</span><span class="token punctuation">;</span>退出mysql客户端,用刚才修改的密码登录确保密码修改成功<span class="token keyword">exit</span><span class="token punctuation">;</span>mysql -u root -p  </code></pre><h1 id="安装php7-1"><a href="#安装php7-1" class="headerlink" title="安装php7.1"></a>安装php7.1</h1><p>安装php源</p><pre class=" language-bash"><code class="language-bash">rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</code></pre><p>检查源是否安装成功</p><pre class=" language-bash"><code class="language-bash">yum repolist enabled <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"webtatic*"</span></code></pre><p>安装php扩展源 </p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> php71w php71w-fpmyum -y <span class="token function">install</span> php71w-mbstring php71w-common php71w-gd php71w-mcryptyum -y <span class="token function">install</span> php71w-mysql php71w-xml php71w-cli php71w-develyum -y <span class="token function">install</span> php71w-pecl-memcached php71w-pecl-redis php71w-opcache</code></pre><p>验证php7.1.x和扩展是否安装成功<br>验证php是否安装成功</p><pre class=" language-bash"><code class="language-bash">php -v</code></pre><p>验证对应的扩展是否安装成功</p><pre class=" language-bash"><code class="language-bash">php -m</code></pre><p>设置php-fpm并检测php-fpm的运行状态<br>启动php-fpm</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> php-fpm start</code></pre><p>检查启动是否成功<br>service php-fpm status<br>设置开机自启动<br>systemctl enable php-fpm.service<br>检查开机自启动是否设置成功</p><pre class=" language-bash"><code class="language-bash">systemctl list-dependencies <span class="token operator">|</span> <span class="token function">grep</span> php-fpm<span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> php-fpm</code></pre><p>nginx配置如下：</p><pre class=" language-bash"><code class="language-bash">server<span class="token punctuation">{</span>    listen       80<span class="token punctuation">;</span>    server_name  youserver<span class="token punctuation">;</span>    index index.html index.php<span class="token punctuation">;</span>    root /home/public<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#charset koi8-r;</span>    <span class="token comment" spellcheck="true">#access_log  logs/host.access.log  main;</span>    location / <span class="token punctuation">{</span>        index  index.html index.htm index.php<span class="token punctuation">;</span>        try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.php?<span class="token variable">$query_string</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    error_page  404              /404.html<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># redirect server error pages to the static page /50x.html</span>    <span class="token comment" spellcheck="true">#</span>    error_page   500 502 503 504  /50x.html<span class="token punctuation">;</span>    location <span class="token operator">=</span> /50x.html <span class="token punctuation">{</span>        root   html<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span>    <span class="token comment" spellcheck="true">#</span>    <span class="token comment" spellcheck="true">#location ~ .php$ {</span>    <span class="token comment" spellcheck="true">#    proxy_pass   http://127.0.0.1;</span>    <span class="token comment" spellcheck="true">#}</span>    <span class="token comment" spellcheck="true"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>    <span class="token comment" spellcheck="true">#</span>    location ~ .php$ <span class="token punctuation">{</span>        root           /home/public<span class="token punctuation">;</span>        fastcgi_pass   127.0.0.1:9000<span class="token punctuation">;</span>        fastcgi_index  index.php<span class="token punctuation">;</span>        fastcgi_param  SCRIPT_FILENAME  /home/public<span class="token variable">$fastcgi_script_name</span><span class="token punctuation">;</span>        include        fastcgi_params<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># deny access to .htaccess files, if Apache's document root</span>    <span class="token comment" spellcheck="true"># concurs with nginx's one</span>    <span class="token comment" spellcheck="true">#</span>    location ~ /.ht <span class="token punctuation">{</span>        deny  all<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> lnmp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云部署多主master高可用k8s集群</title>
      <link href="/2019/07/10/kubernetes%E4%B9%8B%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/07/10/kubernetes%E4%B9%8B%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>阿里云K8S高可用部署(我们需要准备六台阿里云的ECS,选择有公网IP的)</p><h1 id="二进制搭建k8s多master集群之第一篇-集群环境和各个组件功能介绍"><a href="#二进制搭建k8s多master集群之第一篇-集群环境和各个组件功能介绍" class="headerlink" title="二进制搭建k8s多master集群之第一篇(集群环境和各个组件功能介绍)"></a>二进制搭建k8s多master集群之第一篇(集群环境和各个组件功能介绍)</h1><p>规划如下：</p><pre class=" language-bash"><code class="language-bash">master01:172.24.150.85<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>  kube-apiserver  kube-conroller-manager etcd        flannel  dockermaster02:172.24.150.86<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>  kube-apiserver  kube-conroller-manager etcd        flannel     docker        master03:172.24.150.87<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>    kube-apiserver  kube-conroller-manager etcd        flannel     dockernode01:172.24.150.88<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>    kube-proxy  kubelet        flannel     dockernode02:172.24.150.89<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>    kube-proxy  kubelet        flannel     dockerhaproxyharbor:172.24.150.90<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>        haproxy harbor</code></pre><h1 id="一-组件版本"><a href="#一-组件版本" class="headerlink" title="一     组件版本"></a>一     组件版本</h1><ul><li>kubernetes 1.12.3</li><li>Docker 18.06.1-ce</li><li>Etcd 3.3.10</li><li>Flanneld 0.10.0</li><li>插件<ul><li>CoreDNS    </li><li>Dashboard</li><li>Heapster(influxdb,grafana)</li><li>Metrics-Server</li><li>EFK(elasticsearch,fluentd,kibana)</li><li>镜像仓库</li><li>docker registry</li><li>harbor</li></ul></li></ul><h1 id="二-主要配置策略"><a href="#二-主要配置策略" class="headerlink" title="二    主要配置策略"></a>二    主要配置策略</h1><ul><li>kube-apiserver:</li><li>使用keepalived和haproxy实现3节点高可用;</li><li>关闭非安全端口8080和匿名访问;</li><li>在安全端口6443接收https请求；</li><li>严格的认证和授权策略(x509,token,RBAC)</li><li>开启bootstrap token认证，支持kubelet TLS bootstrapping;</li><li>使用https访问kubelet,etcd,加密通信；<br>kube-scheduler:</li><li>3节点高可用;</li><li>使用kubeconfig访问apiserver的安全端口;</li></ul><p>kubelet:</p><ul><li><p>使用kubeadm动态创建bootstrap token，而不是在apiserver中静态配置</p></li><li><p>使用TLS bootstrap机制自动生成client和server证书，过期后自动轮转;</p></li><li><p>在KubeletConfiguration类型的JSON文件配置主要参数;</p></li><li><p>关闭只读端口，在安全端口10250接收https请求，对请求进行认证和授权，拒绝匿名访问和非授权访问;</p></li><li><p>使用kubeconfig访问apiserver的安全端口;</p></li><li><p>kube-proxy:使用kubeconfig访问apiserver的安全端口;</p></li><li><p>在kubeProxyConfiguration类型的JSON文件配置主要参数;</p></li><li><p>IPVS代理模式</p></li><li><p>集群插件:</p><ul><li>DNS：使用功能、性能更好的coredns;</li><li>Dashboard:支持登录认证</li><li>Metric:heapster,metrics-server,使用https访问kubelet安全端口;</li><li>Log:Elasticsearch,Fluend,Kibana;</li><li>Registry镜像库：docker-registry,harbor;</li></ul><p>​    </p></li></ul><h1 id="三-系统初始化"><a href="#三-系统初始化" class="headerlink" title="三    系统初始化"></a>三    系统初始化</h1><h2 id="1-主机名修改-6个节点都操作"><a href="#1-主机名修改-6个节点都操作" class="headerlink" title="1    主机名修改(6个节点都操作)"></a>1    主机名修改(6个节点都操作)</h2><p>例如：master01<br>hostnamectl set-hostname master01</p><h2 id="2-本地hosts解析-6个节点都操作-至于我为啥多加了etcd01-etcd02-etcd03，为啥etcd三节点集群中的命名而已"><a href="#2-本地hosts解析-6个节点都操作-至于我为啥多加了etcd01-etcd02-etcd03，为啥etcd三节点集群中的命名而已" class="headerlink" title="2    本地hosts解析(6个节点都操作)(至于我为啥多加了etcd01,etcd02,etcd03，为啥etcd三节点集群中的命名而已)"></a>2    本地hosts解析(6个节点都操作)(至于我为啥多加了etcd01,etcd02,etcd03，为啥etcd三节点集群中的命名而已)</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span> <span class="token function">cat</span> <span class="token operator">>></span>/etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF172.24.150.85  master01 etcd01172.24.150.86  master02 etcd02172.24.150.87  master03 etcd03172.24.150.88  node01172.24.150.89  node02172.24.150.90  haproxyhaborEOF</span></code></pre><h2 id="3-master01免密码登录其它节点-由于下面的很多操作都是单独在master01-192-168-1-145-上完成的-即设置master01免密登录其它节点"><a href="#3-master01免密码登录其它节点-由于下面的很多操作都是单独在master01-192-168-1-145-上完成的-即设置master01免密登录其它节点" class="headerlink" title="3    master01免密码登录其它节点(由于下面的很多操作都是单独在master01(192.168.1.145)上完成的,即设置master01免密登录其它节点)"></a>3    master01免密码登录其它节点(由于下面的很多操作都是单独在master01(192.168.1.145)上完成的,即设置master01免密登录其它节点)</h2><p>配置master01可以免密SSH登录其它节点，方便远程分发文件及执行命令</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-keygen -t rsa            #生成公钥和私钥，一路Enter键                        </span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@master01    #分发公钥到master01上，这里需要输入一次master01的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@master02    #分发公钥到master02上，这里需要输入一次master02的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@master03    #分发公钥到master03上，这里需要输入一次master03的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@node01        #分发公钥到node01上，这里需要输入一次node01的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@node02        #分发公钥到node02上，这里需要输入一次node02的密码</span></code></pre><h2 id="4-关闭防火墙firewall-6个节点都操作"><a href="#4-关闭防火墙firewall-6个节点都操作" class="headerlink" title="4    关闭防火墙firewall(6个节点都操作)"></a>4    关闭防火墙firewall(6个节点都操作)</h2><pre class=" language-bash"><code class="language-bash">    systemctl stop firewalld          （root权限）    systemctl disable firewalld         <span class="token punctuation">(</span>设置开启未启动模式 <span class="token punctuation">)</span>    iptables -P FORWARD ACCEPT         <span class="token punctuation">(</span>设置FORWARD链为接收模式,要对4表5链有了解哦！<span class="token punctuation">)</span></code></pre><h2 id="5-关闭swap分区"><a href="#5-关闭swap分区" class="headerlink" title="5    关闭swap分区"></a>5    关闭swap分区</h2><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token function">sed</span> -i <span class="token string">'/ swap / s/^\(.*\)$/#\1/g'</span> /etc/fstab <span class="token punctuation">(</span>不太明白哦<span class="token punctuation">)</span></code></pre><h2 id="6-关闭SELinux"><a href="#6-关闭SELinux" class="headerlink" title="6    关闭SELinux"></a>6    关闭SELinux</h2><pre class=" language-bash"><code class="language-bash">setenforce 0<span class="token function">grep</span> SELINUX /etc/selinux/configSELINUX<span class="token operator">=</span>disabled</code></pre><h2 id="7-加载内核模块"><a href="#7-加载内核模块" class="headerlink" title="7    加载内核模块"></a>7    加载内核模块</h2><pre class=" language-bash"><code class="language-bash">modprobe br-netfiltermodprobe ip_vs</code></pre><h2 id="8-设置系统参数"><a href="#8-设置系统参数" class="headerlink" title="8    设置系统参数"></a>8    设置系统参数</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> kubernetes.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0vm.overcommit_memory=1vm.panic_on_oom=0fs.inotify.max_user_watches=89100fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1net.netfilter.nf_conntrack_max=2310720EOF</span>使上面内容生效：sysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><p>tcp_tw_recycle和Kubernetes的NAT冲突，必须关闭,<br>关闭不适用的IPV6协议栈，防止触发docker BUG;</p><h2 id="9-检查系统内核和模块适不适合运行docker-centos系统"><a href="#9-检查系统内核和模块适不适合运行docker-centos系统" class="headerlink" title="9    检查系统内核和模块适不适合运行docker(centos系统)"></a>9    检查系统内核和模块适不适合运行docker(centos系统)</h2><pre class=" language-bash"><code class="language-bash">curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh <span class="token operator">></span> check-config.sh./check-config.sh</code></pre><h1 id="四-环境介绍"><a href="#四-环境介绍" class="headerlink" title="四    环境介绍"></a>四    环境介绍</h1><p>二进制搭建k8s多master集群之第二篇(使用TLS证书搭建etcd三节点高可用集群)<br>下面本文etcd集群才用三台centos7.5搭建完成。<br>etcd01(master01):     172.24.150.85<br>etcd02(master02):    172.24.150.86<br>etcd03(master03):     172.24.150.87</p><h2 id="一-创建CA证书和密钥"><a href="#一-创建CA证书和密钥" class="headerlink" title="一 创建CA证书和密钥"></a>一 创建CA证书和密钥</h2><p>k8s系统各组件间需要使用TLS证书对通信进行加密，本文档使用CloudFlare的PKI工具集<strong>cfssl</strong>来生成Certificate Authority(CA)证书和密钥文件，CA是自签名证书，用来签名后续创建的其它TLS证书。由于第一篇我们做了master01(etcd01)到master02(etcd02),master03(etcd03)的免密验证，因此下面步骤中我们只需要在master01上操作，然后把证书和工具命令拷贝到其它节点上就可以了，有些需要其它节点必须登录操作的，我会红色标记提醒的</p><h3 id="1-安装CFSSL-master01操作"><a href="#1-安装CFSSL-master01操作" class="headerlink" title="1 安装CFSSL(master01操作)"></a>1 安装CFSSL(master01操作)</h3><pre class=" language-bash"><code class="language-bash">curl -o /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64curl -o /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64<span class="token function">chmod</span> +x /usr/local/bin/cfssl*</code></pre><h3 id="2-创建CA配置文件"><a href="#2-创建CA配置文件" class="headerlink" title="2 创建CA配置文件"></a>2 创建CA配置文件</h3><p>先创建存放证书的目录<br>mkdir -p /etc/kubernetes/cert &amp;&amp; cd /etc/kubernetes/cert   (master01,master02,master03都需要操作一遍)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> ca-config.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "signing": {    "default": {      "expiry": "87600h"    },    "profiles": {      "kubernetes": {        "usages": [            "signing",            "key encipherment",            "server auth",            "client auth"        ],        "expiry": "87600h"      }    }  }}EOF</span>简要介绍：    ca-config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；     signing：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA<span class="token operator">=</span>TRUE；     server auth：表示 client 可以用该 CA 对 server 提供的证书进行验证；     client auth：表示 server 可以用该 CA 对 client 提供的证书进行验证；</code></pre><h3 id="3-创建CA证书签名请求"><a href="#3-创建CA证书签名请求" class="headerlink" title="3 创建CA证书签名请求"></a>3 创建CA证书签名请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> ca-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "kubernetes",  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span>简要介绍:    CN：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 <span class="token punctuation">(</span>User Name<span class="token punctuation">)</span>，浏览器使用该字段验证网站是否合法；    O：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 <span class="token punctuation">(</span>Group<span class="token punctuation">)</span>；    kube-apiserver 将提取的 User、Group 作为 RBAC 授权的用户标识；</code></pre><p>生成CA证书和私钥:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span>2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> generating a new CA key and certificate from CSR2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> generate received request2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> received CSR2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> generating key: rsa-20482019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> encoded CSR2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> signed certificate with serial number 605272635170936057386255196971681816888287295153<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</code></pre><h3 id="4-创建etcd证书签名请求文件"><a href="#4-创建etcd证书签名请求文件" class="headerlink" title="4 创建etcd证书签名请求文件"></a>4 创建etcd证书签名请求文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> etcd-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "etcd",  "hosts": [    "127.0.0.1",    "172.24.150.85",    "172.24.150.86",    "172.24.150.87"  ],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span>简要介绍：    hosts 字段指定授权使用该证书的 etcd 节点 IP 或域名列表，这里将 etcd 集群的三个节点 IP 都列在其中<span class="token punctuation">;</span></code></pre><p>生成CA证书和私钥：</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \    -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \    -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \    -profile<span class="token operator">=</span>kubernetes etcd-csr.json <span class="token operator">|</span> cfssljson -bare etcd</code></pre><h3 id="5-将-pem证书分发到其它两台etcd主机节点上即etcd02-master02-、-etcd03-master03"><a href="#5-将-pem证书分发到其它两台etcd主机节点上即etcd02-master02-、-etcd03-master03" class="headerlink" title="5 将*.pem证书分发到其它两台etcd主机节点上即etcd02(master02)、 etcd03(master03)"></a>5 将*.pem证书分发到其它两台etcd主机节点上即etcd02(master02)、 etcd03(master03)</h3><p>另外ca证书也要分发到node01，node02上，因为创建flanneld网络时要用到</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp *.pem master02:/etc/kubernetes/cert</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp *.pem master03:/etc/kubernetes/cert               </span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp ca.pem root@node01:/etc/kubernetes/cert </span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp ca.pem root@node02:/etc/kubernetes/cert </span></code></pre><p>etcd使用证书组件为：<br>​    &gt;    * ca.pem<br>​    &gt;    * etcd-key.pem<br>​    &gt;    * etcd.pem    </p><h2 id="二-部署etcd三节点集群"><a href="#二-部署etcd三节点集群" class="headerlink" title="二 部署etcd三节点集群"></a>二 部署etcd三节点集群</h2><p>三个etcd节点都要安装etcd软件包(即：master01、master02、master03)</p><h3 id="1-三节点下载软件包"><a href="#1-三节点下载软件包" class="headerlink" title="1 三节点下载软件包"></a>1 三节点下载软件包</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/etcd-io/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">tar</span> zxf etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">cp</span>  etcd-v3.3.10-linux-amd64/etcd* /usr/local/bin</code></pre><h3 id="2-三节点都创建etcd数据库工作目录"><a href="#2-三节点都创建etcd数据库工作目录" class="headerlink" title="2 三节点都创建etcd数据库工作目录"></a>2 三节点都创建etcd数据库工作目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/lib/etcd</code></pre><h3 id="3-创建三节点的-systemd-unit-文件"><a href="#3-创建三节点的-systemd-unit-文件" class="headerlink" title="3 创建三节点的 systemd unit 文件"></a>3 创建三节点的 systemd unit 文件</h3><p>master01的systemd unit配置文件如下：<br>###############################  172.24.150.85    ################################</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/etcd.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/ExecStart=/usr/local/bin/etcd \  --name etcd01 \  --cert-file=/etc/kubernetes/cert/etcd.pem \  --key-file=/etc/kubernetes/cert/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/cert/etcd.pem \  --peer-key-file=/etc/kubernetes/cert/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --initial-advertise-peer-urls https://172.24.150.85:2380 \  --listen-peer-urls https://172.24.150.85:2380 \  --listen-client-urls https://172.24.150.85:2379,http://127.0.0.1:2379 \  --advertise-client-urls https://172.24.150.85:2379 \  --initial-cluster-token etcd-cluster-0 \  --initial-cluster etcd01=https://172.24.150.85:2380,etcd02=https://172.24.150.86:2380,etcd03=https://172.24.150.87:2380 \  --initial-cluster-state new \  --data-dir=/var/lib/etcdRestart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>###############################  172.24.150.86    ################################<br>master02的system unit配置文件如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/etcd.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/ExecStart=/usr/local/bin/etcd \  --name etcd02 \  --cert-file=/etc/kubernetes/cert/etcd.pem \  --key-file=/etc/kubernetes/cert/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/cert/etcd.pem \  --peer-key-file=/etc/kubernetes/cert/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --initial-advertise-peer-urls https://172.24.150.86:2380 \  --listen-peer-urls https://172.24.150.86:2380 \  --listen-client-urls https://172.24.150.86:2379,http://127.0.0.1:2379 \  --advertise-client-urls https://172.24.150.86:2379 \  --initial-cluster-token etcd-cluster-0 \  --initial-cluster etcd01=https://172.24.150.85:2380,etcd02=https://172.24.150.86:2380,etcd03=https://172.24.150.87:2380 \  --initial-cluster-state new \  --data-dir=/var/lib/etcdRestart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>###############################  172.24.150.87    ################################<br>master03的system unit配置文件如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/etcd.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/ExecStart=/usr/local/bin/etcd \  --name etcd03 \  --cert-file=/etc/kubernetes/cert/etcd.pem \  --key-file=/etc/kubernetes/cert/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/cert/etcd.pem \  --peer-key-file=/etc/kubernetes/cert/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --initial-advertise-peer-urls https://172.24.150.87:2380 \  --listen-peer-urls https://172.24.150.87:2380 \  --listen-client-urls https://172.24.150.87:2379,http://127.0.0.1:2379 \  --advertise-client-urls https://172.24.150.87:2379 \  --initial-cluster-token etcd-cluster-0 \  --initial-cluster etcd01=https://172.24.150.85:2380,etcd02=https://172.24.150.86:2380,etcd03=https://172.24.150.87:2380 \  --initial-cluster-state new \  --data-dir=/var/lib/etcdRestart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>####################################################################################################<br>为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）； </p><p>创建etcd.pem 证书时使用的 etcd-csr.json 文件的 hosts 字段包含所有 etcd 节点的IP，否则证书校验会出错；<br>–initial-cluster-state 值为 new 时，–name 的参数值必须位于 –initial-cluster 列表中.</p><h3 id="4-最好三节点同时启动并且设置开机自启动-xshell工具，一个窗口连接3个主机"><a href="#4-最好三节点同时启动并且设置开机自启动-xshell工具，一个窗口连接3个主机" class="headerlink" title="4 最好三节点同时启动并且设置开机自启动(xshell工具，一个窗口连接3个主机)"></a>4 最好三节点同时启动并且设置开机自启动(xshell工具，一个窗口连接3个主机)</h3><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl start etcd.servicesystemctl <span class="token function">enable</span> etcd.service</code></pre><h3 id="5-查看etcd服务的状态信息"><a href="#5-查看etcd服务的状态信息" class="headerlink" title="5 查看etcd服务的状态信息"></a>5 查看etcd服务的状态信息</h3><pre class=" language-bash"><code class="language-bash">systemctl status etcd.service</code></pre><p>如果不是一起启动的话，最先启动的etcd进程会卡住一段时间，等待其它节点的etcd进程加入集群，为正常现象</p><h3 id="6-验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓"><a href="#6-验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓" class="headerlink" title="6 验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓"></a>6 验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem cluster-health</span>member 2b7694970ad266e9 is healthy: got healthy result from https://172.24.150.86:2379member 2de7ad1771e372b4 is healthy: got healthy result from https://172.24.150.87:2379member cf6dea03cf608ee3 is healthy: got healthy result from https://172.24.150.85:2379cluster is healthy<span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem member list</span>2b7694970ad266e9: name<span class="token operator">=</span>etcd02 peerURLs<span class="token operator">=</span>https://172.24.150.86:2380 clientURLs<span class="token operator">=</span>https://172.24.150.86:2379 isLeader<span class="token operator">=</span>false2de7ad1771e372b4: name<span class="token operator">=</span>etcd03 peerURLs<span class="token operator">=</span>https://172.24.150.87:2380 clientURLs<span class="token operator">=</span>https://172.24.150.87:2379 isLeader<span class="token operator">=</span>falsecf6dea03cf608ee3: name<span class="token operator">=</span>etcd01 peerURLs<span class="token operator">=</span>https://172.24.150.85:2380 clientURLs<span class="token operator">=</span>https://172.24.150.85:2379 isLeader<span class="token operator">=</span>true</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master02 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem cluster-health</span>member 2b7694970ad266e9 is healthy: got healthy result from https://172.24.150.86:2379member 2de7ad1771e372b4 is healthy: got healthy result from https://172.24.150.87:2379member cf6dea03cf608ee3 is healthy: got healthy result from https://172.24.150.85:2379cluster is healthy<span class="token punctuation">[</span>root@master02 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem member list</span>2b7694970ad266e9: name<span class="token operator">=</span>etcd02 peerURLs<span class="token operator">=</span>https://172.24.150.86:2380 clientURLs<span class="token operator">=</span>https://172.24.150.86:2379 isLeader<span class="token operator">=</span>false2de7ad1771e372b4: name<span class="token operator">=</span>etcd03 peerURLs<span class="token operator">=</span>https://172.24.150.87:2380 clientURLs<span class="token operator">=</span>https://172.24.150.87:2379 isLeader<span class="token operator">=</span>falsecf6dea03cf608ee3: name<span class="token operator">=</span>etcd01 peerURLs<span class="token operator">=</span>https://172.24.150.85:2380 clientURLs<span class="token operator">=</span>https://172.24.150.85:2379 isLeader<span class="token operator">=</span>true<span class="token punctuation">[</span>root@master02 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master03 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem cluster-health</span>member 2b7694970ad266e9 is healthy: got healthy result from https://172.24.150.86:2379member 2de7ad1771e372b4 is healthy: got healthy result from https://172.24.150.87:2379member cf6dea03cf608ee3 is healthy: got healthy result from https://172.24.150.85:2379cluster is healthy<span class="token punctuation">[</span>root@master03 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem member list</span>2b7694970ad266e9: name<span class="token operator">=</span>etcd02 peerURLs<span class="token operator">=</span>https://172.24.150.86:2380 clientURLs<span class="token operator">=</span>https://172.24.150.86:2379 isLeader<span class="token operator">=</span>false2de7ad1771e372b4: name<span class="token operator">=</span>etcd03 peerURLs<span class="token operator">=</span>https://172.24.150.87:2380 clientURLs<span class="token operator">=</span>https://172.24.150.87:2379 isLeader<span class="token operator">=</span>falsecf6dea03cf608ee3: name<span class="token operator">=</span>etcd01 peerURLs<span class="token operator">=</span>https://172.24.150.85:2380 clientURLs<span class="token operator">=</span>https://172.24.150.85:2379 isLeader<span class="token operator">=</span>true</code></pre><p>到此ETCD TLS 3节点集群部署完成，下一篇是二进制搭建k8s三节点master高可用集群之第三篇配置flannel网络</p><p>上一篇我们已经搭建etcd高可用集群，这篇我们将搭建Flannel，目的使跨主机的docker能够相互通信，也是保障kubernetes集群的网络基础和保障，下面开始配置。</p><h1 id="生成Flannel网络TLS证书"><a href="#生成Flannel网络TLS证书" class="headerlink" title="生成Flannel网络TLS证书"></a>生成Flannel网络TLS证书</h1><p>在所有集群节点都安装Flannel,下面的操作就只演示master01上，其它节点重复执行即可。(证书就在master01上生成一次就行，然后分发)</p><h2 id="1-创建证书签名请求"><a href="#1-创建证书签名请求" class="headerlink" title="1    创建证书签名请求"></a>1    创建证书签名请求</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> flanneld-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "flanneld",  "hosts": [],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span></code></pre><p>该证书只会被kubectl当做client证书使用，所以hosts字段为空；</p><p>生成证书和私钥:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes flanneld-csr.json <span class="token operator">|</span> cfssljson -bare flanneld</code></pre><h2 id="2-将证书分发到所有集群节点-etc-kubernetes-cert-目录下"><a href="#2-将证书分发到所有集群节点-etc-kubernetes-cert-目录下" class="headerlink" title="2    将证书分发到所有集群节点/etc/kubernetes/cert/目录下"></a>2    将证书分发到所有集群节点/etc/kubernetes/cert/目录下</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@master02:/etc/kubernetes/cert/<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@master03:/etc/kubernetes/cert/<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@node01:/etc/kubernetes/cert/<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@node02:/etc/kubernetes/cert/</code></pre><h1 id="二-部署Flannel"><a href="#二-部署Flannel" class="headerlink" title="二    部署Flannel"></a>二    部署Flannel</h1><h2 id="1-下载Flannel-所有节点"><a href="#1-下载Flannel-所有节点" class="headerlink" title="1    下载Flannel(所有节点)"></a>1    下载Flannel(所有节点)</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/coreos/flannel/releases/download/v0.10.0/flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">tar</span> -xzvf flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">cp</span> <span class="token punctuation">{</span>flanneld,mk-docker-opts.sh<span class="token punctuation">}</span> /usr/local/bin</code></pre><h2 id="2-向etcd写入网段信息"><a href="#2-向etcd写入网段信息" class="headerlink" title="2 向etcd写入网段信息"></a>2 向etcd写入网段信息</h2><p>下面两条命令在etcd集群中任意一台上执行一次就行，也就是创建一个flannel网段供docker分配使用</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem mkdir /kubernetes/network</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem mk /kubernetes/network/config '{"Network":"172.30.0.0/16","SubnetLen":24,"Backend":{"Type":"vxlan"}}'</span></code></pre><p>第二条这么长是一个整命令哦，不要忘记了哦</p><h2 id="3-创建system-unit文件"><a href="#3-创建system-unit文件" class="headerlink" title="3 创建system unit文件"></a>3 创建system unit文件</h2><p>在master01创建好，然后不用做任何修改分发到master02,master03,node01,node02 上。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/systemd/system/flannel.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Flanneld overlay address etcd agentAfter=network.targetAfter=network-online.targetWants=network-online.targetAfter=etcd.serviceBefore=docker.service[Service]Type=notifyExecStart=/usr/local/bin/flanneld \  -etcd-cafile=/etc/kubernetes/cert/ca.pem \  -etcd-certfile=/etc/kubernetes/cert/flanneld.pem \  -etcd-keyfile=/etc/kubernetes/cert/flanneld-key.pem \  -etcd-endpoints=https://172.24.150.85:2379,https://172.24.150.86:2379,https://172.24.150.87:2379 \  -etcd-prefix=/kubernetes/networkExecStartPost=/usr/local/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/dockerRestart=on-failure[Install]WantedBy=multi-user.targetRequiredBy=docker.serviceEOF</span>简要介绍：    mk-docker-opts.sh 脚本将分配给 flanneld 的 Pod 子网网段信息写入到 /run/flannel/docker 文件中，后续 docker 启动时使用这个文件中参数值设置 docker0 网桥。    flanneld 使用系统缺省路由所在的接口和其它节点通信，对于有多个网络接口的机器（如，内网和公网），可以用 -iface<span class="token operator">=</span>enpxx 选项值指定通信接口。</code></pre><h2 id="4-启动所有节点开始启动flannel并且设置开启自启动"><a href="#4-启动所有节点开始启动flannel并且设置开启自启动" class="headerlink" title="4    启动所有节点开始启动flannel并且设置开启自启动"></a>4    启动所有节点开始启动flannel并且设置开启自启动</h2><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> flanneldsystemctl start flanneld</code></pre><h2 id="5-查看flannel分配的子网信息"><a href="#5-查看flannel分配的子网信息" class="headerlink" title="5    查看flannel分配的子网信息"></a>5    查看flannel分配的子网信息</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /run/flannel/docker </span>DOCKER_OPT_BIP<span class="token operator">=</span><span class="token string">"--bip=172.30.60.1/24"</span>DOCKER_OPT_IPMASQ<span class="token operator">=</span><span class="token string">"--ip-masq=true"</span>DOCKER_OPT_MTU<span class="token operator">=</span><span class="token string">"--mtu=1450"</span>DOCKER_NETWORK_OPTIONS<span class="token operator">=</span><span class="token string">" --bip=172.30.60.1/24 --ip-masq=true --mtu=1450"</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /run/flannel/subnet.env </span>FLANNEL_NETWORK<span class="token operator">=</span>172.30.0.0/16FLANNEL_SUBNET<span class="token operator">=</span>172.30.60.1/24FLANNEL_MTU<span class="token operator">=</span>1450FLANNEL_IPMASQ<span class="token operator">=</span>false</code></pre><p>/run/flannel/docker是flannel分配给docker的子网信息，/run/flannel/subnet.env包含了flannel整个大网段以及在此节点上的子网段</p><h2 id="6-查看flannel网络是否生效"><a href="#6-查看flannel网络是否生效" class="headerlink" title="6     查看flannel网络是否生效"></a>6     查看flannel网络是否生效</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:dc:05:69:5c  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.24.150.85  netmask 255.255.240.0  broadcast 172.24.159.255        ether 00:16:3e:01:36:6e  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 698491  bytes 207475857 <span class="token punctuation">(</span>197.8 MiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 631869  bytes 77810204 <span class="token punctuation">(</span>74.2 MiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0flannel.1: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1450        inet 172.30.60.0  netmask 255.255.255.255  broadcast 0.0.0.0        ether 32:1c:4c:05:4a:22  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets 2246  bytes 161117 <span class="token punctuation">(</span>157.3 KiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2246  bytes 161117 <span class="token punctuation">(</span>157.3 KiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以明显看到flannel1.1的网络信息，说明flannel网络已经正常。</p><h2 id="三-配置docker支持flannel网络"><a href="#三-配置docker支持flannel网络" class="headerlink" title="三     配置docker支持flannel网络"></a>三     配置docker支持flannel网络</h2><h3 id="1-所有节点-master01-03-node01-02-五个节点都安装docker-安装指定版本的docker就不介绍了"><a href="#1-所有节点-master01-03-node01-02-五个节点都安装docker-安装指定版本的docker就不介绍了" class="headerlink" title="1    所有节点(master01-03,node01-02)五个节点都安装docker,安装指定版本的docker就不介绍了"></a>1    所有节点(master01-03,node01-02)五个节点都安装docker,安装指定版本的docker就不介绍了</h3><h3 id="2-配置daocker支持flannel网络"><a href="#2-配置daocker支持flannel网络" class="headerlink" title="2    配置daocker支持flannel网络"></a>2    配置daocker支持flannel网络</h3><p>所有docker节点都操作,对5个节点默认的docker system unit配置文件进行修改</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span>     /usr/lib/systemd/system/docker.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Docker Application Container EngineDocumentation<span class="token operator">=</span>https://docs.docker.comAfter<span class="token operator">=</span>network-online.target firewalld.serviceWants<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notify<span class="token comment" spellcheck="true"># the default is not to use systemd for cgroups because the delegate issues still</span><span class="token comment" spellcheck="true"># exists and systemd currently does not support the cgroup feature set required</span><span class="token comment" spellcheck="true"># for containers run by docker</span>EnvironmentFile<span class="token operator">=</span>/run/flannel/dockerExecStart<span class="token operator">=</span>/usr/bin/dockerd <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>ExecReload<span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span><span class="token comment" spellcheck="true"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><span class="token comment" spellcheck="true"># in the kernel. We recommend using cgroups to do container-local accounting.</span>LimitNOFILE<span class="token operator">=</span>infinityLimitNPROC<span class="token operator">=</span>infinityLimitCORE<span class="token operator">=</span>infinity<span class="token comment" spellcheck="true"># Uncomment TasksMax if your systemd version supports it.</span><span class="token comment" spellcheck="true"># Only systemd 226 and above support this version.</span><span class="token comment" spellcheck="true">#TasksMax=infinity</span>TimeoutStartSec<span class="token operator">=</span>0<span class="token comment" spellcheck="true"># set delegate yes so that systemd does not reset the cgroups of docker containers</span>Delegate<span class="token operator">=</span>yes<span class="token comment" spellcheck="true"># kill only the docker process, not all processes in the cgroup</span>KillMode<span class="token operator">=</span>process<span class="token comment" spellcheck="true"># restart the docker process if it exits prematurely</span>Restart<span class="token operator">=</span>on-failureStartLimitBurst<span class="token operator">=</span>3StartLimitInterval<span class="token operator">=</span>60s<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target<span class="token comment" spellcheck="true">##主要修改配置文件以下两行:</span>EnvironmentFile<span class="token operator">=</span>/run/flannel/dockerExecStart<span class="token operator">=</span>/usr/bin/dockerd <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>这里两行不同而已</code></pre><h2 id="3-重启docker，是配置生效"><a href="#3-重启docker，是配置生效" class="headerlink" title="3    重启docker，是配置生效"></a>3    重启docker，是配置生效</h2><p>先看一下没有修改docker的system unit文件，重启前</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:dc:05:69:5c  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.24.150.85  netmask 255.255.240.0  broadcast 172.24.159.255        ether 00:16:3e:01:36:6e  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 806758  bytes 292970377 <span class="token punctuation">(</span>279.3 MiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 729328  bytes 88585438 <span class="token punctuation">(</span>84.4 MiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0flannel.1: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1450        inet 172.30.60.0  netmask 255.255.255.255  broadcast 0.0.0.0        ether 32:1c:4c:05:4a:22  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets 2914  bytes 195853 <span class="token punctuation">(</span>191.2 KiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2914  bytes 195853 <span class="token punctuation">(</span>191.2 KiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>#添加docker的system unit配置文件后，然后重启docker服务,ifconfig命令查看</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart docker</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.30.60.1  netmask 255.255.255.0  broadcast 172.30.60.255        ether 02:42:dc:05:69:5c  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.24.150.85  netmask 255.255.240.0  broadcast 172.24.159.255        ether 00:16:3e:01:36:6e  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 814217  bytes 293897650 <span class="token punctuation">(</span>280.2 MiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 736551  bytes 89555535 <span class="token punctuation">(</span>85.4 MiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0flannel.1: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1450        inet 172.30.60.0  netmask 255.255.255.255  broadcast 0.0.0.0        ether 32:1c:4c:05:4a:22  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets 2993  bytes 200086 <span class="token punctuation">(</span>195.3 KiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2993  bytes 200086 <span class="token punctuation">(</span>195.3 KiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h2 id="4-查看dockers网络是否生效"><a href="#4-查看dockers网络是否生效" class="headerlink" title="4    查看dockers网络是否生效"></a>4    查看dockers网络是否生效</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动一个容器，查看容器分配的ip是否在flannel网络分配的网段内</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -itd --name ceshi centos</span>Unable to <span class="token function">find</span> image <span class="token string">'centos:latest'</span> locallylatest: Pulling from library/centos8ba884070f61: Pull complete Digest: sha256:a799dd8a2ded4a83484bbae769d97655392b3f86533ceb7dd96bbac929809f3cStatus: Downloaded newer image <span class="token keyword">for</span> centos:latestefbb88d013137b8014f3ca4c6a1f55b706fed2d4575c838b1a4b307c1d1e2508<span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' efbb88</span>172.30.60.2</code></pre><h2 id="5-查看所有集群主机的网络情况"><a href="#5-查看所有集群主机的网络情况" class="headerlink" title="5    查看所有集群主机的网络情况"></a>5    查看所有集群主机的网络情况</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem ls /kubernetes/network/subnets</span>/kubernetes/network/subnets/172.30.21.0-24/kubernetes/network/subnets/172.30.60.0-24/kubernetes/network/subnets/172.30.81.0-24/kubernetes/network/subnets/172.30.80.0-24/kubernetes/network/subnets/172.30.14.0-24</code></pre><p>从输出可以看出容器使用了172.30.0.0/24网络，属于flannel分配的网络段，到此集群网络配置完成</p><p>下一篇将部署二进制搭建k8s三节点master高可用集群之配置k8s master及高可用</p><p>二进制搭建k8s三节点master高可用集群之配置k8s master及高可用<br>k8s master集群部署如下：<br>master01:172.24.150.85<br>master02:172.24.150.86<br>master03:172.24.150.87<br>haproxyharbor:172.24.150.90 (kube-apiserver的前端SLB)</p><h1 id="一-配置kubernetes-master集群-3master节点"><a href="#一-配置kubernetes-master集群-3master节点" class="headerlink" title="一  配置kubernetes master集群(3master节点)"></a>一  配置kubernetes master集群(3master节点)</h1><p>kubernetes master 节点包含的组件：</p><blockquote><ul><li>kube-apiserver</li><li>kube-scheduler</li><li>kbue-controller-manager<br>目前这三个组件需要部署在同一台机器上(这句话不理解，难道是这三节点要么同时部署在master01,要么同时部署在master02,或master03上吗？难道不能kube-apiserver部署在master01,scheduler部署在master02,controller-manager部署在master03上吗？在或者两个组件部署在一个节点，另一个组件部署在其它两个节点任意节点上不可以吗？三个组件必须捆绑在一起吗？) </li><li>kube-scheduler,kube-controller-manager和kube-apiserver三者的功能紧密相关:</li><li>同时只能有一个kube-sheduler、kube-controller-manager进程处于工作状态，如果运行多个，则需要通过选举产生一个leader;</li></ul></blockquote><h2 id="部署kubectl命令工具"><a href="#部署kubectl命令工具" class="headerlink" title="部署kubectl命令工具"></a>部署kubectl命令工具</h2><p>kubectl 是 kubernetes 集群的命令行管理工具，本文档介绍安装和配置它的步骤。<br>kubectl 默认从 ~/.kube/config 文件读取 kube-apiserver 地址、证书、用户名等信息，如果没有配置，执行 kubectl 命令时可能会出错。<br> ~/.kube/config只需要部署一次，然后拷贝到其他的master。</p><h3 id="1-下载kubectl"><a href="#1-下载kubectl" class="headerlink" title="1    下载kubectl"></a>1    下载kubectl</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://dl.k8s.io/v1.12.3/kubernetes-server-linux-amd64.tar.gz<span class="token function">tar</span> -xzvf kubernetes-server-linux-amd64.tar.gz<span class="token function">cd</span> kubernetes/server/bin/<span class="token function">cp</span> kube-apiserver kubeadm kube-controller-manager kubectl kube-scheduler /usr/local/bin</code></pre><h3 id="2-创建请求证书"><a href="#2-创建请求证书" class="headerlink" title="2     创建请求证书"></a>2     创建请求证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> admin-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "admin",  "hosts": [],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "system:masters",      "OU": "yunwei"    }  ]}EOF</span>O 为 system:masters，kube-apiserver 收到该证书后将请求的 Group 设置为 system:masters；预定义的 ClusterRoleBinding cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予所有 API的权限；该证书只会被 kubectl 当做 client 证书使用，所以 hosts 字段为空；</code></pre><p>生成证书和私钥</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes admin-csr.json <span class="token operator">|</span> cfssljson -bare admin</code></pre><h3 id="3-创建-kube-config文件"><a href="#3-创建-kube-config文件" class="headerlink" title="3    创建~/.kube/config文件"></a>3    创建~/.kube/config文件</h3><pre class=" language-bash"><code class="language-bash">kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials admin \  --client-certificate<span class="token operator">=</span>admin.pem \  --client-key<span class="token operator">=</span>admin-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context kubernetes \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>admin \  --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context kubernetes --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig</code></pre><h3 id="4-分发-kube-config文件"><a href="#4-分发-kube-config文件" class="headerlink" title="4    分发~/.kube/config文件"></a>4    分发~/.kube/config文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp kubectl.kubeconfig   ~/.kube/config</span><span class="token punctuation">[</span>root@k8s-master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp kubectl.kubeconfig   root@master02:~/.kube/config</span><span class="token punctuation">[</span>root@k8s-master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp kubectl.kubeconfig   root@master03:~/.kube/config</span></code></pre><h2 id="部署api-server"><a href="#部署api-server" class="headerlink" title="部署api-server"></a>部署api-server</h2><h3 id="1-创建kube-apiserver的证书签名请求"><a href="#1-创建kube-apiserver的证书签名请求" class="headerlink" title="1    创建kube-apiserver的证书签名请求"></a>1    创建kube-apiserver的证书签名请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master01<span class="token punctuation">]</span>cat <span class="token operator">></span> kubernetes-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "kubernetes",  "hosts": [    "127.0.0.1",    "172.24.150.85",    "172.24.150.86",    "172.24.150.87",    "172.24.150.90",    "47.108.21.49",    "kubernetes",    "kubernetes.default",    "kubernetes.default.svc",    "kubernetes.default.svc.cluster",    "kubernetes.default.svc.cluster.local"  ],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span>hosts 字段指定授权使用该证书的 IP 或域名列表，这里列出了 VIP 、apiserver 节点 IP、kubernetes 服务 IP 和域名；域名最后字符不能是 .<span class="token punctuation">(</span>如不能为 kubernetes.default.svc.cluster.local.<span class="token punctuation">)</span>，否则解析时失败，提示： x509: cannot parse dnsName <span class="token string">"kubernetes.default.svc.cluster.local."</span>；如果使用非 cluster.local 域名，如 bqding.com，则需要修改域名列表中的最后两个域名为：kubernetes.default.svc.bqding、kubernetes.default.svc.bqding.com</code></pre><p>生成证书和私钥:</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes kubernetes-csr.json <span class="token operator">|</span> cfssljson -bare kubernetes</code></pre><h3 id="2-将生成的证书和私钥文件拷贝到master节点："><a href="#2-将生成的证书和私钥文件拷贝到master节点：" class="headerlink" title="2     将生成的证书和私钥文件拷贝到master节点："></a>2     将生成的证书和私钥文件拷贝到master节点：</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubernetes*.pem root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@k8s-master1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubernetes*.pem root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建加密配置文件"><a href="#3-创建加密配置文件" class="headerlink" title="3    创建加密配置文件"></a>3    创建加密配置文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat > encryption-config.yaml &lt;&lt;EOF</span>kind: EncryptionConfigapiVersion: v1resources:  - resources:      - secrets    providers:      - aescbc:          keys:            - name: key1              secret: <span class="token variable"><span class="token variable">$(</span><span class="token function">head</span> -c 32 /dev/urandom <span class="token operator">|</span> base64<span class="token variable">)</span></span>      - identity: <span class="token punctuation">{</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="4-分发加密配置文件到master节点"><a href="#4-分发加密配置文件到master节点" class="headerlink" title="4    分发加密配置文件到master节点"></a>4    分发加密配置文件到master节点</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp encryption-config.yaml  root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp encryption-config.yaml  root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="5-创建kube-apiserver-systemd-unit文件"><a href="#5-创建kube-apiserver-systemd-unit文件" class="headerlink" title="5    创建kube-apiserver systemd unit文件"></a>5    创建kube-apiserver systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/kube-apiserver.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-apiserver \  --enable-admission-plugins=Initializers,NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \  --anonymous-auth=false \  --experimental-encryption-provider-config=/etc/kubernetes/cert/encryption-config.yaml \  --advertise-address=172.24.150.85 \  --bind-address=172.24.150.85 \  --insecure-port=0 \  --authorization-mode=Node,RBAC \  --runtime-config=api/all \  --enable-bootstrap-token-auth \  --service-cluster-ip-range=10.254.0.0/16 \  --service-node-port-range=30000-38700 \  --tls-cert-file=/etc/kubernetes/cert/kubernetes.pem \  --tls-private-key-file=/etc/kubernetes/cert/kubernetes-key.pem \  --client-ca-file=/etc/kubernetes/cert/ca.pem \  --kubelet-client-certificate=/etc/kubernetes/cert/kubernetes.pem \  --kubelet-client-key=/etc/kubernetes/cert/kubernetes-key.pem \  --service-account-key-file=/etc/kubernetes/cert/ca-key.pem \  --etcd-cafile=/etc/kubernetes/cert/ca.pem \  --etcd-certfile=/etc/kubernetes/cert/kubernetes.pem \  --etcd-keyfile=/etc/kubernetes/cert/kubernetes-key.pem \  --etcd-servers=https://172.24.150.85:2379,https://172.24.150.86:2379,https://172.24.150.87:2379 \  --enable-swagger-ui=true \  --allow-privileged=true \  --apiserver-count=3 \  --audit-log-maxage=30 \  --audit-log-maxbackup=3 \  --audit-log-maxsize=100 \  --audit-log-path=/var/log/kube-apiserver-audit.log \  --event-ttl=1h \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5Type=notifyLimitNOFILE=65536[Install]WantedBy=multi-user.targeEOF</span>--experimental-encryption-provider-config：启用加密特性；--authorization-mode<span class="token operator">=</span>Node,RBAC： 开启 Node 和 RBAC 授权模式，拒绝未授权的请求；--enable-admission-plugins：启用 ServiceAccount 和 NodeRestriction；--service-account-key-file：签名 ServiceAccount Token 的公钥文件，kube-controller-manager 的 --service-account-private-key-file 指定私钥文件，两者配对使用；--tls-*-file：指定 apiserver 使用的证书、私钥和 CA 文件。--client-ca-file 用于验证 client <span class="token punctuation">(</span>kue-controller-manager、kube-scheduler、kubelet、kube-proxy 等<span class="token punctuation">)</span>请求所带的证书；--kubelet-client-certificate、--kubelet-client-key：如果指定，则使用 https 访问 kubelet APIs；需要为证书对应的用户<span class="token punctuation">(</span>上面 kubernetes*.pem 证书的用户为 kubernetes<span class="token punctuation">)</span> 用户定义 RBAC 规则，否则访问 kubelet API 时提示未授权；--bind-address： 不能为 127.0.0.1，否则外界不能访问它的安全端口 6443；--insecure-port<span class="token operator">=</span>0：关闭监听非安全端口<span class="token punctuation">(</span>8080<span class="token punctuation">)</span>；--service-cluster-ip-range： 指定 Service Cluster IP 地址段；--service-node-port-range： 指定 NodePort 的端口范围；--runtime-config<span class="token operator">=</span>api/all<span class="token operator">=</span>true： 启用所有版本的 APIs，如 autoscaling/v2alpha1；--enable-bootstrap-token-auth：启用 kubelet bootstrap 的 token 认证；--apiserver-count<span class="token operator">=</span>3：指定集群运行模式，多台 kube-apiserver 会通过 leader 选举产生一个工作节点，其它节点处于阻塞状态；</code></pre><h3 id="6-分发kube-apiserver-service文件到其它master"><a href="#6-分发kube-apiserver-service文件到其它master" class="headerlink" title="6 分发kube-apiserver.service文件到其它master"></a>6 分发kube-apiserver.service文件到其它master</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-apiserver.service root@master02:/etc/systemd/system/kube-apiserver.service</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-apiserver.service root@master03:/etc/systemd/system/kube-apiserver.service</span></code></pre><h3 id="7-创建日志目录"><a href="#7-创建日志目录" class="headerlink" title="7 创建日志目录"></a>7 创建日志目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/log/kubernetes/</code></pre><h3 id="8-启动api-server服务"><a href="#8-启动api-server服务" class="headerlink" title="8 启动api-server服务"></a>8 启动api-server服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl daemon-reload<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl <span class="token function">enable</span> kube-apiserver<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl start kube-apiserver</code></pre><h3 id="9-检查api-server和集群状态"><a href="#9-检查api-server和集群状态" class="headerlink" title="9    检查api-server和集群状态"></a>9    检查api-server和集群状态</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -ptln | grep kube-apiserve</span>tcp        0      0 192.168.80.9:6443       0.0.0.0:*               LISTEN      22348/kube-apiserve<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl cluster-info</span>Kubernetes master is running at https://172.24.150.90:6443To further debug and diagnose cluster problems, use <span class="token string">'kubectl cluster-info dump'</span><span class="token keyword">.</span></code></pre><h3 id="10-授予kubernetes证书访问kubelet-api权限"><a href="#10-授予kubernetes证书访问kubelet-api权限" class="headerlink" title="10    授予kubernetes证书访问kubelet api权限"></a>10    授予kubernetes证书访问kubelet api权限</h3><pre class=" language-bash"><code class="language-bash">kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole<span class="token operator">=</span>system:kubelet-api-admin --user kubernetes</code></pre><h2 id="三-部署kube-controller-manager"><a href="#三-部署kube-controller-manager" class="headerlink" title="三  部署kube-controller-manager"></a>三  部署kube-controller-manager</h2><p>该集群包含 3 个节点，启动后将通过竞争选举机制产生一个 leader 节点，其它节点为阻塞状态。当 leader 节点不可用后，剩余节点将再次进行选举产生新的 leader 节点，从而保证服务的可用性。<br>为保证通信安全，本文档先生成 x509 证书和私钥，kube-controller-manager 在如下两种情况下使用该证书：<br>与 kube-apiserver 的安全端口通信时;<br>在安全端口(https，10252) 输出 prometheus 格式的 metrics；</p><h3 id="1-创建kube-controller-manager证书请求"><a href="#1-创建kube-controller-manager证书请求" class="headerlink" title="1    创建kube-controller-manager证书请求"></a>1    创建kube-controller-manager证书请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>cat <span class="token operator">></span> kube-controller-manager-csr.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF{    "CN": "system:kube-controller-manager",    "key": {        "algo": "rsa",        "size": 2048    },    "hosts": [      "127.0.0.1",      "172.24.150.85",      "172.24.150.86",      "172.24.150.87"    ],    "names": [      {        "C": "CN",        "ST": "BeiJing",        "L": "BeiJing",        "O": "system:kube-controller-manager",        "OU": "yunwei"      }    ]}EOF</span>hosts 列表包含所有 kube-controller-manager 节点 IP；CN 为 system:kube-controller-manager、O 为 system:kube-controller-manager，kubernetes 内置的 ClusterRoleBindings system:kube-controller-manager 赋予 kube-controller-manager 工作所需的权限。</code></pre><p>生成证书和私钥：</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes kube-controller-manager-csr.json <span class="token operator">|</span> cfssljson -bare kube-controller-manager</code></pre><h3 id="2-将生成的证书和私钥分发到所有master节点"><a href="#2-将生成的证书和私钥分发到所有master节点" class="headerlink" title="2 将生成的证书和私钥分发到所有master节点"></a>2 将生成的证书和私钥分发到所有master节点</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager*.pem root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager*.pem root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建和分发kubeconfig文件"><a href="#3-创建和分发kubeconfig文件" class="headerlink" title="3 创建和分发kubeconfig文件"></a>3 创建和分发kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash">kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfigkubectl config set-credentials system:kube-controller-manager \  --client-certificate<span class="token operator">=</span>kube-controller-manager.pem \  --client-key<span class="token operator">=</span>kube-controller-manager-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfigkubectl config set-context system:kube-controller-manager \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>system:kube-controller-manager \  --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfigkubectl config use-context system:kube-controller-manager --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfig</code></pre><p>分发kube-controller-manager.kubeconfig到master02、master03节点</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager.kubeconfig root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager.kubeconfig root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="4-创建和分发kube-controller-manager-systemd-unit文件"><a href="#4-创建和分发kube-controller-manager-systemd-unit文件" class="headerlink" title="4    创建和分发kube-controller-manager systemd unit文件"></a>4    创建和分发kube-controller-manager systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span>cat <span class="token operator">></span> /etc/systemd/system/kube-controller-manager.service  <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-controller-manager \  --address=127.0.0.1 \  --kubeconfig=/etc/kubernetes/cert/kube-controller-manager.kubeconfig \  --authentication-kubeconfig=/etc/kubernetes/cert/kube-controller-manager.kubeconfig \  --service-cluster-ip-range=10.254.0.0/16 \  --cluster-name=kubernetes \  --cluster-signing-cert-file=/etc/kubernetes/cert/ca.pem \  --cluster-signing-key-file=/etc/kubernetes/cert/ca-key.pem \  --experimental-cluster-signing-duration=8760h \  --root-ca-file=/etc/kubernetes/cert/ca.pem \  --service-account-private-key-file=/etc/kubernetes/cert/ca-key.pem \  --leader-elect=true \  --feature-gates=RotateKubeletServerCertificate=true \  --controllers=*,bootstrapsigner,tokencleaner \  --horizontal-pod-autoscaler-use-rest-clients=true \  --horizontal-pod-autoscaler-sync-period=10s \  --tls-cert-file=/etc/kubernetes/cert/kube-controller-manager.pem \  --tls-private-key-file=/etc/kubernetes/cert/kube-controller-manager-key.pem \  --use-service-account-credentials=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=onRestart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span>--address：指定监听的地址为127.0.0.1--kubeconfig：指定 kubeconfig 文件路径，kube-controller-manager 使用它连接和验证 kube-apiserver；--cluster-signing-*-file：签名 TLS Bootstrap 创建的证书；--experimental-cluster-signing-duration：指定 TLS Bootstrap 证书的有效期；--root-ca-file：放置到容器 ServiceAccount 中的 CA 证书，用来对 kube-apiserver 的证书进行校验；--service-account-private-key-file：签名 ServiceAccount 中 Token 的私钥文件，必须和 kube-apiserver 的 --service-account-key-file 指定的公钥文件配对使用；--service-cluster-ip-range ：指定 Service Cluster IP 网段，必须和 kube-apiserver 中的同名参数一致；--leader-elect<span class="token operator">=</span>true：集群运行模式，启用选举功能；被选为 leader 的节点负责处理工作，其它节点为阻塞状态；--feature-gates<span class="token operator">=</span>RotateKubeletServerCertificate<span class="token operator">=</span>true：开启 kublet server 证书的自动更新特性；--controllers<span class="token operator">=</span>*,bootstrapsigner,tokencleaner：启用的控制器列表，tokencleaner 用于自动清理过期的 Bootstrap token；--horizontal-pod-autoscaler-*：custom metrics 相关参数，支持 autoscaling/v2alpha1；--tls-cert-file、--tls-private-key-file：使用 https 输出 metrics 时使用的 Server 证书和秘钥；--use-service-account-credentials<span class="token operator">=</span>true:</code></pre><p>分发kube-controller-manager systemd unit文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-controller-manager.service root@master02:/etc/systemd/system/kube-controller-manager.service</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-controller-manager.service root@master03:/etc/systemd/system/kube-controller-manager.service</span></code></pre><h3 id="5-启动kube-controller-manager服务"><a href="#5-启动kube-controller-manager服务" class="headerlink" title="5    启动kube-controller-manager服务"></a>5    启动kube-controller-manager服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable kube-controller-manager &amp;&amp; systemctl start kube-controller-manager</span></code></pre><h3 id="6-检查kube-controller-manager服务"><a href="#6-检查kube-controller-manager服务" class="headerlink" title="6    检查kube-controller-manager服务"></a>6    检查kube-controller-manager服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lnpt|grep kube-controll</span>tcp        0      0 127.0.0.1:10252         0.0.0.0:*               LISTEN      17906/kube-controll tcp6       0      0 :::10257                :::*                    LISTEN      17906/kube-controll</code></pre><h3 id="7-查看当前kube-controller-manager的leader"><a href="#7-查看当前kube-controller-manager的leader" class="headerlink" title="7 查看当前kube-controller-manager的leader"></a>7 查看当前kube-controller-manager的leader</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  kubectl get endpoints kube-controller-manager --namespace=kube-system  -o yaml</span>apiVersion: v1kind: Endpointsmetadata:  annotations:    control-plane.alpha.kubernetes.io/leader: <span class="token string">'{"holderIdentity":"master03_318c0152-a096-11e9-a701-00163e0134cf","leaseDurationSeconds":15,"acquireTime":"2019-07-08T02:25:14Z","renewTime":"2019-07-09T14:40:23Z","leaderTransitions":1}'</span>  creationTimestamp: 2019-07-07T09:04:06Z  name: kube-controller-manager  namespace: kube-system  resourceVersion: <span class="token string">"248855"</span>  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-controller-manager  uid: 2caad7f6-a096-11e9-9fca-00163e0132fb</code></pre><p>当前leader为master03节点</p><h2 id="四-部署kube-scheduler"><a href="#四-部署kube-scheduler" class="headerlink" title="四    部署kube-scheduler"></a>四    部署kube-scheduler</h2><p>该集群包含 3 个节点，启动后将通过竞争选举机制产生一个 leader 节点，其它节点为阻塞状态。当 leader 节点不可用后，剩余节点将再次进行选举产生新的 leader 节点，从而保证服务的可用性。<br>为保证通信安全，本文档先生成 x509 证书和私钥，kube-scheduler 在如下两种情况下使用该证书：<br>1 与 kube-apiserver 的安全端口通信;<br>2 在安全端口(https，10251) 输出 prometheus 格式的 metrics；</p><h3 id="1-创建kube-scheduler证书请求"><a href="#1-创建kube-scheduler证书请求" class="headerlink" title="1 创建kube-scheduler证书请求"></a>1 创建kube-scheduler证书请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span>cat <span class="token operator">></span> kube-scheduler-csr.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF{    "CN": "system:kube-scheduler",    "hosts": [      "127.0.0.1",      "172.24.150.85",      "172.24.150.86",      "172.24.150.87"    ],    "key": {        "algo": "rsa",        "size": 2048    },    "names": [      {        "C": "CN",        "ST": "BeiJing",        "L": "BeiJing",        "O": "system:kube-scheduler",        "OU": "yunwei"      }    ]}EOF</span>hosts 列表包含所有 kube-scheduler 节点 IP；CN 为 system:kube-scheduler、O 为 system:kube-scheduler，kubernetes 内置的 ClusterRoleBindings system:kube-scheduler 将赋予 kube-scheduler 工作所需的权限。</code></pre><p>生成证书和私钥：<br>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem <br>  -ca-key=/etc/kubernetes/cert/ca-key.pem <br>  -config=/etc/kubernetes/cert/ca-config.json <br>  -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler</p><h3 id="2-创建和分发kube-scheduler-kubeconfig文件"><a href="#2-创建和分发kube-scheduler-kubeconfig文件" class="headerlink" title="2    创建和分发kube-scheduler.kubeconfig文件"></a>2    创建和分发kube-scheduler.kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config set-cluster kubernetes \      --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \      --embed-certs<span class="token operator">=</span>true \      --server<span class="token operator">=</span>https://172.24.150.90:6443 \      --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig<span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config set-credentials system:kube-scheduler \  --client-certificate<span class="token operator">=</span>kube-scheduler.pem \  --client-key<span class="token operator">=</span>kube-scheduler-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig<span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config set-context system:kube-scheduler \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>system:kube-scheduler \  --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig<span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config use-context system:kube-scheduler --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig上一步创建的证书、私钥以及 kube-apiserver 地址被写入到 kubeconfig 文件中；</code></pre><p>分发kubeconfig到master02、master03节点</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-scheduler.kubeconfig root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-scheduler.kubeconfig root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建和分发kube-scheduler-systemd-unit文件"><a href="#3-创建和分发kube-scheduler-systemd-unit文件" class="headerlink" title="3    创建和分发kube-scheduler systemd unit文件"></a>3    创建和分发kube-scheduler systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/kube-scheduler.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-scheduler \  --address=127.0.0.1 \  --kubeconfig=/etc/kubernetes/cert/kube-scheduler.kubeconfig \  --leader-elect=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span>--address：在 127.0.0.1:10251 端口接收 http /metrics 请求；kube-scheduler 目前还不支持接收 https 请求；--kubeconfig：指定 kubeconfig 文件路径，kube-scheduler 使用它连接和验证 kube-apiserver；--leader-elect<span class="token operator">=</span>true：集群运行模式，启用选举功能；被选为 leader 的节点负责处理工作，其它节点为阻塞状态；</code></pre><p>分发 systemd unit 文件到所有 master 节点：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-scheduler.service master02:/etc/systemd/system/kube-scheduler.service</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-scheduler.service master03:/etc/systemd/system/kube-scheduler.service</span></code></pre><h3 id="4-启动kube-scheduler服务"><a href="#4-启动kube-scheduler服务" class="headerlink" title="4    启动kube-scheduler服务"></a>4    启动kube-scheduler服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl daemon-reload <span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl <span class="token function">enable</span> kube-scheduler <span class="token operator">&amp;&amp;</span> systemctl start kube-scheduler</code></pre><h3 id="5-查看kube-scheduler运行监听端口"><a href="#5-查看kube-scheduler运行监听端口" class="headerlink" title="5    查看kube-scheduler运行监听端口"></a>5    查看kube-scheduler运行监听端口</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lnpt|grep kube-scheduler</span>tcp        0      0 127.0.0.1:10251         0.0.0.0:*               LISTEN      17921/kube-schedule</code></pre><h3 id="6-查看当前kube-scheduler的leader"><a href="#6-查看当前kube-scheduler的leader" class="headerlink" title="6    查看当前kube-scheduler的leader"></a>6    查看当前kube-scheduler的leader</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get endpoints kube-scheduler --namespace=kube-system  -o yaml</span>apiVersion: v1kind: Endpointsmetadata:  annotations:    control-plane.alpha.kubernetes.io/leader: <span class="token string">'{"holderIdentity":"master03_3e7bc3fc-a097-11e9-ba09-00163e0134cf","leaseDurationSeconds":15,"acquireTime":"2019-07-08T02:24:52Z","renewTime":"2019-07-09T14:51:37Z","leaderTransitions":1}'</span>  creationTimestamp: 2019-07-07T09:11:31Z  name: kube-scheduler  namespace: kube-system  resourceVersion: <span class="token string">"249869"</span>  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-scheduler  uid: 35b657c6-a097-11e9-8e39-00163e01366e</code></pre><p>可见当前的leader为master03节点</p><h2 id="七-在master01、master02、master03节点上验证功能是否正常"><a href="#七-在master01、master02、master03节点上验证功能是否正常" class="headerlink" title="七    在master01、master02、master03节点上验证功能是否正常"></a>七    在master01、master02、master03节点上验证功能是否正常</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   <span class="token punctuation">[</span>root@master02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get componentstatuses</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   <span class="token punctuation">[</span>root@master03 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORscheduler            Healthy   ok                  controller-manager   Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><h2 id="八-haproxy做3master节点的高可用-未做keepalived的心跳检测"><a href="#八-haproxy做3master节点的高可用-未做keepalived的心跳检测" class="headerlink" title="八 haproxy做3master节点的高可用(未做keepalived的心跳检测)"></a>八 haproxy做3master节点的高可用(未做keepalived的心跳检测)</h2><p>haproxy 监听 haproxyharbor主机的6443端口，后端连接所有 kube-apiserver 实例，提供健康检查和负载均衡功能</p><h3 id="1-haproxyharbor主机安装haproxy"><a href="#1-haproxyharbor主机安装haproxy" class="headerlink" title="1     haproxyharbor主机安装haproxy"></a>1     haproxyharbor主机安装haproxy</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@haproxyharbor ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /etc/haproxy/ &amp;&amp; mv haproxy.cfg haproxy.cfg.bak &amp;&amp; cat >/etc/haproxy/haproxy.cfg &lt;&lt;EOF</span>global    log /dev/log    local0    log /dev/log    local1 notice    <span class="token function">chroot</span> /var/lib/haproxy    stats socket /var/run/haproxy-admin.sock mode 660 level admin    stats <span class="token function">timeout</span> 30s    user haproxy    group haproxy    daemon    nbproc 1defaults    log     global    <span class="token function">timeout</span> connect 5000    <span class="token function">timeout</span> client  10m    <span class="token function">timeout</span> server  10mlisten  admin_stats    bind 0.0.0.0:10080    mode http    log 127.0.0.1 local0 err    stats refresh 30s    stats uri /status    stats realm welcome login\ Haproxy    stats auth admin:123456    stats hide-version    stats admin <span class="token keyword">if</span> TRUElisten kube-master    bind 0.0.0.0:6443    mode tcp    option tcplog    balance roundrobin    server master01 172.24.150.85:6443 check inter 2000 fall 2 rise 2 weight 1    server master02 172.24.150.86:6443 check inter 2000 fall 2 rise 2 weight 1    server master03 172.24.150.87:6443 check inter 2000 fall 2 rise 2 weight 1EOFhaproxy 在 10080 端口输出 status 信息；haproxy 监听该主机上所有接口的 6443 端口，该端口与环境变量 <span class="token variable">${KUBE_APISERVER}</span> 指定的端口必须一致；server 字段列出所有 kube-apiserver 监听的 IP 和端口；</code></pre><h3 id="2-启动haproxy服务"><a href="#2-启动haproxy服务" class="headerlink" title="2    启动haproxy服务"></a>2    启动haproxy服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@haproxyharbor ~<span class="token punctuation">]</span> systemctl <span class="token function">enable</span> haproxy <span class="token operator">&amp;&amp;</span> systemctl start haproxy</code></pre><h3 id="3-查看haproxy的服务状态："><a href="#3-查看haproxy的服务状态：" class="headerlink" title="3    查看haproxy的服务状态："></a>3    查看haproxy的服务状态：</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@haproxyharbor ~<span class="token punctuation">]</span> systemctl status haproxy<span class="token operator">|</span><span class="token function">grep</span> Active</code></pre><p>###################################################################</p><h1 id="对node01、node02节点部署k8s-node服务"><a href="#对node01、node02节点部署k8s-node服务" class="headerlink" title="对node01、node02节点部署k8s node服务"></a>对node01、node02节点部署k8s node服务</h1><p>kubernetes work节点运行如下组件：docker、kubelet、kube-proxy、flannel</p><h2 id="一-安装依赖包-node01和node02都安装"><a href="#一-安装依赖包-node01和node02都安装" class="headerlink" title="一    安装依赖包(node01和node02都安装)"></a>一    安装依赖包(node01和node02都安装)</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span>yum <span class="token function">install</span> -y epel-release <span class="token function">wget</span> conntrack ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token operator">&amp;&amp;</span> /usr/sbin/modprobe ip_vs<span class="token punctuation">[</span>root@node02 ~<span class="token punctuation">]</span>yum <span class="token function">install</span> -y epel-release <span class="token function">wget</span> conntrack ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token operator">&amp;&amp;</span> /usr/sbin/modprobe ip_vs</code></pre><h2 id="二-部署kubelet组件"><a href="#二-部署kubelet组件" class="headerlink" title="二     部署kubelet组件"></a>二     部署kubelet组件</h2><p>kublet 运行在每个 worker 节点上，接收 kube-apiserver 发送的请求，管理 Pod 容器，执行交互式命令，如 exec、run、logs 等。<br>kublet 启动时自动向 kube-apiserver 注册节点信息，内置的 cadvisor 统计和监控节点的资源使用情况。<br>为确保安全，本文档只开启接收 https 请求的安全端口，对请求进行认证和授权，拒绝未授权的访问(如 apiserver、heapster)。</p><h3 id="1-下载和分发kubelet二进制文件"><a href="#1-下载和分发kubelet二进制文件" class="headerlink" title="1    下载和分发kubelet二进制文件"></a>1    下载和分发kubelet二进制文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">wget</span> https://dl.k8s.io/v1.12.3/kubernetes-server-linux-amd64.tar.gz<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">tar</span> -xzvf kubernetes-server-linux-amd64.tar.gz<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">cp</span> kubernetes/server/bin/<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">cp</span> kubelet kube-proxy /usr/local/bin<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">scp</span>  kubelet kube-proxy root@node01:/usr/local/bin<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">scp</span>  kubelet kube-proxy root@node02:/usr/local/bin</code></pre><h3 id="2-创建kubelet-bootstrap-kubeconfig文件-master01执行"><a href="#2-创建kubelet-bootstrap-kubeconfig文件-master01执行" class="headerlink" title="2    创建kubelet bootstrap kubeconfig文件(master01执行)"></a>2    创建kubelet bootstrap kubeconfig文件(master01执行)</h3><p>###################由于我是两个node(node01,node02)节点只需创建两个token就可以了##################################</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#创建 token</span><span class="token function">export</span> BOOTSTRAP_TOKEN<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>kubeadm token create \  --description kubelet-bootstrap-token \  --groups system:bootstrappers:master01 \  --kubeconfig ~/.kube/config<span class="token variable">)</span></span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># export BOOTSTRAP_TOKEN=$(kubeadm token create \</span><span class="token operator">></span>   --description kubelet-bootstrap-token \<span class="token operator">></span>   --groups system:bootstrappers:master01 \<span class="token operator">></span>   --kubeconfig ~/.kube/config<span class="token punctuation">)</span>I0709 20:02:07.166974   29695 version.go:93<span class="token punctuation">]</span> could not fetch a Kubernetes version from the internet: unable to get URL <span class="token string">"https://dl.k8s.io/release/stable-1.txt"</span><span class="token keyword">:</span> Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled <span class="token keyword">while</span> waiting <span class="token keyword">for</span> connection <span class="token punctuation">(</span>Client.Timeout exceeded <span class="token keyword">while</span> awaiting headers<span class="token punctuation">)</span>I0709 20:02:07.167046   29695 version.go:94<span class="token punctuation">]</span> falling back to the local client version: v1.12.3<span class="token comment" spellcheck="true">##暂时不用理会这继续往下执行  </span><span class="token comment" spellcheck="true"># 设置集群参数</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials kubelet-bootstrap \  --token<span class="token operator">=</span><span class="token variable">${BOOTSTRAP_TOKEN}</span> \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kubelet-bootstrap \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true">##########################################################################</span><span class="token comment" spellcheck="true">#创建 token</span><span class="token function">export</span> BOOTSTRAP_TOKEN<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>kubeadm token create \  --description kubelet-bootstrap-token \  --groups system:bootstrappers:master02 \  --kubeconfig ~/.kube/config<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 设置集群参数</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials kubelet-bootstrap \  --token<span class="token operator">=</span><span class="token variable">${BOOTSTRAP_TOKEN}</span> \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kubelet-bootstrap \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfigkubelet-bootstrap-master0x.kubeconfig文件创建两次，分别为改成kubelet-bootstrap-master01.kubeconfig,kubelet-bootstrap-master02.kubeconfig证书中写入 Token 而非证书，证书后续由 controller-manager 创建。</code></pre><p>##########################################################################################<br>#创建 token</p><p>注意补充：</p><pre class=" language-bash"><code class="language-bash">使用kubeadm安装需要下载相关的镜像，可以使用以下命令查看<span class="token punctuation">[</span>root@master01 bin<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm config images list</span>I0707 19:23:47.877237   13023 version.go:93<span class="token punctuation">]</span> could not fetch a Kubernetes version from the internet: unable to get URL <span class="token string">"https://dl.k8s.io/release/stable-1.txt"</span><span class="token keyword">:</span> Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled <span class="token keyword">while</span> waiting <span class="token keyword">for</span> connection <span class="token punctuation">(</span>Client.Timeout exceeded <span class="token keyword">while</span> awaiting headers<span class="token punctuation">)</span>I0707 19:23:47.877324   13023 version.go:94<span class="token punctuation">]</span> falling back to the local client version: v1.12.3k8s.gcr.io/kube-apiserver:v1.12.3k8s.gcr.io/kube-controller-manager:v1.12.3k8s.gcr.io/kube-scheduler:v1.12.3k8s.gcr.io/kube-proxy:v1.12.3k8s.gcr.io/pause:3.1k8s.gcr.io/etcd:3.2.24k8s.gcr.io/coredns:1.2.2<span class="token comment" spellcheck="true"># 先在墙外的一台服务器上下载好需要的镜像，然后打tag标签，上传到自己的dockerhub上，再在墙内机器上下载，然后在反打回标签就可以了</span><span class="token punctuation">[</span>root@li1891-184 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker images</span>REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZEcntsp/kube-proxy                     v1.12.3             ab97fa69b926        7 months ago        96.5MBk8s.gcr.io/kube-proxy                v1.12.3             ab97fa69b926        7 months ago        96.5MBcntsp/kube-apiserver                 v1.12.3             6b54f7bebd72        7 months ago        194MBk8s.gcr.io/kube-apiserver            v1.12.3             6b54f7bebd72        7 months ago        194MBcntsp/kube-controller-manager        v1.12.3             c79022eb8bc9        7 months ago        164MBk8s.gcr.io/kube-controller-manager   v1.12.3             c79022eb8bc9        7 months ago        164MBcntsp/kube-scheduler                 v1.12.3             5e75513787b1        7 months ago        58.3MBk8s.gcr.io/kube-scheduler            v1.12.3             5e75513787b1        7 months ago        58.3MBcntsp/etcd                           3.2.24              3cab8e1b9802        9 months ago        220MBk8s.gcr.io/etcd                      3.2.24              3cab8e1b9802        9 months ago        220MBcntsp/coredns                        1.2.2               367cdc8433a4        10 months ago       39.2MBk8s.gcr.io/coredns                   1.2.2               367cdc8433a4        10 months ago       39.2MBcntsp/pause                          3.1                 da86e6ba6ca1        18 months ago       742kBk8s.gcr.io/pause                     3.1                 da86e6ba6ca1        18 months ago       742kBdocker tag cntsp/kube-proxy:v1.12.3  k8s.gcr.io/kube-proxy:v1.12.3docker tag cntsp/kube-apiserver:v1.12.3 k8s.gcr.io/kube-apiserver:v1.12.3docker tag cntsp/kube-controller-manager:v1.12.3 k8s.gcr.io/kube-controller-manager:v1.12.3docker tag cntsp/kube-scheduler:v1.12.3  k8s.gcr.io/kube-scheduler:v1.12.3docker tag cntsp/etcd:3.2.24  k8s.gcr.io/etcd:3.2.24docker tag cntsp/coredns:1.2.2  k8s.gcr.io/coredns:1.2.3docker tag cntsp/pause:3.1  k8s.gcr.io/pause:3.1</code></pre><h3 id="3-查看kubeadm为各个节点创建的token"><a href="#3-查看kubeadm为各个节点创建的token" class="headerlink" title="3    查看kubeadm为各个节点创建的token:"></a>3    查看kubeadm为各个节点创建的token:</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm token list --kubeconfig ~/.kube/config</span>TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION               EXTRA GROUPS5hdpcv.oov1vb6p2pdsk9cj   19h         2019-07-10T20:02:07+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01    5la9kt.rg86oqup9lmh8mc3   20h         2019-07-10T20:54:04+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master03        <span class="token comment" spellcheck="true">##</span>7pmf04.7exbjzt4e0mqb1k6   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-07-08T19:14:17+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master018thsbu.kczv9cg4p18qc1uh   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-07-08T23:53:33+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01a2480e.fcpm6md4y3auhlbj   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-07-08T18:01:24+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01broru2.ntzhoupwbokulsgy   20h         2019-07-10T20:50:56+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01        <span class="token comment" spellcheck="true">##</span>ovf435.wx9o306i9sof1ztm   20h         2019-07-10T20:53:12+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master02        <span class="token comment" spellcheck="true">##</span>创建的 token 有效期为 1 天，超期后将不能再被使用，且会被 kube-controller-manager 的 tokencleaner 清理<span class="token punctuation">(</span>如果启用该 controller 的话<span class="token punctuation">)</span>；kube-apiserver 接收 kubelet 的 bootstrap token 后，将请求的 user 设置为 system:bootstrap:，group 设置为 system:bootstrappers</code></pre><p>查看各token关联的Secret</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get secrets  -n kube-system</span>NAME                                             TYPE                                  DATA   AGEattachdetach-controller-token-pmwks              kubernetes.io/service-account-token   3      2d7hbootstrap-signer-token-fz6jp                     kubernetes.io/service-account-token   3      2d7hbootstrap-token-0a7w0g                           bootstrap.kubernetes.io/token         7      2d4hbootstrap-token-2w1i45                           bootstrap.kubernetes.io/token         7      2d6hbootstrap-token-2xbl5i                           bootstrap.kubernetes.io/token         7      6h28mbootstrap-token-5hdpcv                           bootstrap.kubernetes.io/token         7      4h36mbootstrap-token-5la9kt                           bootstrap.kubernetes.io/token         7      3h44mbootstrap-token-7pmf04                           bootstrap.kubernetes.io/token         7      2d5hbootstrap-token-8thsbu                           bootstrap.kubernetes.io/token         7      2dbootstrap-token-a2480e                           bootstrap.kubernetes.io/token         7      2d6hbootstrap-token-broru2                           bootstrap.kubernetes.io/token         7      3h47mbootstrap-token-bz7en0                           bootstrap.kubernetes.io/token         7      2d4hbootstrap-token-cssc84                           bootstrap.kubernetes.io/token         7      2d7hbootstrap-token-iau28s                           bootstrap.kubernetes.io/token         7      2d7hbootstrap-token-iufp5a                           bootstrap.kubernetes.io/token         7      2d4hbootstrap-token-ovf435                           bootstrap.kubernetes.io/token         7      3h45mbootstrap-token-tv8p15                           bootstrap.kubernetes.io/token         7      37hbootstrap-token-wj6vmg                           bootstrap.kubernetes.io/token         7      2d4hcertificate-controller-token-gh8qq               kubernetes.io/service-account-token   3      2d7hclusterrole-aggregation-controller-token-4nsb7   kubernetes.io/service-account-token   3      2d7hcronjob-controller-token-l95gw                   kubernetes.io/service-account-token   3      2d7hdaemon-set-controller-token-4d5wk                kubernetes.io/service-account-token   3      2d7hdefault-token-p5gvt                              kubernetes.io/service-account-token   3      2d7hdeployment-controller-token-jlnhh                kubernetes.io/service-account-token   3      2d7hdisruption-controller-token-xgt7n                kubernetes.io/service-account-token   3      2d7hendpoint-controller-token-jgr6r                  kubernetes.io/service-account-token   3      2d7hexpand-controller-token-lhbpc                    kubernetes.io/service-account-token   3      2d7hgeneric-garbage-collector-token-6t9mt            kubernetes.io/service-account-token   3      2d7hhorizontal-pod-autoscaler-token-f7zvp            kubernetes.io/service-account-token   3      2d7hjob-controller-token-5bq5b                       kubernetes.io/service-account-token   3      2d7hnamespace-controller-token-vcp7v                 kubernetes.io/service-account-token   3      2d7hnode-controller-token-kzjgc                      kubernetes.io/service-account-token   3      2d7hpersistent-volume-binder-token-2sz49             kubernetes.io/service-account-token   3      2d7hpod-garbage-collector-token-nw6ck                kubernetes.io/service-account-token   3      2d7hpv-protection-controller-token-jg9rq             kubernetes.io/service-account-token   3      2d7hpvc-protection-controller-token-bj5c7            kubernetes.io/service-account-token   3      2d7hreplicaset-controller-token-jv5r5                kubernetes.io/service-account-token   3      2d7hreplication-controller-token-5nfzh               kubernetes.io/service-account-token   3      2d7hresourcequota-controller-token-dpzk9             kubernetes.io/service-account-token   3      2d7hservice-account-controller-token-qxflv           kubernetes.io/service-account-token   3      2d7hservice-controller-token-8bhkb                   kubernetes.io/service-account-token   3      2d7hstatefulset-controller-token-sms2q               kubernetes.io/service-account-token   3      2d7htoken-cleaner-token-85hbw                        kubernetes.io/service-account-token   3      2d7httl-controller-token-zdwb4                       kubernetes.io/service-account-token   3      2d7h</code></pre><h3 id="4-分发bootstrap-kubeconfig文件"><a href="#4-分发bootstrap-kubeconfig文件" class="headerlink" title="4    分发bootstrap kubeconfig文件"></a>4    分发bootstrap kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubelet-bootstrap-master01.kubeconfig root@node01:/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig</span><span class="token punctuation">[</span>root@master1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubelet-bootstrap-master02.kubeconfig root@node02:/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig</span></code></pre><h3 id="5-创建和分发kubelet参数配置文件"><a href="#5-创建和分发kubelet参数配置文件" class="headerlink" title="5    创建和分发kubelet参数配置文件"></a>5    创建和分发kubelet参数配置文件</h3><p>创建 kubelet 参数配置模板文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>cat <span class="token operator">></span> kubelet.config.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "kind": "KubeletConfiguration",  "apiVersion": "kubelet.config.k8s.io/v1beta1",  "authentication": {    "x509": {      "clientCAFile": "/etc/kubernetes/cert/ca.pem"    },    "webhook": {      "enabled": true,      "cacheTTL": "2m0s"    },    "anonymous": {      "enabled": false    }  },  "authorization": {    "mode": "Webhook",    "webhook": {      "cacheAuthorizedTTL": "5m0s",      "cacheUnauthorizedTTL": "30s"    }  },  "address": "172.24.150.88",  "port": 10250,  "readOnlyPort": 0,  "cgroupDriver": "cgroupfs",  "hairpinMode": "promiscuous-bridge",  "serializeImagePulls": false,  "featureGates": {    "RotateKubeletClientCertificate": true,    "RotateKubeletServerCertificate": true  },  "clusterDomain": "cluster.local.",  "clusterDNS": ["10.254.0.2"]}EOF</span>address：API 监听地址，不能为 127.0.0.1，否则 kube-apiserver、heapster 等不能调用 kubelet 的 API；readOnlyPort<span class="token operator">=</span>0：关闭只读端口<span class="token punctuation">(</span>默认 10255<span class="token punctuation">)</span>，等效为未指定；authentication.anonymous.enabled：设置为 false，不允许匿名?访问 10250 端口；authentication.x509.clientCAFile：指定签名客户端证书的 CA 证书，开启 HTTP 证书认证；authentication.webhook.enabled<span class="token operator">=</span>true：开启 HTTPs bearer token 认证；对于未通过 x509 证书和 webhook 认证的请求<span class="token punctuation">(</span>kube-apiserver 或其他客户端<span class="token punctuation">)</span>，将被拒绝，提示 Unauthorized；authroization.mode<span class="token operator">=</span>Webhook：kubelet 使用 SubjectAccessReview API 查询 kube-apiserver 某 user、group 是否具有操作资源的权限<span class="token punctuation">(</span>RBAC<span class="token punctuation">)</span>；featureGates.RotateKubeletClientCertificate、featureGates.RotateKubeletServerCertificate：自动 rotate 证书，证书的有效期取决于 kube-controller-manager 的 --experimental-cluster-signing-duration 参数；需要 root 账户运行；</code></pre><p>为node01、node02分发kubelet配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>scp kubelet.config.json root@node01:/etc/kubernetes/cert/kubelet.config.json<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>scp kubelet.config.json root@node02:/etc/kubernetes/cert/kubelet.config.json</code></pre><h3 id="6-创建和分发kubelet-systemd-unit文件"><a href="#6-创建和分发kubelet-systemd-unit文件" class="headerlink" title="6     创建和分发kubelet systemd unit文件"></a>6     创建和分发kubelet systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/systemd/system/kubelet.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Kubernetes KubeletDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletExecStart=/usr/local/bin/kubelet \  --bootstrap-kubeconfig=/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig \  --cert-dir=/etc/kubernetes/cert \  --kubeconfig=/etc/kubernetes/cert/kubelet.kubeconfig \  --config=/etc/kubernetes/cert/kubelet.config.json \  --hostname-override=172.24.150.89 \  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1 \  --allow-privileged=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span>如果设置了 --hostname-override 选项，则 kube-proxy 也需要设置该选项，否则会出现找不到 Node 的情况；--bootstrap-kubeconfig：指向 bootstrap kubeconfig 文件，kubelet 使用该文件中的用户名和 token 向 kube-apiserver 发送 TLS Bootstrapping 请求；K8S approve kubelet 的 csr 请求后，在 --cert-dir 目录创建证书和私钥文件，然后写入 --kubeconfig 文件；</code></pre><h3 id="7-Bootstrap-Token-Auth和授予权限"><a href="#7-Bootstrap-Token-Auth和授予权限" class="headerlink" title="7    Bootstrap Token Auth和授予权限"></a>7    Bootstrap Token Auth和授予权限</h3><p>kublet 启动时查找配置的 –kubeletconfig 文件是否存在，如果不存在则使用 –bootstrap-kubeconfig 向 kube-apiserver 发送证书签名请求 (CSR)。<br>kube-apiserver 收到 CSR 请求后，对其中的 Token 进行认证（事先使用 kubeadm 创建的 token），认证通过后将请求的 user 设置为 system:bootstrap:，group 设置为 system:bootstrappers，这一过程称为 Bootstrap Token Auth。<br>默认情况下，这个 user 和 group 没有创建 CSR 的权限，kubelet 启动失败，错误日志如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> journalctl -u kubelet -a <span class="token operator">|</span><span class="token function">grep</span> -A 2 <span class="token string">'certificatesigningrequests'</span>july 06 06:42:36 kube-node1 kubelet<span class="token punctuation">[</span>26986<span class="token punctuation">]</span>: F0506 06:42:36.314378   26986 server.go:233<span class="token punctuation">]</span> failed to run Kubelet: cannot create certificate signing request: certificatesigningrequests.certificates.k8s.io is forbidden: User <span class="token string">"system:bootstrap:lemy40"</span> cannot create certificatesigningrequests.certificates.k8s.io at the cluster scopejuly 06 06:42:36 node01 systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: kubelet.service: Main process exited, code<span class="token operator">=</span>exited, status<span class="token operator">=</span>255/n/ajuly 06 06:42:36 node01 systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: kubelet.service: Failed with result <span class="token string">'exit-code'</span><span class="token keyword">.</span></code></pre><p>解决办法是：创建一个 clusterrolebinding，将 group system:bootstrappers 和 clusterrole system:node-bootstrapper 绑定：</p><pre class=" language-bash"><code class="language-bash">root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --group=system:bootstrappers</span></code></pre><h3 id="8-启动kubelet服务"><a href="#8-启动kubelet服务" class="headerlink" title="8    启动kubelet服务"></a>8    启动kubelet服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/log/kubernetes <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> -p /var/lib/kubeletsystemctl daemon-reload systemctl <span class="token function">enable</span> kubelet systemctl restart kubelet</code></pre><p>关闭 swap 分区，否则 kubelet 会启动失败；<br>必须先创建工作和日志目录；<br>kubelet 启动后使用 –bootstrap-kubeconfig 向 kube-apiserver 发送 CSR 请求，当这个 CSR 被 approve 后，kube-controller-manager 为 kubelet 创建 TLS 客户端证书、私钥和 –kubeletconfig 文件。<br>注意：kube-controller-manager 需要配置 –cluster-signing-cert-file 和 –cluster-signing-key-file 参数，才会为 TLS Bootstrap 创建证书和私钥。<br>两个 node 节点的 csr 均处于 pending 状态；<br>** 此时kubelet的进程有，但是监听端口还未启动，需要进行下面步骤！**</p><h3 id="9-approve-kubelet-csr请求"><a href="#9-approve-kubelet-csr请求" class="headerlink" title="9    approve kubelet csr请求"></a>9    approve kubelet csr请求</h3><p>可以手动或自动 approve CSR 请求,** 推荐使用自动的方式**，因为从 v1.8 版本开始，可以自动轮转approve csr 后生成的证书。<br>i、手动approve csr请求<br>查看 CSR 列表:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE   REQUESTOR                 CONDITIONnode-csr-P7XcQAc2yNlXn1pUmQFxXNCdGyyt8ccVuW3bmoUZiK4   30m   system:bootstrap:e7n0o5   Pendingnode-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM   79m   system:bootstrap:ydbwyk   Pendingnode-csr-u2sVzVkFYnMxPIYWjXHbqRJROtTZBYzA1s2vATPLzyo   30m   system:bootstrap:8w6j3n   Pendingapprove CSR <span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl certificate approve node-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM</span>certificatesigningrequest.certificates.k8s.io <span class="token string">"node-csr gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM"</span> approved</code></pre><p>查看 Approve 结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl describe csr node-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM</span>Name:               node-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAMLabels:             <span class="token operator">&lt;</span>none<span class="token operator">></span>Annotations:        <span class="token operator">&lt;</span>none<span class="token operator">></span>CreationTimestamp:  Thu, 20 Dec 2018 19:55:39 +0800Requesting User:    system:bootstrap:ydbwykStatus:             Approved,IssuedSubject:         Common Name:    system:node: 172.24.150.88         Serial Number:           Organization:   system:nodesEvents:  <span class="token operator">&lt;</span>none<span class="token operator">></span>Requesting User：请求 CSR 的用户，kube-apiserver 对它进行认证和授权；Subject：请求签名的证书信息；证书的 CN 是 system:node:192.168.80.10， Organization 是 system:nodes，kube-apiserver 的 Node 授权模式会授予该证书的相关权限；</code></pre><p>ii、自动approve csr请求<br>创建三个 ClusterRoleBinding，分别用于自动 approve client、renew client、renew server 证书：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat > csr-crb.yaml &lt;&lt;EOF</span> <span class="token comment" spellcheck="true"># Approve all CSRs for the group "system:bootstrappers"</span> kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: auto-approve-csrs-for-group subjects: - kind: Group   name: system:bootstrappers   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: system:certificates.k8s.io:certificatesigningrequests:nodeclient   apiGroup: rbac.authorization.k8s.io--- <span class="token comment" spellcheck="true"># To let a node of the group "system:nodes" renew its own credentials</span> kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: node-client-cert-renewal subjects: - kind: Group   name: system:nodes   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   apiGroup: rbac.authorization.k8s.io---<span class="token comment" spellcheck="true"># A ClusterRole which instructs the CSR approver to approve a node requesting a</span><span class="token comment" spellcheck="true"># serving cert matching its client cert.</span>kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  name: approve-node-server-renewal-csrrules:- apiGroups: <span class="token punctuation">[</span><span class="token string">"certificates.k8s.io"</span><span class="token punctuation">]</span>  resources: <span class="token punctuation">[</span><span class="token string">"certificatesigningrequests/selfnodeserver"</span><span class="token punctuation">]</span>  verbs: <span class="token punctuation">[</span><span class="token string">"create"</span><span class="token punctuation">]</span>--- <span class="token comment" spellcheck="true"># To let a node of the group "system:nodes" renew its own server credentials</span> kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: node-server-cert-renewal subjects: - kind: Group   name: system:nodes   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: approve-node-server-renewal-csr   apiGroup: rbac.authorization.k8s.ioEOFauto-approve-csrs-for-group：自动 approve node 的第一次 CSR； 注意第一次 CSR 时，请求的 Group 为 system:bootstrappers；node-client-cert-renewal：自动 approve node 后续过期的 client 证书，自动生成的证书 Group 为 system:nodes<span class="token punctuation">;</span>node-server-cert-renewal：自动 approve node 后续过期的 server 证书，自动生成的证书 Group 为 system:nodes<span class="token punctuation">;</span></code></pre><p>生效配置：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span>kubectl apply -f csr-crb.yaml</code></pre><h3 id="10-查看kubelet情况"><a href="#10-查看kubelet情况" class="headerlink" title="10    查看kubelet情况"></a>10    查看kubelet情况</h3><p>等待一段时间(1-10 分钟)，两个节点的 CSR 都被自动 approve</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE   REQUESTOR                 CONDITIONnode-csr-P7XcQAc2yNlXn1pUmQFxXNCdGyyt8ccVuW3bmoUZiK4   35m   system:bootstrap:e7n0o5   Approved,Issuednode-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM   84m   system:bootstrap:ydbwyk   Approved,Issued</code></pre><p>节点ready:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span>NAME            STATUS   ROLES    AGE     VERSION172.24.150.88   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   3h40m   v1.12.3172.24.150.89   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   3h39m   v1.12.3</code></pre><p>kube-controller-manager 为各 node 生成了 kubeconfig 文件和公私钥：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ll</span>total 52-rw------- 1 root root 1679 Jul  7 14:18 ca-key.pem-rw-r--r-- 1 root root 1359 Jul  7 14:18 ca.pem-rw------- 1 root root 1675 Jul  7 13:30 flanneld-key.pem-rw-r--r-- 1 root root 1391 Jul  7 13:30 flanneld.pem-rw------- 1 root root 2158 Jul  9 20:57 kubelet-bootstrap.kubeconfig-rw------- 1 root root 1273 Jul  9 21:17 kubelet-client-2019-07-09-21-17-43.pemlrwxrwxrwx 1 root root   59 Jul  9 21:17 kubelet-client-current.pem -<span class="token operator">></span> /etc/kubernetes/cert/kubelet-client-2019-07-09-21-17-43.pem-rw-r--r-- 1 root root  800 Jul  9 21:01 kubelet.config.json-rw-r--r-- 1 root root 2185 Jul  9 21:07 kubelet.crt-rw------- 1 root root 1679 Jul  9 21:07 kubelet.key-rw------- 1 root root 2298 Jul  9 21:17 kubelet.kubeconfig-rw-r--r-- 1 root root  321 Jul  9 21:36 kube-proxy.config.yaml-rw------- 1 root root 6273 Jul  9 21:28 kube-proxy.kubeconfigkubelet-server 证书会周期轮转；</code></pre><h2 id="三-部署kube-proxy组件"><a href="#三-部署kube-proxy组件" class="headerlink" title="三    部署kube-proxy组件"></a>三    部署kube-proxy组件</h2><p>kube-proxy 运行在所有 worker 节点上，，它监听 apiserver 中 service 和 Endpoint 的变化情况，创建路由规则来进行服务负载均衡。<br>本文档讲解部署 kube-proxy 的部署，使用 ipvs 模式。</p><h3 id="1-创建证书"><a href="#1-创建证书" class="headerlink" title="1    创建证书"></a>1    创建证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat > kube-proxy-csr.json &lt;&lt;EOF</span><span class="token punctuation">{</span>  <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"system:kube-proxy"</span>,  <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,    <span class="token string">"size"</span><span class="token keyword">:</span> 2048  <span class="token punctuation">}</span>,  <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,      <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"BeiJing"</span>,      <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"BeiJing"</span>,      <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,      <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"yunwei"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFCN：指定该证书的 User 为 system:kube-proxy；预定义的 RoleBinding system:node-proxier 将User system:kube-proxy 与 Role system:node-proxier 绑定，该 Role 授予了调用 kube-apiserver Proxy 相关 API 的权限；该证书只会被 kube-proxy 当做 client 证书使用，所以 hosts 字段为空；</code></pre><h3 id="2-创建和分发kubeconfig文件"><a href="#2-创建和分发kubeconfig文件" class="headerlink" title="2    创建和分发kubeconfig文件"></a>2    创建和分发kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash">root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config set-cluster kubernetes \</span>  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config set-credentials kube-proxy \</span>  --client-certificate<span class="token operator">=</span>kube-proxy.pem \  --client-key<span class="token operator">=</span>kube-proxy-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config set-context default \</span>  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kube-proxy \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span>--embed-certs<span class="token operator">=</span>true：将 ca.pem 和 admin.pem 证书内容嵌入到生成的 kubectl-proxy.kubeconfig 文件中<span class="token punctuation">(</span>不加时，写入的是证书文件路径<span class="token punctuation">)</span>；</code></pre><p>分发kubeconfig文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-proxy.kubeconfig root@node01:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-proxy.kubeconfig root@node02:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建kube-proxy配置文件"><a href="#3-创建kube-proxy配置文件" class="headerlink" title="3    创建kube-proxy配置文件"></a>3    创建kube-proxy配置文件</h3><p>从 v1.10 开始，kube-proxy 部分参数可以配置文件中配置。可以使用 –write-config-to 选项生成该配置文件，或者参考 kubeproxyconfig 的类型定义源文件 ：<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/apis/kubeproxyconfig/types.go" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/apis/kubeproxyconfig/types.go</a><br>创建 kube-proxy config 文件模板：</p><p>[root@master01 cert]# cat &gt;kube-proxy.config.yaml &lt;&lt;EOF<br>apiVersion: kubeproxy.config.k8s.io/v1alpha1<br>bindAddress: 172.24.150.88<br>clientConnection:<br>  kubeconfig: /etc/kubernetes/cert/kube-proxy.kubeconfig<br>clusterCIDR: 172.30.0.0/16<br>healthzBindAddress: 172.24.150.88:10256<br>hostnameOverride: k8s-node1<br>kind: KubeProxyConfiguration<br>metricsBindAddress: 172.24.150.88:10249<br>mode: “ipvs”<br>EOF<br>bindAddress: 监听地址；<br>clientConnection.kubeconfig: 连接 apiserver 的 kubeconfig 文件；<br>clusterCIDR: kube-proxy 根据 –cluster-cidr 判断集群内部和外部流量，指定 –cluster-cidr 或 –masquerade-all选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT；<br>hostnameOverride: 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 ipvs 规则；<br>mode: 使用 ipvs 模式；<br>其中clusterc idr为flannel网络地址。</p><p>文件格式问题，注意参考格式见下<br>[root@kmaster01 kubernetes]# cat /etc/kubernetes/kube-proxy.config.yaml<br>apiVersion: kubeproxy.config.k8s.io/v1alpha1<br>bindAddress: 172.24.150.88<br>clientConnection:<br>  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig<br>clusterCIDR: 172.30.0.0/16<br>healthzBindAddress: 172.24.150.88:10256<br>hostnameOverride: k8s-master1<br>kind: KubeProxyConfiguration<br>metricsBindAddress: 172.24.150.88:10249<br>mode: “ipvs”<br>[root@k8s-master1 kubernetes]#<br>kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig     ## 注意这个前面的空格，没有就会报下面的错误：</p><p>Jul 06 00:35:13 node01 kube-proxy[25540]: I0706 00:35:13.307740   25540 server.go:412] Neither kubeconfig file nor master URL was specified. Falling back to in-cluster config.<br>Jul 06 00:35:13 node01 kube-proxy[25540]: F0706 00:35:13.307780   25540 server.go:360] unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined</p><pre><code>为各节点创建和分发 kube-proxy 配置文件：​```bash[root@master01 cert]# scp kube-proxy.config.yaml root@node01:/etc/kubernetes/cert/[root@master01 cert]# scp kube-proxy.config.yaml root@node02:/etc/kubernetes/cert/</code></pre><h3 id="4-在node01和node02上分别创建-kube-proxy-systemd-unit文件"><a href="#4-在node01和node02上分别创建-kube-proxy-systemd-unit文件" class="headerlink" title="4    在node01和node02上分别创建 kube-proxy systemd unit文件"></a>4    在node01和node02上分别创建 kube-proxy systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat >/etc/systemd/system/kube-proxy.service &lt;&lt;EOF</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes Kube-Proxy ServerDocumentation<span class="token operator">=</span>https://github.com/GoogleCloudPlatform/kubernetesAfter<span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>WorkingDirectory<span class="token operator">=</span>/var/lib/kube-proxyExecStart<span class="token operator">=</span>/usr/local/bin/kube-proxy \  --config<span class="token operator">=</span>/etc/kubernetes/cert/kube-proxy.config.yaml \  --alsologtostderr<span class="token operator">=</span>true \  --logtostderr<span class="token operator">=</span>false \  --log-dir<span class="token operator">=</span>/var/lib/kube-proxy/log \  --v<span class="token operator">=</span>2Restart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>5LimitNOFILE<span class="token operator">=</span>65536<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF<span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat >/etc/systemd/system/kube-proxy.service &lt;&lt;EOF</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes Kube-Proxy ServerDocumentation<span class="token operator">=</span>https://github.com/GoogleCloudPlatform/kubernetesAfter<span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>WorkingDirectory<span class="token operator">=</span>/var/lib/kube-proxyExecStart<span class="token operator">=</span>/usr/local/bin/kube-proxy \  --config<span class="token operator">=</span>/etc/kubernetes/cert/kube-proxy.config.yaml \  --alsologtostderr<span class="token operator">=</span>true \  --logtostderr<span class="token operator">=</span>false \  --log-dir<span class="token operator">=</span>/var/lib/kube-proxy/log \  --v<span class="token operator">=</span>2Restart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>5LimitNOFILE<span class="token operator">=</span>65536<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF</code></pre><h3 id="5-启动kube-proxy服务"><a href="#5-启动kube-proxy服务" class="headerlink" title="5    启动kube-proxy服务"></a>5    启动kube-proxy服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p /var/lib/kube-proxy/log</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable kube-proxy</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart kube-proxy</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p /var/lib/kube-proxy/log</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable kube-proxy</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart kube-proxy</span></code></pre><p>必须先创建工作和日志目录；</p><h3 id="6-检查启动结果-node01和node02上"><a href="#6-检查启动结果-node01和node02上" class="headerlink" title="6    检查启动结果(node01和node02上)"></a>6    检查启动结果(node01和node02上)</h3><pre class=" language-bash"><code class="language-bash">systemctl status kube-proxy<span class="token operator">|</span><span class="token function">grep</span> Active确保状态为 active <span class="token punctuation">(</span>running<span class="token punctuation">)</span>，否则查看日志，确认原因：journalctl -u kube-proxy</code></pre><p>查看监听端口状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lnpt|grep kube-proxy</span>tcp        0      0  172.24.150.88:10256     0.0.0.0:*               LISTEN      9617/kube-proxy     tcp        0      0  172.24.150.88:10249     0.0.0.0:*               LISTEN      9617/kube-proxy10249：http prometheus metrics port<span class="token punctuation">;</span>10256：http healthz port<span class="token punctuation">;</span></code></pre><h3 id="7-查看ipvs路由规则"><a href="#7-查看ipvs路由规则" class="headerlink" title="7 查看ipvs路由规则"></a>7 查看ipvs路由规则</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install ipvsadm</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#ipvsadm -ln</span>IP Virtual Server version 1.2.1 <span class="token punctuation">(</span>size<span class="token operator">=</span>4096<span class="token punctuation">)</span>Prot LocalAddress:Port Scheduler Flags  -<span class="token operator">></span> RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.254.0.1:443 rr  -<span class="token operator">></span>  172.24.150.85:6443            Masq    1      0          0           -<span class="token operator">></span>  172.24.150.86:6443            Masq    1      0          0           -<span class="token operator">></span>  172.24.150.87:6443            Masq    1      0          0 可见将所有到 kubernetes cluster ip 443 端口的请求都转发到 kube-apiserver 的 6443 端口。至此node节点部署完成。</code></pre><h2 id="四-验证集群功能"><a href="#四-验证集群功能" class="headerlink" title="四 验证集群功能"></a>四 验证集群功能</h2><h3 id="1-查看节点状况"><a href="#1-查看节点状况" class="headerlink" title="1    查看节点状况"></a>1    查看节点状况</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span>NAME            STATUS   ROLES    AGE   VERSION172.24.150.88   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   13h   v1.12.3172.24.150.89   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   13h   v1.12.3</code></pre><h3 id="2-创建nginx-web测试文件"><a href="#2-创建nginx-web测试文件" class="headerlink" title="2    创建nginx web测试文件"></a>2    创建nginx web测试文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat >nginx-web.yml&lt;&lt;EOF </span>apiVersion: v1kind: Servicemetadata:  name: nginx-web  labels:    tier: frontendspec:  type: NodePort  selector:    tier: frontend  ports:  - name: http    port: 80    targetPort: 80---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-con  labels:    tier: frontendspec:  replicas: 3  template:    metadata:      labels:        tier: frontend    spec:      containers:      - name: nginx-pod        image: nginx        ports:        - containerPort: 80EOF</code></pre><p>执行nginx-web.yaml文件:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl create -f nginx-web.yml</span></code></pre><h3 id="3-查看各个Node上Pod-IP的连通性"><a href="#3-查看各个Node上Pod-IP的连通性" class="headerlink" title="3    查看各个Node上Pod IP的连通性"></a>3    查看各个Node上Pod IP的连通性</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  kubectl get pod -o wide</span>NAME                         READY   STATUS    RESTARTS   AGE   IP            NODE            NOMINATED NODEnginx-con-594b8d6b48-46gf7   1/1     Running   0          12h   172.30.21.2   172.24.150.88   <span class="token operator">&lt;</span>none<span class="token operator">></span>nginx-con-594b8d6b48-9t2xt   1/1     Running   0          12h   172.30.14.2   172.24.150.89   <span class="token operator">&lt;</span>none<span class="token operator">></span>nginx-con-594b8d6b48-vt589   1/1     Running   1          12h   172.30.21.3   172.24.150.88   <span class="token operator">&lt;</span>none<span class="token operator">></span>可见，nginx 的 Pod IP 分别是 172.30.21.2、172.30.14.2、172.30.21.2，在node01、node02 上分别 <span class="token function">ping</span> 这三个 IP，看是否连通：<span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ping  172.30.21.3</span>PING 172.30.21.3 <span class="token punctuation">(</span>172.30.21.3<span class="token punctuation">)</span> 56<span class="token punctuation">(</span>84<span class="token punctuation">)</span> bytes of data.64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.074 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.034 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.026 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>4 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.022 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>5 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.022 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>6 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.024 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>7 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.021 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>8 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.020 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>9 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.022 ms^C--- 172.30.21.3 <span class="token function">ping</span> statistics ---9 packets transmitted, 9 received, 0% packet loss, <span class="token function">time</span> 7999msrtt min/avg/max/mdev <span class="token operator">=</span> 0.020/0.029/0.074/0.017 ms<span class="token punctuation">[</span>root@node02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ping  172.30.21.3</span>PING 172.30.21.3 <span class="token punctuation">(</span>172.30.21.3<span class="token punctuation">)</span> 56<span class="token punctuation">(</span>84<span class="token punctuation">)</span> bytes of data.64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.415 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.268 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.215 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>4 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.205 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>5 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.208 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>6 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.211 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>7 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>8 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>9 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.203 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>10 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>11 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>12 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.224 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>13 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.217 ms</code></pre><h3 id="4-查看server的集群ip"><a href="#4-查看server的集群ip" class="headerlink" title="4    查看server的集群ip"></a>4    查看server的集群ip</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        AGEkubernetes   ClusterIP   10.254.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP        2d17hnginx-web    NodePort    10.254.189.106   <span class="token operator">&lt;</span>none<span class="token operator">></span>        80:36545/TCP   12h10.254.189.106为nginx service的集群ip，代理的是前面的三个pod容器应用。PORT 80是集群IP的端口，36545是node节点上的端口，可以用nodeip:nodeport方式访问服务node01对应的公网IP为：47.108.67.44 ，在一台和这个k8s集群好不相干的主机上访问<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  curl http://47.108.67.44:36545/</span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span>    body <span class="token punctuation">{</span>        width: 35em<span class="token punctuation">;</span>        margin: 0 auto<span class="token punctuation">;</span>        font-family: Tahoma, Verdana, Arial, sans-serif<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span>/style<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>For online documentation and support please refer to<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://nginx.org/"</span><span class="token operator">></span>nginx.org<span class="token operator">&lt;</span>/a<span class="token operator">></span>.<span class="token operator">&lt;</span>br/<span class="token operator">></span>Commercial support is available at<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://nginx.com/"</span><span class="token operator">></span>nginx.com<span class="token operator">&lt;</span>/a<span class="token operator">></span>.<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>em<span class="token operator">></span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes集群中的pause容器</title>
      <link href="/2019/07/10/kubernetes%E4%B9%8Bpause/"/>
      <url>/2019/07/10/kubernetes%E4%B9%8Bpause/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上搭建好了k8s多主集群，启动了一个nginx的pod，然而每启动一个pod就伴随这一个pause容器，考虑到之前在做kubelet的systemd unit文件时有见到：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps</span>CONTAINER ID    IMAGE                                                                 COMMAND                  CREATED             STATUS        PORTS    NAMES43884d79fe6f    nginx                                                                 <span class="token string">"nginx -g 'daemon of…"</span>   11 hours ago        Up 11 hours            k8s_nginx-pod_nginx-con-594b8d6b48-46gf7_default_25b0048f-a24f-11e9-8149-00163e0134cf_0eff67394c9c8    nginx                                                                 <span class="token string">"nginx -g 'daemon of…"</span>   11 hours ago        Up 11 hours            k8s_nginx-pod_nginx-con-594b8d6b48-vt589_default_25aefc99-a24f-11e9-8149-00163e0134cf_1261226f6b92a    registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1   <span class="token string">"/pause"</span>                 11 hours ago        Up 11 hours            k8s_POD_nginx-con-594b8d6b48-vt589_default_25aefc99-a24f-11e9-8149-00163e0134cf_1fc94013b93dd    registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1   <span class="token string">"/pause"</span>                 11 hours ago        Up 11 hours            k8s_POD_nginx-con-594b8d6b48-46gf7_default_25b0048f-a24f-11e9-8149-00163e0134cf_1</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">### 6     创建和分发kubelet systemd unit文件</span>```bash<span class="token function">cat</span> <span class="token operator">></span>/etc/systemd/system/kubelet.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Kubernetes KubeletDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletExecStart=/usr/local/bin/kubelet \  --bootstrap-kubeconfig=/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig \  --cert-dir=/etc/kubernetes/cert \  --kubeconfig=/etc/kubernetes/cert/kubelet.kubeconfig \  --config=/etc/kubernetes/cert/kubelet.config.json \  --hostname-override=172.24.150.89 \  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1 \  --allow-privileged=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>首先找一下源码看一下：<br><a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause" target="_blank" rel="noopener">pause源码</a>C语言编写的主要有四个文件：<br>orphan.c文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include &lt;unistd.h></span>int main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  pid_t pid<span class="token punctuation">;</span>  pid <span class="token operator">=</span> fork<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span>      <span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"Child exiting: pid=%d ppid=%d\n"</span>, getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>, getppid<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    printf<span class="token punctuation">(</span><span class="token string">"Parent exiting: pid=%d ppid=%d\n"</span>, getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>, getppid<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  perror<span class="token punctuation">(</span><span class="token string">"Could not create child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>pause.c文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;signal.h></span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include &lt;stdlib.h></span><span class="token comment" spellcheck="true">#include &lt;string.h></span><span class="token comment" spellcheck="true">#include &lt;sys/types.h></span><span class="token comment" spellcheck="true">#include &lt;sys/wait.h></span><span class="token comment" spellcheck="true">#include &lt;unistd.h></span><span class="token comment" spellcheck="true">#define STRINGIFY(x) #x</span><span class="token comment" spellcheck="true">#define VERSION_STRING(x) STRINGIFY(x)</span><span class="token comment" spellcheck="true">#ifndef VERSION</span><span class="token comment" spellcheck="true">#define VERSION HEAD</span><span class="token comment" spellcheck="true">#endif</span>static void sigdown<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>  psignal<span class="token punctuation">(</span>signo, <span class="token string">"Shutting down, got signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>static void sigreap<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>waitpid<span class="token punctuation">(</span>-1, NULL, WNOHANG<span class="token punctuation">)</span> <span class="token operator">></span> 0<span class="token punctuation">)</span>    <span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>int argc, char **argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>  int i<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> 1<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>strcasecmp<span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span>, <span class="token string">"-v"</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>      printf<span class="token punctuation">(</span><span class="token string">"pause.c %s\n"</span>, VERSION_STRING<span class="token punctuation">(</span>VERSION<span class="token punctuation">))</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> 0<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 1<span class="token punctuation">)</span>    /* Not an error because pause sees use outside of infra containers. */    fprintf<span class="token punctuation">(</span>stderr, <span class="token string">"Warning: pause should be the first process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGINT, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigdown<span class="token punctuation">}</span>, NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>    <span class="token keyword">return</span> 1<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGTERM, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigdown<span class="token punctuation">}</span>, NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>    <span class="token keyword">return</span> 2<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGCHLD, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigreap,                                             .sa_flags <span class="token operator">=</span> SA_NOCLDSTOP<span class="token punctuation">}</span>,                NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>    <span class="token keyword">return</span> 3<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  fprintf<span class="token punctuation">(</span>stderr, <span class="token string">"Error: infinite loop terminated\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> 42<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至于里面写的啥，我也看不懂，pose出来让你们看看哈！<br><strong>Makefile</strong>文件用于制作pause镜像，制作镜像的模板是Dockerfile，首先看这个Dockerfile(去除注释)文件：</p><pre class=" language-bash"><code class="language-bash">FROM scratchARG ARCHADD bin/pause-<span class="token variable">${ARCH}</span> /pauseENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/pause"</span><span class="token punctuation">]</span></code></pre><p>FROM scratch:    基础镜像是一个空镜像(an explicity empty image)<br>ARG ARCH:    等待在docker-build -build-arg时提供的ARCH参数<br>ADD bin/pause-$(ARCH)/pause:    添加外部文件到内部<br>ENTRYPOINT[“/pause”]:    开启容器，运行命令<br>中间两部非常重要，至于如何实现的不懂哦？</p><p>pause的Makefile</p><pre class=" language-bash"><code class="language-bash">.PHONY: all push container clean orphan all-push push-manifestinclude <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/hack/make-rules/Makefile.manifestREGISTRY ?<span class="token operator">=</span> staging-k8s.gcr.ioIMAGE <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>REGISTRY<span class="token variable">)</span></span>/pauseIMAGE_WITH_ARCH <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>TAG <span class="token operator">=</span> 3.1REV <span class="token operator">=</span> <span class="token punctuation">$(</span>shell <span class="token function">git</span> describe --contains --always --match<span class="token operator">=</span><span class="token string">'v*'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Architectures supported: amd64, arm, arm64, ppc64le and s390x</span>ARCH ?<span class="token operator">=</span> amd64ALL_ARCH <span class="token operator">=</span> amd64 arm arm64 ppc64le s390xCFLAGS <span class="token operator">=</span> -Os -Wall -Werror -static -DVERSION<span class="token operator">=</span>v<span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>REV<span class="token variable">)</span></span>KUBE_CROSS_IMAGE ?<span class="token operator">=</span> k8s.gcr.io/kube-crossKUBE_CROSS_VERSION ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token function">cat</span> <span class="token punctuation">..</span>/build-image/cross/VERSION<span class="token variable">)</span></span>BIN <span class="token operator">=</span> pauseSRCS <span class="token operator">=</span> pause.cifeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,amd64<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> x86_64-linux-gnuendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,arm<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> arm-linux-gnueabihfendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,arm64<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> aarch64-linux-gnuendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,ppc64le<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> powerpc64le-linux-gnuendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,s390x<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> s390x-linux-gnuendif<span class="token comment" spellcheck="true"># If you want to build AND push all containers, see the 'all-push' rule.</span>all: all-containerall-push: all-push-images push-manifestpush-manifest: manifest-tool    manifest-tool push from-args --platforms <span class="token variable"><span class="token variable">$(</span>call join_platforms,<span class="token punctuation">$(</span>ALL_ARCH<span class="token variable">)</span></span><span class="token punctuation">)</span> --template <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span>-ARCH:<span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span> --target <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>sub-container-%:    <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> ARCH<span class="token operator">=</span><span class="token variable">$*</span> containersub-push-%:    <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> ARCH<span class="token operator">=</span><span class="token variable">$*</span> pushall-container: <span class="token variable"><span class="token variable">$(</span>addprefix sub-container-,<span class="token punctuation">$(</span>ALL_ARCH<span class="token variable">)</span></span><span class="token punctuation">)</span>all-push-images: <span class="token variable"><span class="token variable">$(</span>addprefix sub-push-,<span class="token punctuation">$(</span>ALL_ARCH<span class="token variable">)</span></span><span class="token punctuation">)</span>build: bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 先启动一个容器</span>```bashbin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>SRCS<span class="token variable">)</span></span>    <span class="token function">mkdir</span> -p bin    docker run --rm -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        <span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_VERSION<span class="token variable">)</span></span> \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-gcc <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-strip <span class="token variable">$@</span>"</span></code></pre><h1 id="根据上面的启动容器，来build一个pause镜像"><a href="#根据上面的启动容器，来build一个pause镜像" class="headerlink" title="根据上面的启动容器，来build一个pause镜像"></a>根据上面的启动容器，来build一个pause镜像</h1><pre class=" language-bash"><code class="language-bash">container: .container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>.container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>    docker build --pull -t <span class="token variable"><span class="token variable">$(</span>IMAGE_WITH_ARCH<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span> --build-arg ARCH<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span> <span class="token keyword">.</span>    <span class="token function">touch</span> <span class="token variable">$@</span>push: .push-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>.push-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> .container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>    docker push <span class="token variable"><span class="token variable">$(</span>IMAGE_WITH_ARCH<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>    <span class="token function">touch</span> <span class="token variable">$@</span><span class="token comment" spellcheck="true"># Useful for testing, not automatically included in container image</span>orphan: bin/orphan-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>bin/orphan-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> orphan.c    <span class="token function">mkdir</span> -p bin    docker run -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        <span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_VERSION<span class="token variable">)</span></span> \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-gcc <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-strip <span class="token variable">$@</span>"</span>clean:    <span class="token function">rm</span> -rf .container-* .push-* bin/</code></pre><p>ARCH值：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Architectures supported: amd64, arm, arm64, ppc64le and s390x</span>ARCH ?<span class="token operator">=</span> amd64ALL_ARCH <span class="token operator">=</span> amd64 arm arm64 ppc64le s390x</code></pre><p>可以看出支持很多架构类型，默认为amd64</p><p>制作pause镜像的过程如下：</p><pre class=" language-bash"><code class="language-bash">REGISTRY ?<span class="token operator">=</span> staging-k8s.gcr.ioIMAGE <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>REGISTRY<span class="token variable">)</span></span>/pauseIMAGE_WITH_ARCH <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>TAG <span class="token operator">=</span> 3.1ARCH ?<span class="token operator">=</span> amd64BIN <span class="token operator">=</span> pauseSRCS <span class="token operator">=</span> pause.cREV <span class="token operator">=</span> <span class="token punctuation">$(</span>shell <span class="token function">git</span> describe --contains --always --match<span class="token operator">=</span><span class="token string">'v*'</span><span class="token punctuation">)</span>CFLAGS <span class="token operator">=</span> -Os -Wall -Werror -static -DVERSION<span class="token operator">=</span>v<span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>REV<span class="token variable">)</span></span>KUBE_CROSS_IMAGE ?<span class="token operator">=</span> k8s.gcr.io/kube-crossKUBE_CROSS_VERSION ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token function">cat</span> <span class="token punctuation">..</span>/build-image/cross/VERSION<span class="token variable">)</span></span>ifeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,amd64<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> x86_64-linux-gnubuild: bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 启动一个容器</span>bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>SRCS<span class="token variable">)</span></span>    <span class="token function">mkdir</span> -p bin    docker run --rm -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        <span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_VERSION<span class="token variable">)</span></span> \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-gcc <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-strip <span class="token variable">$@</span>"</span><span class="token comment" spellcheck="true"># build一个pause镜像</span>container: .container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>.container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>    docker build --pull -t <span class="token variable"><span class="token variable">$(</span>IMAGE_WITH_ARCH<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span> --build-arg ARCH<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span> <span class="token keyword">.</span>    <span class="token function">touch</span> <span class="token variable">$@</span></code></pre><p>$(KUBE_CROSS_IMAGE):$(KUBE_CROSS_VERSION)=k8s.gcr.io/kube-cross:v1.12.6-1</p><h1 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h1><pre class=" language-bash"><code class="language-bash">bin/pause-amd64:pause.c    <span class="token function">mkdir</span> -p bin    docker run --rm -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        k8s.gcr.io/kube-cross:v1.12.6-1 \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            x86_64-linux-gnu-gcc v3.1-<span class="token variable"><span class="token variable">$(</span>REV<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            x86_64-linux-gnu-strip <span class="token variable">$@</span>"</span><span class="token comment" spellcheck="true"># build一个pause镜像</span>container: .container-amd64.container-amd64: bin/pause-amd64    docker build --pull -t staging-k8s.gcr.io/pause-amd64:3.1 --build-arg ARCH<span class="token operator">=</span>amd64 <span class="token keyword">.</span></code></pre><p>至于详细的构建过程，我就不写了， 我看不懂呀！    </p><p>pause容器的工作<br>可知kubernetes的pod抽象基于Linux的namespace和cgroups，为容器提供了良好的隔离环境。在同一个pod中，不同容器犹如在localhost中。</p><p>在Unix系统中，PID为1的进程为init进程，即所有进程的父进程。它很特殊，维护一张进程表，不断地检查进程状态。例如，一旦某个子进程由于父进程的错误而变成了“孤儿进程”，其便会被init进程进行收养并最终回收资源，从而结束进程。</p><p>或者，某子进程已经停止但进程表中仍然存在该进程，因为其父进程未进行wait syscall进行索引，从而该进程变成“僵尸进程”，这种僵尸进程存在时间较短。不过如果父进程只wait，而未syscall的话，僵尸进程便会存在较长时间。</p><p>同时，init进程不能处理某个信号逻辑，拥有“信号屏蔽”功能，从而防止init进程被误杀。</p><p>容器中使用pid namespace来对pid进行隔离，从而每个容器中均有其独立的init进程。例如对于寄主机上可以用个发送SIGKILL或者SIGSTOP(也就是docker kill 或者docker stop)来强制终止容器的运行，即终止容器内的init进程。一旦init进程被销毁， 同一pid namespace下的进程也随之被销毁，并容器进程被回收相应资源。</p><p>kubernetes中的pause容器便被设计成为每个业务容器提供以下功能：<br>在pod中担任Linux命名空间共享的基础；<br>启用pid命名空间，开启init进程。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -idt --name pause-ceshi cntsp/pause:3.1 </span>ce2a4ffccf1d2b190b9f8cc45f6e4912f278aa7a55280ce8a69433e5345e5816<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -idt --name busybox11 --net=container:pause11 --pid=container:pause11 --ipc=container:pause11 busybox</span>docker: Error response from daemon: No such container: pause11.See <span class="token string">'docker run --help'</span><span class="token keyword">.</span><span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -idt --name busybox11 --net=container:pause-ceshi --pid=container:pause-ceshi --ipc=container:pause-ceshi busybox</span>Unable to <span class="token function">find</span> image <span class="token string">'busybox:latest'</span> locallylatest: Pulling from library/busybox8e674ad76dce: Pull complete Digest: sha256:c94cf1b87ccb80f2e6414ef913c748b105060debda482058d2b8d0fce39f11b9Status: Downloaded newer image <span class="token keyword">for</span> busybox:latest6bec8c69198eaa444580ccaa0a50afbc16a51eea489fa7e81729d535cb691ea6<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps -a </span>CONTAINER ID        IMAGE                                          COMMAND             CREATED             STATUS                PORTS                          NAMES6bec8c69198e        busybox                                        <span class="token string">"sh"</span>                bout a minute ago   Up About a minute                                    busybox11ce2a4ffccf1d        cntsp/pause:3.1                                <span class="token string">"/pause"</span>            2 minutes ago       Up 2 minutes                                         pause-ceshi<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it busybox11 /bin/bash</span>OCI runtime <span class="token function">exec</span> failed: <span class="token function">exec</span> failed: container_linux.go:348: starting container process caused <span class="token string">"exec: \"/bin/bash\": stat /bin/bash: no such file or directory"</span><span class="token keyword">:</span> unknown<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it busybox11 /bin/sh</span>/ <span class="token comment" spellcheck="true"># ps aux</span>PID   USER     TIME  COMMAND    1 root      0:00 /pause    6 root      0:00 sh   16 root      0:00 /bin/sh   21 root      0:00 <span class="token function">ps</span> aux/ <span class="token comment" spellcheck="true"># </span>这里补充一点：Docker网络模式：其中有一种是Container:            <span class="token operator">></span> * 复用其它容器的网络Container模式：    <span class="token operator">></span>    * 重用另一个容器的Network Namespace,新创建的容器不会创建网卡，配置IP    <span class="token operator">></span>    * 和一个指定的容器共享IP、端口范围    <span class="token operator">></span>    * 两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的，两个容器的进程可以通过lo网卡设备通信。    <span class="token operator">></span>    * Pod里的Pause容器和Pod里的其它容器就是此种网络</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> pause </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql整型长度</title>
      <link href="/2019/06/26/mysql%E6%95%B4%E5%9E%8B%E9%95%BF%E5%BA%A6/"/>
      <url>/2019/06/26/mysql%E6%95%B4%E5%9E%8B%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>数据库中很多整型数据限定了长度，int(3):有些人会错误认为3代表的是允许存储的最大宽度，比如：误以为int(3)能存储的最大数是999，不能存储大于999的数值。</p><pre class=" language-bash"><code class="language-bash">MySQL的int和tinyint的默认长度是int<span class="token punctuation">(</span>11<span class="token punctuation">)</span>和tinyint<span class="token punctuation">(</span>4<span class="token punctuation">)</span>，而boolean型实际存储的是tinyint<span class="token punctuation">(</span>1<span class="token punctuation">)</span>.浮点型的长度使用来限制数字存储范围的。比如float<span class="token punctuation">(</span>3,2<span class="token punctuation">)</span>,只能够写入0.00-999.99整型的长度并不会限制存储的数字范围。比如 int和int<span class="token punctuation">(</span>3<span class="token punctuation">)</span>的存储范围都是-2147483648 ~ 2147483647, int unsigned 和 int<span class="token punctuation">(</span>3<span class="token punctuation">)</span> unsigned 的存储范围都是0 ~ 4294967295.整型的长度实际上可以理解为”显示长度“，如果该字段有开启<span class="token string">"zerofill/补零"</span>就能很明显的知道它的作用。</code></pre><p>1    验证整型长度是否会限制存储范围和整型长度的补零作用</p><pre class=" language-bash"><code class="language-bash">创建数据表:    CREATE TABLE test01<span class="token punctuation">(</span>        with_int_length int<span class="token punctuation">(</span>3<span class="token punctuation">)</span>,        without_int_length int    <span class="token punctuation">)</span>    insert into test01<span class="token punctuation">(</span>with_int_length,without_int_length<span class="token punctuation">)</span> values<span class="token punctuation">(</span>1111,1111<span class="token punctuation">)</span><span class="token punctuation">;</span>    insert into test01<span class="token punctuation">(</span>with_int_length,without_int_length<span class="token punctuation">)</span> values<span class="token punctuation">(</span>11111,11111<span class="token punctuation">)</span><span class="token punctuation">;</span>    commit<span class="token punctuation">;</span>    mysql<span class="token operator">></span> <span class="token keyword">select</span> * from test01<span class="token punctuation">;</span>    +-----------------+--------------------+    <span class="token operator">|</span> with_int_length <span class="token operator">|</span> without_int_length <span class="token operator">|</span>    +-----------------+--------------------+    <span class="token operator">|</span>            1111 <span class="token operator">|</span>               1111 <span class="token operator">|</span>    <span class="token operator">|</span>           11111 <span class="token operator">|</span>              11111 <span class="token operator">|</span>    +-----------------+--------------------+    2 rows <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.00 sec<span class="token punctuation">)</span>    CREATE TABLE test02 <span class="token punctuation">(</span>      with_length int<span class="token punctuation">(</span>3<span class="token punctuation">)</span> ZEROFILL,      without_length int    <span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>innodb, CHARSET<span class="token operator">=</span>utf8    insert into test02 <span class="token punctuation">(</span>with_length, without_length<span class="token punctuation">)</span> VALUE <span class="token punctuation">(</span>11, 11<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">select</span> * from test02<span class="token punctuation">;</span>    mysql<span class="token operator">></span> <span class="token keyword">select</span> * from test02<span class="token punctuation">;</span>    +-------------+----------------+    <span class="token operator">|</span> with_length <span class="token operator">|</span> without_length <span class="token operator">|</span>    +-------------+----------------+    <span class="token operator">|</span>         011 <span class="token operator">|</span>             11 <span class="token operator">|</span>    +-------------+----------------+    1 row <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.01 sec<span class="token punctuation">)</span></code></pre><p>高性能MySQL一书中说明：<br>“高性能MySQL” 书中在”4.1 选择优化的数据类型”中提到:<br>MySQL 可以为整数类型指定宽度, 例如 INT(11), 对大多数应用这是没有意义的: 它不会限制值的合法范围, 只是规定了 MySQL 的一些交互工具(例如 MySQL 命令行客户端)用来显示字符的个数. 对于存储和计算来说, INT(1) 和 INT(20) 是相同的</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> int </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务</title>
      <link href="/2019/06/25/mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/06/25/mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="深入学习MySQL事务：ACID特性的实现原理"><a href="#深入学习MySQL事务：ACID特性的实现原理" class="headerlink" title="深入学习MySQL事务：ACID特性的实现原理"></a>深入学习MySQL事务：ACID特性的实现原理</h1><p>事务是MySQL等关系型数据库区别与NoSQL的中重要方面，是保证数据一致性的重要手段，<strong>本文将首先介绍MySQL事务相关的基础概念，然后介绍事务的ACID特性，并分析其实现原理</strong></p><h1 id="一-基础概念"><a href="#一-基础概念" class="headerlink" title="一    基础概念"></a><table><tr><td bgcolor=#7FFFD4;><p style="color:red;font-size:24px">一    基础概念</p></td></tr></table></h1><p>事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQ支持事务，本文介绍基于MySQL5.6.<br>首先回顾一下MySQL事务的基础知识。</p><ol><li>逻辑架构和存储引擎</li></ol><p>如上图所示，MySQL服务器逻辑架构从上往下可以分为三层：<br>(1)第一层：处理客户端连接，授权认证等。<br>(2)第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。<br>(3)第三层：存储引擎，负责MySQL中数据的存储和提取。MySQL中服务器层部管理事务，事务是由存储引擎实现的。MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB使用最为广泛；其它存储引擎不支持事务如MyISAM、Memory等。<br>如无特殊说明，后文中描述的内容都是基于InnoDB.</p><h1 id="提交和回滚"><a href="#提交和回滚" class="headerlink" title="提交和回滚"></a>提交和回滚</h1><p>典型的MySQL事务是如下操作的：</p><pre class=" language-bash"><code class="language-bash">start transaction<span class="token punctuation">;</span>---DML语句--------DML语句--------DML语句-----commit<span class="token punctuation">;</span></code></pre><p>其中start transaction标识事务开始，commit提交事务，将执行结果写入到数据库,如果sql语句执行出现问题，会调用rollback，回滚所有已经执行成功的sql语句，当然，也可以在事务中直接使用rollback语句进行回滚。<br>自动提交：<br>MySQL中默认采用的是自动提交(autocommit)模式，如下所示：<br>mysql&gt; SHOW VARIABLES LIKE ‘AUTOCOMMIT’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| autocommit    | ON    |<br>+—————+——-+<br>1 row in set, 1 warning (0.06 sec)<br>在自动提交模式，如果没有start transaction显式地开始一个事务，那么每个sql语句都会被当作一个事务执行提交操作<br>通过如下方式，可以关闭autocommit;需要注意的是，autocommit参数是针对连接的，在一个连接中修改了参数，不会对其它连接产生影响。<br>mysql&gt; SET AUTOCOMMIT = 0;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; SHOW VARIABLES LIKE ‘AUTOCOMMIT’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| autocommit    | OFF   |<br>+—————+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>如果关闭了autocommit，则所有的sql语句都在一个事务中，直到执行了commit(rollback),该事务成功结束(事务失败结束),同时开始了另外一个事务。<br><strong>特殊操作</strong><br>在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter table)、lock tables语句等等<br>不过，成勇的select、insert、update和delect命令，都不会强制提交事务的。<br><strong>ACID特性</strong><br>ACID是衡量事务的四个特性：</p><blockquote><ul><li>原子性(Atomicity,或称不可分割性)</li><li>一致性(Consistency)</li><li>隔离性(isolation)</li><li>持久性(Durability)<br>按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；InnoDB默认事务隔离级别是可重复读，不满足隔离性；Oracle默认的事务隔离级别为READ COMMITED,不满足隔离性…因此与其说ACID是事务必须满足的条件，不如说他们是衡量事务的四个维度。<br>下面将详细介绍ACID特性及其实现原理；为了便于理解，介绍的顺序不是严格按照A-C-I-D。</li></ul></blockquote><h1 id="二-原子性"><a href="#二-原子性" class="headerlink" title="二    原子性"></a><table><tr><td bgcolor=#7FFFD4;><p style="color:red;font-size:24px">二    原子性</p></td></tr></table></h1><p>1    定义<br>    原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。<br>2    实现原理：undo log<br>    在说明原子性原理之前，首先介绍一个MySQL事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p><pre><code>下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。</code></pre><h1 id="三-持久性"><a href="#三-持久性" class="headerlink" title="三    持久性"></a><table><tr><td bgcolor=#7FFFD4;><p style="color:red;font-size:24px">三    持久性</p></td></tr></table></h1><p>1    定义<br>    持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其它操作或故障不应该对其有任何影响。<br>2    实现原理：redo     log<br>    redo log和undo log都属于InnoDB的事务日志，下面先聊一下(redo log)存在的背景。<br>    InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低，为此，InnoDB提供了缓存(Buffer Pool),Buffer Pool中包含了磁盘中部分数据页映射，作为访问数据库的缓冲;当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool;当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中(这一过程为刷脏)。</p><pre><code>于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。**redo log与binlog**我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。# &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4;&gt;&lt;p style=&quot;color:red;font-size:24px&quot;&gt;三    隔离性&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;1    定义    **与原子性、持久性侧重与研究事务本身不同，隔离性研究的是不同事务之间的相互影响**隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。    隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)，那么隔离性的探讨，主要可以分为两个方面：    &gt; * (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性    &gt; * (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性    **2.锁机制**    首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。    锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。    行锁与表锁        按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。    如何查看锁信息    有多种方法可以查看InnoDB中锁的情况，例如：    ```bash    SELECT * FROM information_schema.innodb_locks;#锁的概况    show engine innodb status;#InnoDB整体状态，其中包括锁的情况    ```    其中lock_type为RECORD，代表锁为行锁(记录锁)；lock_mode为X，代表排它锁(写锁)。    除了排它锁(写锁)之外，MySQL中还有共享锁(读锁)的概念。由于本文重点是MySQL事务的实现原理，因此对锁的介绍到此为止，后续会专门写文章分析MySQL中不同锁的区别、使用场景等，欢迎关注。    **3 脏读、不可重复读和幻读**    首先来看并发情况下，读操作可能存在的三类问题：    (1)    脏读：当前事务(A)中可以读到其它事务(B)未提交的数据(脏数据),这种现象是脏读，举例如下(以账户余额表为例)：        ------------------------------------------------------------------        时间        事务A                    事务B        ------------------------------------------------------------------        T1            开始事务                开始事务        ------------------------------------------------------------------        T2                                    修改zhangsan的余额                                            将余额由100改为200        ------------------------------------------------------------------        T3            查询zhangsan的余额                    结果为200[脏读]        ------------------------------------------------------------------        T4                                    提交事务        ------------------------------------------------------------------    (2)不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。    脏读与不可重复读的区别在于：前者读到的是其他事务为提交的数据，后者读到的是其它事务已提交的数据。        -------------------------------------------------------------------------------        时间        事务A                                            事务B        -------------------------------------------------------------------------------        T1            开始事务                                        开始事务        -------------------------------------------------------------------------------        T2            查询zhangsan的余额,结果为100        -------------------------------------------------------------------------------        T3                                                            修改zhangsan的余额                                                                    将余额由100改为200        -------------------------------------------------------------------------------        T4                                                            提交事务        -------------------------------------------------------------------------------        T5            查询zhangsan的余额，结果为                    200[不可重复读]        -------------------------------------------------------------------------------        (3)幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。举例如下：        ---------------------------------------------------------------------------------        时间            事务A                                事务B        ---------------------------------------------------------------------------------        T1                开始事务                            开始事务        ---------------------------------------------------------------------------------        T2                查询0&lt;id&lt;5的所有用户的余额:                        zhangsan:100(id=1)        ---------------------------------------------------------------------------------        T3                                                    账户余额表中插入新用户                                                            lisi:200(id=2)        ---------------------------------------------------------------------------------        T4                                                    提交事务        ---------------------------------------------------------------------------------        T5                查询0&lt;id&lt;5的所有用户的余额：                        zhangsan:100(id=1)                        lisi:200(id=2)【幻读】        ------------------------------------------------------------------------------------------        4 事务隔离级别        ------------------------------------------------------------------------------------------        SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，        隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：        ------------------------------------------------------------------------------------------        隔离级别                  脏读            不可重复读            幻读        ------------------------------------------------------------------------------------------        Read Uncommitted        可能            可能                可能            读未提交        ------------------------------------------------------------------------------------------        Read committed            不可能            可能                可能            读已提交        ------------------------------------------------------------------------------------------        Repeatable Read            不可能            不可能                可能        可重复读        ------------------------------------------------------------------------------------------        Serializable            不可能            不可能                不可能        可串行化        ------------------------------------------------------------------------------------------        在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是读已提交(如Oracle)或可重复读（如：mysql,后文简称RR）        mysql&gt; select @@global.tx_isolation;        +-----------------------+                   | @@global.tx_isolation |                   +-----------------------+                   | REPEATABLE-READ       |                   +-----------------------+                   1 row in set, 1 warning (0.00 sec)          mysql&gt; select @@tx_isolation;                                    +-----------------+                         | @@tx_isolation  |                         +-----------------+                         | REPEATABLE-READ |                         +-----------------+                         1 row in set, 1 warning (0.00 sec)          MYSQL中InnoDB默认的隔离级别是RR，后文会重点介绍RR。需要注意的是，在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。    5    MVCC        RR解决脏读，不可重复读、幻读等问题，使用的是MVCC：MVCC全称：Multi-Version Concurrency Control,即多版本的并发控制协议，下面的例子很好的体现了MVCC的特点：在同一时刻，不同事务读取到的数据可能是不同的(即多版本)-在T5时刻，事务A和事务C可以读取到不同版本的数据。        ---------------------------------------------------------------------        时间    事务A                   事务B                    事务C        -------------------------------------------------------------------------        T1        开始事务               开始事务                    开始事务        --------------------------------------------------------------------------        T2        查询zhangsan的                余额结果为100        --------------------------------------------------------------------------        T3                                修改zhangsan的余额                                        将余额由100改为200        --------------------------------------------------------------------------        T4                                提交事务        --------------------------------------------------------------------------        T5        查询zhangsan的余额                结果为100                                        查询zhangsan的余额                                                                结果为200        --------------------------------------------------------------------------        MVCC最大的有点是读不加锁，因此读写不冲突，并发性能好，InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(可以称之为标记位)和undo log。其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo log的指针等等，当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log,从而实现MVCC；隐藏列的详细格式不再展开。        下面结合前文提到的几个问题分别说明：        (1)脏读        -------------------------------------------------------------        时间        事务A                        事务B        -------------------------------------------------------------        T1            开始事务                    开始事务        -------------------------------------------------------------        T2                                        修改zhangsan的余额,                                                将余额由100改为200        -------------------------------------------------------------        T3            查询zhangsan的余额                    结果为100(避免了脏读)        -------------------------------------------------------------        T4                                        提交事务        -------------------------------------------------------------        当事务A在T3时间节点读取zhangsan的余额时，会发现数据已被其他事务修改，且状态为未提交。此时事务A读取最新数据后，根据数据的undo log执行回滚操作，得到事务B修改前的数据，从而避免了脏读。        (2)不可重复读        -------------------------------------------------------------        时间        事务A                        事务B        -------------------------------------------------------------        T1            开始事务                    开始事务        -------------------------------------------------------------        T2            查询zhangsan的余额                    结果为100        -------------------------------------------------------------        T3                                        修改zhangsan的余额                                                将余额由100改为200        -------------------------------------------------------------        T4                                        提交事务        -------------------------------------------------------------                查询zhangsan的余额        T5        结果为100(避免了不可重复读)        -------------------------------------------------------------        当事务A在T2节点第一次读取数据时，会记录该数据的版本号（数据的版本号是以row为单位记录的），假设版本号为1；当事务B提交时，该行记录的版本号增加，假设版本号为2；当事务A在T5再一次读取数据时，发现数据的版本号（2）大于第一次读取时记录的版本号（1），因此会根据undo log执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。        (3)幻读        InnoDB实现的RR通过next-key lock机制避免了幻读现象。        **next-key lock是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)；其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。**当然，这里我们讨论的是不加锁读：此时的next-key lock并不是真的加锁，只是为读取的数据增加了标记（标记内容包括数据的版本号等）；准确起见姑且称之为类next-key lock机制。还是以前面的例子来说明：        -------------------------------------------------------------------        时间            事务A                                 事务B        --------------------------------------------------------------------------        T1                开始事务                            开始事务        --------------------------------------------------------------------------        T2                查询0&lt;id&lt;5的所有用户的余额：                        zhangsan:100(id=1)        --------------------------------------------------------------------------        T3                                                    账户余额表中插入新用户                                                            lisi:200(id=2)        --------------------------------------------------------------------------        T4                                                    提交事务        --------------------------------------------------------------------------        T5                查询0&lt;id&lt;5的所有用户的余额：                        zhangsan:100(id=1)                        (避免了幻读)        --------------------------------------------------------------------------        当事务A在T2节点第一次读取0&lt;id&lt;5数据时，标记的不只是id=1的数据，而是将范围(0,5)进行了标记，这样当T5时刻再次读取0&lt;id&lt;5数据时，便可以发现id=4的数据比之前标记的版本号更高，此时再结合undo log执行回滚操作，避免了幻读。    6 总结        概括来说，InnoDB实现的RR，通过锁机制、数据的隐藏列、undo log和类next-key lock,实现了一定程度的隔离性，可以满足大多数场景的需要，不过需要说明的是，RR虽然避免了幻读问题，但是毕竟不是Serializable,不能保证完全的隔离，下面是一个例子，大家可以自己验证一下。        -------------------------------------------------------------------------        时间            事务A                            事务B        -------------------------------------------------------------------------        T1                开始事务                        开始事务        -------------------------------------------------------------------------        T2            查询0&lt;id&lt;5的所有用户的余额：                    zhangsan:100(id=1)                    -------------------------------------------------------------------------        T3                                                账户余额表中插入新用户                                                        lisi:200(id=2)        -------------------------------------------------------------------------        T4                                                提交事务        -------------------------------------------------------------------------        T5            修改0&lt;id&lt;5的所有用户的余额为300        -------------------------------------------------------------------------        T6            提交事务(事务A提交后，zhangsan和lisi的余额都是300)        -------------------------------------------------------------------------# &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4;&gt;&lt;p style=&quot;color:red;font-size:24px&quot;&gt;五    一致性&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    1    **基本概念**        一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。    2    **实现**                         可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。        实现一致性的措施包括：    &gt; *    保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证    &gt; * 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等    &gt; *应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致# &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4;&gt;&lt;p style=&quot;color:red;font-size:24px&quot;&gt;六    总结&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    **下面总结一下ACID特性及其实现原理：**        原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log        持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log        隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制、数据的隐藏列、undo log和类next-key lock机制        一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障</code></pre><p><a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">转载自：</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> transcation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql入门</title>
      <link href="/2019/06/21/mysql%E5%85%A5%E9%97%A8/"/>
      <url>/2019/06/21/mysql%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>SQL概述<br>SQL，一般发音为sequel，SQL的全称Structured Query Language),SQL用来和数据库打交道，完成和数据库的通信，SQL是一套标准。但是每一个数据库都有自己的特性别的数据库没有，当使用这个数据库特性相关的功能，这时SQL语句可能就不是标准了(90%以上的SQL都是通用的)</p><p>什么是数据库<br>数据库，通常是一个或一组文件，保存了一些符合特定规格的数据，数据库对应的英语单词是DataBase,简称DB，数据库软件称为数据库管理系统(DBMS)，全称为DataBase Management System,如：Oracle、SQL Server、MySQL、Sybase、Informix、 DB2、interbase 、PostgreSql</p><p>MySql概述<br>MySQL最初是由”MySQL AB”公司开发的一套关系型数据库管理系统(RDBMS-Relation Database Management System).MySQL不仅是最流行的开源数据库，而且是业界成长最快的数据库，每天有超过7万次的下载量，其应用范围从大型企业到专有的嵌入应用系统。<br>MySQL</p><p>查询建表语句：<br>show create table 表名;<br>show create table draw_company_result; </p><blockquote><p>CREATE TABLE <code>draw_company_result</code> (<br>  <code>draw_id</code> varchar(30) NOT NULL,<br>  <code>game_code</code> varchar(10) NOT NULL DEFAULT ‘’,<br>  <code>company</code> varchar(30) NOT NULL,<br>  <code>result</code> varchar(255) DEFAULT ‘’,<br>  <code>operator</code> varchar(255) DEFAULT NULL,<br>  <code>operatortime</code> datetime DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (<code>draw_id</code>,<code>game_code</code>,<code>company</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8</p></blockquote><p>查询表的单个字段<br>user openfire;<br>select username from ofUser;<br>select username, name, email from ofUser;</p><p>查询重命名表名，并不能修改真正的修改表名</p><p>mysql&gt; select username, encryptedPassword from ofUser;<br>+———-+————————————————–+<br>| username | encryptedPassword                                |<br>+———-+————————————————–+<br>| admin    | 61a46ea4fb839834cc6e88519e28a5e353a96d402957e094 |<br>| gang     | 269d01e7a82a1cd51642e1e574357bf30e4ad174f3f26bde |<br>| jia      | 248be0a8c9a505221bf7a0a7523521119cfaa2bfa288a106 |<br>| jian     | 65b416288a78bac5732531ff33565860e71a203d9974de4c |<br>| pei      | 4242b7cb67849778199f189d97010b24291c03d8cab70a41 |<br>+———-+————————————————–+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select username,encryptedPassword as passwd from ofUser;<br>+———-+————————————————–+<br>| username | passwd                                           |<br>+———-+————————————————–+<br>| admin    | 61a46ea4fb839834cc6e88519e28a5e353a96d402957e094 |<br>| gang     | 269d01e7a82a1cd51642e1e574357bf30e4ad174f3f26bde |<br>| jia      | 248be0a8c9a505221bf7a0a7523521119cfaa2bfa288a106 |<br>| jian     | 65b416288a78bac5732531ff33565860e71a203d9974de4c |<br>| pei      | 4242b7cb67849778199f189d97010b24291c03d8cab70a41 |<br>+———-+————————————————–+<br>5 rows in set (0.00 sec)<br>注意：可以写成 select username,encryptedPassword  passwd from ofUser;<br>省去as关键字也是可以的<br>注意：字符串用单引号</p><p>条件查询:<br>条件查询需要用到where语句，where必须放到from语句表的后面<br>支持如下运算符<br>运算符                      说明<br>=                          等于<br>&lt;&gt;或!=                    不等于<br>&lt;                          小于<br>&lt;=                          小于等于</p><blockquote><pre><code>                    大于</code></pre><p>=                        大于等于<br>between … and …       两个值之间,等同于&gt;= and &lt;=<br>is null                   为null(is not null 不为空)<br>and                          并且<br>or                          或者<br>in                        包含，相当于多个or(not in不在这个范围中)<br>not                       not可以取非，主要用在is 或者in中<br>like                      like 称为模糊查询，支持%或下划线匹配<br>str_to_date                将字符串转换日期<br>date_format                  格式化日期<br>format                      设置千分位<br>round                      四舍五入<br>rand()                      生成随机数<br>Ifnull                      可以将null转换成一个具体值</p></blockquote><p>mysql&gt; select username,name,creationDate as crtDate from ofUser where email=’123@qq.com’;<br>+———-+——+—————–+<br>| username | name | crtDate         |<br>+———-+——+—————–+<br>| gang     | gang | 001560644570688 |<br>+———-+——+—————–+<br>1 row in set (0.00 sec)</p><p>找出工资大于1800的员工，要求部门编号是20或者30的。</p><p>select<br>    empno,enmae,sal,deptno<br>from<br>    emp<br>where<br>    sal &gt; 1800 and (deptno = 20 or deptno =30);<br>    mysql&gt; SELECT EMPNO,ENAME,SAL,DEPTNO FROM EMP WHERE SAL&gt;1800 AND (DEPTNO =20 OR DEPTNO = 30);<br>    +——-+——-+———+——–+<br>    | EMPNO | ENAME | SAL     | DEPTNO |<br>    +——-+——-+———+——–+<br>    |  7566 | JONES | 2975.00 |     20 |<br>    |  7698 | BLAKE | 2850.00 |     30 |<br>    |  7782 | CLARK | 2450.00 |     20 |<br>    |  7788 | SCOTT | 3000.00 |     20 |<br>    |  7902 | FORD  | 3000.00 |     20 |<br>    +——-+——-+———+——–+<br>    5 rows in set (0.00 sec)</p><p>查找出某个字段对应的数据中T字母结尾的：<br>mysql&gt; select ENAME FROM EMP WHERE ENAME LIKE ‘%T’;<br>+——-+<br>| ENAME |<br>+——-+<br>| SCOTT |<br>+——-+<br>1 row in set (0.00 sec)</p><p>查找出某个字段对应的数据中第二个字母是A的：<br>mysql&gt; select ENAME FROM EMP WHERE ENAME LIKE ‘_A%’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| WARD   |<br>| MARTIN |<br>| JAMES  |<br>+——–+<br>3 rows in set (0.00 sec)</p><p>查找出某个字段对应的数据中里面含有A的：<br>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME LIKE ‘%A%’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| ALLEN  |<br>| WARD   |<br>| MARTIN |<br>| BLAKE  |<br>| CLARK  |<br>| ADAMS  |<br>| JAMES  |<br>+——–+<br>7 rows in set (0.00 sec)</p><p>注意：%代表任意多个字符，_代表任意单个字符</p><p>注意：Null为空，但不是空串</p><p>排序 order by<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>默认升序排序<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL asc;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| KING   | 5000.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| SMITH  |  800.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)<br>DESC:     降序排序</p><p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC,ENAME ASC;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| KING   | 5000.00 |<br>| FORD   | 3000.00 |<br>| SCOTT  | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>| MARTIN | 1250.00 |<br>| WARD   | 1250.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| SMITH  |  800.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>单一字段排序<br>排序采用order by子句，order by后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序，如果存在where子句，那么order by<br>必须放到where语句的后面</p><ul><li>按照薪水由小到大排序(系统默认由小到大)<br>mysql&gt; SELECT * FROM EMP ORDER BY SAL;</li></ul><p>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+<br>14 rows in set (0.00 sec)</p><p>使用字段的位置来排序<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY 2;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+</p><p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY 1;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| ADAMS  | 1100.00 |<br>| ALLEN  | 1600.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| FORD   | 3000.00 |<br>| JAMES  |  950.00 |<br>| JONES  | 2975.00 |<br>| KING   | 5000.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| SCOTT  | 3000.00 |<br>| SMITH  |  800.00 |<br>| TURNER | 1500.00 |<br>| WARD   | 1250.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>数据处理函数/单行处理函数</p><p>Lower        转换小写<br>upper        转换大写<br>substr        取字串(substr(被截取的字符串，起始下标，截取的长度))<br>length        取长度<br>trim        去空格</p><p>将查询结果显示小写</p><p>mysql&gt; SELECT lower(ENAME) as ename from EMP;<br>+——–+<br>| ename  |<br>+——–+<br>| smith  |<br>| allen  |<br>| ward   |<br>| jones  |<br>| martin |<br>| blake  |<br>| clark  |<br>| scott  |<br>| king   |<br>| turner |<br>| adams  |<br>| james  |<br>| ford   |<br>| miller |<br>+——–+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; SELECT upper(ENAME) as ename from EMP;<br>+——–+<br>| ename  |<br>+——–+<br>| SMITH  |<br>| ALLEN  |<br>| WARD   |<br>| JONES  |<br>| MARTIN |<br>| BLAKE  |<br>| CLARK  |<br>| SCOTT  |<br>| KING   |<br>| TURNER |<br>| ADAMS  |<br>| JAMES  |<br>| FORD   |<br>| MILLER |<br>+——–+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; select username from ofUser;<br>+———-+<br>| username |<br>+———-+<br>| admin    |<br>| pei      |<br>| gang     |<br>| jian     |<br>| jia      |<br>+———-+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select upper(username) from ofUser;<br>+—————–+<br>| upper(username) |<br>+—————–+<br>| ADMIN           |<br>| PEI             |<br>| GANG            |<br>| JIAN            |<br>| JIA             |<br>+—————–+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select upper(username) as username from ofUser;<br>+———-+<br>| username |<br>+———-+<br>| ADMIN    |<br>| PEI      |<br>| GANG     |<br>| JIAN     |<br>| JIA      |<br>+———-+<br>5 rows in set (0.00 sec)</p><p>substr(args1,args2,args3)<br>args1参数为字段名，<br>args2参数为起始下标，<br>args3参数为截取的长度</p><p>查找表emp中字段ename中第二个字母为A的：<br>之前的方法：<br>    mysql&gt; SELECT ENAME FROM EMP WHERE ENAME LIKE ‘_A%’;<br>    +——–+<br>    | ENAME  |<br>    +——–+<br>    | WARD   |<br>    | MARTIN |<br>    | JAMES  |<br>    +——–+<br>    3 rows in set (0.00 sec)</p><p>substr()函数的方法：<br>    mysql&gt; SELECT ENAME FROM EMP WHERE substr(ENAME,2,1) = ‘A’;<br>    +——–+<br>    | ENAME  |<br>    +——–+<br>    | WARD   |<br>    | MARTIN |<br>    | JAMES  |<br>    +——–+<br>    3 rows in set (0.00 sec)</p><p>length(args1)</p><p>select length(ename) from emp;</p><p>trim  去除查询中输入的空格<br>mysql&gt; SELECT ENAME FROM EMP WHERE substr(ENAME,2,1) = ‘A’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| WARD   |<br>| MARTIN |<br>| JAMES  |<br>+——–+<br>3 rows in set (0.00 sec)</p><p>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME=’ SMITH ‘;<br>Empty set (0.00 sec)</p><p>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME = trim(‘ SMITH ‘);<br>+——-+<br>| ENAME |<br>+——-+<br>| SMITH |<br>+——-+<br>1 row in set (0.00 sec)</p><p>补助为空的显示为0<br>mysql&gt; SELECT ENAME,ifnull(comm,0) as comm from EMP;<br>+——–+———+<br>| ENAME  | comm    |<br>+——–+———+<br>| SMITH  |    0.00 |<br>| ALLEN  |  300.00 |<br>| WARD   |  500.00 |<br>| JONES  |    0.00 |<br>| MARTIN | 1400.00 |<br>| BLAKE  |    0.00 |<br>| CLARK  |    0.00 |<br>| SCOTT  |    0.00 |<br>| KING   |    0.00 |<br>| TURNER |    0.00 |<br>| ADAMS  |    0.00 |<br>| JAMES  |    0.00 |<br>| FORD   |    0.00 |<br>| MILLER |    0.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; SELECT ENAME,(SAL+ifnull(comm,0))*12 as yearsal from EMP;<br>+——–+———-+<br>| ENAME  | yearsal  |<br>+——–+———-+<br>| SMITH  |  9600.00 |<br>| ALLEN  | 22800.00 |<br>| WARD   | 21000.00 |<br>| JONES  | 35700.00 |<br>| MARTIN | 31800.00 |<br>| BLAKE  | 34200.00 |<br>| CLARK  | 29400.00 |<br>| SCOTT  | 36000.00 |<br>| KING   | 60000.00 |<br>| TURNER | 18000.00 |<br>| ADAMS  | 13200.00 |<br>| JAMES  | 11400.00 |<br>| FORD   | 36000.00 |<br>| MILLER | 15600.00 |<br>+——–+———-+<br>14 rows in set (0.00 sec)</p><p>0     先了解一下数据库中的数据类型：<br>    int            整数型<br>    varchar        可变长度字符串<br>    char        定长字符串<br>    date        日期类型<br>    double        浮点类型</p><ol><li><p>关于MYSQL中的日期处理<br> 1.1  每一个数据库处理日期的时候，采用的机制都是不同的，日期处理都有自己的一套机制。<br> 所有在实际的开发中，表中的字段定义为DATE类型，这种情况很少。因为一旦使用日期类型，那么java程序将不能够通用。在实际开发中，一般使用日期字符串来表示日期<br> 1.2  日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以还是需要掌握。</p><pre><code>     -     str_to_date     -    date_format str_to_date:     该函数的作用是：将“日期字符串”转换成“日期类型”的数据 【varchar  ----&gt; date】                 该函数的执行结果是DATE类型                 该函数的使用格式：                     str_to_date(&#39;日期字符串&#39;,&#39;日期格式&#39;)                 关于MYSQL中的日期格式：                         回顾java中的日期格式：                             yyyy    年                             MM        月                             dd        日                             HH        时                             mm        分                             ss        秒                             SSS        毫秒                 java中将字符串转换成日期类型：                     SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);                     Date date = sdf.parse(&quot;1970-10-10&quot;);                 MySQL的日期格式：                     %Y          年                     %m            月                     %d            日                     %H            时                     %i            分                     %s            秒</code></pre></li></ol><p>MYSQL默认的日期格式： %Y-%m-%d              </p><pre><code>        案例： 查询出1980-12-17入职的员工                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE = &#39;1980-12-17&#39;;                +-------+------------+                | ENAME | HIREDATE   |                +-------+------------+                | SMITH | 1980-12-17 |                +-------+------------+                1 row in set (0.01 sec)                等同如下SQL命令:                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE = str_to_date(&#39;1980-12-17&#39;,&#39;%Y-%m-%d&#39;);                +-------+------------+                | ENAME | HIREDATE   |                +-------+------------+                | SMITH | 1980-12-17 |                +-------+------------+                1 row in set (0.00 sec)                MYSQL默认的日期格式： %Y-%m-%d，以上的日期字符串&#39;1980-12-17&#39;正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE=&#39;12-17-1980&#39;;                Empty set, 1 warning (0.00 sec)                &#39;12-17-1980&#39;日期字符串和mysql默认的日期格式不同                hiredate是date类型，&#39;12-17-1980&#39;是一个字符串varchar类型，类型不匹配.                所以无法查询结果，并且有警告方法。                纠正以上SQL语句的错误：                select ENAME, HIREDATE from EMP where HIREDATE = str_to_date(&#39;12-17-1980&#39;,%d-%m-%Y);                mysql&gt; select version();                +-----------+                | version() |                +-----------+                | 5.7.26    |                +-----------+                1 row in set (0.00 sec)                mysql&gt; select ENAME, HIREDATE from EMP where HIREDATE = str_to_date(&#39;12-17-1980&#39;,%d-%m-%Y);                ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;%d-%m-%Y)&#39; at line 1                在5.7.26中没有测试通过        3.6  案例：            创建学生表: 【create 语句，以后详细讲】            create table t_student(                id int(10),                name varchar(32),                birth date            );            插入数据：【insert语句，以后详细讲】            insert into t_student(id,name,birth) values(1,&#39;jack&#39;,&#39;1980-10-11&#39;);            以上可以执行，因为&#39;1980-10-11&#39;虽然是一个varchar类型，但是由于格式和MYSQL数据库默认的日期格式相同，所以存在自动类型转换.            mysql&gt;insert into t_student(id,name,birth) values(2,&#39;zhangsan&#39;,&#39;10-11-1970&#39;);            ERROR 1292(22007):Incorrect date value:&#39;10-11-1970&#39; for column &#39;birth&#39; at row 1 以上发生错误：                    第一：&#39;10-11-1970&#39;日期字符串的格式和mysql默认的格式不同                    第二：&#39;10-11-1970&#39;是varchar类型，birth字段需要date类型，类型不匹配.                    纠正以上错误：                    insert into t_student(id,name,birth) values(2,&#39;zhangsan&#39;,str_to_date(&#39;10-11-1970&#39;,&#39;%m-%d-%Y&#39;));    str_to_date函数通常使用在插入操作中，字段是date类型，不接收字符串varchar类型。    需要通过该函数将varchar变成date再插入数据，才能成功。date_format:    该函数的作用是：将&quot;日期类型date&quot;转换成具有特定格式的日期字符串varchar【date---&gt;varchar】    该函数的运算结果是:varchar类型【具备特定格式的】    该函数的语法格式：    date_format(日期类型数据,&#39;日期格式&#39;)    回顾java中的日期格式化：            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            Date nowTime = new Date();            String strTime = sdf.format(newTime);        案例：查询员工的入职日期，以&#39;10-12-1980&#39;的格式显示到窗口中。            mysql&gt; SELECT ENAME, date_format(hiredate,&#39;%m-%d-%Y&#39;) as HIREDATE  from EMP;            +--------+------------+            | ENAME  | HIREDATE   |            +--------+------------+            | SMITH  | 12-17-1980 |            | ALLEN  | 02-20-1981 |            | WARD   | 02-22-1981 |            | JONES  | 04-02-1981 |            | MARTIN | 09-28-1981 |            | BLAKE  | 05-01-1981 |            | CLARK  | 06-09-1981 |            | SCOTT  | 04-19-1987 |            | KING   | 11-17-1981 |            | TURNER | 09-08-1981 |            | ADAMS  | 05-23-1987 |            | JAMES  | 12-03-1981 |            | FORD   | 12-03-1981 |            | MILLER | 01-23-1982 |            +--------+------------+            14 rows in set (0.00 sec)        以下两个DQL语句的执行结果相同：        select ename,hiredate from emp; 【hiredate自动转换成varchar类型，并且采用 %Y-%m-%d 格式】            mysql&gt; SELECT ENAME, HIREDATE FROM EMP;            +--------+------------+            | ENAME  | HIREDATE   |            +--------+------------+            | SMITH  | 1980-12-17 |            | ALLEN  | 1981-02-20 |            | WARD   | 1981-02-22 |            | JONES  | 1981-04-02 |            | MARTIN | 1981-09-28 |            | BLAKE  | 1981-05-01 |            | CLARK  | 1981-06-09 |            | SCOTT  | 1987-04-19 |            | KING   | 1981-11-17 |            | TURNER | 1981-09-08 |            | ADAMS  | 1987-05-23 |            | JAMES  | 1981-12-03 |            | FORD   | 1981-12-03 |            | MILLER | 1982-01-23 |            +--------+------------+            14 rows in set (0.00 sec)        select ename,date_format(hiredate,&#39;%Y-%m-%d&#39;) as hiredate from emp;        mysql&gt; SELECT ENAME,date_format(HIREDATE,&#39;%Y-%m-%d&#39;) as HIREDATE FROM EMP;        +--------+------------+        | ENAME  | HIREDATE   |        +--------+------------+        | SMITH  | 1980-12-17 |        | ALLEN  | 1981-02-20 |        | WARD   | 1981-02-22 |        | JONES  | 1981-04-02 |        | MARTIN | 1981-09-28 |        | BLAKE  | 1981-05-01 |        | CLARK  | 1981-06-09 |        | SCOTT  | 1987-04-19 |        | KING   | 1981-11-17 |        | TURNER | 1981-09-08 |        | ADAMS  | 1987-05-23 |        | JAMES  | 1981-12-03 |        | FORD   | 1981-12-03 |        | MILLER | 1982-01-23 |        +--------+------------+        14 rows in set (0.00 sec)        结论：date_format函数主要使用在查询操作中，客户需要日期以特定格式展示的时候，需要用到该函数。</code></pre><p>分组函数/聚合函数/多行处理函数<br>注意：分组函数不能直接使用在where子句中<br>count         取得记录数<br>sum            求和<br>avg            取平均<br>max            取最大的数<br>min            取最小的数<br>注意：分组函数自动忽略空值，不需要手动的加where条件排除控制<br>select count(*) from emp where xxx;符合条件的所有记录总数<br>select count(comm) from emp; comm这个字段中不为空的元素总数<br>注意：分组函数不能直接使用在where关键字后面</p><p>distinct关键字  去除重复记录<br>注意：distinct只能放到所有字段最前面<br>    mysql&gt; SELECT JOB FROM EMP;<br>    +———–+<br>    | JOB       |<br>    +———–+<br>    | CLERK     |<br>    | SALESMAN  |<br>    | SALESMAN  |<br>    | MANAGER   |<br>    | SALESMAN  |<br>    | MANAGER   |<br>    | MANAGER   |<br>    | ANALYST   |<br>    | PRESIDENT |<br>    | SALESMAN  |<br>    | CLERK     |<br>    | CLERK     |<br>    | ANALYST   |<br>    | CLERK     |<br>    +———–+<br>    14 rows in set (0.00 sec)</p><pre><code>mysql&gt; SELECT distinct JOB FROM EMP;+-----------+| JOB       |+-----------+| CLERK     || SALESMAN  || MANAGER   || ANALYST   || PRESIDENT |+-----------+5 rows in set (0.00 sec)mysql&gt; SELECT DEPTNO,JOB FROM EMP;+--------+-----------+| DEPTNO | JOB       |+--------+-----------+|     20 | CLERK     ||     30 | SALESMAN  ||     30 | SALESMAN  ||     20 | MANAGER   ||     30 | SALESMAN  ||     30 | MANAGER   ||     20 | MANAGER   ||     20 | ANALYST   ||     10 | PRESIDENT ||     30 | SALESMAN  ||     20 | CLERK     ||     30 | CLERK     ||     20 | ANALYST   ||     10 | CLERK     |+--------+-----------+14 rows in set (0.00 sec)mysql&gt; SELECT distinct DEPTNO,JOB FROM EMP;+--------+-----------+| DEPTNO | JOB       |+--------+-----------+|     20 | CLERK     ||     30 | SALESMAN  ||     20 | MANAGER   ||     30 | MANAGER   ||     20 | ANALYST   ||     10 | PRESIDENT ||     30 | CLERK     ||     10 | CLERK     |+--------+-----------+8 rows in set (0.00 sec)</code></pre><p>select count(distinct job) from emp;<br>    mysql&gt; SELECT count(distinct JOB) from EMP;<br>    +———————+<br>    | count(distinct JOB) |<br>    +———————+<br>    |                   5 |<br>    +———————+<br>    1 row in set (0.00 sec)</p><p>分组查询：<br>    分组查询主要涉及两个子句，分别是：group by和 having<br>    group by 分组查询<br>            order by 【表示通过哪个或者哪些字段进行排序】<br>            group by 【表示通过哪个或者哪些字段进行分组】<br>    2.2    案例：找出每个工作岗位的最高薪水 【先按照工作岗位分组，使用max求每一组的最高薪水】<br>        select<br>                max(sal)<br>        from<br>                emp<br>        group by<br>                job;<br>        mysql&gt; SELECT max(SAL) FROM EMP GROUP BY JOB;<br>        +———-+<br>        | max(SAL) |<br>        +———-+<br>        |  3000.00 |<br>        |  1300.00 |<br>        |  2975.00 |<br>        |  5000.00 |<br>        |  1600.00 |<br>        +———-+<br>        5 rows in set (0.00 sec)</p><pre><code>    以上的SQL语句表示，先按照job分组，然后对每一组使用max(sal)求最高薪水。    以上查询结果是5条记录。        工作岗位可以写到select后面吗？        可以，因为正好工作岗位job也是5个不同的值。        select                 job,max(sal)        from                 emp        group by                job;        mysql&gt; SELECT JOB,max(SAL) FROM EMP GROUP BY JOB;        +-----------+----------+        | JOB       | max(SAL) |        +-----------+----------+        | ANALYST   |  3000.00 |        | CLERK     |  1300.00 |        | MANAGER   |  2975.00 |        | PRESIDENT |  5000.00 |        | SALESMAN  |  1600.00 |        +-----------+----------+        5 rows in set (0.00 sec)    ename可以编写到select后面吗？            - mysql中，可以，语法在这方面比较松散，不严格，但是查询结果没有意义            - oracle中，不可以，执行的时候报错。                select                 ename,job,max(sal)        from                emp        group by                job;        mysql&gt; select ENAME,JOB,MAX(SAL) FROM EMP GROUP BY JOB;            ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;bjpowernode.EMP.ENAME&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by            mysql&gt; SELECT ENAME,JOB,max(SAL) from EMP group by JOB;            ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;bjpowernode.EMP.ENAME&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by    *重点：若一条SQL语句当中有group by子句，那么select关键子后面只能跟参与分组的字段和分组的函数。*2.3 案例：计算每个部门的平均薪水【按照部门编号分组，对每一组求平均薪水】    mysql&gt; select deptno,avg(sal) as avgsal from emp group by deptno;    mysql&gt; SELECT DEPTNO,avg(SAL) as avgsal FROM EMP GROUP BY DEPTNO;    +--------+-------------+    | DEPTNO | avgsal      |    +--------+-------------+    |     10 | 3150.000000 |    |     20 | 2220.833333 |    |     30 | 1566.666667 |    +--------+-------------+    3 rows in set (0.00 sec)    mysql&gt; SELECT * FROM DEPT;    +--------+------------+-----------+    | DEPTNO | DNAME      | LOC       |    +--------+------------+-----------+    |     10 | ACCOUNTING | NEW YOURK |    |     20 | RESEARCH   | DALLAS    |    |     30 | SALES      | CHICAGO   |    |     40 | OPERATIONS | BOSTON    |    +--------+------------+-----------+    4 rows in set (0.00 sec)    mysql&gt; SELECT * FROM EMP;    +-------+--------+-----------+------+------------+---------+---------+--------+    | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |    +-------+--------+-----------+------+------------+---------+---------+--------+    |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |    |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |    |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |    |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |    |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |    |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |    |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |    |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |    |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |    |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |    |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |    |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |    |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |    |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |    +-------+--------+-----------+------+------------+---------+---------+--------+2.4 案例：计算不同部门中的不同岗位的最高薪水    select deptno,job,max(sal) from emp group by deptno,job;   //deptno,job两个字段联合起来分组。    mysql&gt; SELECT DEPTNO, JOB,max(SAL) from EMP group by DEPTNO,JOB;    +--------+-----------+----------+    | DEPTNO | JOB       | max(SAL) |    +--------+-----------+----------+    |     10 | CLERK     |  1300.00 |    |     10 | PRESIDENT |  5000.00 |    |     20 | ANALYST   |  3000.00 |    |     20 | CLERK     |  1100.00 |    |     20 | MANAGER   |  2975.00 |    |     30 | CLERK     |   950.00 |    |     30 | MANAGER   |  2850.00 |    |     30 | SALESMAN  |  1600.00 |    +--------+-----------+----------+    8 rows in set (0.00 sec)2.5 找出每个工作岗位的最高薪水，除MANAGER之外    mysql&gt; select job,max(sal) from emp group by job;        mysql&gt; SELECT JOB,max(SAL) from EMP group by JOB;        +-----------+----------+        | JOB       | max(SAL) |        +-----------+----------+        | ANALYST   |  3000.00 |        | CLERK     |  1300.00 |        | MANAGER   |  2975.00 |        | PRESIDENT |  5000.00 |        | SALESMAN  |  1600.00 |        +-----------+----------+        5 rows in set (0.00 sec)    mysql&gt; select job,max(sal) from emp where job&lt;&gt;&#39;MANAGER&#39; group by job;    mysql&gt;     mysql&gt; SELECT JOB,max(SAL) from EMP where JOB&lt;&gt;&#39;MANAGER&#39; GROUP BY JOB;    +-----------+----------+    | JOB       | max(SAL) |    +-----------+----------+    | ANALYST   |  3000.00 |    | CLERK     |  1300.00 |    | PRESIDENT |  5000.00 |    | SALESMAN  |  1600.00 |    +-----------+----------+    4 rows in set (0.00 sec)2.6 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.    select job,avg(sal)  from emp group by job;    select job,avg(sal) from emp where avg(sal)&gt;1500 group by job;    ERROR 1111(HY00):Invalid user of group function    where关键字后面不能使用分组函数.    分组函数必须在分组完成后执行，而分组需要group by,而group by在where后面执行。注意：下面这个SQL语句执行会报错误：Group function is not allowed here    找出公司中哪些部门的平均薪水大于6000的列出来：        select                 department_id, avg(salary)        from                    employees        where                 avg(salary)&gt;6000        group by department_id        #having avg(salary) &gt;6000        ;    原因：        sql语句的执行顺序为：            from         子句            where        子句            group by     子句            having         子句            order by     子句            select         子句        首先得知道分组/聚合函数是对结果集运算的，当在where子句使用聚合函数时，此时根据group by分割结果集的子句还没有执行，此时只有from后的结果集。        所以无法在where子句中使用聚合函数。</code></pre><ol start="3"><li><p>having</p><pre><code>  having 和 where功能都是为了完成数据的过滤  where和having后面都是添加条件  *where  在group by之前完成过滤*  *having 在group by之后完成过滤*  案例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500  select           job,avg(sal)  from          emp  group by          job  having          avg(sal)&gt;1500;  mysql&gt; SELECT JOB,avg(SAL) FROM EMP group by JOB having avg(SAL) &gt;1500;  +-----------+-------------+  | JOB       | avg(SAL)    |  +-----------+-------------+  | ANALYST   | 3000.000000 |  | MANAGER   | 2758.333333 |  | PRESIDENT | 5000.000000 |  +-----------+-------------+  3 rows in set (0.00 sec)</code></pre></li></ol><pre><code>    原则：            尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。            效率的问题</code></pre><ol start="4"><li><p>一个完整的DQL语句的总结<br>  select</p><pre><code>      ...</code></pre><p>  from</p><pre><code>      ...</code></pre><p>  where</p><pre><code>      ...</code></pre><p>  group by</p><pre><code>      ...</code></pre><p>  having </p><pre><code>      ...</code></pre><p>  order by</p><pre><code>      ...</code></pre><p>  第一：以上的关键字顺序不能变，严格遵守<br>  第二：执行顺序</p><pre><code>      1.from       从某张表中检索数据      2.where      经过某条件进行过滤      3.group by      然后分组      4.having     分组之后不满意再过滤      5.select     查询出来      6.order by   排序输出</code></pre></li></ol><p>连接查询<br>    1 什么是连接查询？<br>            - 查询的时候只从一张表检索数据，被称为单表查询<br>            - 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中<br>                这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，<br>                这种多表查询被称为连接查询或者叫做跨表查询。<br>    2 连接查询根据出现年代分类：<br>            - SQL92【1992】<br>            - SQL99【1999：更新的语法，主要掌握这种语法】<br>            DBA: DataBase Administrator【数据库管理员，薪水很高】<br>            老的DBA可能还在编写SQL92语法，所以SQL92语法也要会，起码能看懂。<br>    3 连接查询根据连接方式可以分为：<br>            - 内连接<br>                * 等值连接<br>                * 非等值连接<br>                * 自连接<br>            - 外链接<br>                * 左外连接（左连接）<br>                * 右外连接(右连接)<br>            - 全连接【不讲，使用很少】</p><pre><code>4 当多张表进行连接查询，若没有任何条件进行限制，会发生什么现象？    案例：查询每一个员工所在的部门名称，要求最终显示员工名和对应的部门名。    SELECT ENAME,DEPTNO FROM EMP;&lt;emp是员工表&gt;    mysql&gt; SELECT ENAME,DEPTNO FROM EMP;    +--------+--------+    | ENAME  | DEPTNO |    +--------+--------+    | SMITH  |     20 |    | ALLEN  |     30 |    | WARD   |     30 |    | JONES  |     20 |    | MARTIN |     30 |    | BLAKE  |     30 |    | CLARK  |     20 |    | SCOTT  |     20 |    | KING   |     10 |    | TURNER |     30 |    | ADAMS  |     20 |    | JAMES  |     30 |    | FORD   |     20 |    | MILLER |     10 |    +--------+--------+    14 rows in set (0.00 sec)    SELECT DEPTNO,DNAME FROM DEPT;&lt;dept是部门表&gt;    mysql&gt; SELECT DEPTNO,DNAME FROM DEPT;    +--------+------------+    | DEPTNO | DNAME      |    +--------+------------+    |     10 | ACCOUNTING |    |     20 | RESEARCH   |    |     30 | SALES      |    |     40 | OPERATIONS |    +--------+------------+    4 rows in set (0.00 sec)    主要分析：多张表连接查询，若没有任何条件限制，会发生什么？    小知识点：在进行多表连接查询的时候，尽量给表起别名，这样效率高，可读性高。    mysql&gt; select e.ENAME,d.DNAME from EMP e,DEPT d;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | ACCOUNTING |    | SMITH  | RESEARCH   |    | SMITH  | SALES      |    | SMITH  | OPERATIONS |    | ALLEN  | ACCOUNTING |    | ALLEN  | RESEARCH   |    | ALLEN  | SALES      |    | ALLEN  | OPERATIONS |    | WARD   | ACCOUNTING |    | WARD   | RESEARCH   |    | WARD   | SALES      |    | WARD   | OPERATIONS |    | JONES  | ACCOUNTING |    | JONES  | RESEARCH   |    | JONES  | SALES      |    | JONES  | OPERATIONS |    | MARTIN | ACCOUNTING |    | MARTIN | RESEARCH   |    | MARTIN | SALES      |    | MARTIN | OPERATIONS |    | BLAKE  | ACCOUNTING |    | BLAKE  | RESEARCH   |    | BLAKE  | SALES      |    | BLAKE  | OPERATIONS |    | CLARK  | ACCOUNTING |    | CLARK  | RESEARCH   |    | CLARK  | SALES      |    | CLARK  | OPERATIONS |    | SCOTT  | ACCOUNTING |    | SCOTT  | RESEARCH   |    | SCOTT  | SALES      |    | SCOTT  | OPERATIONS |    | KING   | ACCOUNTING |    | KING   | RESEARCH   |    | KING   | SALES      |    | KING   | OPERATIONS |    | TURNER | ACCOUNTING |    | TURNER | RESEARCH   |    | TURNER | SALES      |    | TURNER | OPERATIONS |    | ADAMS  | ACCOUNTING |    | ADAMS  | RESEARCH   |    | ADAMS  | SALES      |    | ADAMS  | OPERATIONS |    | JAMES  | ACCOUNTING |    | JAMES  | RESEARCH   |    | JAMES  | SALES      |    | JAMES  | OPERATIONS |    | FORD   | ACCOUNTING |    | FORD   | RESEARCH   |    | FORD   | SALES      |    | FORD   | OPERATIONS |    | MILLER | ACCOUNTING |    | MILLER | RESEARCH   |    | MILLER | SALES      |    | MILLER | OPERATIONS |    +--------+------------+    56 rows in set (0.00 sec)结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，这种现象被称为笛卡尔积现象。为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件。5    案例：查询每一个员工所在的部门名称，要求最终显示员工名和对应的部门名。    mysql&gt; SELECT ENAME,DEPTNO FROM EMP;   &lt;EMP是员工表&gt;    +--------+--------+    | ENAME  | DEPTNO |    +--------+--------+    | SMITH  |     20 |    | ALLEN  |     30 |    | WARD   |     30 |    | JONES  |     20 |    | MARTIN |     30 |    | BLAKE  |     30 |    | CLARK  |     20 |    | SCOTT  |     20 |    | KING   |     10 |    | TURNER |     30 |    | ADAMS  |     20 |    | JAMES  |     30 |    | FORD   |     20 |    | MILLER |     10 |    +--------+--------+    14 rows in set (0.00 sec)mysql&gt; SELECT DEPTNO,DNAME FROM DEPT;&lt;DEPT是部门表&gt;    +--------+------------+    | DEPTNO | DNAME      |    +--------+------------+    |     10 | ACCOUNTING |    |     20 | RESEARCH   |    |     30 | SALES      |    |     40 | OPERATIONS |    +--------+------------+    4 rows in set (0.00 sec)注意：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。SQL92语法：内连接中的等值连接mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e, DEPT d where e.DEPTNO = d.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)SQL99语法：内连接中的等值连接SQL99语法的优点：表连接独立出来了，结构更清晰，对表连接不满意的话，可以再追加where进行过滤。mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e join DEPT d on e.DEPTNO = d.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e inner join DEPT d on e.DEPTNO = d.DEPTNO; //inner可以省略mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e inner join DEPT d on e.DEPTNO = d.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)6. 案例：找出每一个员工对应的工资等级，要求显示员工名、工资等级。mysql&gt; SELECT * FROM SALGRADE;+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+5 rows in set (0.00 sec)mysql&gt; SELECT * FROM EMP;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+14 rows in set (0.00 sec)mysql&gt; SELECT * from EMP E, SALGRADE S WHERE E.SAL between S.LOSAL AND S.HISAL;+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | GRADE | LOSAL | HISAL |+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |     1 |   700 |  1200 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     3 |  1401 |  2000 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     2 |  1201 |  1400 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     2 |  1201 |  1400 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |     4 |  2001 |  3000 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |     5 |  3001 |  9999 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     3 |  1401 |  2000 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |     1 |   700 |  1200 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |     1 |   700 |  1200 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |     2 |  1201 |  1400 |+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+14 rows in set (0.00 sec)mysql&gt; SELECT E.ENAME,E.SAL,S.GRADE from EMP E, SALGRADE S WHERE E.SAL between S.LOSAL AND S.HISAL;+--------+---------+-------+| ENAME  | SAL     | GRADE |+--------+---------+-------+| SMITH  |  800.00 |     1 || ALLEN  | 1600.00 |     3 || WARD   | 1250.00 |     2 || JONES  | 2975.00 |     4 || MARTIN | 1250.00 |     2 || BLAKE  | 2850.00 |     4 || CLARK  | 2450.00 |     4 || SCOTT  | 3000.00 |     4 || KING   | 5000.00 |     5 || TURNER | 1500.00 |     3 || ADAMS  | 1100.00 |     1 || JAMES  |  950.00 |     1 || FORD   | 3000.00 |     4 || MILLER | 1300.00 |     2 |+--------+---------+-------+14 rows in set (0.00 sec)SQL99语法：内连接中的非等值连接    SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e inner join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;//inner可以省略    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e inner join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;    +--------+---------+-------+    | ENAME  | SAL     | GRADE |    +--------+---------+-------+    | SMITH  |  800.00 |     1 |    | ALLEN  | 1600.00 |     3 |    | WARD   | 1250.00 |     2 |    | JONES  | 2975.00 |     4 |    | MARTIN | 1250.00 |     2 |    | BLAKE  | 2850.00 |     4 |    | CLARK  | 2450.00 |     4 |    | SCOTT  | 3000.00 |     4 |    | KING   | 5000.00 |     5 |    | TURNER | 1500.00 |     3 |    | ADAMS  | 1100.00 |     1 |    | JAMES  |  950.00 |     1 |    | FORD   | 3000.00 |     4 |    | MILLER | 1300.00 |     2 |    +--------+---------+-------+    14 rows in set (0.00 sec)    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;    +--------+---------+-------+    | ENAME  | SAL     | GRADE |    +--------+---------+-------+    | SMITH  |  800.00 |     1 |    | ALLEN  | 1600.00 |     3 |    | WARD   | 1250.00 |     2 |    | JONES  | 2975.00 |     4 |    | MARTIN | 1250.00 |     2 |    | BLAKE  | 2850.00 |     4 |    | CLARK  | 2450.00 |     4 |    | SCOTT  | 3000.00 |     4 |    | KING   | 5000.00 |     5 |    | TURNER | 1500.00 |     3 |    | ADAMS  | 1100.00 |     1 |    | JAMES  |  950.00 |     1 |    | FORD   | 3000.00 |     4 |    | MILLER | 1300.00 |     2 |    +--------+---------+-------+    14 rows in set (0.00 sec)SQL92语法：内连接中的非等值连接    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e, SALGRADE s where e.SAL between s.LOSAL and s.HISAL;    +--------+---------+-------+    | ENAME  | SAL     | GRADE |    +--------+---------+-------+    | SMITH  |  800.00 |     1 |    | ALLEN  | 1600.00 |     3 |    | WARD   | 1250.00 |     2 |    | JONES  | 2975.00 |     4 |    | MARTIN | 1250.00 |     2 |    | BLAKE  | 2850.00 |     4 |    | CLARK  | 2450.00 |     4 |    | SCOTT  | 3000.00 |     4 |    | KING   | 5000.00 |     5 |    | TURNER | 1500.00 |     3 |    | ADAMS  | 1100.00 |     1 |    | JAMES  |  950.00 |     1 |    | FORD   | 3000.00 |     4 |    | MILLER | 1300.00 |     2 |    +--------+---------+-------+    14 rows in set (0.00 sec)7.     案例：找出每一个员工的上级领导，要求显示员工名以及对应的领导名    SQL92语法：内连接中的自连接    select a.ename empname,b.ename leadername from emp a, emp b where a.mgr = b.empno;    mysql&gt; SELECT * FROM EMP;    +-------+--------+-----------+------+------------+---------+---------+--------+    | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |    +-------+--------+-----------+------+------------+---------+---------+--------+    |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |    |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |    |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |    |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |    |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |    |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |    |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |    |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |    |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |    |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |    |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |    |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |    |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |    |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |    +-------+--------+-----------+------+------------+---------+---------+--------+    14 rows in set (0.00 sec)    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A,EMP B WHERE A.MGR = B.EMPNO;    +---------+------------+    | EMPNAME | LEADERNAME |    +---------+------------+    | SMITH   | FORD       |    | ALLEN   | BLAKE      |    | WARD    | BLAKE      |    | JONES   | KING       |    | MARTIN  | BLAKE      |    | BLAKE   | KING       |    | CLARK   | KING       |    | SCOTT   | JONES      |    | TURNER  | BLAKE      |    | ADAMS   | SCOTT      |    | JAMES   | BLAKE      |    | FORD    | JONES      |    | MILLER  | CLARK      |    +---------+------------+    13 rows in set (0.00 sec)    SQL99语法：内连接中的自连接    select a.ename empname,b.ename leadername from emp a inner *join* emp b *on* a.mgr=b.empno;//inner可以省略    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A INNER JOIN EMP B ON A.MGR = B.EMPNO;    +---------+------------+    | EMPNAME | LEADERNAME |    +---------+------------+    | SMITH   | FORD       |    | ALLEN   | BLAKE      |    | WARD    | BLAKE      |    | JONES   | KING       |    | MARTIN  | BLAKE      |    | BLAKE   | KING       |    | CLARK   | KING       |    | SCOTT   | JONES      |    | TURNER  | BLAKE      |    | ADAMS   | SCOTT      |    | JAMES   | BLAKE      |    | FORD    | JONES      |    | MILLER  | CLARK      |    +---------+------------+    13 rows in set (0.00 sec)    select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A JOIN EMP B ON A.MGR=B.EMPNO;    +---------+------------+    | EMPNAME | LEADERNAME |    +---------+------------+    | SMITH   | FORD       |    | ALLEN   | BLAKE      |    | WARD    | BLAKE      |    | JONES   | KING       |    | MARTIN  | BLAKE      |    | BLAKE   | KING       |    | CLARK   | KING       |    | SCOTT   | JONES      |    | TURNER  | BLAKE      |    | ADAMS   | SCOTT      |    | JAMES   | BLAKE      |    | FORD    | JONES      |    | MILLER  | CLARK      |    +---------+------------+    13 rows in set (0.00 sec)8、案例：找出每一个员工对应的部门名称,要求显示所有部门    内连接：        A表和B表能够完全匹配的记录查询出来，被称为内连接    外连接：        A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，这种查询被称为外连接。        外连接的查询结果条数 &gt;= 内连接的查询结果条数    select e.ename, d.dname from emp e join dept d on e.deptno=d.deptno;    mysql&gt; SELECT * FROM DEPT;    +--------+------------+-----------+    | DEPTNO | DNAME      | LOC       |    +--------+------------+-----------+    |     10 | ACCOUNTING | NEW YOURK |    |     20 | RESEARCH   | DALLAS    |    |     30 | SALES      | CHICAGO   |    |     40 | OPERATIONS | BOSTON    |    +--------+------------+-----------+    4 rows in set (0.00 sec)    有四个部门    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)    14条记录只显示了三个部门    SQL99语法：外连接中的右外连接[右外连接]    select e.ename, d.dname from emp e right join dept d on e.deptno=d.deptno;    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E RIGHT JOIN DEPT D ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    15条记录显示了，所有4个部门    select e.ename,d.dname from emp e right outer join dept d on e.deptno=d.deptno; //outer可以省略    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E RIGHT OUTER JOIN DEPT D ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    SQL99语法：外连接中的左外连接[左外连接]    select e.ename, d.dname from dept d left join emp e on e.deptno=d.deptno;    mysql&gt; SELECT E.ENAME,D.DNAME FROM DEPT D LEFT JOIN EMP E ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    select e.ename,d.dname from dept d left outer join emp e on e.deptno=d.deptno; //outer可以省略    mysql&gt; SELECT E.ENAME,D.DNAME FROM DEPT D LEFT OUTER JOIN EMP E ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    注意：任何一个右外连接都可以写成左外连接，任何一个左外连接也同样可以写成右外连接为什么inner和outter可以省略，加上去有什么好处？        -    可以省略，因为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right            若存在，表示一定是一个外连接，其它都是内连接。        -    加上去的好处是增强可读性。9.    案例：找出每一个员工对应的领导名，要求显示所有的员工        select A.ENAME EMPNAME,B.ENAME LEADERNAME from EMP A left join EMP B on A.mgr=B.empno;        SELECT B.ENAME LEADERNAME, A.ENAME EMPNAME FROM EMP B RIGHT OUTER JOIN EMP A ON A.MGR=B.EMPNO;    mysql&gt; SELECT B.ENAME LEADERNAME, A.ENAME EMPNAME FROM EMP B RIGHT OUTER JOIN EMP A ON A.MGR=B.EMPNO;        +------------+---------+        | LEADERNAME | EMPNAME |        +------------+---------+        | FORD       | SMITH   |        | BLAKE      | ALLEN   |        | BLAKE      | WARD    |        | KING       | JONES   |        | BLAKE      | MARTIN  |        | KING       | BLAKE   |        | KING       | CLARK   |        | JONES      | SCOTT   |        | NULL       | KING    |        | BLAKE      | TURNER  |        | SCOTT      | ADAMS   |        | BLAKE      | JAMES   |        | JONES      | FORD    |        | CLARK      | MILLER  |        +------------+---------+        14 rows in set (0.00 sec)        mysql&gt; select A.ENAME EMPNAME,B.ENAME LEADERNAME from EMP A left OUTER join EMP B on A.mgr=B.empno;        +---------+------------+        | EMPNAME | LEADERNAME |        +---------+------------+        | SMITH   | FORD       |        | ALLEN   | BLAKE      |        | WARD    | BLAKE      |        | JONES   | KING       |        | MARTIN  | BLAKE      |        | BLAKE   | KING       |        | CLARK   | KING       |        | SCOTT   | JONES      |        | KING    | NULL       |        | TURNER  | BLAKE      |        | ADAMS   | SCOTT      |        | JAMES   | BLAKE      |        | FORD    | JONES      |        | MILLER  | CLARK      |        +---------+------------+        14 rows in set (0.01 sec)</code></pre><p>10    案例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级</p><pre><code>*多张表进行表连接的语法格式*select         xxxfrom        ajoin        bon        条件join        con        条件原理：a和b表进行表连接1    先找出每一个员工对应的部门名称，显示员工名、部门名        mysql&gt; SELECT A.ENAME EMPNAME ,B.DNAME DEPTNAME FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO ;        +---------+------------+        | EMPNAME | DEPTNAME   |        +---------+------------+        | SMITH   | RESEARCH   |        | ALLEN   | SALES      |        | WARD    | SALES      |        | JONES   | RESEARCH   |        | MARTIN  | SALES      |        | BLAKE   | SALES      |        | CLARK   | RESEARCH   |        | SCOTT   | RESEARCH   |        | KING    | ACCOUNTING |        | TURNER  | SALES      |        | ADAMS   | RESEARCH   |        | JAMES   | SALES      |        | FORD    | RESEARCH   |        | MILLER  | ACCOUNTING |        +---------+------------+        14 rows in set (0.00 sec)mysql&gt; SELECT * FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO ;+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO | DNAME      | LOC       |+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     30 | SALES      | CHICAGO   ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     30 | SALES      | CHICAGO   ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     30 | SALES      | CHICAGO   ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |     30 | SALES      | CHICAGO   ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |     10 | ACCOUNTING | NEW YOURK ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     30 | SALES      | CHICAGO   ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |     30 | SALES      | CHICAGO   ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |     10 | ACCOUNTING | NEW YOURK |+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+14 rows in set (0.00 sec)    mysql&gt; SELECT A.ENAME EMPNAME ,A.SAL EMPSAL ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL&gt;C.LOSAL AND A.SAL&lt;C.HISAL ;    +---------+------------+-------+    | EMPNAME | DEPTNAME   | GRADE |    +---------+------------+-------+    | SMITH   | RESEARCH   |     1 |    | ALLEN   | SALES      |     3 |    | WARD    | SALES      |     2 |    | JONES   | RESEARCH   |     4 |    | MARTIN  | SALES      |     2 |    | BLAKE   | SALES      |     4 |    | CLARK   | RESEARCH   |     4 |    | KING    | ACCOUNTING |     5 |    | TURNER  | SALES      |     3 |    | ADAMS   | RESEARCH   |     1 |    | JAMES   | SALES      |     1 |    | MILLER  | ACCOUNTING |     2 |    +---------+------------+-------+    12 rows in set (0.00 sec    mysql&gt; SELECT A.ENAME EMPNAME ,A.SAL EMPSAL ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL&gt;C.LOSAL AND A.SAL&lt;C.HISAL ;        +---------+---------+------------+-------+        | EMPNAME | EMPSAL  | DEPTNAME   | GRADE |        +---------+---------+------------+-------+        | SMITH   |  800.00 | RESEARCH   |     1 |        | ALLEN   | 1600.00 | SALES      |     3 |        | WARD    | 1250.00 | SALES      |     2 |        | JONES   | 2975.00 | RESEARCH   |     4 |        | MARTIN  | 1250.00 | SALES      |     2 |        | BLAKE   | 2850.00 | SALES      |     4 |        | CLARK   | 2450.00 | RESEARCH   |     4 |        | KING    | 5000.00 | ACCOUNTING |     5 |        | TURNER  | 1500.00 | SALES      |     3 |        | ADAMS   | 1100.00 | RESEARCH   |     1 |        | JAMES   |  950.00 | SALES      |     1 |        | MILLER  | 1300.00 | ACCOUNTING |     2 |        +---------+---------+------------+-------+        12 rows in set (0.00 sec)        mysql&gt; SELECT * FROM SALGRADE;        +-------+-------+-------+        | GRADE | LOSAL | HISAL |        +-------+-------+-------+        |     1 |   700 |  1200 |        |     2 |  1201 |  1400 |        |     3 |  1401 |  2000 |        |     4 |  2001 |  3000 |        |     5 |  3001 |  9999 |        +-------+-------+-------+        5 rows in set (0.00 sec)    mysql&gt; SELECT A.ENAME EMPNAME ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL BETWEEN C.LOSAL AND HISAL ;    +---------+------------+-------+    | EMPNAME | DEPTNAME   | GRADE |    +---------+------------+-------+    | SMITH   | RESEARCH   |     1 |    | ALLEN   | SALES      |     3 |    | WARD    | SALES      |     2 |    | JONES   | RESEARCH   |     4 |    | MARTIN  | SALES      |     2 |    | BLAKE   | SALES      |     4 |    | CLARK   | RESEARCH   |     4 |    | SCOTT   | RESEARCH   |     4 |    | KING    | ACCOUNTING |     5 |    | TURNER  | SALES      |     3 |    | ADAMS   | RESEARCH   |     1 |    | JAMES   | SALES      |     1 |    | FORD    | RESEARCH   |     4 |    | MILLER  | ACCOUNTING |     2 |    +---------+------------+-------+    14 rows in set (0.00 sec)</code></pre><p>子查询<br>子查询就是嵌套的select语句，可以理解为子查询是一张表<br>    在where语句中使用子查询，也就是在where语句中加入select语句<br>    1、什么是子查询？<br>        - select 语句嵌套select语句<br>    2、子查询可以出现在哪？<br>        select …(select)<br>        from…(select)<br>        where…(select)<br>    WHERE后面使用子查询<br>    3、案例：找出薪水比公司平均薪水高的员工，显示员工名和薪水</p><pre><code>select ENAME,SAL from EMP where SAL &gt;avg(SAL);以上语句执行报错，分组函数不能直接使用在where后面第一步： 找出公司的平均薪水mysql&gt; select avg(SAL) from EMP;+-------------+| avg(SAL)    |+-------------+| 2073.214286 |+-------------+1 row in set (0.00 sec)第二步：找出薪水大于平均薪水的员工信息：mysql&gt; SELECT ENAME,SAL FROM EMP WHERE SAL &gt; (select avg(SAL) from EMP);+-------+---------+| ENAME | SAL     |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING  | 5000.00 || FORD  | 3000.00 |+-------+---------+6 rows in set (0.00 sec)</code></pre><p>4.from后面使用子查询【小窍门：将查询语句当作临时表】<br>    案例：  找出每一个部门的平均薪水，并且要求显示平均薪水的薪水等级。<br>    第一步：找出每个部门的平均薪水<br>    select DEPTNO,avg(SAL) from EMP group by DEPTNO;<br>    mysql&gt; select DEPTNO,avg(SAL) avgsal from EMP group by DEPTNO;<br>    +——–+————-+<br>    | DEPTNO | avgsal      |<br>    +——–+————-+<br>    |     10 | 3150.000000 |<br>    |     20 | 2220.833333 |<br>    |     30 | 1566.666667 |<br>    +——–+————-+<br>    3 rows in set (0.00 sec)</p><pre><code>第二步：将上面查询结果当作临时表t,t表和salgrade s表进行连接，条件：t.avgsal between s.losal and s.hisal;mysql&gt; select a.avgsal , b.GRADE from (select DEPTNO,avg(SAL) avgsal from EMP group by DEPTNO) a join SALGRADE b on a.avgsal between b.LOSAL and b.HISAL ;+-------------+-------+| avgsal      | GRADE |+-------------+-------+| 3150.000000 |     5 || 2220.833333 |     4 || 1566.666667 |     3 |+-------------+-------+3 rows in set (0.00 sec)</code></pre><p>5     在select后面使用子查询【了解】<br>    mysql&gt; SELECT E.ENAME,(SELECT D.DNAME FROM DEPT D WHERE E.DEPTNO=D.DEPTNO) AS DNAME FROM EMP E;<br>    +——–+————+<br>    | ENAME  | DNAME      |<br>    +——–+————+<br>    | SMITH  | RESEARCH   |<br>    | ALLEN  | SALES      |<br>    | WARD   | SALES      |<br>    | JONES  | RESEARCH   |<br>    | MARTIN | SALES      |<br>    | BLAKE  | SALES      |<br>    | CLARK  | RESEARCH   |<br>    | SCOTT  | RESEARCH   |<br>    | KING   | ACCOUNTING |<br>    | TURNER | SALES      |<br>    | ADAMS  | RESEARCH   |<br>    | JAMES  | SALES      |<br>    | FORD   | RESEARCH   |<br>    | MILLER | ACCOUNTING |<br>    +——–+————+<br>    14 rows in set (0.00 sec)</p><p>union</p><pre><code>mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB = &#39;MANAGER&#39; OR JOB=&#39;SALESMAN&#39;;+--------+----------+| ENAME  | JOB      |+--------+----------+| ALLEN  | SALESMAN || WARD   | SALESMAN || JONES  | MANAGER  || MARTIN | SALESMAN || BLAKE  | MANAGER  || CLARK  | MANAGER  || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec)mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;MANAGER&#39;;+-------+---------+| ENAME | JOB     |+-------+---------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER |+-------+---------+3 rows in set (0.01 sec)mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;SALESMAN&#39;;+--------+----------+| ENAME  | JOB      |+--------+----------+| ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+4 rows in set (0.00 sec)mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;MANAGER&#39;     -&gt; UNION    -&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;SALESMAN&#39;;+--------+----------+| ENAME  | JOB      |+--------+----------+| JONES  | MANAGER  || BLAKE  | MANAGER  || CLARK  | MANAGER  || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec)</code></pre><p>LIMIT<br>    1     limit用来获取一张表中的某部分数据<br>    2    limit只有在MYSQL数据库中存在，不通用，是MYSQL数据库管理系统的特色。</p><pre><code>3     案例：找出员工表前5条记录    mysql&gt; SELECT ENAME FROM EMP limit 5;    +--------+    | ENAME  |    +--------+    | SMITH  |    | ALLEN  |    | WARD   |    | JONES  |    | MARTIN |    +--------+    5 rows in set (0.00 sec)    以上SQL语句的&quot;limit 5&quot;中的5表示从表中记录下表0开始，取5条等同于下面的SQL语句：    mysql&gt; select ENAME FROM EMP LIMIT 0,5;    +--------+    | ENAME  |    +--------+    | SMITH  |    | ALLEN  |    | WARD   |    | JONES  |    | MARTIN |    +--------+    5 rows in set (0.00 sec)    LIMIT的使用语法格式：        limit起始下标，长度        起始下标没有指定，默认从0开始，0表示表中第一条记录。4    案例：找出公司中工资排名在前5名的员工    思路：按照工资降序排列取前5个    mysql&gt;     mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC;    +--------+---------+    | ENAME  | SAL     |    +--------+---------+    | KING   | 5000.00 |    | SCOTT  | 3000.00 |    | FORD   | 3000.00 |    | JONES  | 2975.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | ALLEN  | 1600.00 |    | TURNER | 1500.00 |    | MILLER | 1300.00 |    | WARD   | 1250.00 |    | MARTIN | 1250.00 |    | ADAMS  | 1100.00 |    | JAMES  |  950.00 |    | SMITH  |  800.00 |    +--------+---------+    14 rows in set (0.01 sec)    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 5;    +-------+---------+    | ENAME | SAL     |    +-------+---------+    | KING  | 5000.00 |    | FORD  | 3000.00 |    | SCOTT | 3000.00 |    | JONES | 2975.00 |    | BLAKE | 2850.00 |    +-------+---------+    5 rows in set (0.00 sec)5     案例：找出工资排名【3-9】名的员工    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 3,9;    +--------+---------+    | ENAME  | SAL     |    +--------+---------+    | JONES  | 2975.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | ALLEN  | 1600.00 |    | TURNER | 1500.00 |    | MILLER | 1300.00 |    | WARD   | 1250.00 |    | MARTIN | 1250.00 |    | ADAMS  | 1100.00 |    +--------+---------+    9 rows in set (0.00 sec)    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 2,8;    +--------+---------+    | ENAME  | SAL     |    +--------+---------+    | SCOTT  | 3000.00 |    | JONES  | 2975.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | ALLEN  | 1600.00 |    | TURNER | 1500.00 |    | MILLER | 1300.00 |    | WARD   | 1250.00 |    +--------+---------+    8 rows in set (0.00 sec)6     MYSQL中通用的分页SQL语句：    每页显示3条记录    第一页：0,3    第二页：3,3    第三页：6,3    第四页：9,3    每页显示pageSize条记录    第pageNo页：( pageNo - 1 ) * pageSize , pageSize    SELECT         t.*    FROM        t    ORDER BY        t.x DESC/ASC    LIMIT ( pageNo - 1 ) * pageSize , pageSize</code></pre><p>创建表 DDL()</p><ul><li><p>语法格式：<br>create table tableName(<br>   columnName dataType(length),<br>   columnName dataType(length),<br>);<br>set character_set_results=’utf-8’;</p><p>表：<br>   1    表格(table),用来存储数据，表格是一种结构化文件。<br>   2    表格行被称为记录(表中的数据)，表格列被称为字段。<br>   3    表格的字段属性包括：字段名称、字段数据类型、字段长度、字段约束</p><p>   4    创建表的语法：</p><pre><code>   CREATE TABLE tablename(       columnname1 dataType(length),       columnname2 dataType(length),   );</code></pre><p>   5    关于MYSQL数据库中的数据类型？</p><pre><code>   -    VARCHAR           * 可变长度字符串           * VARCHAR(3) 表示存储的数据不能超过3个字符长度   -    CHAR           * 定长字符串           * VARCHAR和CHAR对比：               - 都是字符串类型               - VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间，                 但是在分配的时候需要执行相关的判断程序，效率较低               - CHAR不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。               - 若字段中的数据布局配伸缩性，建议采用CHAR类型存储               - 若字段中的数据具备很强伸缩性，建议采用VARCHAR类型存储。               * CHAR(3)：表示存储的数据不能超过3个字符长度   -    INT           * 整数型           * INT(3) 表示最大可以存储999(老师课堂讲解有误)           INT(3) 3表示的是可以显示的有效长度(添加补零功能后，比较明显)               CREATE TABLE test01(                   with_int_length int(3),                   without_int_length int               )               insert into test01(with_int_length,without_int_length) values(1111,1111);               insert into test01(with_int_length,without_int_length) values(11111,11111);               commit;               mysql&gt; select * from test01;               +-----------------+--------------------+               | with_int_length | without_int_length |               +-----------------+--------------------+               |            1111 |               1111 |               |           11111 |              11111 |               +-----------------+--------------------+               2 rows in set (0.00 sec)               CREATE TABLE test02 (                 with_length int(3) ZEROFILL,                 without_length int               ) ENGINE=innodb, CHARSET=utf8               insert into test02 (with_length, without_length) VALUE (11, 11);               select * from test02;               mysql&gt; select * from test02;               +-------------+----------------+               | with_length | without_length |               +-------------+----------------+               |         011 |             11 |               +-------------+----------------+               1 row in set (0.01 sec)   -    BIGINT           * 长整型           * 对应Java程序中的long类型   -     FLOAT           * 浮点型单精度   -    DOUBLE           * 浮点型双精度           * DOUBLE(7,2)   表示7个有效数字，2个小数位   -    DATE           * 日期类型           * 在实际开发中为了通用，所以日期类型一般不使用，采用字符串代替日期比较多。   -    BLOB           *  Binary Large OBject 二进制大对象           * 专门存储图片声音视频等数据           *  数据库表中存储一个图片是很常见的，但是存储一个比较大的视频是很少见的。           一般都是提供一个视频的链接地址   -    CLOB           * Character Large OBject 二进制大对象           * 可以存储比较打的文本，4G+   -    其它</code></pre></li></ul><p>6    创建表格[学生表]<br>        设计：建立学生信息表，字段包括：<br>                学号 【INT】<br>                姓名 【VARCHAR】<br>                性别 【CHAR】<br>                出生日期【DATA】<br>                邮箱地址【VARCHAR】</p><pre><code>        建表语句：            CREATE TABLE t_student(            NO  INT(10),            NAME VARCHAR(32),            SEX  CHAR(1),            BIRTH DATE,            EMAIL VARCHAR(128)        );        注意：            * 表格的名字最好以t_ 或者 tb1_开始，增强可读性            * VARCHAR长度最好是2的倍数，方便存储中文        删除表格：            drop table t_student;【这种删除格式，若数据库没有这个表格，会报错】            drop table if exists t_student;【最好采用这种方式删除，mysql数据库管理系统的特色语法】        mysql&gt; desc t_student;        +-------+--------------+------+-----+---------+-------+        | Field | Type         | Null | Key | Default | Extra |        +-------+--------------+------+-----+---------+-------+        | NO    | int(10)      | YES  |     | NULL    |       |        | NAME  | varchar(32)  | YES  |     | NULL    |       |        | SEX   | char(1)      | YES  |     | NULL    |       |        | BIRTH | date         | YES  |     | NULL    |       |        | EMAIL | varchar(128) | YES  |     | NULL    |       |        +-------+--------------+------+-----+---------+-------+        5 rows in set (0.00 sec)7.     向t_student表格中插入数据    7.1 向表格插入数据必须使用insert语句，这属于DML语句    7.2 DML语句包括：insert,update,delete【增删改表中的数据，和表结构无关】    7.3    insert语句的语法格式：        INSERT INTO tablename(columnname1,columnname2,columnname3,...) values(value1,value2,value3,...)字段和值必须一一对应，个数必须相同，数据类型必须一致    7.4    向t_student表格中插入数据        INSERT INTO t_student(NO,NAME,SEX,BIRTH,EMAIL) values(1,&#39;cntsp&#39;,&#39;m&#39;,&#39;1948-11-51&#39;,&#39;cntsp@beijingpowernode.com&#39;);        INSERT INTO t_student(NO,NAME,SEX,BIRTH,EMAIL) values(2,&#39;zhongjie&#39;,&#39;m&#39;,&#39;1958-11-21&#39;,&#39;zhongjie@beijingpowernode.com&#39;);                mysql&gt; select * from t_student;        +------+----------+------+------------+-------------------------------+        | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |        +------+----------+------+------------+-------------------------------+        |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |        |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |        +------+----------+------+------------+-------------------------------+    7.5    可以这样执行insert语句吗？        INSERT INTO t_student(name,email) VALUES(&#39;wangwu&#39;,&#39;wangwu@bjpowernode.com&#39;);        mysql&gt; INSERT INTO t_student(name,email) VALUES(&#39;wangwu&#39;,&#39;wangwu@bjpowernode.com&#39;);        Query OK, 1 row affected (0.01 sec)        mysql&gt; select * from t_student;        +------+----------+------+------------+-------------------------------+        | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |        +------+----------+------+------------+-------------------------------+        |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |        |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |        | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |        +------+----------+------+------------+-------------------------------+        3 rows in set (0.00 sec)        默认情况下：当一张表被创建之后，没有指定约束的话，可以为NULL，并且没有指定任何默认值的话，默认值为NULL，这里的默认值NLL表示：若插入数据的时候没有给该字段指定任何数据，默认插入NULL值。            我们可以再向NO,SEX,BIRTH字段中插入值吗？            INSERT INTO t_student(NO,SEX,BIRTH) VALUES(3,&#39;m&#39;,&#39;1990-11-12&#39;);            mysql&gt; INSERT INTO t_student(NO,SEX,BIRTH) VALUES(3,&#39;m&#39;,&#39;1990-11-12&#39;);            Query OK, 1 row affected (0.01 sec)            mysql&gt; select * from t_student;            +------+----------+------+------------+-------------------------------+            | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |            +------+----------+------+------------+-------------------------------+            |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |            |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |            | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |            |    3 | NULL     | m    | 1990-11-12 | NULL                          |            +------+----------+------+------------+-------------------------------+            4 rows in set (0.00 sec)            以上执行insert语句只能导致底层数据库表中新增一条记录。            若希望NULL变成其它数据，需要使用UPDAT语句进行更新操作。    7.6    INSERT语句中字段的名字可以省略吗？            mysql&gt; INSERT INTO t_student VALUES(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1960-12-16&#39;,&#39;zhaoliu@163.com&#39;);            Query OK, 1 row affected (0.01 sec)            mysql&gt; select * from t_student;            +------+----------+------+------------+-------------------------------+            | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |            +------+----------+------+------------+-------------------------------+            |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |            |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |            | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |            |    3 | NULL     | m    | 1990-11-12 | NULL                          |            |    4 | zhaoliu  | m    | 1960-12-16 | zhaoliu@163.com               |            +------+----------+------+------------+-------------------------------+            5 rows in set (0.00 sec)            INSERT INTO t_student VALUES(5,&#39;LTIANLI&#39;,&#39;m&#39;,&#39;1990-05-18&#39;);            mysql&gt; INSERT INTO t_student VALUES(5,&#39;LTIANLI&#39;,&#39;m&#39;,&#39;1990-05-18&#39;);            ERROR 1136 (21S01): Column count doesn&#39;t match value count at row 1            结论：建立不要将前面的字段省略，如省略就表示将表中所有字段全部加上。省略之后程序不健壮，无法修改表结构，修改表结构，可能导致insert语句执行失败。    7.7  插入中文试试？【在DOS窗口中】            mysql&gt; show create table t_student;</code></pre><p>+———–+——————————————————————————————————————————————————————————————————————————–+<br>| Table     | Create Table                                                                                                                                                                                                                   |<br>+———–+——————————————————————————————————————————————————————————————————————————–+<br>| t_student | CREATE TABLE <code>t_student</code> (<br>  <code>NO</code> int(10) DEFAULT NULL,<br>  <code>NAME</code> varchar(32) DEFAULT NULL,<br>  <code>SEX</code> char(1) DEFAULT NULL,<br>  <code>BIRTH</code> date DEFAULT NULL,<br>  <code>EMAIL</code> varchar(128) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 |<br>+———–+——————————————————————————————————————————————————————————————————————————–+<br>1 row in set (0.00 sec)<br>            编码方式为：utf8<br>            DOS窗口操作数据库<br>            set character_set_result = ‘GBK’;<br>            插入失败，原因是DOS窗口是GBK的编码方式，但是数据库表只能接受UTF8<br>            怎么解决？<br>                使用MYSQL Front工具插入数据【MYSQL的客户端软件，在实际开发中使用较多】<br>                使用mysql front 工具插入数据成功，在DOS窗口中使用select语句查询的时候出现乱码，怎么解决？<br>                    修改查询结果集的显示编码方式，这里修改的不是DOS窗口的编码：<br>                    mysql&gt; set character_set_results = ‘GBK’;【临时有效，当前窗口有效】</p><pre><code>                查看MYSQL的相关字符编码方式：show variables like &#39;%char%&#39;;8     关于创建表格的时候给字段添加默认值：    drop table if exists t_student;    create table t_student(        no int(10),        name varchar(32),        sex char(1) default &#39;m&#39;    );    insert into t_student(no,name) values(1,&#39;jack&#39;);    insert into t_student(no,name) values(2,&#39;lucy&#39;);    commit;    mysql&gt; select * from t_student;    +------+------+------+    | no   | name | sex  |    +------+------+------+    |    1 | jack | m    |    |    2 | lucy | m    |    +------+------+------+    2 rows in set (0.00 sec)    mysql&gt; desc t_student;    +-------+-------------+------+-----+---------+-------+    | Field | Type        | Null | Key | Default | Extra |    +-------+-------------+------+-----+---------+-------+    | no    | int(10)     | YES  |     | NULL    |       |    | name  | varchar(32) | YES  |     | NULL    |       |    | sex   | char(1)     | YES  |     | m       |       |    +-------+-------------+------+-----+---------+-------+    3 rows in set (0.00 sec)    关于SQL脚本：        你是怎么看SQL脚本的？            - 该文件是一个普通的文本文件，后缀名.sql，被称为SQL脚本            - 在SQL脚本中有大量的SQL语句，想批量的执行SQL语句，可以将这些SQL语句写入SQL脚本文件中，            直接使用source执行这个脚本，可以执行大量的SQL语句。            - 若项目中期就职，可能数据库表，以及表中的记录都已经准备好了，可能Team leader就给你一个SQL脚本，直接执行这个SQL脚本将底层数据库中的数据完成初始化，就可以开发了    9     获取系统当前时间        mysql&gt; select now()            -&gt; ;        +---------------------+        | now()               |        +---------------------+        | 2019-06-22 15:55:37 |        +---------------------+        1 row in set (0.00 sec)    创建表：机构表        create table t_organization(            code char(20),            name varchar(32),            createTime date        );        insert into t_organization(code,name,createTime) values(&#39;11111&#39;,&#39;国家外汇局&#39;,now());                insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;河北省外汇局&#39;,now());        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;河南省外汇局&#39;,now());        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;山东省外汇局&#39;,now());10    表的复制【快速复制】        mysql&gt;create table EMP1 as select * from EMP;         mysql&gt; create table EMP1 as select * from EMP;         Query OK, 14 rows affected (0.01 sec)        Records: 14  Duplicates: 0  Warnings: 0        mysql&gt; show tables;        +-----------------------+        | Tables_in_bjpowernode |        +-----------------------+        | DEPT                  |        | EMP                   |        | EMP1                  |        | SALGRADE              |        | t_student             |        +-----------------------+        5 rows in set (0.00 sec)        mysql&gt; select * from EMP1;        +-------+--------+-----------+------+------------+---------+---------+--------+        | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |        +-------+--------+-----------+------+------------+---------+---------+--------+        |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |        |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |        |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |        |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |        |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |        |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |        |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |        |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |        |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |        |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |        |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |        |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |        |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |        |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |        +-------+--------+-----------+------+------------+---------+---------+--------+        14 rows in set (0.00 sec)        mysql&gt; create table  EMP2 as select EMPNO,ENAME,SAL FROM EMP;        Query OK, 14 rows affected (0.00 sec)        Records: 14  Duplicates: 0  Warnings: 0        mysql&gt;         mysql&gt; select * from EMP2;        +-------+--------+---------+        | EMPNO | ENAME  | SAL     |        +-------+--------+---------+        |  7396 | SMITH  |  800.00 |        |  7499 | ALLEN  | 1600.00 |        |  7521 | WARD   | 1250.00 |        |  7566 | JONES  | 2975.00 |        |  7654 | MARTIN | 1250.00 |        |  7698 | BLAKE  | 2850.00 |        |  7782 | CLARK  | 2450.00 |        |  7788 | SCOTT  | 3000.00 |        |  7839 | KING   | 5000.00 |        |  7844 | TURNER | 1500.00 |        |  7876 | ADAMS  | 1100.00 |        |  7900 | JAMES  |  950.00 |        |  7902 | FORD   | 3000.00 |        |  7934 | MILLER | 1300.00 |        +-------+--------+---------+        14 rows in set (0.01 sec)语法结构：        CREATE TABLE tablename AS SELECT COLUMNNAME,... FROM tablename;11    将查询结果插入到某张表中    insert into EMP2 select * from EMP2 where sal=3000;    mysql&gt; insert into EMP2 select * from EMP2 where sal=3000;    Query OK, 2 rows affected (0.00 sec)    Records: 2  Duplicates: 0  Warnings: 0    mysql&gt; SELECT * FROM EMP2;    +-------+--------+---------+    | EMPNO | ENAME  | SAL     |    +-------+--------+---------+    |  7396 | SMITH  |  800.00 |    |  7499 | ALLEN  | 1600.00 |    |  7521 | WARD   | 1250.00 |    |  7566 | JONES  | 2975.00 |    |  7654 | MARTIN | 1250.00 |    |  7698 | BLAKE  | 2850.00 |    |  7782 | CLARK  | 2450.00 |    |  7788 | SCOTT  | 3000.00 |    |  7839 | KING   | 5000.00 |    |  7844 | TURNER | 1500.00 |    |  7876 | ADAMS  | 1100.00 |    |  7900 | JAMES  |  950.00 |    |  7902 | FORD   | 3000.00 |    |  7934 | MILLER | 1300.00 |    |  7788 | SCOTT  | 3000.00 |    |  7902 | FORD   | 3000.00 |    +-------+--------+---------+    16 rows in set (0.00 sec)12  增/删/改 表结构【DDL语句】    drop table if exists t_student;    create table t_student{        NAME VARCHAR(10),        SEX CHAR(1)    };    INSERT INTO t_student(NAME,SEX) values(&#39;JACK&#39;,&#39;M&#39;);    INSERT INTO t_student(NAME,SEX) VALUES(&#39;MARY&#39;,&#39;F&#39;);    commit;    DROP TABLE IF EXISTS runoob_tb1;    CREATE TABLE IF NOT EXISTS `runoob_tbl`(       `runoob_id` INT UNSIGNED AUTO_INCREMENT,       `runoob_title` VARCHAR(100) NOT NULL,       `submission_date` DATE,        PRIMARY KEY ( `runoob_id` )        )ENGINE=InnoDB DEFAULT CHARSET=utf8;    添加字段        如：需求发生改变，需要向runoob_tbl中加入联系作者字段，字段名称为：author类型为varchar(100)        alter table runoob_tbl add author varchar(100) not null default &#39;&#39;,ALGORITHM=INPLACE;        给runoob_tbl表格添加一个作者字段        alter table runoob_tbl add author varchar(100) not null default &#39;&#39;,ALGORITHM=INPLACE;        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(100)     | NO   |     |         |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        将ru表格中的tel字段长度扩展到120个长度【改】        ALTER TABLE runoob_tbl MODIFY author VARCHAR(120);        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(100)     | NO   |     |         |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        mysql&gt; ALTER TABLE runoob_tbl MODIFY author VARCHAR(120);        Query OK, 0 rows affected (0.04 sec)        Records: 0  Duplicates: 0  Warnings: 0        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(120)     | YES  |     | NULL    |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        将runoob_tbl 表格中的author字段删除【删】        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(120)     | YES  |     | NULL    |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        mysql&gt; ALTER TABLE runoob_tbl DROP author;        Query OK, 0 rows affected (0.01 sec)        Records: 0  Duplicates: 0  Warnings: 0        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        +-----------------+------------------+------+-----+---------+----------------+        3 rows in set (0.01 sec)13    增/删/改 表中的数据【insert, update,delete 属于DML语句】    update        update 语句的语法格式                UPDATE tablename SET 字段名=字段值 ,字段名=字段值 where 条件;                注意： update语句没有条件，会将一张表所有的数据都更新        delete 语法格式：                DELETE FROM tablename where 条件;                注意： 若没有条件限制，会将这张表的数据全部删除约束和非空约束    1    什么是约束，为什么使用约束？            -    约束对应的英语单词：constraint            -    约束实际上就是表中数据的限制条件            -    表的设计的时候加入约束的目的就是为了保证表中的记录完整和有效    2    约束包括哪些呢？            -    非空约束        (not null)            -    唯一性约束        (unique)            -    主键约束        (primary key)  简称 PK            -    外键约束        (foreign key)     简称 FK            -    检查约束        (MYSQL不支持，oracle支持)    3    非空约束            -    not null约束的字段，不能为NULL值，必须给定具体的数据            -    创建表，给字段添加非空约束【创建用户表，用户名不能为空】    4    唯一性约束            - unique约束的字段具有唯一性，不可重复            - 创建用户，保证邮箱地址唯一            drop table if exists t_user;            //列级约束            create table t_user(                id int(10),                name varchar(32) not null,                email varchar(128) unique            );            insert into t_user(id,name,email) values(1,&#39;jack&#39;,&#39;jack@bjpowernode.com&#39;);//成功            insert into t_user(id,name,email) values(2,&#39;abc&#39;&#39;jack@bjpowernode.com&#39;);//失败            EEROR 1062 (23000): Duplicate entry &#39;jack@bjpowernode.com&#39; for key &#39;emial&#39;            insert into t_user(id,name) value(2,&#39;abc&#39;);//成功            insert into t_user(id,name) values(3,&#39;def&#39;);//成功            unique约束的字段不能重复，但是可以为NULL             drop table if exists t_user;            //表级约束            create table t_user{                id int(10),                name varchar(32) not null,                email varcher(128),                unique(email)            };            //表级约束给多个字段联合添加约束【一下程序表示name和email连个字段联合唯一】            drop table if exists t_user;            create table t_user(                    id int(10),                    name varchar(32) not null,                    email varchar(128),                    unique(name,email)            );            //表级约束还可以给约束起名字            //为什么要起名字？因为以后要通过这个名字来删除这个约束            drop table if exists t_user;            create table t_user(                id int(10),                name varchar(32) not null,                email varchar(128),                constraint t_user_email_unique unique(email)            );            //查询约束的名字            mysql&gt; use information_schema;            Reading table information for completion of table and column names            You can turn off this feature to get a quicker startup with -A            Database changed            mysql&gt; show tables;            +---------------------------------------+            | Tables_in_information_schema          |            +---------------------------------------+            | CHARACTER_SETS                        |            | COLLATIONS                            |            | COLLATION_CHARACTER_SET_APPLICABILITY |            | COLUMNS                               |            | COLUMN_PRIVILEGES                     |            | ENGINES                               |            | EVENTS                                |            | FILES                                 |            | GLOBAL_STATUS                         |            | GLOBAL_VARIABLES                      |            | KEY_COLUMN_USAGE                      |            | OPTIMIZER_TRACE                       |            | PARAMETERS                            |            | PARTITIONS                            |            | PLUGINS                               |            | PROCESSLIST                           |            | PROFILING                             |            | REFERENTIAL_CONSTRAINTS               |            | ROUTINES                              |            | SCHEMATA                              |            | SCHEMA_PRIVILEGES                     |            | SESSION_STATUS                        |            | SESSION_VARIABLES                     |            | STATISTICS                            |            | TABLES                                |            | TABLESPACES                           |            | TABLE_CONSTRAINTS                     |            | TABLE_PRIVILEGES                      |            | TRIGGERS                              |            | USER_PRIVILEGES                       |            | VIEWS                                 |            | INNODB_LOCKS                          |            | INNODB_TRX                            |            | INNODB_SYS_DATAFILES                  |            | INNODB_FT_CONFIG                      |            | INNODB_SYS_VIRTUAL                    |            | INNODB_CMP                            |            | INNODB_FT_BEING_DELETED               |            | INNODB_CMP_RESET                      |            | INNODB_CMP_PER_INDEX                  |            | INNODB_CMPMEM_RESET                   |            | INNODB_FT_DELETED                     |            | INNODB_BUFFER_PAGE_LRU                |            | INNODB_LOCK_WAITS                     |            | INNODB_TEMP_TABLE_INFO                |            | INNODB_SYS_INDEXES                    |            | INNODB_SYS_TABLES                     |            | INNODB_SYS_FIELDS                     |            | INNODB_CMP_PER_INDEX_RESET            |            | INNODB_BUFFER_PAGE                    |            | INNODB_FT_DEFAULT_STOPWORD            |            | INNODB_FT_INDEX_TABLE                 |            | INNODB_FT_INDEX_CACHE                 |            | INNODB_SYS_TABLESPACES                |            | INNODB_METRICS                        |            | INNODB_SYS_FOREIGN_COLS               |            | INNODB_CMPMEM                         |            | INNODB_BUFFER_POOL_STATS              |            | INNODB_SYS_COLUMNS                    |            | INNODB_SYS_FOREIGN                    |            | INNODB_SYS_TABLESTATS                 |            +---------------------------------------+            61 rows in set (0.00 sec)            mysql&gt; desc COLLATIONs;            +--------------------+-------------+------+-----+---------+-------+            | Field              | Type        | Null | Key | Default | Extra |            +--------------------+-------------+------+-----+---------+-------+            | COLLATION_NAME     | varchar(32) | NO   |     |         |       |            | CHARACTER_SET_NAME | varchar(32) | NO   |     |         |       |            | ID                 | bigint(11)  | NO   |     | 0       |       |            | IS_DEFAULT         | varchar(3)  | NO   |     |         |       |            | IS_COMPILED        | varchar(3)  | NO   |     |         |       |            | SORTLEN            | bigint(3)   | NO   |     | 0       |       |            +--------------------+-------------+------+-----+---------+-------+            6 rows in set (0.00 sec)            mysql&gt; DESC TABLE_CONSTRAINTS;【该表格专门存储约束信息的】            +--------------------+--------------+------+-----+---------+-------+            | Field              | Type         | Null | Key | Default | Extra |            +--------------------+--------------+------+-----+---------+-------+            | CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |            | CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |            | CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |            | TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |            | TABLE_NAME         | varchar(64)  | NO   |     |         |       |            | CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |            +--------------------+--------------+------+-----+---------+-------+            6 rows in set (0.00 sec)            mysql&gt; select CONSTRAINT_NAME from TABLE_CONSTRAINTS where TABLE_NAME=&#39;t_user&#39;;5    not null和unique可以联合使用吗？        -    可以联合使用        -    被not null unique 约束的字段，既不能为空，也不能重复        -    例子：6    主键约束-primary key  简称:PK        6.1        主键涉及到的术语:                    -    主键约束                    -    主键字段                    -    主键值        6.2        以上的主键约束、主键字段、主键值的关系？                - 表中某个字段添加主键约束之后                该字段被称为主键字段，主键字段中                出现的每一个数据能被称为主键值        6.3        给某个字段添加主键约束之后，该字段不能重复，并且也不能为空                效果和 not null unique  约束相同，但是本质不同，主键约束除了可以做到&quot;not null unique&quot;之外，主键字段还会默认添加&quot;索引-index&quot;        6.4        一张表应该有主键字段，若没有，表示这张表是无效的。                &quot;主键值&quot;是当前行数据的唯一标识。&quot;主键值&quot;是当前行数据的身份证号。                即使表中的两行记录相关的数据是相同的，但是由于主键值不同，我们认为这是两行完全不同的数据。        6.5        给一个字段添加主键约束，被称为单一主键。                    //单一主键                    //列级约束                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(5) UNSIGNED PRIMARY KEY,                        name VARCHAR(20)                    );                    //单一主键                    //表级约束                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(5) UNSIGNED,                        name VARCHAR(20),                        PRIMARY KEY(id)                    );                     //单一主键                    //表级约束                    //起名                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(3) UNSIGNED,                        name VARCHAR(32),                        email VARCHAR(40),                        CONSTRAINT t_user_id_pk PRIMARY KEY(id)                    );        6.6        给多个字段联合添加一个主键约束，被称为复合主键。                    //复合主键                    //表级约束                    //起名                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(2) UNSIGNED,                        name VARCHAR(10),                        CONSTRAINT t_user_id_pk PRIMARY KEY(id,name)                    );                    INSERT INTO t_user(id,name) values(10000,&#39;jack&#39;);                    INSERT INTO t_user(id,name) values(10000,&#39;cntsp&#39;);                    INSERT INTO t_user(id,name) values(5456,&#39;cntsp&#39;);                    COMMIT;                    SELECT * FROM t_user;        6.7        无论是单一主键还是复合主键，一张表主键约束只能有一个。        6.8        主键根据性质分类：                -    自然主键                    *     主键值若是一个自然数，这个自然数和当前表的业务没有任何关系，这种主键叫做自然主键                -    业务主键                    *    主键值若和当前表中业务紧密相关的，那么这种主键值被称为业务主键，当业务数据发生改变的时候，主键值通常受到影响。                    所以业务主键使用较少。大部分都是使用自然主键            6.9        在MYSQL数据库管理系统中提供了一个自增的数字，专们用来自动生成主键值。                    主键值不需要用户维护，也不需要用户提供了，自动生成的，这个自增的数字默认从1开始，以1递增：                    1,2,3,4,5,6,7,8.....                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(10) UNSIGNED PRIMARY KEY auto_increment,                        name VARCHAR(32),                        email VARCHAR(40)                    );                    INSERT INTO t_user(name,email) values(&#39;jack&#39;,&#39;123@qq.com&#39;);                    INSERT INTO t_user(name,email) values(&#39;jack&#39;,&#39;123@qq.com&#39;);                    COMMIT;    7    外键约束foreign  key-简称FK        7.1    外键涉及到的术语：                -    外键约束                -    外键字段                -    外键值        7.2    外键约束、外键字段、外键值之间的的关系？                某个字段添加外键约束之后，该字段称为外键字段                外键字段中的每一个数据都是外键值        7.3    外键也分为：单一外键【给一个字段添加外键约束】和复合外键【给多个字段联合添加一个外键约束】        7.4    一张表中可以有多个外键字段        7.5    分析场景：            请设计数据库表用来存储学生和班级信息，给出两种解决方案            学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系            第一种涉及方案：将学生信息和班级信息存储到一张表中。            学生信息表t_student            sno(pk)     sname        classno        cname            ---------------------------------------------------------            1            jack        100            北京海定区...高三1班            2            lucy        100            北京海定区...高三1班            3            zhangsan     100            北京海定区...高三1班            4            ford        200            北京海定区...高三2班            5            king        200            北京海定区...高三2班            6            allen        300            北京海定区...高三3班            7            lisi        300            北京海定区...高三3班            以上设计的缺点：数据臃肿            第二种解决方案：将学生信息和班级信息分开两张表存储，学生表 + 班级表            学生表t_student            sno(pk)        sname       classno(fk)            -----------------------------------            1            jack        100            2            lucy        100            3            zhangsan    100            4            ford        200            5            king        200            6            allen        300            7            lisi        300            班级表t_class            cno(pk)         cname            ------------------------------------------------            100                北京海淀区....高三1班            200                北京海淀区....高三2班            300                北京海淀区....高三3班            结论：为了保证t_student表中的class字段中的数据必须来自于t_class表中cno字段中的数据，有必要给t_studnet            表中的classno字段添加外键约束，classno字段被称为外键字段，该字段中的100 200 300被称为外键值。classno这里是一个单一外键字段            注：    外键值可以为NULL            注：    外键字段去引用一张表的某个字段的时候，被引用的字段必须具有unique约束。            注：    有了外键引用之后，表分为父表和子表，以上父表是：班级表，子表是：学生表            创建表先创建父表，再创建子表，删除数据的时候先删除子表中的数据，再删除父表中的数据，插入父表中的数据，再插入子表中的数据。            -------------------------------------SQL文----------------------------------------------------------------            DROP TABLE IF EXISTS t_student;            DROP TABLE IF EXISTS t_class;            CREATE TABLE t_class(                    cno int(3) unsigned primary key,                    cname varchar(120) not null unique            );            CREATE TABLE t_student(                sno int(3) unsigned primary key,                sname varchar(32) not null,                classno int(3) unsigned,                constraint t_student_classno_fk foreign key(classno) references t_class(cno)            );            insert into t_class(cno,cname) values(100,&#39;高三1班&#39;);            insert into t_class(cno,cname) values(200,&#39;高三2班&#39;);            insert into t_class(cno,cname) values(300,&#39;高三3班&#39;);            insert into t_student(sno,sname,classno) values(1,&#39;jack&#39;,100);            insert into t_student(sno,sname,classno) values(2,&#39;lucy&#39;,100);            insert into t_student(sno,sname,classno) values(3,&#39;zhangsan&#39;,100);            insert into t_student(sno,sname,classno) values(4,&#39;ford&#39;,200);            insert into t_student(sno,sname,classno) values(5,&#39;king&#39;,200);            insert into t_student(sno,sname,classno) values(6,&#39;allen&#39;,300);            insert into t_student(sno,sname,classno) values(7,&#39;lisi&#39;,300);            select * from t_student;            select * from t_class;            commit;            insert into t_student(sno,sname,classno) values(8,&#39;lisi&#39;,500);            -------------------------------------SQL文-------------------------------------------------------------------            找出每个学生的班级名称            mysql&gt; SELECT s.sname,c.cname from t_student s join t_class c on s.classno = c.cno;            +----------+------------+            | sname    | cname      |            +----------+------------+            | jack     | 高三1班    |            | lucy     | 高三1班    |            | zhangsan | 高三1班    |            | ford     | 高三2班    |            | king     | 高三2班    |            | allen    | 高三3班    |            | lisi     | 高三3班    |            +----------+------------+            7 rows in set (0.00 sec)            重点：典型的一对多，在多的一方加外键8    级联更新和级联删除        -    添加级联更新和级联删除的时候要在外键约束后面添加        -     在删除父表中数据的时候，级联删除子表中的数据                * 删除外键约束                    alter table t_student drop foreign key t_student_classno_fk;                * 添加外键的约束                    alert table t_student add                     constraint t_student_classno_fk                    foreign key(classno) t_class(cno) on delete cascade;        -    在更新父表中数据的时候，级联更新子表中的数据                * 删除外键约束                    alter table t_student drop foreign key t_student_classno_fk;                * 添加外键的约束                    alert table t_student add                     constraint t_student_classno_fk                    foreign key(classno) t_class(cno) on update cascade ;        -    以上的级联更新和级联删除谨慎使用，因为级联操作会将数据改变或者删除【数据无价】15    存储引擎    存储引擎的使用        数据库中的各表均被(在创建表时)指定的存储引擎来处理。        服务器可用的引擎依赖于以下因素：            &gt; * MySQL的版本            &gt; * 服务器在开发时如何被配置            &gt; * 启动选项为了了解当前服务器中有哪些存储引擎可用，可使用SHOW ENGINES语句：mysql&gt; SHOW ENGINES\G;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        || MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         || MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         || BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         || MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         || CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         || ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         || PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         || FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)15.2.1     MyISAM存储引擎        &gt; * MyISAM    存储引擎是MySQL最常用的引擎        &gt; * 它管理的表具有以下特征：            -     使用三个文件表示每个表:                    &gt; * 使用三个文件表示每个表：                        * 格式文件 -存储表结构的定义(mytable.frm)                        * 数据文件 -存储表行的内容(mytable.MYD)                        * 索引文件 -存储表上索引(mytable.MYI)                    -    灵活的AUTO_INCREMENT字段处理                    -    可被转换为压缩、只读表来节省空间15.2.2        InnoDB存储引擎            &gt;    *     InnoDB存储引擎是MySQL的缺省引擎。            &gt;    *     它管理的表具有以下主要特征：                    -    每个InooDB表在数据库目录中以.frm格式文件表示                    -    InnoDB表空间tablespace被用于存储表的内容                    -    提供一组用来记录事务性活动的日志文件                    -    用COMMIT(提交)、SAVEPOINT及ROLLBACK(回滚)支持事务处理                    -    提供全ACID兼容                    -    在MySQL服务器崩溃后提供自动恢复                    -    多版本(MVCC)和行级锁定                    -    支持外键及引用的完整性，包括级联删除和更新            MEMORY存储引擎                    *    使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得MEMORY存储引擎非常快                    *    MEMORY存储引擎管理的表具有一下特征：                        -    在数据库目录内，每个表均以.frm格式的文件表示                        -    表数据及索引被存储在内存中                        -    表级锁机制                        -    不能包含TEXT或BLOB字段                    *    MEMORY存储引擎以前被称为HEAP引擎。        15.3        选择合适的存储引擎                    *    MyISAM 表最适合于大量的数据读而少量数据更新的混合操作，MyISAM表的另一种使用情形是使用压缩的只读表。                    *    如果查询中包含较多的数据更新操作，应使用InnoDB,其行级锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制。                    *    可使用MEMORY存储引擎来存储非永久需要的数据，或者是能够从基于磁盘的表中重新生成的数据。    事务：            1    什么是事务？                    -    事务对应的英语但是：Transaction                    -    事务：一个最小的不可再分的工作单元。                    -    通常一个事务对应一个完整的业务。 【例如：银行账户转账业务，该业务就是一个最小的工作单元】                    -    而一个完整的业务需要批量的DML语句(insert,update,delete)共同联合完成。                    -    事务只和DML语句有关系，或者说DML语句才有事务                    -    以上所描述的&quot;批量的DML语句&quot;共有多少条DML语句，这个和业务逻辑有关系                    业务逻辑不同DML语句的个数不同。            2.    关于银行账户转账操作，账户转账是一个完整的业务，最小的单元，不可再分。也就是说银行账户转账是一个事务。                    t_act 账户表                    actno        balance                    -----------------------------------------                    act-001        50000.0                    act-002        10000.0                    执行转账操作(10000):                        update     t_act set balance=40000.0    where actno=&#39;act-001&#39;;                        update  t_act set balance=20000.0    where actno=&#39;act-002&#39;;                        以上的两条DML语句要求必须同时成功或者同时失败，最小单元，不可再分。当第一条DML语句执行成功之后，并不能将底层数据库中第一个账户的数据修改。只是将操作记录一下，这个记录是在内存中完成的，当第二条DML语句执行失败，情况所有的历史操作记录。要完成以上的功能，必须借助事务。        3    事务的四个特性：                -    原子性(A)【Atomicity,或称不可分割性】                        * 事务是最小的工作单元，不可再分                -    一致性(C)【Consistency】                        *  事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败                -    隔离性(I)【isolation】                        *    事务A和事务B之间具有隔离                -    持久性(D)【Durablity】                        *    是事务的保证，事务终结的标志【内存中的数据持久到硬盘文件中】        4    关于一些术语：                -    开启事务: Start Transaction                -    事务结束：End Transaction                -    提交事务: Commit Transacton                -    回滚事务: Rollback Transaction        5    和事务有关的两条重要的SQL语句【TCL】                commit:      提交     成功的结束，将所有的DML语句操作历史记录和底层硬盘文件中的数据来一次同步。                rollback:    回滚    失败的结束，将所有的DML语句操作历史记录全部清空        6    事务开启的标志是什么？事务结束的标志是什么？                -    开启的标志                -    结束的标志        7    重点：                在事务进行过程中，未结束之前，DML语句是不会更改底层数据库文件中的数据。只是将历史操作记录一下，在内存中完成记录。                只有在事务结束的时候，而且是成功的结束的时候才会修改底层硬盘文件中的数据。    8    在MYSQL数据库管理系统中，事务的提交和回滚的演示        -    在MYSQL数据库管理系统中，默认情况下，事务是自动提交的，也就是说，只要执行一条DML语句，开启了事务，并且提交了事务。        -    这种自动提交机制是可以关闭的: 【关闭的第一种方式】            start transaction;     手动开启事务            DML语句...            DML语句...            DML语句...            commit;             手动提交事务【事务成功的结束】            start transaction;    手动开启事务            DML语句...            DML语句...            DML语句...            DML语句...            DML语句...            rollback;    手动回滚事务【事务失败的结束】            -    如果禁用自动提交，事务可以跨越多条语句。            -    在这种情况下，事务可以用COMMIT和ROLLBACK语句来显式地提交或回滚。    *    自动提交模式下可以通过服务器变量AUTOCOMMIT来控制    例如：        关闭自动提交模式        mysql&gt;SET AUTOCOMMIT = OFF;        或        mysql&gt;SET SESSION AUTOCOMMIT = OFF;        打开自动提交模式        mysql&gt;SET AUTOCOMMIT = ON;        或        mysql&gt;SET SESSION AUTOCOMMIT = ON;        只对当前事务有效        mysql&gt;show variables like &#39;%auto%&#39;;查看变量状态9    事务四个特性之一：隔离性(isolation)            9.1    事务A和事务B之间具有一定的隔离性        9.2    隔离性有隔离级别(4个)：                -    read uncommitted 读未提交                -    read committed   读已提交                -   repeatable read  可重复性                -    serializable     串行化        9.3    read uncommitted 读未提交            -    事务A和事务B，事务A未提交的数据，事务B可以读取到            -    这里读取到的数据可以叫做&quot;脏数据&quot;或者叫做“Dirty Read”            -    这种隔离级别是最低级别，这种级别一般都是在理论上存在，数据库默认的隔离级别一般都是高于该隔离界别的。        9.4    read committed 读已提交            -    事务A和事务B，事务A提交的数据，事务B才能读取到。            -    这种隔离级别高于上面的读未提交            -    换句话说：对方事务提交之后的数据，我当前事务才能过读取到。            -    这种隔离级别可以避免脏数据。            -    这种隔离界别会导致：“不可重复读取”            -    Oracle数据库管理系统默认的隔离级别就是：读已提交        9.5    repeatable read 可重复读            -    事务A和事务B，事务A提交之后的数据，事务B读取不到。            -    事务B是可重复读取数据的            -    这种隔离级别高于读取数据的。            -    换句话说：对方提交之后的数据我还是读取不到.            -    这种隔离级别可以避免“不可重复读取”，达到可重复读取            -    MYSQL数据库管理系统默认的隔离级别就是：可重复读            -    虽然可以达到“可重复读”的效果，但是会导致：“幻象读”        9.6    serializable  串行化            -    事务A和事务B，事务A在操作数据库表中数据的时候，事务B只能排队等待。            -    这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好。            -    这种隔离级别可以避免“幻象读”，每一次读取的都是数据库表中真实记录。            -    事务A和事务B不再并发。10.        隔离级别与一致性问题的关系        隔离级别        脏读取        不可重复读取            设置事务的隔离级别：            第一种方式：修改my.ini配置文件            可选值：                -    READ-UNCOMMITTED                -    READ-COMMITTED                -    REPEATABLE-READ                -    SERIALIZABLE                ----------------my.ini----------------                [mysqld]                transaction-ioslation = READ-COMMITTED            第二种方式：使用命令动态设置事务的隔离级别            &gt;    *     隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句            &gt;    *    语法模式为： SET|GLOBAL|SESSION|TRANSACTION|ISOLATIONLEVEL &lt;isolation-level&gt;            其中的&lt;isolation-level&gt;可以是：                -    READ-UNCOMMITTED                -    READ-COMMITTED                -    REPEATABLE-READ                -    SERIALIZABLE            例如：SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;    隔离级别的作用范围：            事务隔离级别的作用范围分为两种：                -    全局及：对所有的会话有效                -    会话级：只对当前的会话有效            &gt;*    例如：设置会话级隔离级别为READ COMMITTED；                SET TRANACTION ISOLATION LEVEL READCOMMITTED;                或者：                SET SESSION TRANACTION ISOLATION LEVEL READ COMMITTED;                设置全局级隔离级别为READ COMMITTED                SET GLOBAL TRANACTION ISOLATION LEVEL READ COMMITTED;        16.4.6  查看隔离级别                服务器变量tx_isolation(包含会话级和全局级两个变量)中保存着当前的会话隔离级别。                为了查看当前隔离级别，可访问tx_isolation变量；                    -    查看会话级的当前隔离级别；                    mysql&gt; SELECT @@tx_isolation;                    或：                    mysql&gt; SELECT @@session.tx_isolation;                    查看全局级的当前隔离级别；                    mysql&gt;SELECT @@global.tx_isolation        12    并发事务与隔离级别示例            12.1    读未提交     read uncommitted</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level read uncommitted;<br>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;<br>start transaction;                                                                            start transacton;<br>insert into t_user(name) values(‘wangwu’);                                                    select * from t_user;</p><pre><code>                                                                                select * from t_us    12.2    可重复读     read committed</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level read committed;<br>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;</p><p>start transaction;                                                                            start transacton;</p><p>insert into t_user(name) values(‘ford’);                                                    select * from t_user;</p><p>commit;                                                                                        select * from t_user;</p><pre><code>        12.3    可重复读     repeatable read</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level repeatable read;<br>select @@tx_isolation;</p><hr><p>|@@tx_isolation |<br>+—————+<br>|READ-COMMITTED |</p><p>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;</p><p>start transaction;                                                                            start transacton;</p><p>select * from t_user;                                                                       select * from t_user;</p><p>insert into t_user(name) values(‘cntsp’);                                                    select * from t_user;</p><p>commit;                                                                                        select * from t_user;</p><pre><code>索引：    1    什么是索引？            -    索引对应的英语单词是：index            -    索引相当于一本字典的目录，索引的作用是提高程序的检索【查询】效率。    2    主键自动添加索引，所以能够通过主键查询尽量通过主键查询，效率较高。    3    索引和表相同，都是一个对象，表是存储在硬盘文件中的，那么索引是表的一部分，索引也是存储在硬盘文件中。    4    在MYSQL数据库管理系统中，对表中记录进行检索的时候，通常包括几种检索方式：        第一种方式：全表扫描【效率较低】                假设有一张表：emp员工表                select * from emp where ename=&#39;KING&#39;;                若ename字段上没有添加索引，那么在通过ename字段过滤数据的时候                ename字段会被全表扫描                假设有一张表：dept部门表                select * from dept where dname=&#39;ACCOUNTING&#39;;                若dname字段上没有索引，那么在通过dname字段过滤数据的时候，dname字段会被全部扫描        第二种方式：通过索引进行检索【提高查询效率】5.    一张表中有多个字段，每一个字段都是可以添加索引的。6.    什么情况下适合给表中的某个字段添加索引呢？        -    该字段数据量庞大        -    该字段很少的DML操作【DML操作很多的话，索引也是需要不断的维护，效率反而降低】        -    该字段经常出现在where子句中        索引原理            索引被用来快速找出在一个列某一特定值的行，没有索引，MySQL不得不首先以第一条记录开始，然后读完整个表知道它找出相关的行。表越大，花费时间越多，对于一个有序字段，可以运用二分查找(BinarySearch)，这就是为什么性能能得到本质上的提高。MYISAM和INNODB都是B+Tree作为索引结构。            (主键：unique都会默认的添加索引)    7    怎么创建索引?        create index dept_dname index on dept(dname);        create unique index dept_dname_index on dept(dname);//添加unique表示dept表中的dname字段添加一个唯一性约束    8    删除索引        drop     index dept_dname_index on dept;19    DBA命令    19.1    新建命令            CREATE USER username IDENTIFIED BY &#39;password&#39;;            说明username --你将创建的用户名，password --该用户的登录密码：密码可以为空，如果为空则该用户可以不需要密码登录服务器    192.    授权            命令详解            mysql&gt;grant all privileges on dbname.tbname to username@&#39;loginip&#39; identified by &#39;passwd&#39; with grant option;            dbname=*  表示所有数据库            taname=*  表示所有表    19    导出            导出整个数据库            在windows 的DOS命令窗口中执行：mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123            导出指定库下的指定表            在window的dos命令窗口中执行：mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p123    19.4.2    导入            mysql&gt;source D:\bjpowernode.sql</code></pre><p>数据库设计三范式：<br>        1、 数据库设计三范式：<br>            设计数据库表的时候所依据的规范，共三个规范</p><pre><code>        第一范式：            要求有主键，并且要求每一个字段原子性不可再分            数据库表中不能出现重复记录，每个字段是原子性的不能再分            不符合第一范式的示例            ------------------------------------------------------------            学生编号        学生姓名            联系方式            ------------------------------------------------------------            1001            张三                zs@gamil.com.13599999999            ------------------------------------------------------------            1002            李四                ls@gmail.com.13699999999            ------------------------------------------------------------            1001            王五                ww@163.com.134888888888            ------------------------------------------------------------            存在的问题：                ** 最后一条记录和第一条重复(不唯一，没有主键) **                ** 联系方式字段可以再分，不是原子性的 **            修改后为：            --------------------------------------------------------------------            学生编号        学生姓名            邮箱地址            电话号码            --------------------------------------------------------------------            1001            张三                zs@gamil.com        13599999999            --------------------------------------------------------------------            1002            李四                ls@gmail.com        13699999999            --------------------------------------------------------------------            1003            王五                ww@163.com          134888888888            --------------------------------------------------------------------            **关于第一范式,每一行必须唯一，也就是每个表必须有主键，这是我们数据库涉及的最基本要求，主要通常采用数值型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定，如联系方式，为了开发上的便利可能就采用一个字段了**        第二范式：            要求所有非主键字段完全依赖主键，不能产生部分依赖            第二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖            示例：            --------------------------------------------------------------------            学生编号        学生姓名            教师编号            电话号码            --------------------------------------------------------------------            1001            张三                001                    王老师            --------------------------------------------------------------------            1002            李四                002                    赵老师            --------------------------------------------------------------------            1003            王五                001                  王老师            --------------------------------------------------------------------            1001            张三                002                    赵老师            --------------------------------------------------------------------            确定主键：            --------------------------------------------------------------------            学生编号(PK)        教师编号(PK)        学生姓名        教师姓名            --------------------------------------------------------------------            1001                001                    张三            王老师            --------------------------------------------------------------------            1002                002                    李四            赵老师            --------------------------------------------------------------------            1003                001                    王五            王老师            --------------------------------------------------------------------            1001                002                    张三            赵老师            --------------------------------------------------------------------            以上虽然确定了主键，但此表会出现大量的沉余，主要涉及到的沉余字段为“学生姓名”和“教师姓名”，出现沉余的            原因在于，学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部门依赖了主键的一个字段教师编号，这就是第二范式部分依赖。            解决方案如下：            学生信息表：            ------------------------------------------------            学生编号(PK)            学生姓名            ------------------------------------------------            1001                    张三            ------------------------------------------------            1002                    李四            ------------------------------------------------            1003                    王五            ------------------------------------------------            教师信息表            ------------------------------------------------            教师编号(PK)            教师姓名            ------------------------------------------------            001                        王老师            ------------------------------------------------            002                        赵老师            ------------------------------------------------            教师和学生的关系表            -------------------------------------------------------------------------            学生编号(PK) fk-&gt;学生表的学生编号        教师编号(PK)fk-&gt;教师表的教师编号            -------------------------------------------------------------------------            1001                                        001            -------------------------------------------------------------------------            1002                                        002            -------------------------------------------------------------------------            1003                                        001            -------------------------------------------------------------------------            1001                                        002            -------------------------------------------------------------------------            如果一个表是单一主键，那么它就是复合第二范式，部分依赖和主键有关系            以上是一种典型的“多对多”的涉及        第三范式：            所有非主键字段和主键字段之间不能产生传递依赖            建立在第二范式基础上的，非主键字段不能传递依赖与主键字段(不要产生传递依赖)            --------------------------------------------------------------------------            学生编号(PK)         学生姓名        班级编号            班级名称            --------------------------------------------------------------------------            1001                张三            01                    一年一班            --------------------------------------------------------------------------            1002                李四            02                    一年二班            --------------------------------------------------------------------------            1003                王五            03                    一年三班            --------------------------------------------------------------------------            1004                赵六            03                    一年三班            --------------------------------------------------------------------------            从上表可以看出，班级名称字段存在沉余，因为班级名称字段没有直接依赖于主键，班级名称字段依赖与班级编号，            班级编号依赖于学生编号，那么这就是传递依赖，解决的办法是将沉余字段单独拿出来建立表，如：            学生信息表：            -----------------------------------------------------            学生编号(PK)            学生姓名        班级编号(FK)            -----------------------------------------------------            1001                    张三            01            -----------------------------------------------------            1002                    李四            02            -----------------------------------------------------            1003                    王五            03            -----------------------------------------------------            1004                    赵六            03            -----------------------------------------------------            班级信息表            -----------------------------------------------------            班级编号(PK)                班级名称            -----------------------------------------------------            01                            一年一班            02                            一年二班            -----------------------------------------------------            03                            一年三班            -----------------------------------------------------            以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一对一    2、 几个比较经典的范式：        一对一：                第一种方案：    分两张表存储，共享主键                                t_husband                                hno(pk)    hname                                --------------------                                1            张三                                2            王五                                3            赵六                                --------------------                                t_wife                                wno(pk) wname 【wno同时也是fk，引用t_husband中的hno】                                -----------------------------------                                3        a                                2        b                                1        c                                ----------------------------------                第二种方案：    分两张表存储，外键唯一                                t_husband                                hno(pk)    hname    wifeno                                ----------------------------------                                1            张三    100                                2            王五    300                                3            赵六    200                                ----------------------------------                                t_wife                                wno(pk) wname 【wno同时也是fk，引用t_husband中的hno】                                -----------------------------------                                100        a                                300     b                                200        c                                ----------------------------------        一对多：分两张表存储，在多的一方添加外键，这个外键字段引用一对一放中的主键字段        多对多：分三张表存储，在学生表中存储学生信息，在课程表中存储学生和课程信息6    在实际开发中是怎样的？        数据库设计尽量遵循三范式，        但是还是根据实际情况进行取舍        有时可能会拿沉余换速度        最终目的要满足客户需求</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-module-str-bytes</title>
      <link href="/2019/05/18/python-module-str-bytes/"/>
      <url>/2019/05/18/python-module-str-bytes/</url>
      
        <content type="html"><![CDATA[<h2 id="Python3-bytes和str的不同"><a href="#Python3-bytes和str的不同" class="headerlink" title="Python3 bytes和str的不同"></a>Python3 bytes和str的不同</h2><p>Python3 最重要的新特性之一是对字符串和二进制数据流做了明确区分。文本总是Unicode,由str类型表示，二进制数据则由bytes类型表示。Python3 不会以任意隐式的方式混用str和bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串(反之亦然)，也不能将字符串传入参数为字节流的函数(反之亦然)。</p><pre class=" language-bash"><code class="language-bash">bytes.decode<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"utf-8"</span>, errors<span class="token operator">=</span><span class="token string">"strict"</span><span class="token punctuation">)</span>Return a string decoded from the given bytes. Default encoding is <span class="token string">'utf-8'</span><span class="token keyword">.</span> errors may be given to <span class="token keyword">set</span> a different error handling scheme. The default <span class="token keyword">for</span> errors is <span class="token string">'strict'</span>, meaning that encoding errors raise a UnicodeError. Other possible values are <span class="token string">'ignore'</span>, <span class="token string">'replace'</span> and any other name registered via codecs.register_error<span class="token punctuation">(</span><span class="token punctuation">)</span>, see section Error Handlers. For a list of possible encodings, see section Standard Encodings.</code></pre><p>返回从给定字节解码的字符串。 默认编码为’utf-8’。 可以给出错误以设置不同的错误处理方案。 错误的默认值是’strict’，这意味着编码错误会引发UnicodeError。 其他可能的值是’ignore’，’replace’以及通过codecs.register_error（）注册的任何其他名称，请参阅错误处理程序部分。 有关可能的编码列表，请参阅标准编码部分。</p><pre class=" language-bash"><code class="language-bash">str.encode<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"utf-8"</span>, errors<span class="token operator">=</span><span class="token string">"strict"</span><span class="token punctuation">)</span>Return an encoded version of the string as a bytes object. Default encoding is <span class="token string">'utf-8'</span><span class="token keyword">.</span> errors may be given to <span class="token keyword">set</span> a different error handling scheme. The default <span class="token keyword">for</span> errors is <span class="token string">'strict'</span>, meaning that encoding errors raise a UnicodeError. Other possible values are <span class="token string">'ignore'</span>, <span class="token string">'replace'</span>, <span class="token string">'xmlcharrefreplace'</span>, <span class="token string">'backslashreplace'</span> and any other name registered via codecs.register_error<span class="token punctuation">(</span><span class="token punctuation">)</span>, see section Error Handlers. For a list of possible encodings, see section Standard Encodings.522/5000</code></pre><p>将字符串的编码版本作为字节对象返回。 默认编码为’utf-8’。 可以给出错误以设置不同的错误处理方案。 错误的默认值是’strict’，这意味着编码错误会引发UnicodeError。 其他可能的值是’ignore’，’replace’，’xmlcharrefreplace’，’backslashreplace’以及通过codecs.register_error（）注册的任何其他名称，请参阅错误处理程序部分。 有关可能的编码列表，请参阅标准编码部分。</p><p>下面谈谈编码发展的历史：<br>在谈bytes和str之前，需要先说说关于编码是如何发展的。<br>在计算机历史的早期，美国为代表的英语系国家主导了整个计算机行业，26个英文字母组成了多样的英文单词、语句、文章。因此，最早的字符编码规范ASCII码，一种8位即1个字节的编码规范，它可以涵盖整个英语系的编码需要。</p><p><strong style="color:rgb(255 0 0)">编码是什么?</strong> 编码就是把一个字符用一个二进制表示。我们都知道，所有的东西，不管是英文、中文还是符号等等，最终存储在磁盘上都是01010101这类，在计算机内部，读取和存储数据归根结底，处理的都是0 1 组成的比特流，问题来了，低智商的人类是看不懂这些比特流的，如何让这些0101011对人类变的可读呢？于是出现了字符编码，它就是个翻译官，在计算机内部某个地方，透明的帮我把这些比特流翻译成人类可以直接理解的文字，对于一般用户，不需要知道这个过程是什么原理，是怎么执行的，但是对于程序员却是必须搞清楚搞明白的大问题。</p><p>以ASCII编码为例，它规定1个字节8个比特位代表1个字符的编码，也就是“00000000”这个宽度，一个一个字节的解读。例如01000001表示大写字母A，有时我们会“偷懒”用十进制的65来表示A在ASCII中的编码。8个比特位，可以没有重复的最多表示<strong style="color:green">2的8次方(255)</strong>个字符。</p><p>后来，计算机得到了普及，中文、法文、韩文、日文等国家的文字需要在计算机上显示，ASCII的255位已经远远不够了，于是标准组织定出了叫做<strong style="color:red">UNICODE</strong>的万国码，它规定任何一个字符(不管哪个国的)至少用2个字节来表示，两个字节就是16位的比特位了，那用来表示上面的A就要00000000 01000001这时高8位都是0，相当于多占用地方了，有没有无所谓，但是有的话，就要多分配内存或磁盘空间了，<strong>UNICODE</strong>中，英文字母就是用了2个字节，而汉字是3个字节，这个编码虽然可以表示更多国家的文字了，满足了所有人的需求，但是它不兼容ASCII，同时就会占用较多的磁盘空间和内存空间。英文国家中明明可以一个字节8个比特位表示所有的文字的，干嘛非要用2个字节呢？</p><p>于是<strong style="color:red">UTF-8</strong>编码应运而生，它规定英文母语系的用1个字节表示，汉字用3个字节表示等等其它国家的，因此，它兼容ASCII，可以解码早期的文档，UTF-8很快就得到了广泛的应用。</p><p>在编码的发展历程中，我国创造了自己的编码方式，例如GBK，GB2312，BIG5。他们只局限于在国内使用。在GBK编码中，中文汉字占用2个字节。</p><p>bytes和str之间的异同</p><p>回到<code>bytes</code>和<code>str</code>的身上。<code>bytes</code>是一种比特流，它的存在形式是01010001110这种。我们无论是在写代码，还是阅读文章的过程中，肯定不会有人直接阅读这种比特流，它必须有一个编码方式，使得它变成有意义的比特流，而不是一堆晦涩难懂的01组合。因为编码方式的不同，对这个比特流的解读也会不同，对实际使用造成了很大的困扰。下面让我们看看Python是如何处理这一系列编码问题的：</p><pre class=" language-python"><code class="language-python">root@localhost<span class="token punctuation">:</span><span class="token operator">~</span><span class="token comment" spellcheck="true"># python3.5</span>Python <span class="token number">3.5</span><span class="token punctuation">.</span><span class="token number">2</span> <span class="token punctuation">(</span>default<span class="token punctuation">,</span> Nov <span class="token number">23</span> <span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">:</span><span class="token number">37</span><span class="token punctuation">:</span><span class="token number">01</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>GCC <span class="token number">5.4</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token number">20160609</span><span class="token punctuation">]</span> on linuxType <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> <span class="token operator">or</span> <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"中国"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token string">'中国'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> bytes<span class="token punctuation">(</span>s<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> bb<span class="token string">'\xe4\xb8\xad\xe5\x9b\xbd'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> bb<span class="token string">'\xe4\xb8\xad\xe5\x9b\xbd'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> str<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">"b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd'"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> str<span class="token punctuation">(</span>b<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s2<span class="token string">'中国'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span></code></pre><p>从例子可以看出，<code>s</code>是个字符串类型。Python有个内置函数<code>bytes()</code>可以将字符串<code>str</code>类型转换成<code>bytes</code>类型，<code>b</code>实际上是一串01的组合，但为了在ide环境中让我们相对直观的观察，它被表现成了<code>b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</code>这种形式，开头的<code>b</code>表示这是一个<code>bytes</code>类型。<code>\xe4</code>是十六进制的表示方式，它占用1个字节的长度，因此”中文“被编码成<code>utf-8</code>后，我们可以数得出一共用了6个字节，每个汉字占用3个，这印证了上面的论述。<strong>*在使用内置函数bytes()的时候，必须明确encoding的参数*</strong>，不可省略。</p><p>我们都知道，<strong>*字符串类str里有一个encode()方法，它是从字符串向比特流的编码过程。而bytes类型恰好有个decode()方法，它是从比特流向字符串解码的过程。***</strong>*除***此之外，我们查看Python源码会发现<code>bytes</code>和<code>str</code>拥有几乎一模一样的方法列表，最大的区别就是<code>encode</code>和<code>decode</code>。</p><p>从实质上来说，字符串在磁盘上的保存形式也是01的组合，也需要编码解码。</p><p>如果，上面的阐述还不能让你搞清楚两者的区别，那么记住下面两几句话：</p><ol><li>在将字符串存入磁盘和从磁盘读取字符串的过程中，Python自动地帮你完成了编码和解码的工作，你不需要关心它的过程。</li><li>使用<code>bytes</code>类型，实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。</li><li>Python已经严格区分了<code>bytes</code>和<code>str</code>两种数据类型，你不能在需要<code>bytes</code>类型参数的时候使用<code>str</code>参数，反之亦然。这点在读写磁盘文件时容易碰到。</li></ol><p>在bytes和str的互相转换过程中，实际就是编码解码的过程，必须显式地指定编码格式。</p><pre class=" language-python"><code class="language-python">root@localhost<span class="token punctuation">:</span><span class="token operator">~</span><span class="token comment" spellcheck="true"># python3.5</span>Python <span class="token number">3.5</span><span class="token punctuation">.</span><span class="token number">2</span> <span class="token punctuation">(</span>default<span class="token punctuation">,</span> Nov <span class="token number">23</span> <span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">:</span><span class="token number">37</span><span class="token punctuation">:</span><span class="token number">01</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>GCC <span class="token number">5.4</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token number">20160609</span><span class="token punctuation">]</span> on linuxType <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> <span class="token operator">or</span> <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"中国"</span><span class="token operator">>></span><span class="token operator">></span> s<span class="token string">'中国'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> bytes<span class="token punctuation">(</span>s<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> bb<span class="token string">'\xe4\xb8\xad\xe5\x9b\xbd'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> bb<span class="token string">'\xe4\xb8\xad\xe5\x9b\xbd'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> str<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">"b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd'"</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> str<span class="token punctuation">(</span>b<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">'中国'</span></code></pre><p>这里在把字符串s1，转换为gbk编码的bytes类型：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> str<span class="token punctuation">(</span>b<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">'中国'</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">'中国'</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> bytes<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'gbk'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> bb<span class="token string">'\xd6\xd0\xb9\xfa'</span></code></pre><p>编码可以将抽象字符串以二进制数据的形式表示，有很多编码方法，如utf-8、gbk等，<strong style="color:red">可以使用encode()函数对字符串进行编码，转换成二进制字节数据，也可用decode()函数将字节解码成字符串</strong>；用decode()函数解码，可不要用指定编码格式；</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># a:按照utf-8的方式编码，转成bytes；以及解码成字符串</span><span class="token operator">></span>aa <span class="token operator">=</span> <span class="token string">"I LOVE YOU"</span><span class="token operator">></span>type<span class="token punctuation">(</span>aa<span class="token punctuation">)</span><span class="token operator">&lt;</span>class <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">></span>bb <span class="token operator">=</span> aa.encode<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">></span>type<span class="token punctuation">(</span>bb<span class="token punctuation">)</span><span class="token operator">&lt;</span>class <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">></span>bbb<span class="token string">'I LOVE YOU'</span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span>bb<span class="token string">'\xd6\xd0\xb9\xfa'</span><span class="token operator">></span>bbb<span class="token string">'I LOVE YOU'</span><span class="token operator">></span>cc <span class="token operator">=</span> bb.decode<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token operator">></span>type<span class="token punctuation">(</span>cc<span class="token punctuation">)</span><span class="token operator">&lt;</span>class <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">></span>cc<span class="token string">'I LOVE YOU'</span><span class="token comment" spellcheck="true"># b: 安装gbk的方式编码，转成bytes;以及编码成字符串</span><span class="token operator">></span> aa<span class="token string">'I LOVE YOU'</span><span class="token operator">></span> xx <span class="token operator">=</span> aa.encode<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"gbk"</span><span class="token punctuation">)</span><span class="token operator">></span> type<span class="token punctuation">(</span>xx<span class="token punctuation">)</span><span class="token operator">&lt;</span>class <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">></span> xxb<span class="token string">'I LOVE YOU'</span><span class="token operator">></span> yy <span class="token operator">=</span> xx.decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> type<span class="token punctuation">(</span>yy<span class="token punctuation">)</span><span class="token operator">&lt;</span>class <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">></span> yy<span class="token string">'I LOVE YOU'</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> str </tag>
            
            <tag> bytes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-TCP-UDP</title>
      <link href="/2019/05/18/python-TCP-UDP/"/>
      <url>/2019/05/18/python-TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket通讯及其TCP-IP原语"><a href="#Socket通讯及其TCP-IP原语" class="headerlink" title="Socket通讯及其TCP/IP原语"></a>Socket通讯及其TCP/IP原语</h1><h2 id="Socket通讯"><a href="#Socket通讯" class="headerlink" title="Socket通讯"></a>Socket通讯</h2><p>Socket提供了一个通信端口，应用程序在网络上传输/接收的信息都通过Socket接口来实现的。在应用开发中可以像使用文件句柄一样来对Socket句柄进行读写操作。Windows Socket与协议无关并向下兼容，可以使用任何底层传输协议提供的通信能力，来为上层应用程序完成网络数据通讯，而不关心底层网络链路的通讯情况，实现了底层网络通讯对应用程序的透明。在TCP/IP网络应用中，通信的两个进程间相互作用的主要模式是客户/服务器模式。<br>在开始使用socket套接字编程之前，首先必须建立一下概念：</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>传输层与网络层在功能上的最大区别是传输层提供进程通信能力。从这个意义上讲，网络通信的最终地址就不仅仅是主机地址了，还包括可以描述进程的某个标识符。为此，TCP/IP协议提出了协议端口(protocol port 简称端口)的概念，用于标识通信的进程。应用程序(即进程)通过系统调用与某端口建立链接(binding)后，传输层传给该端口的数据都被相应进程所接收，相应进程发给传输层的数据都通过该端口输出。在TCP/IP协议的实现中，端口操作类似于一般的I/O操作，进程获取一个端口，相当于获取本地唯一的I/O文件，可以用一般的读写原语访问。<br>注意：当调用bind()的时候，不要把端口数设置的过小，小于1024的所有端口都是保留下来作为系统使用端口的，没有root权利无法使用，可以使用1024以上的任何端口，一直到65535。最后注意有关bind()的是：有时候并不一定要调用bind()来建立网络连接，比如你只是想连接到一个远程主机上面进行通讯，并不在乎你究竟是用的自己机器上的哪个端口进行通讯（比如Telnet），那么你可以简单的直接调用connect()函数，connect()将自动寻找出本地机器上的一个未使用的端口，然后调用bind()来将其socket 绑定到那个端口上。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>网络通信中通信的两个进程分别在不同的机器上。在互连网络中，两台机器可能位于不同的网络，这些网络通过网络互连设备(网关，网桥，路由器等)连接，因此需要三级寻址：<br>1.某一个主机可与多个网络相连，必须指定一特定网络地址。<br>2.网络上每一台主机应有其唯一的地址；<br>3.每一个主机上的每一个进程应有在该主机上的唯一标识符。<br>通常主机地址由网络ID和主机ID组成，在TCP/IP协议中用32位整数值表示；TCP和UDP均使用16位端口号标识用户进程。</p><h2 id="重复服务和并发服务"><a href="#重复服务和并发服务" class="headerlink" title="重复服务和并发服务"></a>重复服务和并发服务</h2><p>在客户/服务器模式中，有两种类型的服务：重复服务和并发服务。accept()调用为实现并发服务提供了极大方便，因为它要返回一个新的套接字号，其典型结构为：<br>int initsockid, newsockid;<br>if ((initsockid = socket(….)) &lt; 0)<br>       error(“can’t create socket”);<br>if (bind(initsockid,….) &lt; 0)<br>       error(“bind error”);<br>if (listen(initsockid , 5) &lt; 0)<br>       error(“listen error”);<br>for (;;) {<br>       newsockid = accept(initsockid, …)               /* 阻塞 <em>/<br>       if (newsockid &lt; 0)<br>                error(“accept error”);<br>       if (fork() == 0){                    /</em> 子进程 <em>/<br>                closesocket(initsockid);<br>                do(newsockid);<br> /</em> 处理请求 <em>/<br>                exit(0);<br>       }<br>       closesocket(newsockid);                                    /</em><br>父进程 */<br>}</p><pre><code>  这段程序执行的结果是newsockid与客户的套接字建立相关，子进程启动后，关闭继承下来的主服务器的initsockid,并利用新的newsockid与客户通信。主服务器的initsockid可继续等待新的客户连接请求。由于在Unix等抢先多任务系统中，在系统调度下，多个进程可以同时进行。因此，使用并发服务器可以使服务器进程在同一时间可以有多个子进程和不同的客户程序连接、通信。在客户程序看来，服务器可以同时并发地处理多个客户的请求，这就是并发服务器名称的来由</code></pre><p> 面向连接服务器也可以是重复服务器，其结构如下：<br>int initsockid, newsockid;<br>if ((initsockid = socket(….))&lt;0)<br>       error(“can’t create socket”);<br>if (bind(initsockid,….)&lt;0)<br>       error(“bind error”);<br>if (listen(initsockid,5)&lt;0)<br>       error(“listen error”);<br>for (;;) {<br>       newsockid = accept(initsockid, …)     /* 阻塞 <em>/<br>       if (newsockid &lt; 0)<br>                error(“accept error”);<br>       do(newsockid);                               /</em> 处理请求 */<br>       closesocket(newsockid);<br>}</p><pre><code>        重复服务器在一个时间只能和一个客户程序建立连接，它对多个客户程序的处理是采用循环的方式重复进行，因此叫重复服务器。并发服务器和重复服务器各有利弊：并发服务器可以改善客户程序的响应速度，但它增加了系统调度的开销；重复服务器正好与其相反，因此用户在决定是使用并发服务器还是重复服务器时，要根据应用的实际情况来定。</code></pre><h2 id="网络字节顺序"><a href="#网络字节顺序" class="headerlink" title="网络字节顺序"></a>网络字节顺序</h2><p>不同的计算机存放多字节值的顺序不同，有的机器在起始地址存放低位字节（低价先存），有的存高位字节（高价先存）。为保证数据的正确性，在网络协议中须指定网络字节顺序。TCP/IP协议使用16位整数和32位整数的高价先存格式，它们均含在协议头文件中。</p><p>下面给出套接字字节转换程序的列表：<br>htons()——“Host to Network Short” 主机字节顺序转换为网络字节顺序（对无符号<br>短型进行操作4 bytes）<br>htonl()——“Host to Network Long”　主机字节顺序转换为网络字节顺序（对无符<br>号长型进行操作8 bytes）<br>ntohs()——“Network to Host Short “　网络字节顺序转换为主机字节顺序（对无符<br>号短型进行操作4 bytes）<br>ntohl()——“Network to Host Long “　网络字节顺序转换为主机字节顺序（对无符<br>号长型进行操作8 bytes）<br>在把数据发送到Internet 之前，一定要把它的字节顺序从主机字节顺序转换到网络字节顺序！</p><p>注：在struct sockaddr_in 中的sin_addr 和sin_port 他们的字节顺序都是网络字节顺序，而<br>sin_family 却不是网络字节顺序的。为什么呢？<br>这个是因为sin_addr 和sin_port 是从IP 和UDP 协议层取出来的数据，而在IP 和UDP<br>协议层，是直接和网络相关的，所以，它们必须使用网络字节顺序。然而， sin_family 域<br>只是内核用来判断struct sockaddr_in 是存储的什么类型的数据，并且 sin_family 永远也<br>不会被发送到网络上，所以可以使用主机字节顺序来存储。</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞：一般的I/O操作可以在新建的流中运用，在服务器回应前它等待客户端发送一个空白的行，当会话结束时，服务器关闭流和客户端socket。如果在队列中没有请示将会出现什么情况呢？那个方法将会等待一个的到来，这个行为叫做阻塞。accept()方法会阻塞服务器线程知道一个呼叫到来，当5个连接处理完闭之后，服务器退出，任何的在队列中的呼叫将会被取消。<br>非阻塞：非阻塞套接字是指执行此套接字的网络调用时，不管是否执行成功，都立即返回。比如调用recv()函数读取网络缓冲中数据，不管是否读到数据都立即返回，而不会一直挂载此函数调用上。在实际window网络通信软件开发中，异步非阻塞套接字是用的最多的，平常所说的C/S(客户端/服务器)结构的软件就是异步非阻塞模式的。<br>socket工作过程如下：</p><table><thead><tr><th>服务器</th><th></th><th>客户端</th></tr></thead><tbody><tr><td>Socket()</td><td></td><td>socket()</td></tr><tr><td>Bind()</td><td></td><td></td></tr><tr><td>Linsten()</td><td></td><td></td></tr><tr><td>等待连接请求</td><td>&lt;—–请示连接</td><td>connect()</td></tr><tr><td>accept()</td><td></td><td></td></tr><tr><td>Recv()&amp;Senc()</td><td>&lt;—–数据交互——&gt;</td><td>Recv()&amp;Send()</td></tr><tr><td>closesocket()</td><td></td><td>Closesocket()</td></tr><tr><td>服务器首先启动，通过调用socket()建立一个套接字，然后调用bind()将该套接字和本地网络地址联系在一起，再调用listen()使套接字做好侦听的准备，并规定它的请求队列的长度，之后就调用accept()来接收连接。客户在建立套接字后就可调用connect()和服务器建立连接。连接一旦建立，客户机和服务器之间就可以通过调用read()和write()来发送和接收数据。最后，待数据传送结束后，双方调用close()关闭套接字。</td><td></td><td></td></tr><tr><td>## TCP/IP连接原语</td><td></td><td></td></tr><tr><td>1. 传输层协议</td><td></td><td></td></tr><tr><td>从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层，为应用进程之间提供端到端的逻辑通信。传输层还要对收到的报文进行差错检测。传输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP。</td><td></td><td></td></tr></tbody></table><p>TCP/IP结构体系中的传输层协议</p><table><thead><tr><th></th><th>应用层</th></tr></thead><tbody><tr><td>传输层</td><td>&lt;—–(UDP、TCP)</td></tr><tr><td></td><td>IP</td></tr><tr><td></td><td>与各种网络接口</td></tr></tbody></table><h2 id="传输层协议和网络层协议的主要区别"><a href="#传输层协议和网络层协议的主要区别" class="headerlink" title="传输层协议和网络层协议的主要区别"></a>传输层协议和网络层协议的主要区别</h2><p>| 应用进程&lt;—–&gt;主机&lt;——-&gt;因特网&lt;——-&gt;主机&lt;——-&gt;应用进程 |<br>|——-|——|<br>| IP协议的作用范围 |<br>| ——(提供主机之间的逻辑通信)—— |<br>| TCP和UDP协议的作用范围 |<br>| ——(提供进程之间的逻辑通信)—– |</p><h2 id="TCP头和IP头对应关系"><a href="#TCP头和IP头对应关系" class="headerlink" title="TCP头和IP头对应关系"></a>TCP头和IP头对应关系</h2><p>| TCP报文段=|TCP首部|+|TCP数据部分|<br>|IP首部|IP数据部分|</p><h2 id="下图为TCP首部"><a href="#下图为TCP首部" class="headerlink" title="下图为TCP首部"></a>下图为TCP首部</h2><p>| TCP首部 |<br>| 源端口 | 目的端口 |<br>| 序号 |<br>| 确认号 |<br>| 数据偏移 |保留|URG|ACK|PSH|RST|SYN|FIN|窗口|<br>| 检验和 | 紧急指针 |<br>| 选项(长度可变)|填充 |</p><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.其中， SYN表示建立连接；FIN表示关闭连接；ACK表示响应；PSH表示有DATA数据传输；RST表示连接重置。</p><h2 id="用三次握手建立TCP连接"><a href="#用三次握手建立TCP连接" class="headerlink" title="用三次握手建立TCP连接"></a>用三次握手建立TCP连接</h2><p>|主机A| |主机B|<br>|主动打开||被动打开|<br>|连接请求|——SYN,SEQ=X——| |<br>||&lt;——SYN,ACK,SEQ=Y,ACK=x+1—-|确认|<br>||&lt;—–SYN,ACK,SEQ=X+1,ACK=Y+1—–||<br>A的TCP向B发出连接请求报文段，其首部中的同步比特SYN应置为1，并选择序号x，表明传送数据时的第一个数据字节的序号是x。B的TCP收到连接请求报文段后，如同意则发回确认。B在确认报文段中应将SYN置为1，其确认号应为x+1，同时也为自己选择序号y。A收到此报文段后，向B给出确认，其确认号应为y+1。A的TCP通知上层应用进程，连接已经建立。当运行服务器进程的主机B的TCP收到主机A的确认后，也通知其上层应用进程，连接已经建立。 </p><h2 id="TCP连接释放的过程"><a href="#TCP连接释放的过程" class="headerlink" title="TCP连接释放的过程"></a>TCP连接释放的过程</h2><p>|主机A||主机B|<br>|——|——|<br>|应用进程释放连接|—–FIN,SEQ=X—–&gt;|通知主机应用进程|<br>||&lt;—–ACK,SEQ=y,ACK=X+1—–|确认|<br>|确认|——-SEQ=Y+1——-&gt;||</p><h2 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h2><p>LISTEN: 侦听来自远方的TCP端口的连接请求<br>SYN-SET: 在发送连接请求后等待匹配的连接请求<br>SYN-RECEIVED: 再收到和发送一个连接请求后等待对方对连接请求的确认<br>ESTABLISHED: 代表一个打开的连接<br>FIN-WAIT-1: 等待远程TCP连接中断请求，或先前的连接中断请求的确认。<br>FIN-WAIT-2:从远程TCP等待连接中断请求<br>CLOSE-WAIT：等待从本地用户发来的连接中断请求<br>CLOSING：等待远程TCP对连接中断的确认<br>LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认<br>TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认<br>CLOSED：没有任何连接状态</p><h3 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h3><ul><li>所有连接开始于CLOSED状态。</li><li>服务器先执行一个被动TCP打开操作，使TCP转到LISTEN状态。</li><li>客户执行一个主动TCP打开操作，发送SYN，转到SYN_SENT状态。</li><li>当服务器收到SYN后，发送SYN＋ACK, 转到SYN_RCVD。</li><li>当客户收到SYN＋ACK后，向服务器发送ACK，转到ESTABLISHED状态。</li><li>当服务器收到ACK后，转到ESTABLISHED状态。<br>以上完成三次握手。<br>注：1) 如果客户发送到服务器的ACK（第三次握手）丢失，因为客户已经处于ESTABLISHED状态，连接仍能正常工作，所以客户应用进程可以向服务器开始发送数据。<br>2) 超时重传机制没有在状态转移图中显示。大多数状态向另一方发送数据的同时也调用超时机制。如果没有出现期望的响应，则重发该数据。若数次重发仍没有得到期望的响应，TCP则放弃重传并回到CLOSED状态。<h3 id="终止连接过程"><a href="#终止连接过程" class="headerlink" title="终止连接过程"></a>终止连接过程</h3></li></ul><p>终止连接过程：<br>    各方的应用进程必须独立地关闭自己一方的连接。若一方关闭，该方不再发送数据，但仍能接收发来的数据。任何一方从ESTABLISHED状态转到CLOSED状态都有三种转换组合：<br>1） 这一方先关闭：<br>ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED<br>2） 另一方先关闭：<br> ESTABLISHED -&gt; CLOSE_WAIT -&gt;LIST_ACK -&gt; CLOSED<br>3） 双方同时关闭：<br>   ESTABLISHED -&gt; FIN_WAIT_1 -&gt; CLOSING -&gt; TIME_WAIT -&gt; CLOSED</p><h2 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h2><p>TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。<br>上面的概念容易理解，我们这里说一下快重传。快重传算法规定，发送端只要一连收到三个重复的ACK即可断定有分组丢失了，就应立即重传丢失的报文段而不必继续等待为该报文段设置的重传计时器的超时。不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>快重传举例</p><p>|主机A—–主机B||<br>|—M1,M2—-&gt;|A发送M1和M2|<br>|&lt;—-ACK2,ACK3—-|B确认M1和M2|<br>|—–M3—–&gt;丢失|A发送M3但丢失了|<br>|—-M4—–|A发送M4|<br>|&lt;—-ACK3—-|B只能再次确认M2(因为M3没有收到)|<br>|—-M5——-&gt;|A发送M5|<br>|&lt;—-ACK3—-|B发送第二个重复确认ACK3|<br>|—–M6——&gt;|A发送M6|<br>|&lt;—–ACK3——|B发送第三个重复确认ACK3|<br>|—-M3—–&gt;|A收到了三个重复的确认ACK3，就立即重传M3，而不必等待超时重传|</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> socket </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制部署k8s</title>
      <link href="/2019/04/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s/"/>
      <url>/2019/04/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s/</url>
      
        <content type="html"><![CDATA[<p>Centos7系统使用二进制包部署kubernetes1.13集群</p><p>一 简述<br>Kubernetes1.13 的核心特性包括：利用kubeadm简化集群管理、容器存储接口(CSI)以及将CoreDNS作为默认DNS。<br>利用kubeadm简化集群管理功能<br>Kubeadm是管理集群生命周期的重要工具，能够帮助从我们从创建到配置再到升级的整个过程，随着1.13版本的发布，kubeadm功能进入GA版本，正式普遍可用。kubeadm处理现有硬件上的生产集群的引导，并以最佳实践方式配置kubernetes核心组件，以便为新节点提供安全而简单的连接流程并支持轻松升级。<br>该GA版本中最值得注意的是已经毕业的高级功能，尤其是可插拔性和可配置性。kubeadm旨在为管理员与高级自动化系统提供一套工具箱，如今已迈出重要一步。<br>容器存储接口(CSI)<br>容器存储接口最初于1.9版本中作为alpha测试功能引入，在1.10版本中进入beta测试，如今终于进入GA阶段正式普遍可用。在CSI的帮助下，kubernetes卷层将真正实现可扩展性。通过CSI，第三方存储供应商将可以直接编写可与kubernetes互操作的代码，而无需触及任何kubernetes核心代码。事实上，相关规范也已经同步进入1.0阶段。随着CSI的稳定，插件作者将能够按照自己的节奏开发核心存储插件，详见CSI文档。<br>CoreDNS称为Kubernetes的默认DNS服务器<br>在1.11版本中，开发团队宣布CoreDNS已实现基于DNS服务发现的普遍可用性。在最新的1.13版本中，CoreDNS正式去掉kuber-dns成为Kubernetes中的默认DNS服务器。CoreDNS是一种通用的、权威的DNS服务器，能够提供与Kubernetes向下兼容且具备可扩展性的集成能力。由于CoreDNS自身单一可执行文件与单一进程的特性，因此CoreDNS的活动部件数量会少于之前的DNS服务器，且能够通过创建自定义DNS条目来支持各类灵活的用例。此外，由于CoreDNS采用Go语言编写，它具有强大的内存安全性。</p><p>CoreDNS现在是kubernetes1.13急后续版本推荐的DNS解决方案，Kubernetes已将常用测试基础设施架构切换为默认使用CoreDNS,因此，开发团队建议用户也尽快完成切换。KubeDNS仍将至少支持一个版本，但现在是时候开始规划迁移了。</p><p>centos7系统的内网服务器三台：master:192.168.1.119;node1:192.168.1.118;node2:192.168.1.163</p><p>一 初始化系统环境和安装指定版本的docker(三台机器同时进行如下部署)(墙外环境)<br>1 关闭防火墙和SELINUX</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld.service <span class="token operator">&amp;&amp;</span> systemctl disable firewalld.service<span class="token comment" spellcheck="true"># 禁用SELINUX,临时生效</span>setenforce 0<span class="token comment" spellcheck="true"># 修改配置文件，重启后生效</span><span class="token function">sed</span> -i <span class="token string">'s#SELINUX=enforcing#SELINUX=disabled#g'</span> /etc/selinux/config或者打开配置文件修改<span class="token function">vi</span> /etc/selinux/configSELINUX<span class="token operator">=</span>disabled  </code></pre><p>2 关闭swap</p><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token operator">&amp;&amp;</span> sysctl -w vm.swappiness<span class="token operator">=</span>0<span class="token function">vi</span> /etc/fstab<span class="token comment" spellcheck="true">#UUID=7bff6243-324c-4587-b550-55dc34018ebf swap   swap defaults   0 0</span></code></pre><p>3 设置Docker所需参数</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> /etc/sysctl.d/k8s.confnet.ipv4.ip_forward <span class="token operator">=</span> 1net.bridge.bridge-nf-call-ip6tables <span class="token operator">=</span> 1net.bridge.bridge-nf-call-iptables <span class="token operator">=</span> 1EOFsysctl -p /etc/sysctl.d/k8s.conf</code></pre><p>4 安装Docker</p><pre class=" language-bash"><code class="language-bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<span class="token comment" spellcheck="true"># 如果没有yum-config-manager命令的话，请安装，步骤如下</span>--------------------------------------------------- start -----------------------------------------------------------<span class="token punctuation">[</span>root@rancherserver ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum search yum-config-manager</span>已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: centos.uhost.hk * epel: mirror.pregi.net * extras: centos.uhost.hk * updates: centos.uhost.hk<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>匹配：yum-config-manager <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>yum-utils.noarch <span class="token keyword">:</span> Utilities based around the yum package manageryum -y <span class="token function">install</span> yum-utils <span class="token comment" spellcheck="true"># 安装yum-config-manager的依赖包就可以了</span>---------------------------------------------------- end --------------------------------------------------------------yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -ryum <span class="token function">install</span> docker-ce-18.06.0.ce-3.el7 -ysystemctl start docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><h1 id="二-下面只需在192-168-1-119-master主机上部署"><a href="#二-下面只需在192-168-1-119-master主机上部署" class="headerlink" title="二 下面只需在192.168.1.119  master主机上部署"></a>二 下面只需在192.168.1.119  master主机上部署</h1><h2 id="2-1-创建k8s目录和下载自制证书的工具"><a href="#2-1-创建k8s目录和下载自制证书的工具" class="headerlink" title="2.1 创建k8s目录和下载自制证书的工具"></a>2.1 创建k8s目录和下载自制证书的工具</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">###  2.1.1 创建安装目录</span><span class="token function">mkdir</span> -p  /home/k8s/etcd/<span class="token punctuation">{</span>bin,cfg,ssl<span class="token punctuation">}</span><span class="token function">mkdir</span> -p  /home/k8s/kubernetes/<span class="token punctuation">{</span>bin,cfg,ssl<span class="token punctuation">}</span><span class="token function">mkdir</span> -p  /home/k8s/cfssl/<span class="token punctuation">{</span>etcd,kubernetes<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">#(这两个目录用来存放相关证书文件)</span><span class="token comment" spellcheck="true">### 2.1.2 安装配置CFSSL(CFSSL是自己创建证书的工具)</span><span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssl_linux-amd64<span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64<span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64<span class="token function">chmod</span> +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64<span class="token function">mv</span> cfssl_linux-amd64 /usr/local/bin/cfssl<span class="token function">mv</span> cfssljson_linux-amd64 /usr/local/bin/cfssljson<span class="token function">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre><h2 id="2-2-开始创建证书"><a href="#2-2-开始创建证书" class="headerlink" title="2.2 开始创建证书"></a>2.2 开始创建证书</h2><h3 id="2-2-1创建ETCD证书-目录为-home-k8s-cfssl-etcd"><a href="#2-2-1创建ETCD证书-目录为-home-k8s-cfssl-etcd" class="headerlink" title="2.2.1创建ETCD证书(目录为/home/k8s/cfssl/etcd/)"></a>2.2.1创建ETCD证书(目录为/home/k8s/cfssl/etcd/)</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-config.json<span class="token punctuation">{</span>  <span class="token string">"signing"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"default"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>    <span class="token punctuation">}</span>,    <span class="token string">"profiles"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"www"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>,         <span class="token string">"usages"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token string">"signing"</span>,            <span class="token string">"key encipherment"</span>,            <span class="token string">"server auth"</span>,            <span class="token string">"client auth"</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="2-2-2-创建ETCD-CA配置文件"><a href="#2-2-2-创建ETCD-CA配置文件" class="headerlink" title="2.2.2 创建ETCD CA配置文件"></a>2.2.2 创建ETCD CA配置文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"etcd CA"</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="2-2-3创建ETCD-Server证书"><a href="#2-2-3创建ETCD-Server证书" class="headerlink" title="2.2.3创建ETCD Server证书"></a>2.2.3创建ETCD Server证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> server-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"etcd"</span>,    <span class="token string">"hosts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token string">"192.168.1.119"</span>,    <span class="token string">"192.168.1.118"</span>,    <span class="token string">"192.168.1.63"</span>    <span class="token punctuation">]</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="2-2-4生成ETCD-CA证书和私钥"><a href="#2-2-4生成ETCD-CA证书和私钥" class="headerlink" title="2.2.4生成ETCD CA证书和私钥"></a>2.2.4生成ETCD CA证书和私钥</h3><pre class=" language-bash"><code class="language-bash">cfssl gencert -initca ca-csr.json <span class="token operator">|</span> cfssljson -bare ca -cfssl gencert -ca<span class="token operator">=</span>ca.pem -ca-key<span class="token operator">=</span>ca-key.pem -config<span class="token operator">=</span>ca-config.json -profile<span class="token operator">=</span>www server-csr.json <span class="token operator">|</span> cfssljson -bare server</code></pre><h3 id="2-2-5创建Kubernetes-CA证书"><a href="#2-2-5创建Kubernetes-CA证书" class="headerlink" title="2.2.5创建Kubernetes CA证书"></a>2.2.5创建Kubernetes CA证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-config.json<span class="token punctuation">{</span>  <span class="token string">"signing"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"default"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>    <span class="token punctuation">}</span>,    <span class="token string">"profiles"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"kubernetes"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>,         <span class="token string">"usages"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token string">"signing"</span>,            <span class="token string">"key encipherment"</span>,            <span class="token string">"server auth"</span>,            <span class="token string">"client auth"</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>EOF<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"kubernetes"</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,            <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"System"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFcfssl gencert -initca ca-csr.json <span class="token operator">|</span> cfssljson -bare ca -</code></pre><h3 id="2-2-6-生成API-SERVER证书"><a href="#2-2-6-生成API-SERVER证书" class="headerlink" title="2.2.6 生成API_SERVER证书"></a>2.2.6 生成API_SERVER证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> server-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"kubernetes"</span>,    <span class="token string">"hosts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>      <span class="token string">"10.0.0.1"</span>,      <span class="token string">"127.0.0.1"</span>,      <span class="token string">"192.168.1.119"</span>,      <span class="token string">"kubernetes"</span>,      <span class="token string">"kubernetes.default"</span>,      <span class="token string">"kubernetes.default.svc"</span>,      <span class="token string">"kubernetes.default.svc.cluster"</span>,      <span class="token string">"kubernetes.default.svc.cluster.local"</span>    <span class="token punctuation">]</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,            <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"System"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFcfssl gencert -ca<span class="token operator">=</span>ca.pem -ca-key<span class="token operator">=</span>ca-key.pem -config<span class="token operator">=</span>ca-config.json -profile<span class="token operator">=</span>kubernetes server-csr.json <span class="token operator">|</span> cfssljson -bare server</code></pre><h3 id="2-2-7-创建Kubernetes-Proxy证书"><a href="#2-2-7-创建Kubernetes-Proxy证书" class="headerlink" title="2.2.7 创建Kubernetes Proxy证书"></a>2.2.7 创建Kubernetes Proxy证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> kube-proxy-csr.json<span class="token punctuation">{</span>  <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"system:kube-proxy"</span>,  <span class="token string">"hosts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,  <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,    <span class="token string">"size"</span><span class="token keyword">:</span> 2048  <span class="token punctuation">}</span>,  <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,      <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,      <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,      <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,      <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"System"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFcfssl gencert -ca<span class="token operator">=</span>ca.pem -ca-key<span class="token operator">=</span>ca-key.pem -config<span class="token operator">=</span>ca-config.json -profile<span class="token operator">=</span>kubernetes kube-proxy-csr.json <span class="token operator">|</span> cfssljson -bare kube-proxy</code></pre><h2 id="2-3-Master主机到其它两个node节点做ssh-key认证"><a href="#2-3-Master主机到其它两个node节点做ssh-key认证" class="headerlink" title="2.3  Master主机到其它两个node节点做ssh-key认证"></a>2.3  Master主机到其它两个node节点做ssh-key认证</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ssh-keygen </span>Generating public/private rsa key pair.Enter <span class="token function">file</span> <span class="token keyword">in</span> <span class="token function">which</span> to save the key <span class="token punctuation">(</span>/root/.ssh/id_rsa<span class="token punctuation">)</span>: Created directory <span class="token string">'/root/.ssh'</span><span class="token keyword">.</span>Enter passphrase <span class="token punctuation">(</span>empty <span class="token keyword">for</span> no passphrase<span class="token punctuation">)</span>: Enter same passphrase again: Your identification has been saved <span class="token keyword">in</span> /root/.ssh/id_rsa.Your public key has been saved <span class="token keyword">in</span> /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:FQjjiRDp8IKGT+UDM+GbQLBzF3DqDJ+pKnMIcHGyO/o root@qas-k8s-master01The key's randomart image is:+---<span class="token punctuation">[</span>RSA 2048<span class="token punctuation">]</span>----+<span class="token operator">|</span>o.<span class="token operator">==</span>o o. <span class="token punctuation">..</span>      <span class="token operator">|</span><span class="token operator">|</span>ooB+o+ o.  <span class="token keyword">.</span>     <span class="token operator">|</span><span class="token operator">|</span>B++@o o   <span class="token keyword">.</span>      <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">=</span>X**o    <span class="token keyword">.</span>       <span class="token operator">|</span><span class="token operator">|</span>o<span class="token operator">=</span>O. <span class="token keyword">.</span>  S        <span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">..</span>+              <span class="token operator">|</span><span class="token operator">|</span>oo <span class="token keyword">.</span>             <span class="token operator">|</span><span class="token operator">|</span>* <span class="token keyword">.</span>              <span class="token operator">|</span><span class="token operator">|</span>o+E              <span class="token operator">|</span>+----<span class="token punctuation">[</span>SHA256<span class="token punctuation">]</span>-----+<span class="token comment" spellcheck="true"># ssh-copy-id 192.168.1.119</span><span class="token comment" spellcheck="true"># ssh-copy-id 192.168.1.63</span><span class="token comment" spellcheck="true"># 上面一步要输入这两台机器的密码</span></code></pre><h1 id="三-部署ETCD服务集群-三台机器同时都需要部署"><a href="#三-部署ETCD服务集群-三台机器同时都需要部署" class="headerlink" title="三 部署ETCD服务集群(三台机器同时都需要部署)"></a>三 部署ETCD服务集群(三台机器同时都需要部署)</h1><h2 id="三个节点都要下载etcd源码包，三台机器通过xshell同时连接"><a href="#三个节点都要下载etcd源码包，三台机器通过xshell同时连接" class="headerlink" title="三个节点都要下载etcd源码包，三台机器通过xshell同时连接"></a>三个节点都要下载etcd源码包，三台机器通过xshell同时连接</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src/<span class="token function">wget</span> http://down.cdn1688.net/k8s1.13/etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">tar</span> -xvf etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">cd</span> etcd-v3.3.10-linux-amd64/ <span class="token operator">&amp;&amp;</span> <span class="token function">cp</span> etcd etcdctl /home/k8s/etcd/bin/</code></pre><h2 id="192-168-1-119-Master节点部署如下"><a href="#192-168-1-119-Master节点部署如下" class="headerlink" title="192.168.1.119 Master节点部署如下"></a>192.168.1.119 Master节点部署如下</h2><pre class=" language-bash"><code class="language-bash">vim /home/k8s/etcd/cfg/etcd<span class="token comment" spellcheck="true">#[Member]</span>ETCD_NAME<span class="token operator">=</span><span class="token string">"etcd1"</span>ETCD_DATA_DIR<span class="token operator">=</span><span class="token string">"/var/lib/etcd/default.etcd"</span>ETCD_LISTEN_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2380"</span>ETCD_LISTEN_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379"</span><span class="token comment" spellcheck="true">#[Clustering]</span>ETCD_INITIAL_ADVERTISE_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2380"</span>ETCD_ADVERTISE_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379"</span>ETCD_INITIAL_CLUSTER<span class="token operator">=</span><span class="token string">"etcd1=https://192.168.1.119:2380,etcd2=https://192.168.1.118:2380,etcd3=https://192.168.1.63:2380"</span>ETCD_INITIAL_CLUSTER_TOKEN<span class="token operator">=</span><span class="token string">"etcd-cluster"</span>ETCD_INITIAL_CLUSTER_STATE<span class="token operator">=</span><span class="token string">"new"</span></code></pre><h2 id="创建etcd的systemd-unit文件"><a href="#创建etcd的systemd-unit文件" class="headerlink" title="创建etcd的systemd unit文件"></a>创建etcd的systemd unit文件</h2><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/etcd.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Etcd ServerAfter<span class="token operator">=</span>network.targetAfter<span class="token operator">=</span>network-online.targetWants<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notifyEnvironmentFile<span class="token operator">=</span>/home/k8s/etcd/cfg/etcdExecStart<span class="token operator">=</span>/home/k8s/etcd/bin/etcd \--name<span class="token operator">=</span><span class="token variable">${ETCD_NAME}</span> \--data-dir<span class="token operator">=</span><span class="token variable">${ETCD_DATA_DIR}</span> \--listen-peer-urls<span class="token operator">=</span><span class="token variable">${ETCD_LISTEN_PEER_URLS}</span> \--listen-client-urls<span class="token operator">=</span><span class="token variable">${ETCD_LISTEN_CLIENT_URLS}</span>,http://127.0.0.1:2379 \--advertise-client-urls<span class="token operator">=</span><span class="token variable">${ETCD_ADVERTISE_CLIENT_URLS}</span> \--initial-advertise-peer-urls<span class="token operator">=</span><span class="token variable">${ETCD_INITIAL_ADVERTISE_PEER_URLS}</span> \--initial-cluster<span class="token operator">=</span><span class="token variable">${ETCD_INITIAL_CLUSTER}</span> \--initial-cluster-token<span class="token operator">=</span><span class="token variable">${ETCD_INITIAL_CLUSTER_TOKEN}</span> \--initial-cluster-state<span class="token operator">=</span>new \--cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--key-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pem \--peer-cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--peer-key-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pem \--trusted-ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem \--peer-trusted-ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pemRestart<span class="token operator">=</span>on-failureLimitNOFILE<span class="token operator">=</span>65536<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><h3 id="把目录-home-k8s-cfssl-etcd-下制作的证书文件拷贝到-home-k8s-etcd-ssl目录下用于启动etcd服务"><a href="#把目录-home-k8s-cfssl-etcd-下制作的证书文件拷贝到-home-k8s-etcd-ssl目录下用于启动etcd服务" class="headerlink" title="把目录/home/k8s/cfssl/etcd/下制作的证书文件拷贝到/home/k8s/etcd/ssl目录下用于启动etcd服务"></a>把目录/home/k8s/cfssl/etcd/下制作的证书文件拷贝到/home/k8s/etcd/ssl目录下用于启动etcd服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> /home/k8s/cfssl/etcd/  /home/k8s/etcd/ssl/</code></pre><h2 id="192-168-1-118-node1节点部署如下"><a href="#192-168-1-118-node1节点部署如下" class="headerlink" title="192.168.1.118  node1节点部署如下"></a>192.168.1.118  node1节点部署如下</h2><pre class=" language-bash"><code class="language-bash">把master的etcd的配置文件和启动文件拷贝到node1上<span class="token comment" spellcheck="true"># 进入192.168.1.119(master)的/home/k8s/目录</span><span class="token function">scp</span> -r /home/k8s/etcd    192.168.1.118:/home/k8s/<span class="token function">scp</span> -r /usr/lib/systemd/system/etcd.service 192.168.1.118:/usr/lib/systemd/system/etcd.service<span class="token comment" spellcheck="true"># 进入192.168.1.118(node1)需要对/home/k8s/etcd/cfg/etcd配置文件进行修改</span>vim /home/k8s/etcd/cfg/etcd<span class="token comment" spellcheck="true">#[Member]</span>ETCD_NAME<span class="token operator">=</span><span class="token string">"etcd2"</span>ETCD_DATA_DIR<span class="token operator">=</span><span class="token string">"/var/lib/etcd/default.etcd"</span>ETCD_LISTEN_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2380"</span>ETCD_LISTEN_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2379"</span><span class="token comment" spellcheck="true">#[Clustering]</span>ETCD_INITIAL_ADVERTISE_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2380"</span>ETCD_ADVERTISE_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2379"</span>ETCD_INITIAL_CLUSTER<span class="token operator">=</span><span class="token string">"etcd1=https://192.168.1.119:2380,etcd2=https://192.168.1.118:2380,etcd3=https://192.168.1.63:2380"</span>ETCD_INITIAL_CLUSTER_TOKEN<span class="token operator">=</span><span class="token string">"etcd-cluster"</span>ETCD_INITIAL_CLUSTER_STATE<span class="token operator">=</span><span class="token string">"new"</span>node1节点的 etcd的 systemd unit 文件<span class="token punctuation">(</span>启动文件<span class="token punctuation">)</span>不需要修改</code></pre><h2 id="192-168-1-163-node2节点部署如下"><a href="#192-168-1-163-node2节点部署如下" class="headerlink" title="192.168.1.163  node2节点部署如下"></a>192.168.1.163  node2节点部署如下</h2><pre class=" language-bash"><code class="language-bash">把master的etcd的配置文件和启动文件拷贝到node1上<span class="token comment" spellcheck="true"># 进入192.168.1.119(master)的/home/k8s/目录</span><span class="token function">scp</span> -r /home/k8s/etcd    192.168.1.163:/home/k8s/<span class="token function">scp</span> -r /usr/lib/systemd/system/etcd.service 192.168.1.63:/usr/lib/systemd/system/etcd.service<span class="token comment" spellcheck="true"># 进入192.168.1.63(node2)需要对/home/k8s/etcd/cfg/etcd配置文件进行修改</span>vim /home/k8s/etcd/cfg/etcd<span class="token comment" spellcheck="true">#[Member]</span>ETCD_NAME<span class="token operator">=</span><span class="token string">"etcd3"</span>ETCD_DATA_DIR<span class="token operator">=</span><span class="token string">"/var/lib/etcd/default.etcd"</span>ETCD_LISTEN_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2380"</span>ETCD_LISTEN_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2379"</span><span class="token comment" spellcheck="true">#[Clustering]</span>ETCD_INITIAL_ADVERTISE_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2380"</span>ETCD_ADVERTISE_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2379"</span>ETCD_INITIAL_CLUSTER<span class="token operator">=</span><span class="token string">"etcd1=https://192.168.1.119:2380,etcd2=https://192.168.1.118:2380,etcd3=https://192.168.1.63:2380"</span>ETCD_INITIAL_CLUSTER_TOKEN<span class="token operator">=</span><span class="token string">"etcd-cluster"</span>ETCD_INITIAL_CLUSTER_STATE<span class="token operator">=</span><span class="token string">"new"</span>node2节点的 etcd的 systemd unit 文件<span class="token punctuation">(</span>启动文件<span class="token punctuation">)</span>也不需要修改</code></pre><h3 id="三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）"><a href="#三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）" class="headerlink" title="三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）"></a>三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）</h3><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> etcdsystemctl start etcd</code></pre><p>###<br>验证集群是否正常运行</p><pre class=" language-bash"><code class="language-bash">/home/k8s/etcd/bin/etcdctl \--ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem \--cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--key-file<span class="token operator">=</span>/homek8s/etcd/ssl/server-key.pem \--endpoints<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379,\https://192.168.1.118:2379,\https://192.168.1.63:2379"</span> cluster-health</code></pre><h2 id="四-三节点部署Flannel网络"><a href="#四-三节点部署Flannel网络" class="headerlink" title="四 三节点部署Flannel网络"></a>四 三节点部署Flannel网络</h2><h3 id="先在master上部署Flannel网络，登录master机器"><a href="#先在master上部署Flannel网络，登录master机器" class="headerlink" title="先在master上部署Flannel网络，登录master机器"></a>先在master上部署Flannel网络，登录master机器</h3><p>向etcd写入集群Pod网段信息</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/k8s/etcd/ssl//home/k8s/etcd/bin/etcdctl \--ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem  \--cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--key-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pem \--endpoints<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379,\https://192.168.1.118:2379,https://192.168.1.63:2379"</span> \<span class="token keyword">set</span> /coreos.com/network/config  <span class="token string">'{ "Network": "172.18.0.0/16", "Backend": {"Type": "vxlan"}}'</span></code></pre><p>下面这两句话部署的过程中我不懂啥意思，尤其是第一句简直就是懵逼了</p><blockquote><ul><li>flanneld当前版本(v0.10.0)不支持etcdv3,故使用etcd v2 API写入配置key和网段数据</li><li>写入Pod网段 ${CLUSTER_CIDR}必须是/16段地址，必须与kube-controller-的-cluster-cidr参数值一致;</li></ul></blockquote><p>下载安装flannel软件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src/ <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> http://down.cdn1688.net/k8s1.13/flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">tar</span> -xvf flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">mv</span> flannel mk-docker-opts.sh /home/k8s/kubernetes/bin/创建Flannel配置文件vim /home/k8s/kubernetes/cfg/flanneldFLANNEL_OPTIONS<span class="token operator">=</span><span class="token string">"--etcd-endpoints=https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile=/home/k8s/etcd/ssl/ca.pem -etcd-certfile=/home/k8s/etcd/ssl/server.pem -etcd-keyfile=/home/k8s/etcd/ssl/server-key.pem"</span></code></pre><p>创建flanneld的systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/flanneld.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Flanneld overlay address etcd agentAfter<span class="token operator">=</span>network-online.target network.targetBefore<span class="token operator">=</span>docker.service<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notifyEnvironmentFile<span class="token operator">=</span>/home/k8s/kubernetes/cfg/flanneldExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/flanneld --ip-masq <span class="token variable">$FLANNEL_OPTIONS</span>ExecStartPost<span class="token operator">=</span>/home/k8s/kubernetes/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/subnet.envRestart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><blockquote><ul><li>mk-docker-opts.sh脚本分配给flanneld的Pod子网网段信息写入/run/flannel/docker文件，后续docker启动时使用这个文件中的环境变量配置docker0网桥;</li><li>flanneld使用系统缺省路由所在的接口与其它节点通信，对于有多个网络接口(如内网和公网)的节点，可以用-iface参数指定通信接口，如上面的eth0接口;</li><li>flanneld运行时需要root权限<br>配置Docker启动指定子网段</li></ul></blockquote><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/docker.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Docker Application Container EngineDocumentation<span class="token operator">=</span>https://docs.docker.comAfter<span class="token operator">=</span>network-online.target firewalld.serviceWants<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notifyEnvironmentFile<span class="token operator">=</span>/run/flannel/subnet.envExecStart<span class="token operator">=</span>/usr/bin/dockerd <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>ExecReload<span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span>LimitNOFILE<span class="token operator">=</span>infinityLimitNPROC<span class="token operator">=</span>infinityLimitCORE<span class="token operator">=</span>infinityTimeoutStartSec<span class="token operator">=</span>0Delegate<span class="token operator">=</span>yesKillMode<span class="token operator">=</span>processRestart<span class="token operator">=</span>on-failureStartLimitBurst<span class="token operator">=</span>3StartLimitInterval<span class="token operator">=</span>60s<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>注意：对上面的文件内容做一下解析：</p><blockquote><ul><li>FLannel网络必须在宿主机网络能对外(其它node节点)正常通信的情况下启动才有意义，所以这里定义After=network.target</li><li>只有当Flannel网络启动之后，才能创建一个与其它节点不会冲突的网络，而docker的网络需要和fannel网络相同才能保证跨主机通信，所以docker必须要在flannel网络创建后才能启动，这里定义before=docker.service<br>将flanneld systemd unit文件拷贝到所有节点(在master上操作)</li></ul></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#把对应的配置文件拷贝到node1和node2上</span><span class="token function">scp</span> -r /home/k8s/kubernetes    192.168.1.118:/home/k8s/<span class="token function">scp</span> -r /home/k8s/kubernetes    192.168.1.63:/home/k8s/<span class="token function">scp</span> /home/k8s/kubernetes/cfg/flanneld   192.168.1.118:/home/k8s/kubernetes/cfg/flanneld<span class="token function">scp</span> /home/k8s/kubernetes/cfg/flanneld   192.168.1.63:/home/k8s/kubernetes/cfg/flanneld<span class="token function">scp</span> /usr/lib/systemd/system/docker.server 192.168.1.118:/usr/lib/systemd/system/docker.servier<span class="token function">scp</span> /usr/lib/systemd/system/docker.server   192.168.1.63:/usr/lib/systemd/system/docker.servier<span class="token function">scp</span> /usr/lib/systemd/system/flanneld.service  192.168.1.118:/usr/lib/systemd/system/flanneld.servier<span class="token function">scp</span> /usr/lib/systemd/system/flanneld.service  192.168.1.63:/usr/lib/systemd/system/flanneld.servier</code></pre><p>三节点都执行下面命令：启动服务和重启docker</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl start flanneld <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> flanneldsystemctl restart docker</code></pre><p>可以在各个节点上查看是否生效(下面是在master、node1、node2上的操作结果)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ip addr</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: em1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc mq state UP qlen 1000    link/ether 80:18:44:e3:61:e4 brd ff:ff:ff:ff:ff:ff    inet 192.168.1.119/24 brd 192.168.1.255 scope global em1       valid_lft forever preferred_lft forever    inet6 fe80::4e7f:7ff9:fbc0:d131/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever3: em2: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:61:e5 brd ff:ff:ff:ff:ff:ff4: em3: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:61:e6 brd ff:ff:ff:ff:ff:ff5: em4: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:61:e7 brd ff:ff:ff:ff:ff:ff6: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UP     link/ether 02:42:24:16:72:04 brd ff:ff:ff:ff:ff:ff    inet 172.18.89.1/24 brd 172.18.89.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:24ff:fe16:7204/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever7: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN     link/ether 4a:a6:d0:d3:f2:ce brd ff:ff:ff:ff:ff:ff    inet 172.18.89.0/32 scope global flannel.1       valid_lft forever preferred_lft forever11: vethea3f23b@if10: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether be:59:a5:d3:cd:41 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::bc59:a5ff:fed3:cd41/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever<span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ip addr</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: em1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc mq state UP qlen 1000    link/ether 80:18:44:e3:56:c0 brd ff:ff:ff:ff:ff:ff    inet 192.168.1.118/24 brd 192.168.1.255 scope global em1       valid_lft forever preferred_lft forever    inet6 fe80::4585:be92:8558:dbf6/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever3: em2: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:56:c1 brd ff:ff:ff:ff:ff:ff4: em3: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:56:c2 brd ff:ff:ff:ff:ff:ff5: em4: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:56:c3 brd ff:ff:ff:ff:ff:ff6: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UP     link/ether 02:42:e2:a7:53:8f brd ff:ff:ff:ff:ff:ff    inet 172.18.99.1/24 brd 172.18.99.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:e2ff:fea7:538f/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever7: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN     link/ether ba:7d:4e:4b:6a:ef brd ff:ff:ff:ff:ff:ff    inet 172.18.99.0/32 scope global flannel.1       valid_lft forever preferred_lft forever9: vethd9144bb@if8: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether c2:39:12:a7:be:cd brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::c039:12ff:fea7:becd/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever11: vethec20706@if10: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether de:d4:47:90:8d:a5 brd ff:ff:ff:ff:ff:ff link-netnsid 1    inet6 fe80::dcd4:47ff:fe90:8da5/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever<span class="token comment" spellcheck="true">#######################################################################################</span><span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ip addr</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: em1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc mq state UP qlen 1000    link/ether 20:47:47:8d:f4:9c brd ff:ff:ff:ff:ff:ff    inet 192.168.1.63/24 brd 192.168.1.255 scope global em1       valid_lft forever preferred_lft forever    inet6 fe80::976b:ad75:61c6:8c2d/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever3: em2: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 20:47:47:8d:f4:9d brd ff:ff:ff:ff:ff:ff4: em3: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 20:47:47:8d:f4:9e brd ff:ff:ff:ff:ff:ff5: em4: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 20:47:47:8d:f4:9f brd ff:ff:ff:ff:ff:ff6: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UP     link/ether 02:42:79:c7:6b:62 brd ff:ff:ff:ff:ff:ff    inet 172.18.72.1/24 brd 172.18.72.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:79ff:fec7:6b62/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever7: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN     link/ether 4e:cd:29:4b:df:1b brd ff:ff:ff:ff:ff:ff    inet 172.18.72.0/32 scope global flannel.1       valid_lft forever preferred_lft forever13: veth1e4d6e8@if12: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether fe:6c:77:28:be:eb brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::fc6c:77ff:fe28:beeb/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever17: veth7a9dd40@if16: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether 7a:05:16:52:c1:4a brd ff:ff:ff:ff:ff:ff link-netnsid 1    inet6 fe80::7805:16ff:fe52:c14a/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever</code></pre><p>这时三个节点都部署了etcd、flannled、docker服务了,下面是master、node1、node2上的显示</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lntp |grep etcd</span>tcp        0      0 192.168.1.119:2379      0.0.0.0:*               LISTEN      12651/etcd          tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      12651/etcd          tcp        0      0 192.168.1.119:2380      0.0.0.0:*               LISTEN      12651/etcd   <span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep flannel</span>root      12903      1  0 4月29 ?       00:08:32 /home/k8s/kubernetes/bin/flanneld --ip-masq --etcd-endpoints<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem -etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem -etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot      64750  64185  0 15:46 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto flannel<span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep docker</span>root      13017      1  0 4月29 ?       01:25:11 /usr/bin/dockerd --bip<span class="token operator">=</span>172.18.89.1/24 --ip-masq<span class="token operator">=</span>false --mtu<span class="token operator">=</span>1450root      13031  13017  0 4月29 ?       00:55:16 docker-containerd --config /var/run/docker/containerd/containerd.tomlroot      65318  64185  0 15:51 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto docker<span class="token comment" spellcheck="true">#######################################################################################</span><span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lntp |grep etcd</span>tcp        0      0 192.168.1.118:2379      0.0.0.0:*               LISTEN      11976/etcd          tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      11976/etcd          tcp        0      0 192.168.1.118:2380      0.0.0.0:*               LISTEN      11976/etcd   <span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep flanneld</span>root      12131      1  0 4月29 ?       00:08:42 /home/k8s/kubernetes/bin/flanneld --ip-masq --etcd-endpoints<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem -etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem -etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot     114125 114001  0 15:47 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto flanneld<span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep docker</span>root      12243      1  0 4月29 ?       01:40:32 /usr/bin/dockerd --bip<span class="token operator">=</span>172.18.99.1/24 --ip-masq<span class="token operator">=</span>false --mtu<span class="token operator">=</span>1450root      12258  12243  1 4月29 ?       02:13:34 docker-containerd --config /var/run/docker/containerd/containerd.toml<span class="token comment" spellcheck="true">#######################################################################################</span><span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lntp |grep etcd</span>tcp        0      0 192.168.1.63:2379       0.0.0.0:*               LISTEN      11645/etcd          tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      11645/etcd          tcp        0      0 192.168.1.63:2380       0.0.0.0:*               LISTEN      11645/etcd   <span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep flanneld</span>root      11781      1  0 4月29 ?       00:08:47 /home/k8s/kubernetes/bin/flanneld --ip-masq --etcd-endpoints<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem -etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem -etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot      35948  35741  0 15:45 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto flanneld<span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep docker</span>root      11892      1  0 4月29 ?       01:42:50 /usr/bin/dockerd --bip<span class="token operator">=</span>172.18.72.1/24 --ip-masq<span class="token operator">=</span>false --mtu<span class="token operator">=</span>1450root      11906  11892  1 4月29 ?       02:25:14 docker-containerd --config /var/run/docker/containerd/containerd.toml</code></pre><h2 id="五-部署master节点"><a href="#五-部署master节点" class="headerlink" title="五    部署master节点"></a>五    部署master节点</h2><p>kubernetes master节点运行如下组件：</p><blockquote><ul><li>kuber-apiserver</li><li>kube-scheduler</li><li>kube-controller-manager  </li><li>注意：kuber-scheduler和kube-controlller-manager可以以集群模式运行，通过leader选举产生一个工作进程，其它进程处于阻塞模式。</li></ul></blockquote><p>将kubernetes-server二进制文件解压拷贝到master节点</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> http://down.cdn1688.net/k8s1.13/kubernetes-server-linux-amd64.tar.gz<span class="token comment" spellcheck="true"># 特别注意下面这目录</span><span class="token function">cd</span> /usr/local/src/kubernetes/server/bin <span class="token function">cp</span> kube-scheduler kube-apiserver kube-controller-manager kubectl /home/k8s/kubernetes/bin/<span class="token comment" spellcheck="true">## 拷贝证书</span><span class="token function">cp</span> /home/k8s/cfssl/kubernetes/*pem  /home/k8s/kubernetes/ssl/</code></pre><p>部署kube-apiserver组件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建TLS Bootstrapping Token</span><span class="token operator">></span> <span class="token function">head</span> -c 16 /dev/urandom <span class="token operator">|</span> od -An -t x <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">' '</span>b2d81324fb83862f435f66498b90e5bdvim /home/k8s/kubernetes/cfg/token.csvb2d81324fb83862f435f66498b90e5bd,kubelet-bootstrap,10001,<span class="token string">"system:kubelet-bootstrap"</span></code></pre><p>创建apiserver配置文件</p><pre class=" language-bash"><code class="language-bash">vim /home/k8s/kubernetes/cfg/kube-apiserverKUBE_APISERVER_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--etcd-servers=https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 \--bind-address=192.168.1.119 \--secure-port=6443 \--advertise-address=192.168.1.119 \--allow-privileged=true \--service-cluster-ip-range=10.0.0.0/24 \--enable-admission-plugins=NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota,NodeRestriction \--authorization-mode=RBAC,Node \--enable-bootstrap-token-auth \--token-auth-file=/home/k8s/kubernetes/cfg/token.csv \--service-node-port-range=30000-50000 \--tls-cert-file=/home/k8s/kubernetes/ssl/server.pem  \--tls-private-key-file=/home/k8s/kubernetes/ssl/server-key.pem \--client-ca-file=/home/k8s/kubernetes/ssl/ca.pem \--service-account-key-file=/home/k8s/kubernetes/ssl/ca-key.pem \--etcd-cafile=/home/k8s/etcd/ssl/ca.pem \--etcd-certfile=/home/k8s/etcd/ssl/server.pem \--etcd-keyfile=/home/k8s/etcd/ssl/server-key.pem"</span></code></pre><p>创建kube-apiserver systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/kube-apiserver.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes API ServerDocumentation<span class="token operator">=</span>https://github.com/kubernetes/kubernetes<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-apiserverExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-apiserver <span class="token variable">$KUBE_APISERVER_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>启动kube-apiserver服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-apiserversystemctl restart kube-apiserver<span class="token comment" spellcheck="true"># 查看apiserver是否运行</span><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps  -ef | grep kube-apiserver </span>root      16331      1  3 4月29 ?       06:43:45 /home/k8s/kubernetes/bin/kube-apiserver --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --etcd-servers<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 --bind-address<span class="token operator">=</span>192.168.1.119 --secure-port<span class="token operator">=</span>6443 --advertise-address<span class="token operator">=</span>192.168.1.119 --allow-privileged<span class="token operator">=</span>true --service-cluster-ip-range<span class="token operator">=</span>10.0.0.0/24 --enable-admission-plugins<span class="token operator">=</span>NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota,NodeRestriction --authorization-mode<span class="token operator">=</span>RBAC,Node --enable-bootstrap-token-auth --token-auth-file<span class="token operator">=</span>/home/k8s/kubernetes/cfg/token.csv --service-node-port-range<span class="token operator">=</span>30000-50000 --tls-cert-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/server.pem --tls-private-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/server-key.pem --client-ca-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca.pem --service-account-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca-key.pem --etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem --etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem --etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot     109163 104117  0 21:41 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto kube-apiserver</code></pre><p>部署kube-scheduler</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建kube-scheduler配置文件</span>vim /home/k8s/kubernetes/cfg/kube-schedulerKUBE_SCHEDULER_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true --v=4 --master=127.0.0.1:8080 --leader-elect"</span></code></pre><blockquote><ul><li>-address:在127.0.0.1:10251 端口接收http/metrics请求；kube-scheduler目前还不支持接收https请求；</li><li>-kubeconfig:指定kubeconfig文件路径，kube-scheduler使用它连接和验证kube-apiserver;</li><li>-leader-elect=true:集群运行模式，启用选举功能；被选为leader的节点负责处理工作，其它节点为阻塞状态；</li></ul></blockquote><p>创建kube-scheduler systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/kube-scheduler.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes SchedulerDocumentation<span class="token operator">=</span>https://github.com/kubernetes/kubernetes<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-schedulerExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-scheduler <span class="token variable">$KUBE_SCHEDULER_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>启动服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-scheduler.servicesystemctl .restart kube-scheduler.service<span class="token comment" spellcheck="true">## 查看kube-scheduler是否运行和状态</span><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  ps -ef |grep kube-scheduler </span>root      32101      1  1 4月29 ?       02:01:04 /home/k8s/kubernetes/bin/kube-scheduler --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-electroot     110330 104117  0 21:50 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto kube-scheduler<span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kube-scheduler.service</span>● kube-scheduler.service - Kubernetes Scheduler   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/kube-scheduler.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since 一 2019-04-29 21:21:08 CST<span class="token punctuation">;</span> 1 weeks 1 days ago     Docs: https://github.com/kubernetes/kubernetes Main PID: 32101 <span class="token punctuation">(</span>kube-scheduler<span class="token punctuation">)</span>   Memory: 26.1M   CGroup: /system.slice/kube-scheduler.service           └─32101 /home/k8s/kubernetes/bin/kube-scheduler --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-elect5月 07 21:44:19 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:44:19.379442   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/kubernetes/cmd/kube-scheduler/app/server.go:232: Watch close - *v1.Pod total 3 items received5月 07 21:44:44 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:44:44.318917   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.Service total 0 items received5月 07 21:45:09 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:45:09.308219   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.PersistentVolumeClaim total 0 items received5月 07 21:48:08 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:48:08.319573   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.Node total 105 items received5月 07 21:48:26 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:48:26.301859   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.ReplicaSet total 4 items received5月 07 21:48:34 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:48:34.319324   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.ReplicationController total 0 items received5月 07 21:49:20 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:49:20.328175   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.PersistentVolume total 0 items received5月 07 21:49:22 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:49:22.380500   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/kubernetes/cmd/kube-scheduler/app/server.go:232: Watch close - *v1.Pod total 3 items received5月 07 21:49:33 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:49:33.290127   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1beta1.PodDisruptionBudget total 0 items received5月 07 21:50:15 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:50:15.277980   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.StorageClass total 0 items received</code></pre><p>部署kube-controller-manager</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建kube-controller-manager配置文件</span>vim /home/k8s/kubernetes/cfg/kube-controller-manager KUBE_CONTROLLER_MANAGER_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--master=127.0.0.1:8080 \--leader-elect=true \--address=127.0.0.1 \--service-cluster-ip-range=10.0.0.0/24 \--cluster-name=kubernetes \--cluster-signing-cert-file=/home/k8s/kubernetes/ssl/ca.pem \--cluster-signing-key-file=/home/k8s/kubernetes/ssl/ca-key.pem  \--root-ca-file=/home/k8s/kubernetes/ssl/ca.pem \--service-account-private-key-file=/home/k8s/kubernetes/ssl/ca-key.pem"</span></code></pre><p>创建kube-controller-manager systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/kube-controller-manager.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes Controller ManagerDocumentation<span class="token operator">=</span>https://github.com/kubernetes/kubernetes<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-controller-managerExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-controller-manager <span class="token variable">$KUBE_CONTROLLER_MANAGER_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>启动kube-controller-manager服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-controller-managersystemctl restart kube-controller-manager</code></pre><p>查看kube-controller-manager是否运行</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kube-controller-manager</span>● kube-controller-manager.service - Kubernetes Controller Manager   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/kube-controller-manager.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since 一 2019-04-29 21:25:58 CST<span class="token punctuation">;</span> 1 weeks 1 days ago     Docs: https://github.com/kubernetes/kubernetes Main PID: 32544 <span class="token punctuation">(</span>kube-controller<span class="token punctuation">)</span>   Memory: 76.2M   CGroup: /system.slice/kube-controller-manager.service           └─32544 /home/k8s/kubernetes/bin/kube-controller-manager --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-elect<span class="token operator">=</span>true --address<span class="token operator">=</span>127.0.0.1 --service-cluster-ip-range<span class="token operator">=</span>10.0.0.0/24 --cluster-name<span class="token operator">=</span>kubernetes --cluster-signing-cert-file<span class="token operator">=</span>/home/k8s/kuberne<span class="token punctuation">..</span>.5月 07 21:56:02 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:02.328943   32544 attach_detach_controller.go:634<span class="token punctuation">]</span> processVolumesInUse <span class="token keyword">for</span> node <span class="token string">"192.168.1.118"</span>5月 07 21:56:03 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:03.184628   32544 node_lifecycle_controller.go:929<span class="token punctuation">]</span> Node 192.168.1.119 ReadyCondition updated. Updating timestamp.5月 07 21:56:03 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:03.184673   32544 node_lifecycle_controller.go:929<span class="token punctuation">]</span> Node 192.168.1.118 ReadyCondition updated. Updating timestamp.5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.193087   32544 attach_detach_controller.go:634<span class="token punctuation">]</span> processVolumesInUse <span class="token keyword">for</span> node <span class="token string">"192.168.1.63"</span>5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.614869   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.614875   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.712730   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:08 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:08.184898   32544 node_lifecycle_controller.go:929<span class="token punctuation">]</span> Node 192.168.1.63 ReadyCondition updated. Updating timestamp.5月 07 21:56:08 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:08.782878   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:08 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:08.793132   32544 pv_controller_base.go:408<span class="token punctuation">]</span> resyncing PV controller<span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep kube-controller-manager</span>root      32544      1  4 4月29 ?       09:30:31 /home/k8s/kubernetes/bin/kube-controller-manager --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-elect<span class="token operator">=</span>true --address<span class="token operator">=</span>127.0.0.1 --service-cluster-ip-range<span class="token operator">=</span>10.0.0.0/24 --cluster-name<span class="token operator">=</span>kubernetes --cluster-signing-cert-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca.pem --cluster-signing-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca-key.pem --root-ca-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca.pem --service-account-private-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca-key.pemroot     111998 104117  0 22:03 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto kube-controller-manager</code></pre><p>将可执行文件路径/home/k8s/kubernetes/bin/添加到环境变量PATH中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/profile.d/vim k8s.sh<span class="token function">export</span> PATH<span class="token operator">=</span>/home/k8s/kubernetes/bin:<span class="token variable">$PATH</span><span class="token function">source</span> k8s.sh</code></pre><p>查看集群master状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs,nodes</span>NAME                                 STATUS    MESSAGE             ERRORcomponentstatus/controller-manager   Healthy   ok                  componentstatus/scheduler            Healthy   ok                  componentstatus/etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><h1 id="六-部署node1和node2节点"><a href="#六-部署node1和node2节点" class="headerlink" title="六 部署node1和node2节点"></a>六 部署node1和node2节点</h1><p>kubernetes work节点运行如下组件：</p><blockquote><ul><li>docker   ：开头我们已经部署了</li><li>kubelet</li><li>kube-proxy</li></ul></blockquote><p>部署kubelet组件</p><blockquote><ul><li>kubelet运行在每个work节点上，接收kube-apiserver发送的请求，管理Pod容器，执行交互式命令，如exec、run、logs等</li><li>kubelet启动时自动向kube-apiserver注册节点信息，内置的cadvisor统计和监控节点的资源使用情况</li><li>为确保安全，本文档只开启接收https请求的安全端口，对请求进行认证和授权，拒绝未授权的访问(如apierver、heapster)。</li></ul></blockquote><p>将master节点上kubelet二进制文件拷贝到node1和node2节点上</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 bin<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/k8s/kubernetes/bin<span class="token punctuation">[</span>root@docker-1 bin<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /usr/local/src/kubernetes/server/bin </span><span class="token comment" spellcheck="true">#master也作为一个节点使用</span><span class="token punctuation">[</span>root@docker-1 /usr/local/src/kubernetes/server/bin<span class="token punctuation">]</span> <span class="token function">cp</span> kubelet kube-proxy  /home/k8s/kubernetes/bin<span class="token function">scp</span> kubelet kube-proxy 192.168.1.118:/home/k8s/kubernetes/bin/<span class="token function">scp</span> kubelet kube-proxy 192.168.1.63:/home/k8s/kubernetes/bin</code></pre><p>创建kubelet bootstrap kubeconfig文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/k8s/cfssl/kubernetes<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#vim environment.sh </span><span class="token comment" spellcheck="true"># 创建kubelet bootstrapping kubeconfig </span>BOOTSTRAP_TOKEN<span class="token operator">=</span>b2d81324fb83862f435f66498b90e5bdKUBE_APISERVER<span class="token operator">=</span><span class="token string">"https://192.168.1.119:6443"</span><span class="token comment" spellcheck="true"># 设置集群参数</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>./ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span><span class="token variable">${KUBE_APISERVER}</span> \  --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials kubelet-bootstrap \  --token<span class="token operator">=</span><span class="token variable">${BOOTSTRAP_TOKEN}</span> \  --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kubelet-bootstrap \  --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true">#----------------------</span><span class="token comment" spellcheck="true"># 创建kube-proxy kubeconfig文件</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>./ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span><span class="token variable">${KUBE_APISERVER}</span> \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfigkubectl config set-credentials kube-proxy \  --client-certificate<span class="token operator">=</span>./kube-proxy.pem \  --client-key<span class="token operator">=</span>./kube-proxy-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfigkubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kube-proxy \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfigkubectl config use-context default --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig</code></pre><p>将生成的bootstrap.kubeconfig 、kube-proxy.kubeconfig两个文件拷贝到所有nodes节点 </p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">pwd</span>/home/k8s/cfssl/kubernetes<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">cp</span> /home/k8s/cfssl/kubernetes/bootstrap.kubeconfig kube-proxy.kubeconfig /home/k8s/kubernetes/cfg/<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">cp</span> /home/k8s/cfssl/kubernetes/bootstrap.kubeconfig kube-proxy.kubeconfig   192.168.1.118:/home/k8s/kubernetes/cfg/<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">cp</span> /home/k8s/cfssl/kubernetes/bootstrap.kubeconfig kube-proxy.kubeconfig   192.168.1.63:/home/k8s/kubernetes/cfg/</code></pre><p>继续在master主机上创建kubelet参数配置文件拷贝到所有nodes节点</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建kubelet参数配置模板文件</span>vim /home/k8s/kubernetes/cfg/kubelet.configapiVersion: kubelet.config.k8s.io/v1beta1address: 192.168.1.119port: 10250readOnlyPort: 10255cgroupDriver: cgroupfsclusterDNS: <span class="token punctuation">[</span><span class="token string">"10.0.0.2"</span><span class="token punctuation">]</span>clusterDomain: cluster.local.failSwapOn: <span class="token boolean">false</span>authentication:  anonymous:    enabled: <span class="token boolean">true</span><span class="token comment" spellcheck="true"># 创建kubelet配置文件</span>vim /home/k8s/kubernetes/cfg/kubeletKUBELET_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--hostname-override=192.168.1.119 \--kubeconfig=/home/k8s/kubernetes/cfg/kubelet.kubeconfig \--bootstrap-kubeconfig=/home/k8s/kubernetes/cfg/bootstrap.kubeconfig \--config=/home/k8s/kubernetes/cfg/kubelet.config \--cert-dir=/home/k8s/kubernetes/ssl \--pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0"</span><span class="token comment" spellcheck="true"># 创建kubelet systemd unit文件</span>vim /usr/lib/systemd/system/kubelet.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes KubeletAfter<span class="token operator">=</span>docker.serviceRequires<span class="token operator">=</span>docker.service<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>/home/k8s/kubernetes/cfg/kubeletExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kubelet <span class="token variable">$KUBELET_OPTS</span>Restart<span class="token operator">=</span>on-failureKillMode<span class="token operator">=</span>process<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>在master操作将kubelet-bootstrap用户绑定到系统集群角色</p><pre class=" language-bash"><code class="language-bash">kubectl create clusterrolebinding kubelet-bootstrap \  --clusterrole<span class="token operator">=</span>system:node-bootstrapper \  --user<span class="token operator">=</span>kubelet-bootstrap</code></pre><p>将master上的<b>/home/k8s/kubernetes/cfg/kubelet</b>文件和<strong>/usr/lib/systemd/system/kubelet.service</strong>拷贝到node1和node2上</p><p>[root@docker-1]scp /home/k8s/kubernetes/cfg/kubelet   192.168.1.118:/home/k8s/kubernetes/cfg/kubelet</p><p>&amp;&amp;  scp /home/k8s/kubernetes/cfg/kubelet</p><p>[root@docker-1]scp /usr/lib/systemd/system/kubelet.service 192.168.1.118:/usr/lib/systemd/system/kubelet.service &amp;&amp;  scp  /usr/lib/systemd/system/kubelet.service 192.168.1.63:/usr/lib/systemd/system/kubelet.service</p><p>其中<font color=red>/home/k8s/kubernetes/cfg/kubelet</font>文件要修改为对应的IP,node1修改为<font color=blue>–hostname-override=192.168.1.118</font>、 node2修改为<font color=red>–hostname-override=192.168.1.63  </font>                  </p><p>  其中<font color=red>usr/lib/systemd/system/kubelet.service</font> 文件不需要修改</p><p>启动三台服务器的kubelet服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kubeletsystemctl restart kubelet</code></pre><p><strong>approve kubelet CSR请求</strong></p><p>查看CSR列表</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE    REQUESTOR           CONDITIONnode-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs   39m    kubelet-bootstrap   Pendingnode-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s   5m5s   kubelet-bootstrap   Pending<span class="token comment" spellcheck="true"># kubectl certificate approve node-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs</span>certificatesigningrequest.certificates.k8s.io/node-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs <span class="token comment" spellcheck="true"># kubectl certificate approve node-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s  </span>certificatesigningrequest.certificates.k8s.io/node-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s approved<span class="token punctuation">[</span><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE     REQUESTOR           CONDITIONnode-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs   41m     kubelet-bootstrap   Approved,Issuednode-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s   7m32s   kubelet-bootstrap   Approved,Issued</code></pre><blockquote><ul><li>Requesting User: 请求CSR的用户，kube-apiserver对它进行认证和授权</li><li>Subject: 请求签名的证书信息</li><li>证书的 CN 是system:node;kube-node2, Organization 是system:nodes,kube-apiserver的Node授权模式会授予该证书的相关权限；</li></ul></blockquote><p><strong>在master上查看集群状态</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span>NAME            STATUS   ROLES    AGE     VERSION192.168.1.118   Ready    node     7d22h   v1.13.0192.168.1.119   Ready    master   8d      v1.13.0192.168.1.63    Ready    node     7d22h   v1.13.0</code></pre><p><b>先在master上部署kube-proxy组件</b></p><p>kube-proxy运行在所有node节点上，它监听apiserver中 service 和Endpoint的变化情况，创建路由规则来进行服务负载均衡。</p><p>创建kube-proxy配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#vim /home/k8s/kubernetes/cfg/kube-proxy</span>KUBE_PROXY_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--hostname-override=192.168.1.119 \--cluster-cidr=10.0.0.0/24 \--kubeconfig=/home/k8s/kubernetes/cfg/kube-proxy.kubeconfig"</span></code></pre><blockquote><ul><li>bindAddress：监听地址；</li><li>clientConnection.kubeconfig: 连接apiserver的kubeconfig文件；</li><li>clusterCIDR: kube-proxy根据-cluster-cidr判断集群内部和外部流量指定 –cluster-cidr 或 –masquerade-all 选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT；</li><li>hostnameOverride: 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 ipvs 规则；</li><li>mode: 使用ipvs模式；</li></ul></blockquote><p>创建kube-proxy systemd unit文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim /home/k8s/kubernetes/cfg/kube-proxy</span>KUBE_PROXY_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--hostname-override=192.168.1.119 \--cluster-cidr=10.0.0.0/24 \--kubeconfig=/home/k8s/kubernetes/cfg/kube-proxy.kubeconfig"</span><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /usr/lib/systemd/system/kube-proxy.service </span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes ProxyAfter<span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-proxyExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-proxy <span class="token variable">$KUBE_PROXY_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>在node1和node2上部署kube-proxy服务</p><p>把<strong>master</strong>上<font color=blue>kube-proxy</font>配置文件和<font color=red>kube-proxy systemd unit</font>文件拷贝到node1和node2，其中/home/k8s/kubenetes/cfg/kube-proxy需要修改为相应的IP</p><p>最后启动服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-proxysystemctl restart kube-proxy<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kube-proxy</span>● kube-proxy.service - Kubernetes Proxy   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/kube-proxy.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since 二 2019-04-30 00:46:30 CST<span class="token punctuation">;</span> 1 weeks 0 days ago Main PID: 51295 <span class="token punctuation">(</span>kube-proxy<span class="token punctuation">)</span>   Memory: 11.1M   CGroup: /system.slice/kube-proxy.service           ‣ 51295 /home/k8s/kubernetes/bin/kube-proxy --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --hostname-override<span class="token operator">=</span>192.168.1.119 --cluster-cidr<span class="token operator">=</span>10.0.0.0/24 --kubeconfig<span class="token operator">=</span>/home/k8s/kubernetes/cfg/kube-proxy.kubeconfig5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.815793   51295 proxier.go:664<span class="token punctuation">]</span> Syncing iptables rules5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.834550   51295 iptables.go:327<span class="token punctuation">]</span> running iptables-save <span class="token punctuation">[</span>-t filter<span class="token punctuation">]</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.836358   51295 iptables.go:327<span class="token punctuation">]</span> running iptables-save <span class="token punctuation">[</span>-t nat<span class="token punctuation">]</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.839045   51295 proxier.go:1019<span class="token punctuation">]</span> Port <span class="token string">"nodePort for kube-system/kubernetes-dashboard:"</span> <span class="token punctuation">(</span>:49655/tcp<span class="token punctuation">)</span> was <span class="token function">open</span> before and is still needed5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.839157   51295 iptables.go:391<span class="token punctuation">]</span> running iptables-restore <span class="token punctuation">[</span>--noflush --counters<span class="token punctuation">]</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.844415   51295 healthcheck.go:235<span class="token punctuation">]</span> Not saving endpoints <span class="token keyword">for</span> unknown healthcheck <span class="token string">"default/nginx"</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.844438   51295 proxier.go:641<span class="token punctuation">]</span> syncProxyRules took 28.670563ms5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.844451   51295 bounded_frequency_runner.go:221<span class="token punctuation">]</span> sync-runner: ran, next possible <span class="token keyword">in</span> 0s, periodic <span class="token keyword">in</span> 30s5月 07 23:10:01 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:01.729871   51295 config.go:141<span class="token punctuation">]</span> Calling handler.OnEndpointsUpdate5月 07 23:10:01 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:01.730171   51295 config.go:141<span class="token punctuation">]</span> Calling handler.OnEndpointsUpdate</code></pre><p>集群状态</p><p>打node或master节点的标签</p><pre class=" language-bash"><code class="language-bash">kubectl label node 192.168.1.119  node-role.kubernetes.io/master<span class="token operator">=</span><span class="token string">'master'</span>kubectl label node 192.168.1.118  node-role.kubernetes.io/node<span class="token operator">=</span><span class="token string">'node'</span>kubectl label node 192.168.1.63  node-role.kubernetes.io/node<span class="token operator">=</span><span class="token string">'node'</span><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node,cs</span>NAME                 STATUS   ROLES    AGE     VERSIONnode/192.168.1.118   Ready    node     7d22h   v1.13.0node/192.168.1.119   Ready    master   8d      v1.13.0node/192.168.1.63    Ready    node     7d22h   v1.13.0NAME                                 STATUS    MESSAGE             ERRORcomponentstatus/scheduler            Healthy   ok                  componentstatus/controller-manager   Healthy   ok                  componentstatus/etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes,docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csrf</title>
      <link href="/2018/12/03/python-csrf/"/>
      <url>/2018/12/03/python-csrf/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-的CSRF保护机制"><a href="#Django-的CSRF保护机制" class="headerlink" title="Django 的CSRF保护机制"></a>Django 的CSRF保护机制</h1><h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF(Cross Site Request Forgery),跨站点请求伪造。也被称为one-click-attack或者session riding,通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本(XSS)相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。</p><h2 id="Django提供的CSRF防护机制"><a href="#Django提供的CSRF防护机制" class="headerlink" title="Django提供的CSRF防护机制"></a>Django提供的CSRF防护机制</h2><p>django第一次响应来自某个客户端的请求时，会在服务器端随机生成一个token，把这个token放在cookie里。然后每次POST请求都会带上这个token，这样就能避免CSRF攻击。</p><blockquote><ul><li>在返回的HTTP响应的cookie里，django会为你添加一个csrftoken字段，其值为一个自动生成的token</li><li>在所有的POST表单时，必须包含一个csrfmiddlewaretoken字段(只需要在模板里加一个tag,django就会自动帮你生成)</li><li>在处理POST请求之前，django会验证这个请求的cookie里的csrftoken字段的值和提交的表单里的csrfmiddlewaretoken字段的值是否一样。如果一样，则表明这是一个合法的请求，否则，这个请求可能来自别人的csrf攻击，返回403 Forbidden.</li><li>在所有ajax POST请求里，添加一个X-CSRFTOKEN header,其值为cookie里的csrftoken值</li></ul></blockquote><h2 id="Django里如何使用CSRF防护"><a href="#Django里如何使用CSRF防护" class="headerlink" title="Django里如何使用CSRF防护"></a>Django里如何使用CSRF防护</h2><blockquote><ul><li>首先，最基本的原则是： GET请求不要用，有危险性，也就是任何处理GET请求的代码对资源的访问都一定要是”只读”的</li><li>要启用django.middleware.csrf.CsrfViewMiddleware这个中间件</li><li>再次，在所有的POST表单元素时，需要加上一个</li><li>在渲染模块时，使用RequestContext.RequestContext会处理csr_token这个tag，从而自动为表单添加一个名为csrfmiddlewaretoke的input</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysqldump</title>
      <link href="/2018/08/02/mysqldump/"/>
      <url>/2018/08/02/mysqldump/</url>
      
        <content type="html"><![CDATA[<p>mysqldump -uroot -phonjia@mariadb –single-transaction –master-data=2 –flush-logs -R -E lottery | gzip &gt; /backupmyql/lottery_<code>date &#39;+%m-%d-%Y&#39;</code>.sql.gz</p><a id="more"></a><p>参数解析：<br><strong>–single-transaction:</strong><br>This option sends a START TRANSACTION SQL statement to the server before dumping data.It is useful only with transaction tables such as InnoDB, because then it dumps the consistent state of the database at the time when BEGIN was issued without blocking any applications.</p><p>When using this option,you should keep in mind that only InnoDB tables are dumped in a consistent state. The single-transaction feature depends not only on the engine being transactional and capable of <strong>repeatable-read</strong>,but also on <strong>start transaction with consistent snapshot</strong>. The dump is not guaranteed to be consistent for other storage engines.For example, any TokuDB,MyISAM or MEMORY tables dumped while using this option may still change state.<br>While a –single-transaction dump is in process,to ensure a valid dump file(correct table contents and binary log coordinates),no other connection should use the following statements:ALTER TABLE,CREATE TABLE,DROP TABLE,RENAME TABLE,OR TRUNCATE TABLE.</p><p>While a –single-transaction dump is in process,to ensure a valid dump file(correct table contents and binary log coordinates),no other connection should use the following statements:ALTER TABLE,CREATE TABLE,DROP TABLE,RENAME TABLE,or TRUNCATE TABLE. A consistent read is not isolated from those statement,so use of them on a table to be dumped can cause the <strong>SELECT</strong> (performed by mysqldump to retrieve the table contents) to obtain incorrect contents or fail.</p><p>The –single-transaction option and the –lock-tables option are mutually exclusive because automatically turns off –lock-tables<br>TO dump large tables,you should combine the –single-transaction option with –quick</p><p><strong>–master-data[=#]:</strong><br>Causes the <strong>binary log</strong> position and filename to be appended to the output,useful dumping a master replication server to produce a dump file that can be used to set up another server as slave of the master.These are the master server coordinates from which the slave should start replicating after you load the dump file into the slave. If the option is set to 1(the default),will print it as a <strong>change master</strong>command;if set to 2,that command will be prefixed with a comment symbol.This –master-data option will turn –lock-all-tables on, unless <strong>–single-transaction</strong> is specified too.Before <strong>MariaDB 5.3</strong> this would tabke a global read lock for a short time at the beginning of the dump –see <strong>Enhancements for start transaction with consistent snapshot</strong> and  the <strong>–single-transaction *<em>option below. In all cases,any action on logs will happen at the exact moment of the dump. This option automatically turns *</em>–lock-tables</strong> off</p><p>In all cases,any action on logs happens at the exact moment of the dump.</p><p>it is also possible to set up a slave by dumping an existing slave of the master.To do this,use the following procedure on the existing slave:</p><p>1.Stop the slave’s SQL thread and get its current status:<br>mysql&gt; STOP SLAVE SQL_THREAD;<br>mysql&gt; SHOW SLAVE STATUS;</p><p>2.From the output of the SHOW SLAVE STATUS statement,the binary log coordinates of the master server from which the new slave should start replicating are the values of the Relay_Master_Log_File and Exec_Master_Log_Pos fields.Denote those values as file_name and file_pos.</p><p>3 Restart the slave:<br>mysql&gt; START SLAVE;</p><p>4 On the new slave,load the dump file:<br>shell&gt;mysql&lt;dumpfile</p><p>5 On the new slave,set the replication coordinates to those of the master server obtained earlier:<br>mysql&gt; CHANGE MASTER TO MASTER_LOG_FILE = ‘file_name’, MASTER_LOG_POS = file_pos;<br>The *<em>CHANGE MASTER *</em> TO statement might also need other parameters,such as MASTER_HOST to point the slave to the correct master server host.Add any such parameters necessary.</p><p><strong>-F, –flush-logs:</strong><br>Flush the MariaDB server log files before starting the dump.This option requires the RELOAD privilege.If you use this option in combination with the –databases= or –all-databases option,the logs are flushed for each database dumped.The exception is when using <strong>–lock-all-tables</strong> or <strong>–master-data</strong> In this case,the logs are flushed only once,corresponding to the moment all tables are locked. If you want your dump and the log flush to happen at the same exact moment,you should use <strong>–flush-logs</strong> together with either <strong>–lock-all-tables</strong> or <strong>–master-data</strong>.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysqldump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gevent简明教程</title>
      <link href="/2018/08/01/python-gevent%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2018/08/01/python-gevent%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://softlns.github.io/2015/11/28/python-gevent/" target="_blank" rel="noopener">转载于：</a></p><h2 id="进程-线程-协程-异步"><a href="#进程-线程-协程-异步" class="headerlink" title="进程 线程 协程 异步"></a>进程 线程 协程 异步</h2><p>并发编程(不是并行)目前有四种方式：多进程、多线程、协程、和异步</p><blockquote><ul><li>多进程编程在python中有类似C的os.fork，更高层封装的有multiprocessing标准库</li><li>多线程编程python中有Thread和threading</li><li>异步编程在linux下主要有三种实现select、poll、epoll</li><li>协程在python中通常会说得yield，关于协程的库主要有greenlet,stackless,eventlet等实现</li></ul></blockquote><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><ul><li>不共享任何状态</li><li>调度由操作系统完成</li><li>有独立的内存空间(上下文切换的时候需要保存栈、cpu寄存器、虚拟内存、以及打开的相关句柄等信息，开销大)</li><li>通讯主要通过信号传递的方式来实现(实现方式有多种，信号量、管道、事件等，通讯都需要过内核，效率低)</li></ul></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote><ul><li>共享变量(解决了通讯麻烦的问题，但是对于变量的访问需要加锁)</li><li>调度由操作系统完成(由于共享内存，上下文切换变得高效)</li><li>一个进程可以有多个线程，每个线程会共享父进程的资源(创建线程开销占用比进程小很多，可创建的数量也会很多)</li><li>通讯除了可使用进程间通讯的方式，还可以通过共享内存的方式进行通信(通过共享内存通信比通过内核要快很多)</li></ul></blockquote><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><blockquote><ul><li>调度完全由用户控制</li><li>一个线程(进程)可以有多个协程</li><li>每个线程(进程)循环按照指定的任务清单顺序完成不同的任务(当任务被堵塞时，执行下一个任务;当恢复时，再回来执行这个任务;任务间切换只需要保存任务的上下文，没有内核的开销，可以不加锁的访问全局变量)</li><li>协程需要保证是非堵塞的且没有相互依赖</li><li>协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高</li></ul></blockquote><p>总结</p><blockquote><ul><li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度</li><li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)</li><li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度</li></ul></blockquote><p>聊聊协程<br>协程，又称线程，纤程<br>Python的线程并不是标准线程，是系统级进程，线程间上下文切换有开销，而且Python在执行多线程时默认加了一个全局解释器锁(GIL),因此Python的多线程其实是串行的，所以并不能利用多核的优势，也就是说一个进程内的多个线程只能使用一个CPU。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">coroutine</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">ret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        f <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> f    <span class="token keyword">return</span> ret@coroutine<span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">"Wait to getting a task"</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">yield</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">"Got %s"</span><span class="token punctuation">,</span>n<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> consumer<span class="token punctuation">(</span><span class="token punctuation">)</span>    task_id <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">print</span> <span class="token string">"Send a task to consumer"</span> <span class="token operator">%</span> task_id        c<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"task %s"</span> <span class="token operator">%</span> task_id<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    producer<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Wait to getting a task<br>Send a task 0 to consumer<br>Got task 0<br>Send a task 1 to consumer<br>Got task 1<br>Send a task 2 to consumer<br>Got task 2</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待,但是容易死锁<br>如果改用协程，生成者生成消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高</p><p>Gevent<br>介绍<br>gevent是基于协程的Python网络库。特点：</p><blockquote><ul><li>基于libev的快速事件循环(Linux上epoll，FreeBSD上kqueue)</li><li>基于greenlet的轻量级执行单元</li><li>API的概念和Python标准库一致(如事件，队列)</li><li>可以配合socket,ssl模块使用</li><li>能够使用标准库和第三方模块创建标准的阻塞套接字(gevent.monkey)</li><li>默认通过线程池进行DNS查询，也可通过c-are(通过GEVENT_RESOLVER=ares环境变量开启)</li><li>TCP/UDP/HTTP服务器</li><li>子进程支持(通过gevent.subprocess)</li><li>线程池</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gevent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yield关键字</title>
      <link href="/2018/07/31/python-yield/"/>
      <url>/2018/07/31/python-yield/</url>
      
        <content type="html"><![CDATA[<p>[转载于：]{<a href="https://liam0205.me/2017/06/30/understanding-yield-in-python/}" target="_blank" rel="noopener">https://liam0205.me/2017/06/30/understanding-yield-in-python/}</a><br>yield关键字，及其相关的概念</p><h2 id="迭代、可迭代、迭代器"><a href="#迭代、可迭代、迭代器" class="headerlink" title="迭代、可迭代、迭代器"></a>迭代、可迭代、迭代器</h2><h2 id="迭代-iteration-与可迭代-iterable"><a href="#迭代-iteration-与可迭代-iterable" class="headerlink" title="迭代(iteration)与可迭代(iterable)"></a>迭代(iteration)与可迭代(iterable)</h2><p>迭代是一种操作;可迭代是对象的一种特性<br>很多数据对象都是<code>容器</code>;它们包含了很多其它类型的元素，实际使用容器时，我们常常需要逐个获取其中的元素<br>逐个获取元素的过程，就是[迭代]</p><pre class=" language-python"><code class="language-python">a_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a_list<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><a id="more"></a><p>如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是<code>可迭代的</code><br>Python中的顺序类型，都是可迭代的(<code>list</code>,<code>tuple</code>,<code>string</code>),其余包括<code>dict</code>,<code>set</code>,<code>file</code>也是可迭代的，对于用户自己实现的类型，如果提供了<strong>iter</strong>()或者<strong>getitem</strong>()方法，那么该类的对象也是可迭代的</p><p>迭代器(iterator)<br>迭代器是一种对象<br>迭代器抽象的是一个[数据流]，是只允许迭代一次的对象，对迭代器不断调用next()方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用<code>next()</code>方法会抛出StopIteration异常，迭代器的<strong>iter</strong>()方法返回迭代器自身；因此迭代器也是可迭代的</p><h2 id="迭代器协议-iterator-protocol"><a href="#迭代器协议-iterator-protocol" class="headerlink" title="迭代器协议(iterator protocol)"></a>迭代器协议(iterator protocol)</h2><p>迭代器协议指的是容器类需要包含一个特殊方法<br>如果一个容器类提供了<strong>iter</strong>()方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议<br>Python中的迭代器和Python中的<code>for</code>循环是紧密相连的</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> someting<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre><p>Python 处理 <code>for</code>循环时，首先会调用内建函数<code>iter(someting)</code>,它实际上会调用<code>something.__iter__()</code>,返回<code>something</code>对应的迭代器。而后，<code>for</code>循环会调用内建函数<code>next()</code>,作用在迭代器上，获取迭代器的下一个元素，并赋值给x。此后，Python才开始执行循环体。</p><h2 id="生成器、yield表达式"><a href="#生成器、yield表达式" class="headerlink" title="生成器、yield表达式"></a>生成器、yield表达式</h2><p>生成器函数(generator function)和生成器(generator)<br>** 如果一个函数包含yield表达式，那么它是一个生成器函数，调用它会返回一个特殊的迭代器，称为生成器。**</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token keyword">def</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>gen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>如上，生成器<code>gen</code>看起来和普通的函数没有太大区别。仅只是将<code>return</code>换成了<code>yield</code>。用<code>type()</code>函数打印二者的类型区别也能发现，<code>func</code>和<code>gen</code>都是函数。然而，二者的返回值类型就不同了。<code>func()</code>是一个<code>int</code>类型的对象;而<code>gen()</code>则是一个迭代器对象。</p><p>与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器(generator-iterator)。当返回生成器调用成员方法时，相应的生成器函数中的代码才会执行。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> x <span class="token operator">**</span> <span class="token number">2</span>square_gen <span class="token operator">=</span> square<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>square_gen<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>square_gen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>square_gen<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>square_gen<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> x <span class="token keyword">in</span> square_gen<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre><p>前面说到，<code>for</code>循环会调用<code>iter()</code>函数，获取一个生成器;而后调用<code>next()</code>函数，将生成器中的下一个值赋值给<code>x</code>;再执行循环体。因此，上述<code>for</code>循环基本等价于：</p><pre class=" language-python"><code class="language-python">geniter <span class="token operator">=</span> square_gen<span class="token punctuation">.</span>__iter__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> geniter<span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#Python3是__next__()</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre><p>注意到，<code>square</code>是一个生成器函数;作为它的返回值，<code>square_gen</code> 已经是一个迭代器;迭代器的<strong>iter</strong>()返回它自己。因此<code>geniter</code>对应的生成器函数，即是<code>square</code>.<br>每次执行到<code>x = geniter.next()</code>时，<code>square</code>函数会从上一次暂停的位置开始，一直执行到下一个<code>yield</code>表达式，将<code>yield</code>关键字后的表达式列表返回给调用者，并再次暂停。注意，** 每次暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致 **</p><h2 id="生成器的方法"><a href="#生成器的方法" class="headerlink" title="生成器的方法"></a>生成器的方法</h2><p>生成器有一些方法。调用这些方法可以控制对应的生成器函数，不过，若是生成器函数已在执行过程中，调用这些方法则会抛出<code>ValueError</code>异常。</p><blockquote><ul><li>从上一次在<code>yield</code>表达式暂停的状态恢复，继续执行到下一次遇见<code>yield</code>表达式。当该方法被调用时，当前<code>yield</code>表达式的值为<code>None</code>,下一个<code>yield</code>表达式中的表达式列表会被返回给该方法的调用者。若没有遇到<code>yield</code>表达式，生成器函数就已经退出了，那么该方法会抛出StopIterator异常</li><li>generator.send(value)和generator.next()类似，差别仅在与它会将当前<code>yield</code>表达式的值设置为<code>value</code>。</li><li>generator.throw(type[, value[, traceback[]]]):向生成器函数抛出一个类型type值为<code>value</code>调用栈为<code>traceback</code>的异常，而后让生成器函数继续执行到下一个<code>yield</code>表达式。其余行为与<code>generator.next()</code>类似.</li><li>generator.close():告诉生成器函数，当前生成器作废不再使用。</li></ul></blockquote><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>如果你还是不太能理解生成器函数，那么大致上你可以这样去理解</p><blockquote><ul><li>在函数开始处，加入<code>result = list()</code>;</li><li>将每个<code>yield</code>表达式<code>yield expr</code>替换为<code>result.append(expr)</code></li><li>在函数末尾处，加入<code>return result</code></li></ul></blockquote><h2 id="关于-下一个-yield表达式"><a href="#关于-下一个-yield表达式" class="headerlink" title="关于[下一个]yield表达式"></a>关于[下一个]<code>yield</code>表达式</h2><p>介绍[生成器的方法]时，我们说当调用<code>generator.next()</code>时，生成器函数会从当前位置开始执行到下一个<code>yield</code>表达式。这里的[下一个]指的是执行逻辑的下一个，因此</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f123</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">yield</span> <span class="token number">1</span>    <span class="token keyword">yield</span> <span class="token number">2</span>    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token keyword">for</span> item <span class="token keyword">in</span> f123<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">f13</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">yield</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token boolean">False</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> <span class="token number">2</span>    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token keyword">for</span> item <span class="token keyword">in</span> f13<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span></code></pre><p>使用<code>send()</code>方法与生成器函数通信</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> x<span class="token punctuation">)</span>        x <span class="token operator">+=</span> ygeniter <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>geniter<span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span>geniter<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>geniter<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><p>此处，生成器函数<code>func</code>用<code>yield</code>表达式，将处理好的<code>x</code>发送给生成器调用者;与此同时，生成器的调用者通过<code>send</code>函数，将外部信息作为生成器函数内部的<code>yield</code>表达式的值，保存在<code>y</code>当中，并参与后续的处理</p><p><code>yield</code>的好处<br>Python的老用户应该会熟悉Python2中的一个特性：内建函数<code>range</code>和<code>xrange</code>,其中，<code>range</code>函数返回的是一个列表；而<code>xrange</code>返回的是一个迭代器.</p><blockquote><ul><li>在Python3中，<code>range</code>相当于Python2中的<code>xrange</code>;而Python2中的<code>range</code>可以用<code>list(range())</code>来实现。</li></ul></blockquote><p>现在假设，我们有一个函数，其产出(返回值)是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用<code>yield</code>把函数变成一个生成器函数，每次只生成一个元素，就不能节省很多开销了。</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mha原理</title>
      <link href="/2018/07/11/mha%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/11/mha%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.kancloud.cn/devops-centos/centos-linux-devops/385181" target="_blank" rel="noopener">转载至：</a><br>MHA原理：<br>MHA(Master High Availability)目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本人youshimaton开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到0~30秒之内自动完成数据的故障切换操作，并且在进行故障切换的过程中，MHA能最大程度上保证数据库的一致性，以达到真正意义上的高可用。MHA由两部分组成：MHA Manager(管理节点)和MHA Node(数据节点). MHA Manager可以独立部署在一台独立的机器上管理多个Master-Slave集群，也可以部署在一台Slave上，当Master出现故障时，它可以自动将最新数据的slave提升为Master,然后将所有其它的Slave重新指向新的Master，整个故障转移对应用程序完全透明的。</p><p>在MHA自动故障切换的过程中，MHA试图从宕掉的主服务器上保存二进制日志，最大程度保证数据的不丢失，但这并不总是可行的。<br>例如:如果主服务器硬件故障或无法通过SSH访问，MHA没有办法保存二进制日志，只能进行故障转移而丢失了最新数据。mysql服务挂了，但是可以从服务器拷贝二进制。但如果硬件宕机或者SSH不能连接，不能获取到最新阿binlog日志，如果复制出现延迟，会丢失数据。<br>使用MySQL5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以和半同步复制结合起来，如果只有一个Slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其它所有Slave服务器上，保持数据一致性。<br>最新版0.56版本，增加了支持GTID的功能，建议在MySQL5.6及之后版本使用。MySQL5.5建议使用管理节点版本0.55，数据节点0.54</p><p>适用场景<br>目前MHA主要支持一主多从的架构，要搭建MHA，要求一个复制集群必须最少有3台数据库服务器，一主二从，即一台充当Master,一台充当备用Master,另一个台充当从库。出于成本考虑，淘宝在此基础上进行了改造，目前淘宝开发的TMHA已经支持一主一从。</p><p>MHA工作原理<br>1.从宕机崩溃的Master保存二进制日志事件(binlog event)。<br>2.识别含有最新更新的Slave.<br>3.应用差异的中继日志(relay log)到其它Slave.<br>4.应用从Master保存的二进制日志事件<br>5.提升一个Slave为新的Master<br>6.使其它的Slave连接新的Master进行复制<br>MHA的组成：</p><ol><li>Manager工具包情况如下:<blockquote><ul><li>masterha_check_ssh：检查MHA的SSH配置情况。</li><li>masterha_check_repl:检查MySQL复制情况。</li><li>masterha_manager；启动MHA</li><li>masterha_check_status:检测当前MHA运行状态</li><li>masterha_master_monitor:检测Master是否宕机</li><li>masterha_master_switch:控制故障转移(自动或手动)</li><li>masterha_conf_host:添加或删除配置的server信息</li></ul></blockquote></li></ol><p>2.Node工具包(通常由MHA Manager的脚本触发，无需人工操作)情况如下：</p><blockquote><ul><li>save_binary_log：保存和复制Master的binlog日志</li><li>apply_diff_relay_logs:识别差异的中级日志时间并将其应用到其它Slave.</li><li>filter_mysqlbinlog:去除不必要的ROOLBACK事件(已经废弃)</li><li>purge_relay_logs:清楚中继日志(不阻塞SQL线程)</li></ul></blockquote><p>重：为了尽可能的减少因为主库硬件损坏宕机造成的数据丢失，因此在配置MHA的同时建议必须配置MySQL5.5半同步复制。<br>拓展思想：为了保证数据一致性，MySQL复制中，常常会在Master上使用sync_binlog参数保证binlog持久化，保证数据一致性。但这种方式对磁盘I/O会造成10-20%的影响，但是还有另外一个思路，就是使用MySQL半同步复制来保证数据一致性，MySQL半同步复制是在从服务器的内存中处理数据并进行发聩，虽然也会造成性能影响，但是相对于Master造成的磁盘I/O的影响来说，反而是个更好的方法，据&lt;高性能MySQL&gt;第三版中10.9的测试，写入远程的内存(一台从库的反馈)比写入本地的磁盘(写入并刷新)要更快，使用半同步复制相比在主库上进行强持久化的性能有两倍的改善.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> master high availability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>master-slave0</title>
      <link href="/2018/07/11/master-slave0/"/>
      <url>/2018/07/11/master-slave0/</url>
      
        <content type="html"><![CDATA[<p>搭建一主两从的mysql5.7.22数据库架构(阿里云ECS云主机centos7.3系统)</p><p>192.168.1.102  DB1  master    写入，数据节点<br>192.168.1.103  DB2  slave1    读，数据节点<br>192.168.1.104  DB3  slave2    读，数据节点</p><p>三个数据库服务器上都关闭selinux,编辑/etc/selinux/config文件，使SELINUX=disabled,<br>阿里云的ECS云主机默认selinux和防火墙firewall已经设置了关闭。</p><a id="more"></a><p>设置主机名：</p><pre class=" language-bash"><code class="language-bash">登录192.168.1.102上：hostnamectl set-hostname DB01登录192.168.1.103上：hostnamectl set-hostname DB02登录192.168.1.104上：hostnamectl set-hostname DB03编辑三个主机的/etc/hosts文件<span class="token function">cat</span> <span class="token operator">>></span>/etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF192.168.1.102 DB01192.168.1.103 DB02192.168.1.104 DB03EOF</span></code></pre><p>设置三台机器相互之间的免密钥登录<br>登录到DB1上：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsassh-copy-id DB01ssh-copy-id DB02ssh-copy-id DB03登录到DB2上：ssh-keygen -t rsassh-copy-id DB01ssh-copy-id DB02ssh-copy-id DB03登录到DB3上：ssh-keygen -t rsassh-copy-id DB01ssh-copy-id DB02ssh-copy-id DB03</code></pre><p>同时连上DB01、DB02、DB03<br>安装前准备：<br>卸载centos7系统自带的mariadb,由于我们需要指定mysql数据库的数据存放目录，故不采用yum安装的方法。</p><pre class=" language-bash"><code class="language-bash">rpm -qa <span class="token operator">|</span><span class="token function">grep</span> mariadbrpm -e --nodeps mariadb-libs-5.5.52-1.el7.x86_64<span class="token comment" spellcheck="true"># 删除etc目录下数据库的配置文件my.cnf</span><span class="token function">rm</span> /etc/my.cnf</code></pre><p>检查mysql是否存在</p><pre class=" language-bash"><code class="language-bash">rpm -qa <span class="token operator">|</span><span class="token function">grep</span> mysql<span class="token function">cat</span> /etc/group  <span class="token operator">|</span><span class="token function">grep</span> mysql<span class="token function">cat</span> /etc/passwd <span class="token operator">|</span><span class="token function">grep</span> mysql<span class="token comment" spellcheck="true"># 如果不存在，创建数据库用户mysql</span><span class="token function">groupadd</span> -g 1001 mysql  <span class="token comment" spellcheck="true">#-g:用于指定GID，默认为使用当前组大的GID+1</span><span class="token function">useradd</span> -m -u 1001 -g mysql mysql <span class="token comment" spellcheck="true">#-m:创建用户的家目录  -g GROUP:指定新用户的主组，-u UID:指定新用户的主组</span></code></pre><p>三台云主机都下载mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/<span class="token function">wget</span> https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz<span class="token function">tar</span> -zxf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz<span class="token function">mv</span> mysql-5.7.22-linux-glibc2.12-x86_64 mysql/<span class="token function">chown</span> -R mysql:mysql mysql/<span class="token function">cd</span> /home/mysql <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> data<span class="token function">chown</span> -R mysql:mysql mysql/<span class="token function">cd</span> /usr/local/mysqlbin/mysql_install_db   --user<span class="token operator">=</span>mysql --basedir<span class="token operator">=</span>/usr/local/mysql --datadir<span class="token operator">=</span>/home/mysql/data/<span class="token function">cp</span> ./support-files/mysql.server   /etc/init.d/mysqld<span class="token function">chmod</span> a+x /etc/init.d/mysqld/etc/init.d/mysqld start<span class="token function">netstat</span> -lntp <span class="token operator">|</span><span class="token function">grep</span> mysqld<span class="token function">cd</span> /etc/profile.d/<span class="token function">vi</span> mysql.sh<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/usr/local/mysql/bin<span class="token function">source</span> mysql.sh</code></pre><p>获取root的初始密码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /root/.mysql_secret</code></pre><p>登录修改root密码(内网一般%变为192.168.1.%)：</p><pre class=" language-bash"><code class="language-bash">mysql -uroot -pmysql<span class="token operator">>></span>ALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> identified by <span class="token string">'TANGshupei1!'</span><span class="token punctuation">;</span>mysql<span class="token operator">>></span>GRANT ALL PRIVILEGES ON *.* TO <span class="token string">'root'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'TANGshupei1!'</span> WITH GRANT OPTION<span class="token punctuation">;</span>mysql<span class="token operator">>></span>FLUSH PRIVILEGES<span class="token punctuation">;</span>mysql<span class="token operator">>></span>exit<span class="token function">killall</span> mysqld/etc/init.d/mysqld restart<span class="token comment" spellcheck="true">#设置开机自启动</span><span class="token function">chkconfig</span> --add mysqld<span class="token function">chkconfig</span> --level 35 mysqld on<span class="token function">chkconfig</span> --list mysqld<span class="token function">service</span> mysqld status</code></pre><p>主从配置<br>登录DB01主库<br>mysql -uroot -p</p><p>创建replication用户并设置密码为replication</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>CREATE USER replication IDENTIFIED BY <span class="token string">'replication'</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>GRANT REPLICATION SLAVE ON *.* TO <span class="token string">'replication'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'replication'</span> <span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>exit</code></pre><p>修改DB01的/etc/my.cnf配置文件<br>对DB01 DB02 DB03的/etc/my.cnf配置文件进行修改<br>DB01 Master</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[mysql]default-character-set=utf8 [mysqld]server-id=001user=mysqlport = 3306 basedir=/usr/local/mysqldatadir=/home/mysql/data# Logsetting# relay-log=DB01-relay-bin# relay-log-index=DB01-relay-bin.index# read_only=1log-bin=mysql-bin   binlog-ignore-db=mysql sync_binlog = 1    max_binlog_size=1024Mmax_binlog_cache_size=4096Mbinlog_stmt_cache_size=1Mbinlog_checksum = none binlog_format = mixedbinlog_cache_size=4Mexpire_logs_days=30relay_log_purge=0skip-name-resolve# InnoDBSettinginnodb_buffer_pool_size=16384Minnodb_log_file_size=512Minnodb_log_buffer_size=16Minnodb_log_files_in_group=3innodb_flush_log_at_trx_commit=1innodb_stats_on_metadata=OFFinnodb_flush_method=O_DIRECTtable_open_cache=4096sort_buffer_size=2M# 允许最大连接数max_connections=800# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB lower_case_table_names=1max_allowed_packet=16MEOF</span></code></pre><p>重启DB01数据库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld restart<span class="token comment" spellcheck="true">#登录数据库查询master_log_file和master_log_position</span>mysql -uroot -ppassword:********<span class="token punctuation">(</span>root@192.168.1.102:3306<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">></span>show master status\G<span class="token punctuation">;</span>*************************** 1. row ***************************             File: mysql-bin.000004         Position: 1631     Binlog_Do_DB:  Binlog_Ignore_DB: Executed_Gtid_Set: 1 row <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.01 sec<span class="token punctuation">)</span>ERROR: No query specified</code></pre><p>记录下来：File文件名和Position的位置</p><p>配置DB02从库<br>修改/etc/my.cnf文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[mysql]default-character-set=utf8 [mysqld]server-id=002user=mysqlport = 3306 basedir=/usr/local/mysqldatadir=/home/mysql/data# Logsettingrelay-log=DB02-relay-binrelay-log-index=DB02-relay-bin.index#read_only=1log-bin=mysql-bin   binlog-ignore-db=mysql sync_binlog = 1    max_binlog_size=1024Mmax_binlog_cache_size=4096Mbinlog_stmt_cache_size=1Mbinlog_checksum = none binlog_format = mixedbinlog_cache_size=4Mexpire_logs_days=30relay_log_purge=0skip-name-resolve# InnoDBSettinginnodb_buffer_pool_size=16384Minnodb_log_file_size=512Minnodb_log_buffer_size=16Minnodb_log_files_in_group=3innodb_flush_log_at_trx_commit=1innodb_stats_on_metadata=OFFinnodb_flush_method=O_DIRECTtable_open_cache=4096sort_buffer_size=2M# 允许最大连接数max_connections=800# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB lower_case_table_names=1max_allowed_packet=16MEOF</span></code></pre><p>重启MySQL<br>service mysqld restart </p><p>登录DB02数据库</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>CHANGE MASTER TO master_host<span class="token operator">=</span><span class="token string">'192.168.1.102'</span>,master_port<span class="token operator">=</span>3306,master_user<span class="token operator">=</span><span class="token string">'replication'</span>,master_password<span class="token operator">=</span><span class="token string">'replication'</span>,master_log_file<span class="token operator">=</span><span class="token string">'mysql-bin.000004'</span>,master_log_pos<span class="token operator">=</span>1631<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>START SLAVE<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>SHOW SLAVE STATUS\G<span class="token punctuation">;</span></code></pre><p>配置DB03从库<br>修改/etc/my.cnf文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[mysql]default-character-set=utf8 [mysqld]server-id=003user=mysqlport = 3306 basedir=/usr/local/mysqldatadir=/home/mysql/data# Logsettingrelay-log=DB03-relay-binrelay-log-index=DB03-relay-bin.index#read_only=1log-bin=mysql-bin   binlog-ignore-db=mysql sync_binlog = 1    max_binlog_size=1024Mmax_binlog_cache_size=4096Mbinlog_stmt_cache_size=1Mbinlog_checksum = none binlog_format = mixedbinlog_cache_size=4Mexpire_logs_days=30relay_log_purge=0skip-name-resolve# InnoDBSettinginnodb_buffer_pool_size=16384Minnodb_log_file_size=512Minnodb_log_buffer_size=16Minnodb_log_files_in_group=3innodb_flush_log_at_trx_commit=1innodb_stats_on_metadata=OFFinnodb_flush_method=O_DIRECTtable_open_cache=4096sort_buffer_size=2M# 允许最大连接数max_connections=800# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB lower_case_table_names=1max_allowed_packet=16MEOF</span></code></pre><p>重启MySQL</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld restart </code></pre><p>登录DB03数据库</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>CHANGE MASTER TO master_host<span class="token operator">=</span><span class="token string">'192.168.1.102'</span>,master_port<span class="token operator">=</span>3306,master_user<span class="token operator">=</span><span class="token string">'replication'</span>,master_password<span class="token operator">=</span><span class="token string">'replication'</span>,master_log_file<span class="token operator">=</span><span class="token string">'mysql-bin.000002'</span>,master_log_pos<span class="token operator">=</span>2247<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>START SLAVE<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>SHOW SLAVE STATUS\G<span class="token punctuation">;</span></code></pre><p>补充：–master-data 和–single-transaction 在mysqldump中使用–master-data=2，会记录binlog文件和position的信息 。–single-transaction会将隔离级别设置成repeatable-commited</p><p>mysqldump -uroot -pTANGshupei1! –master-data=2 –single-transaction -R –triggers test_db1 &gt; test_db1.sql</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL一主两从配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>master-slave1</title>
      <link href="/2018/07/11/master-slave1/"/>
      <url>/2018/07/11/master-slave1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000008942618#articleHeader5" target="_blank" rel="noopener">转载至：</a></p><h2 id="MySQL主从复制及配置实现"><a href="#MySQL主从复制及配置实现" class="headerlink" title="MySQL主从复制及配置实现"></a>MySQL主从复制及配置实现</h2><h3 id="一-什么是MySQL主从复制"><a href="#一-什么是MySQL主从复制" class="headerlink" title="一 什么是MySQL主从复制"></a>一 什么是MySQL主从复制</h3><p>MySQL主从复制是其最重要的功能之一，主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器中。对于多级复制，数据库服务器即可充当主机，也可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。</p><h3 id="二-MySQL主从复制的类型"><a href="#二-MySQL主从复制的类型" class="headerlink" title="二 MySQL主从复制的类型"></a>二 MySQL主从复制的类型</h3><p>1 基于语句的复制<br>主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。<br>存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。。<br>2 基于行的复制<br>把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。<br>存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，因此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。<br>3 混合类型的复制：<br>MySQL默认使用基于语句的复制，当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择。<br>在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话(多台从服务器还要从主服务器上面同步数据)，单主模型的复制中主服务器势必会成为性能瓶颈。</p><a id="more"></a><h3 id="三-MySQL主从复制工作原理"><a href="#三-MySQL主从复制工作原理" class="headerlink" title="三 MySQL主从复制工作原理"></a>三 MySQL主从复制工作原理</h3><p>主服务器上面的任何修改都会保存在二进制日志Binary log里面，从服务器上面启动一个I/O thread (实际上就是一个主服务器的客户端进程)，连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log里面。从服务器上面开启一个SQL thread定时检查Realy log,如果发现有更改立即把更改的内容在本机上面执行一遍。</p><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。工作原理图如下：</p><p>实际上在老版本的MySQL主从复制中Slave端并不是两个进程完成的，而是由一个进程完成，但是后来发现这样做存在较大的风险和性能问题，主要如下：</p><p>首先，一个进程会使复制bin-log日志和解析日志并在自身执行的过程成为一个串行的过程，性能受到了一定的限制，异步复制的延迟也会比较长。另外，Slave端从Master端获取bin-log过来之后，需要接着解析日志内容，然后在自身执行，在这过程中，Master端可能又产生了大量变化并新增了大量的日志，如果在这阶段Master端的存储出现了无法修复的错误，那么在这个阶段所产生的所有变更都将永远无法找回，如果在Slave端的压力比较大的时候，这个过程的时间可能会比较长。<br>为了提高复制的性能并解决存在的风险，后面版本的MySQL将Slave端的复制动作交有两个进程完成，提出这个改进方案的人是Yahoo!的一位工程师”Jeremy Zawodny”。这样既解决了性能问题，又缩短了异步的延时时间，同时也减少了可能存在的数据丢失量。<br>当然，即使是换成了现在这样两个线程处理以后，同样也还是存在slave数据延时以及数据丢失的可能性的，毕竟这个复制是异步的，只要数据的更改不是在一个事务中，这些问题都是会存在的，如果要完全避免这些问题，就只能用MySQL的cluster来解决了。不过MySQL的cluster是内存数据库的解决方案，需要将所有数据都load到内存中，这样就对内存的要求就非常大了，对于一般的应用来说可实施性不是太大。<br>还有一点要提的是MySQL的复制过滤(Replication Filters),复制过滤可以让你只复制服务器中的一部分数据。有两种复制过滤，在master上过滤二进制日志中的事件，在slave上过滤中继日志中的事件。如下：</p><h3 id="四-MySQL主从复制的过程"><a href="#四-MySQL主从复制的过程" class="headerlink" title="四 MySQL主从复制的过程"></a>四 MySQL主从复制的过程</h3><p>MySQL主从复制的两种情况：同步复制和异步复制，实际复制架构中大部分为异步复制。<br>复制的基本过程如下：<br>1 Slave上面的IO进程连接上Master,并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容。<br>2 Master接收到来自Slave的IO进程的请求后，负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。<br>3 Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master’我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我’。<br>4 Slave的sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Mater端真实执行时候的那些可执行的内容，并在自身执行。</p><h3 id="五-MySQL主从复制的具体配置"><a href="#五-MySQL主从复制的具体配置" class="headerlink" title="五 MySQL主从复制的具体配置"></a>五 MySQL主从复制的具体配置</h3><p>复制通常用来创建主节点的副本，通过添加冗余节点来保证高可用性，当然复制也可以用于其他用途，例如在从节点上进行数据读、分析等等。在横向扩展的业务中，复制很容易实施，主要表现在利用主节点进行写操作，多个节点进行读操作，MySQL复制的异步是指：事务首先在主节点上提交，然后复制给从节点并在从节点上应用，这样意味着在同一个时间点主从上的数据可能不一致。异步复制的好处在于它比同步复制要快，如果对数据的一致性要求很高，还是采用同步复制较好。<br>最简单的复制模式就是一主一从的复制模式了，这样一个简单的架构只需要三个步骤即可完成：<br>(1) 建立一个主节点，开启binlog，设置服务器id;<br>(2) 建立一个从节点，设置服务器id;<br>(3) 将从节点连接到主节点上。</p><p>下面我们开始操作，以MySQL5.5为例，操作系统Ubuntu12.10,Master10.1.6.159 Slave 101.6.191</p><p>apt-get install mysql-server</p><p>Master机器<br>Master上面开启binlog日志，并且设置一个唯一的服务器id，在局域网内这个id必须唯一。二进制的binlog日志记录master上的所有数据库改变，这个日志会被复制到从节点上，并且在从节点上回放，修改my.cnf文件，在mysqld模块下修改如下内容：<br>[mysqld]<br>server-id = 1<br>log_bin = /var/log/mysql/mysql-bin.log</p><p>log_bin设置二进制日志所产生文件的基本名称，二进制日志由一些列文件组成，log_bin的值是可选项，如果没有为log_biin设置值，则默认值是：主机名-bin。如果随便修改主机名，则binlog日志的名称也会被改变的。server-id是用来唯一标识一个服务器的，每个服务器的server-id都不一样。这样slave连接到master后，会请求master将所有的binlog传递给它，然后将这些binlog在slave上回放，为了防止权限混乱，一般都是建立有一个单独用于复制的账户。<br>binlog是复制过程的关键，它记录了数据库的所有改变，通常即将执行完毕的语句会在binlog日志的末尾写入一条记录，binlog只记录改变数据库的语句，对于不改变数据库的语句则不进行记录。这种情况叫做基于语句的复制，前面提到过还有一种情况是基于行的复制，两种模式各有各的优缺点。</p><p>Slave机器<br>slave机器和master一样，需要一个唯一的server-id<br>[mysqld]<br>server-id = 2</p><p>连接Slave到Master,<br>在Master和Slave都配置好后，只需要把slave指向master,启动从库.</p><p>change master to master_host=’192.168.1.105’,master_port=3306,master_user=’replication’,master_password=’replication’;<br>start slave;</p><p>连接Slave到Master<br>接下来在master上做一些针对改变数据的操作，来观察slave的变化情况。在修改完my.cnf配置重启数据库后，就开始记录binlog了，可以在/var/log/mysql目录下看到一个mysql-bin.000001文件，而且还有一个mysql-bin.index文件，这个mysql-bin.index文件是什么？这个文件保存了所有的binlog文件列表，但是我们在配置文件中并没有设置该值，这个可以通过log_bin_index进行设置，如果没有设置该值，则默认值和log_bin一样。在master上执行show binlog events命令，可以看到第一个binlog文件的内容。<br>注意：上面的sql语句是从头开始复制第一个binlog，如果想从某个位置开始复制binlog，就需要在change master to时指定要开始的binlog文件名和语句在文件中的起点位置，参数如下：master_log_file和master_log_pos。</p><p>mysql&gt; show binlog events\G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>   Log_name: mysql-bin.000001<br>        Pos: 4<br> Event_type: Format_desc<br>  Server_id: 1<br>End_log_pos: 107<br>       Info: Server ver: 5.5.28-0ubuntu0.12.10.2-log, Binlog ver: 4<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>   Log_name: mysql-bin.000001<br>        Pos: 107<br> Event_type: Query<br>  Server_id: 1<br>End_log_pos: 181<br>       Info: create user rep<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 3. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>   Log_name: mysql-bin.000001<br>        Pos: 181<br> Event_type: Query<br>  Server_id: 1<br>End_log_pos: 316<br>       Info: grant replication slave on <em>.</em> to rep identified by ‘123456’<br>3 rows in set (0.00 sec)</p><blockquote><ul><li>Log_name是二进制日志文件的名称，一个事件不能横跨两个文件</li><li>Pos 这是该事件在文件中的开始位置</li><li>Event_type事件的类型，事件类型是给slave传递信息的基本方法，每个新的binlog都已Format_desc类型开始，以Rotate类型结束。</li><li>Server_id 创建该事件的服务器id</li><li>End_log_pos该事件的结束位置，也是下一个事件的开始位置，因此事件范围为Pos-End_log_pos-1</li><li>Info事件信息的可读文本，不同的事件有不同的信息</li></ul></blockquote><p>在master的test库中创建一个student表，并插入一条记录。<br>create table student(name var);<br>insert into rep values(‘guoguo’);<br>flush logs;</p><p>flush logs命令强制轮转日志，生成一个新的二进制日志，可以通过show binlog events in ‘xxx’ 来查看该二进制日志，可以通过show master status 查看当前正在写入的binlog文件，这样就会在slave上执行相应的改变操作。<br>上面就是最简单的主从复制模式，不过有时候随着时间的推进，binlog会变的非常庞大，如果新增加一台slave，从头开始复制master的binLog文件是非常耗时的，所以我们可以从一个指定的位置开始复制binlog日志，可以通过其它方法把以前的binLog文件进行复制，例如copy物理文件，在change master to 中有两个参数可以实现该功能，master_log_file和master_log_pos,通过这两个参数指定binlog文件及位置，我们可以从master复制也可以从slave上复制，假如从master上复制，具体操作如下：<br>(1) 为了防止在操作过程中数据更新，导致数据不一致，所以需要先刷新数据并锁定数据库:flush tables with read lock.</p><p>(2) 检查当前的binlog文件及其位置：show master status。</p><p>mysql&gt; show master status\G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>File: mysql-bin.000003<br>Position: 107<br>Binlog_Do_DB:<br>Binlog_Ignore_DB:<br>1 row in set (0.00 sec)</p><p>(3) 通过mysqldump命令创建数据库的逻辑备份：mysqldump –all-databases -hlocalhost -p &gt;back.sql.<br>(4) 有了master的逻辑备份后，对数据库进行解锁：unlock tables.<br>(5) 把back.sql复制到新的slave上，执行：mysql -hlocalhost -p把master的逻辑备份插入slave的数据库中。<br>(6) 现在可以把新的slave连接到master上了，只需要在change master to中多设置两个参数master_log_file=’mysql.bin.000003’和master_log_pos=’107’即可，然后启动slave:start slave,这样slave就可以接着107的位置进行复制了。</p><p>change master to master_host=’10.1.6.159’,master_port=3306,master_user=’rep’,master_password=’123456’,master_log_file=’mysql-bin.000003’,master_log_pos=’107’;<br>start slave;<br>有时候master并不能让你锁住表进行复制，因为可能跑一些不间断的服务，如果这时master已经有了一个slave，我们则可以通过这个slave进行再次扩展一个新的slave.原理在master上进行复制差不多，关键在于找到binlog的位置，你在复制的同时可能该slave也在和master进行同步，操作如下：<br>(1) 为了防止数据变动，还是需要停止slave的同步：stop slave.<br>(2) 然后刷新表，并用mysqldump逻辑备份数据库。<br>(3) 使用show slave status 查看slave的相关信息，记录下两个字段的值Relay_Master_Log_File和Exec_Master_Log_Pos，这个用来确定从后面哪里开始复制。<br>(4) 对slave解锁，把备份的逻辑库导入新的slave的数据库中，然后设置change master to,这一步和复制master 一样。</p><h3 id="六-深入了解MySQL主从配置"><a href="#六-深入了解MySQL主从配置" class="headerlink" title="六 深入了解MySQL主从配置"></a>六 深入了解MySQL主从配置</h3><p>1.一主多从<br>由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。在实际应用场景中，MySQL复制90%以上都是一个Master复制一个或者多个Slave的架构模式，主要用于读压力比较大的应用的数据库端廉价扩展解决方案。</p><p>在上图中，是我们开始时提到的一主多从的情况，这时主库既要负责写又要负责为几个从库提供二进制。这种情况将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从，或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。</p><p>2 主主复制<br>上图中，Master-Master复制的两台服务器，既是master,又是另一台服务器的slave，这样，任何一方所做的变更，都会通过复制应用到另一个方的数据库中。在这种复制架构中，各自上运行的不是同一个db，比如左边的是db1,右边是db2，db1的从在db2上，db2的从在db1上，两者互为主从，再辅助一些监控的服务还可以实现一定程度上的高可用。</p><p>2.1 主动-被动模式的Master-Master(Master-Master in Active-Passivee Mode)<br>上图中，这是由master-master结构变换而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用行的系统，它的不同的在于其中只有一个节点在提供读写服务，另外一个节点时刻准备着，当主节点一旦故障马上接替服务。比如通过corosync+pacemaker+drbd+MySQL就可以提供这样一组高可用服务，主备模式下再跟着slave服务器，主备模式下再跟着slave服务器，也可以实现读写分离。<br>2.2 带从服务器的Master-Master结构(Master-Master with Slaves)<br>这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。</p><p>MySQL-5.5支持半同步复制<br>早前的MySQL复制只能是基于异步来实现，从MySQL-5.5开始，支持半自动复制。在以前的异步(asynchronous)复制中，主库在执行完一些事务后，是不会管备库的进度的。如果备库处于落后，而更不幸的是主库此时又出现Crash(例如宕机)，这时备库中的数据就是不完整的。简而言之，在主库发生故障的时候，我们无法使用备库来继续提供数据一致的服务了，Semisynchronous中，仅仅保证事务的已经传递到备库上，但是并不确保已经在备库上执行完成了。<br>此外，还有一种情况会导致主备数据不一致。在某个session中，主库上提交一个事务后，会等待事务传递给至少一个备库，如果在这个等待过程中主库Crash,那么也可能备库和主库不一致，这是很致命的，如果主备网络故障或者备库挂了，主库在事务提交后等待10秒(rpl_semi_sync_master_timeout的默认值)后，就会继续，这时，主库就会变回原来的异步状态。</p><p>MySQL在加载并开启Semi-sync插件后，每一个事务需等待备库接收日志后才返回给客户端，如果做的是小事务，两台主机的延迟又较小，则Semi-sync可以实现在性能很小损失的情况下的零数据丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL主从原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>py编码</title>
      <link href="/2018/06/15/python-%E7%BC%96%E7%A0%81/"/>
      <url>/2018/06/15/python-%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="编码：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。-我的理解就是从人能看懂的到人看不懂的是编码，从人看不懂的到人能看懂的是解码"><a href="#编码：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。-我的理解就是从人能看懂的到人看不懂的是编码，从人看不懂的到人能看懂的是解码" class="headerlink" title="编码：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。(我的理解就是从人能看懂的到人看不懂的是编码，从人看不懂的到人能看懂的是解码)"></a>编码：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。(我的理解就是从人能看懂的到人看不懂的是编码，从人看不懂的到人能看懂的是解码)</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>计算机中的所有的数据，不论是文字、图片、视频、音频等文件，本质上都是按照010101的二进制存储的，计算机只懂得二进制数字。<br>因此我们如何能我们能识别的符号唯一的与一组二进制数字对应上呢，于是美利坚的朋友通过一个电平的高低状态来代指0或1，八个电平作为一组就可以表示出256种不同的状态，每种状态就唯一对应一个字符，比如A—-》00010001，而英文只有26个字符，算上一些特殊字符和数字，128哥状态就够了，每一个电平称为一个比特位，8个比特位构成一个字节，这样计算机就可以用127个不同字节来存储英语的文字了。这就是ASCII编码。</p><h3 id="扩展ANSII编码"><a href="#扩展ANSII编码" class="headerlink" title="扩展ANSII编码"></a>扩展ANSII编码</h3><p>刚才说了，最开始，一个字节有8位，最高位没有用上，默认为0，后来为了计算机可以表示拉丁文，就将最后一位也用上了，从128到255的字符集对应拉丁文啦，至此，一个字节就用满了</p><a id="more"></a><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>计算机来多中国后，问题出现了，计算机不认识中文，当然就没法显示中文，而且一个字节的所有状态都被占满了，为了表示中文，国人重写了一张表，直接把扩展的第8位对应的拉丁文全部删掉，规定一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节(高字节)从0xA1用到0xF7,后面一个字节(低字节)从0xA1到0xFE，这样我们就可以组合出大约7000多哥简体汉字了，这种汉字方案叫做”GB2312”. GB2312是对ASCII的中文扩展。</p><h3 id="GBK和GB18030编码"><a href="#GBK和GB18030编码" class="headerlink" title="GBK和GB18030编码"></a>GBK和GB18030编码</h3><p>但是汉字太多了，GB2312也不够用，于是规定：只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容，结果扩展之后的编码方案被称为GBK标准，GBK包括了GB2312的所有内容，同时又增加了近20000个新的汉字(包括繁体字)和符号。</p><h3 id="UNICODE编码"><a href="#UNICODE编码" class="headerlink" title="UNICODE编码"></a>UNICODE编码</h3><p>很多其它国家都搞出了自己的编码标准，彼此间却相互不支持，这就带来了很多问题，于是，国际标准化组织为了统一编码：提出了标准编码表<br>则：UNCODE<br>UNCODE是用两个字节表示为一个字符，它总共可以组合出65535个不同的字符，这足以覆盖世界上所有符号(包括甲骨文)</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>unicode都一统天下了，为什么还要有个utf-8的编码呢？<br>大家想，对于英文世界的人们来讲，一个字节就够了，比如要存储A，本来0100 0001就可以了，现在吃上了UNICODE的大锅饭，得用两个字节：00000000 01000001才行，浪费太严重了！基于此，美利坚的科学家提出了天才的想法：utf8,UTF-8(8-bit Unicode Transformation Format)是一种针对Unicode的可变长度字符编码，它可以使用1~4个字节表示一个符号，根据不同符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，所以是兼容ASCII编码的。<br>这样显著的好处是：虽然在我们内存中的数据都是unicode，但当数据要保存到磁盘或者用于网络传输时，直接使用unicode就远不如utf8省空间啦！这也是我们推荐使用utf8的编码方式。<br>UNICODE与utf8的关系：<br>一言以蔽之：Unicode是内存编码表示方案(是规范),而UTF8是如何保存和传输Unicode的方案(是实现)这也是UTF8与Unicode的区别</p><p>补充：utf8是如何节约硬盘和流量的<br>s=”I’m 唐书培” (python3默认的str是unicode的) 也就是说s=”I’m 唐书培” 与s=u”I’m 唐书培”是一样的<br>因此这些字符串对应unicode编码16进制 和二进制表示为如下：</p><pre class=" language-python"><code class="language-python">I  <span class="token number">0049</span>'  <span class="token number">0027</span>m  <span class="token number">006d</span>   <span class="token number">0020</span>唐 <span class="token number">5510</span>书 <span class="token number">4e66</span>培 <span class="token number">57f9</span>具体转换过程为：st <span class="token operator">=</span> u<span class="token string">'唐'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'unicode-escape'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span>b<span class="token string">'\\u5510'</span>st <span class="token operator">=</span> st<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span>\u5510st <span class="token operator">=</span> st<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>r<span class="token string">"\u"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token number">5510</span>计算机只懂得二进制，故上面字符对应的二进制表示为：I   <span class="token number">00000000</span> <span class="token number">01001001</span>'   <span class="token number">00000000</span> <span class="token number">00100111</span>m   <span class="token number">00000000</span> <span class="token number">01101101</span>    <span class="token number">00000000</span> <span class="token number">00100000</span>唐  <span class="token number">01010101</span> <span class="token number">00010000</span>书  <span class="token number">01001110</span> <span class="token number">01100110</span>培  <span class="token number">01010111</span> <span class="token number">11111001</span></code></pre><p>这个s字符串如果用unicode编码方式在计算机存储共总占用了14个字节，但是对比中英文的二进制码，可以发现，英文前9位都是0，存储浪费空间，传输浪费流量，怎么办，UTF8上场啦。。。</p><pre class=" language-bash"><code class="language-bash">I   01001001'   00100111m   01101101    00100000唐  11100101 10010100 10010000书  11100100 10111001 10100110培  11100101 10011111 10111001</code></pre><p>如果用utf8编码方式在计算机中存储共占用13个字节，比unicode少了一个，由于在编程程序中英文字符远多于中文支付，所以空间会省很多。。。</p><h2 id="二：python2的string编码"><a href="#二：python2的string编码" class="headerlink" title="二：python2的string编码"></a>二：python2的string编码</h2><p>在py2中，有两种字符串类型：str类型和unicode类型；注意，这仅仅是两个名字，python定义的两个名字，关键是这两种数据类型在程序运行时存储在内存地址的是什么？</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token string">'唐'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> repr<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token string">'\xe5\x94\x90'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> u<span class="token string">'唐'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span>u<span class="token string">'\u5510'</span></code></pre><p>内置函数repr可以帮我们在这里显示存储内容。原来，str和unicode分别存的是字节数据和unicode数据；那么两种数据之间是什么关系呢？如何转换呢?这里就涉及到编码(encode)和解码(decode)了</p><pre class=" language-python"><code class="language-python">Python <span class="token number">2.7</span><span class="token punctuation">.</span><span class="token number">7</span> <span class="token punctuation">(</span>default<span class="token punctuation">,</span> Apr  <span class="token number">3</span> <span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">05</span><span class="token punctuation">:</span><span class="token number">52</span><span class="token punctuation">:</span><span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>GCC <span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">7</span> <span class="token number">20120313</span> <span class="token punctuation">(</span>Red Hat <span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">]</span> on linux2Type <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> <span class="token operator">or</span> <span class="token string">"license"</span> <span class="token keyword">for</span> more informat<span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token string">'唐'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> repr<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token string">'\xe5\x94\x90'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> u<span class="token string">'唐'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>唐<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span>u<span class="token string">'\u5510'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> u<span class="token string">'唐'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span>u<span class="token string">'\u5510'</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> s1<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>唐<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">'\xe5\x94\x90'</span><span class="token operator">>></span><span class="token operator">></span>注意<span class="token punctuation">:</span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token string">'唐书培'</span> <span class="token punctuation">(</span>python2中汉字字符默认utf8编码<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> u <span class="token operator">=</span> s1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span> u唐书培<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span>u<span class="token string">'\u5510\u4e66\u57f9'</span><span class="token operator">>></span><span class="token operator">></span> u1 <span class="token operator">=</span> s1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'gbk'</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>UnicodeDecodeError<span class="token punctuation">:</span> <span class="token string">'gbk'</span> codec can't decode byte <span class="token number">0xb9</span> <span class="token keyword">in</span> position <span class="token number">8</span><span class="token punctuation">:</span> incomplete multibyte sequence</code></pre><p>无论是utf8还是gbk都只是一种编码规则，一种把unicode数据编码成字节数据的规则，所以utf8编码的字节一定要用utf8的规则解码，否则就会出现乱码或者报错的情况。</p><h2 id="三-python3的string编码"><a href="#三-python3的string编码" class="headerlink" title="三 python3的string编码"></a>三 python3的string编码</h2><p>python3 renamed the unicode type to str, the old str type has been replaced by bytes.<br>python3也有两种数据类型：str和bytes; str类型存unicode数据，bytse类型存bytes数据，与py2比只是换了一下名字而已。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'唐书培'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token string">"\u5510\u4e66\u57f9"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">"\u5510\u4e66\u57f9"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b<span class="token string">'\xe5\x94\x90\xe4\xb9\xa6\xe5\x9f\xb9'</span><span class="token operator">>></span><span class="token operator">></span> u <span class="token operator">=</span> b<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>唐书培<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token string">"\u5510\u4e66\u57f9"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">3</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span><span class="token string">'唐书培'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">3</span></code></pre><p>python3的编码哲学：<br>python3最重要的新特性大概算是对文本和二进制数据作了更为清晰的区分，不再会对bytes字节串进行自动解码。文本总是Unicode，由str类型表示，二进制数据则有bytes类型表示。python3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串(反之亦然)。</p><pre class=" language-python"><code class="language-python">Python <span class="token number">2.7</span><span class="token punctuation">.</span><span class="token number">7</span> <span class="token punctuation">(</span>default<span class="token punctuation">,</span> Apr  <span class="token number">3</span> <span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">05</span><span class="token punctuation">:</span><span class="token number">52</span><span class="token punctuation">:</span><span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>GCC <span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">7</span> <span class="token number">20120313</span> <span class="token punctuation">(</span>Red Hat <span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">]</span> on linux2Type <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> <span class="token operator">or</span> <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cntsp'</span><span class="token operator">+</span>u<span class="token string">'nihao'</span><span class="token punctuation">)</span>cntspnihao<span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token string">'cntsp'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> u<span class="token string">'cntsp'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>type <span class="token string">'unicode'</span><span class="token operator">></span>Python <span class="token number">3.5</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span>default<span class="token punctuation">,</span> Oct <span class="token number">30</span> <span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">:</span><span class="token number">56</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>GCC <span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">7</span> <span class="token number">20120313</span> <span class="token punctuation">(</span>Red Hat <span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">]</span> on linuxType <span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"copyright"</span><span class="token punctuation">,</span> <span class="token string">"credits"</span> <span class="token operator">or</span> <span class="token string">"license"</span> <span class="token keyword">for</span> more information<span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token string">'cntsp'</span><span class="token operator">+</span>u<span class="token string">'nihao'</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>TypeError<span class="token punctuation">:</span> can't concat bytes to str<span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token string">'nihao'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> u<span class="token string">'nihao'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span></code></pre><p>注意：无论py2,还是py3，与明文直接对应的就是unicode数据，打印unicode数据就会显示相应的明文(包括英文和中文)</p><h2 id="四-文件从磁盘到内存的编码"><a href="#四-文件从磁盘到内存的编码" class="headerlink" title="四 文件从磁盘到内存的编码"></a>四 文件从磁盘到内存的编码</h2><p>说到这，才来到我们的重点！</p><p>抛开执行程序，请问大家，文本编辑器大家都是用过的吧，如果不懂是什么，那么word总用过吧，ok,当我们在word上编辑文字的时候，不管是中文还是英文，计算机都是不认识的，那么在保存之前数据是通过什么形式存在内存的呢？yes，就是unicode数据，为什么要存unicode数据，因为它的名字最屌：万国码！解释起来就是无论地球上的哪一种语言，不管是英文、中文、德文、日文、拉丁文、甚至甲骨文，unicode都有唯一的编码对应，所以兼容性是最好的。<br>然而，当我们保存了数据从内存写入磁盘上时有时以何种编码方式以何种形式存在呢？<br>答案：是通过某种编码方式编码的bytes字节串存储在磁盘上的，编码方式比如：utf8  一种可变长编码，很好的节省了空间；当然还有历史产物的gbk编码等等，于是在我们的文本编辑器软件都有默认的保存文件的编码方式，比如utf8，比如gbk。当我们点击保存的时候，这些编辑软件已经默默地帮我们做了编码工作了，那当我们再打开这个文件时，软键又默默地给我们做了解码的工作，将数据在解码成unicode，然后就可以呈现明文给用户了，所以，unicode是离用户更近的数据，bytes是离计算机更近的数据。说了这么多，和我们程序执行有什么关系呢？<br>先明确一个概念：py解析器本身就是一个软件，一个类似于文本编辑器一样的软件！<br>现在让我们一起还原一个py文件从创建到执行的编码过程：<br>在pycharm中，创建一个hello.py文件，写入：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello世界你好！"</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token string">'hello世界你好！'</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>s1 <span class="token operator">=</span> s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>对应输出为：<span class="token operator">>></span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span>hello世界你好！<span class="token operator">>></span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span>b<span class="token string">'hello\xe4\xb8\x96\xe7\x95\x8c\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x81'</span></code></pre><p>当我们保存的时候，hello.py文件就以pycharm默认的编码方式保存到了磁盘;关闭文件后再打开，pycharm就再以默认的编码方式对该文件打开后读到的内容进行编码，转成unicode到内存我们就看到了我们的明文；<br>而如果我们点击运行按钮后者在命令行运行该文件时，py解释器这个软件就会被调用，打开文件，然后解码存在磁盘上的bytes数据成unicode数据，这个过程和编辑器是一样的，不同的是解释器会在将这些unicode数据翻译成C代码再转成二进制的数据流，最后通过控制操作系统调用cpu来执行这些二进制数据，整个过程才算结束。<br>那么问题来了，我们的文本编辑器有自己默认的编码解码方式，我们的解释器有吗？<br>这是肯定的，python2默认是ASCII码，python3默认的utf8，可以通过如下方式查询</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getdefaultencoding<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>大家还记得这个声明吗？<br>#-<em>-coding:utf8-</em>-</p><p>由于py2中解析器默认的编解码是ASCII，如果py2解释器去执行一个utf8编码的文件，就会以默认的解码方式ASCII去解码utf8，一旦程序中有中文，自然解码错误，所以我们在文件的开头位置声明，#-<em>-coding:utf8-</em>- ，其实就是告诉解释器，你不要以默认的编码方式去解码这个文件，要以这个文件原有的编码方式utf8来解码它，由于python3中解释器默认utf8编码，所以可以不用写这个声明。<br><img src="https://github.com/cntsp/cntsp.github.io/tree/master/images/py1.png" alt="python编码"></p><p><a href="http://www.cnblogs.com/yuanchenqi/articles/5956943.html" target="_blank" rel="noopener">py编码终极版</a></p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ASCII </tag>
            
            <tag> GB2312 </tag>
            
            <tag> UNICODE </tag>
            
            <tag> UTF8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-event</title>
      <link href="/2018/05/19/mysql-event/"/>
      <url>/2018/05/19/mysql-event/</url>
      
        <content type="html"><![CDATA[<p>Mysql定时任务&amp;存储过程<br>Mysql属于中小型数据库系统，它的事件调度器是在mysql5.1才开始引入的，事件调度器是在Mysql5.1中新增的另一个特色功能，可以作为定时任务调度器，取代部分原先只能用操作系统任务调度器(如linux的crontab)才能完成的定时功能。时间调度器是定时触发执行的，在这个角度上也可以称作”临时的触发器”。触发器只是针对某个表产生的事件执行一些语句，而事件调度器则是在某一个(间隔)时间执行一些语句。事件是由一个特定的线程来管理的，也就是所谓的”事件调度器”</p><p>查看开启调度器<br>查看event是否开启：SHOW VARIABLES LIKE ‘%event_sche%’;<br>将事件计划开启： SET GLOBAL event_scheduler = 1;<br>关闭事件任务： ALTER EVERNT e_test ON COMPLETION PRESERVE DISABLE;<br>开启事件任务： ALTER EVENT e_test ON COMPLETION PRESERVER ENABLE;<br>查看事件任务：SHOW EVENTS;</p><a id="more"></a><p>事件的优缺点<br>    1 一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。<br>    2 可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。<br>缺点：<br>    1 定时触发，不可以调用</p><p>创建事件<br>    一条create event 语句创建一个事件，每个事件由两部分组成，第一部分是事件调度(event schedule)，表示事件何时启动以及按什么频率启动，第二部分是事件动作(event action)，这是事件启动时执行的代码，事件的动作包含一条SQL语句，它可能是一个简单的INSERT 或者 update语句，也可以是一个存储过程或者benin..end语句块，这两种情况允许我们执行多条SQL。</p><pre><code>一个事件可以是活动(打开)的或停止(关闭)的，活动意味着事件调度器检查事件动作是否必须调用，停止意味着事件的声明存储在目录中，但调度器不会检查它是否应该调用。在一个事件创建之后，它立即变为活动的，一个活动的事件可以执行一次或者多次。</code></pre><p>创建语法如下：<br>CREATE<br>    [DEFINER = { user | CURRENT_USER}]<br>    EVENT<br>    [IF NOT EXISTS]<br>    event_name<br>    ON SCHEDULE schedule<br>    [ON COMPLETION [NOT] PRESERVER]<br>    [ENABLE | DISABLE |DISABLE ON SLAVE]<br>    [COMMENT ‘comment’]<br>    DO event_body;</p><p>schedule:<br>    AT timestamp [+ INTERVAL interval]…<br>    | EVERY interval<br>    [STARTS timestamp [+ INTERVAL interval]…]<br>    [ENDS timestamp [+ INTERVAL interval]…]<br>interval:<br>    quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK| SECOND |<br>    YEAR_MONTH| DAY_HOUR | DAY_MINUTE| DAY_SECOND|HOUR_MINUTE |HOUR_SECOND| MINUTE_SECOND}</p><p>名词解释：<br>    event_name:创建的event名字(唯一确定的)。<br>    ON SCHEDULE：计划任务<br>    schedule:决定event的执行时间和频率(注意时间一定要是将来的时间，过去的时间会出错)，有两种形式 AT 和 EVERY。<br>    [ON COMPLETION [NOT] PRESERVER]: 可选项，默认是ON COMPLETION NOT PRESERVER 即计划任务执行完毕后自动drop该事件；ON COMPLETION PRESERVER则不会drop掉。<br>    [COMMENT ‘comment’]:可选项，comment用来描述event；相当于注释：最大长度64个字节。<br>    [ENABLE | DISABLE]:设定event的状态，默认enable:表示系统尝试执行这个事件，DISABLE：关闭该事件，可以用alter修改。<br>    DO event_body:需要执行的sql语句(可以是复合语句)。CREATE EVENT在存储过程中使用时合法的。</p><p>开启关闭事件调度器：<br>MySQL事件调度器event_scheduler负责调用事件，它默认是关闭的。这个调度器不断地监视一个事件是否要调用，要创建事件，必须打开调度器。<br>mysql&gt; show variables like ‘%event_scheduler%’;</p><p>开启事件调度器：<br>可通过下面的任意一条命令来关闭事件调度器：<br>SET GLOBAL event_scheduler = OFF;<br>SET @@global.event_scheduler = OFF;<br>SET GLOBAL event_scheduler = 0;<br>SET @@global.evet_scheduler = 0;</p><p>通过配置文件my.cnf<br>在[mysqld]下增加<br>event_scheduler = 0 #或者OFF，DISABLED</p><p>查看调度器线程：<br>mysql&gt; show processlist;</p><p>创建事件2(每分钟启动事件)<br>create event test.event_minute<br>on schedule<br>every 1 minute<br>do insert into events_list values(‘event_now’, now());</p><p>查看事件执行结果<br>mysql&gt; select * from events_list;</p><p>注意：<br>默认创建事件存储在当前库中，也可显示指定事件创建在哪个库中<br>通过show events只能查看当前库中创建的事件<br>事件执行完即释放，如立即执行事件，执行完后，事件便自动删除，多次调用事件或等待执行事件可以看到。<br>如果两个事件需要在同一个时刻调用，mysql会确定调用他们的顺序，如果要指定顺序，需要确保一个事件至少在另一个事件1秒后执行。<br>对于递归调度的事件，结束日期不能在开始日期之前。<br>select可以包含在一个事件中，然而他的结果消失了，就好像没执行过。</p><p>查看事件<br>查看当前所在库的事件<br>mysql&gt; show events;</p><p>查看所有事件<br>mysql&gt;select * from mysql.event;</p><p>修改事件<br>一条alter event语句可以修改事件的定义和属性。我们可以让一个事件成为停止的或者再次让它活动，也可以修改一个事件的名字或者整个调度。然而当一个使用ON COMPLETION NOT COMPLETION NOT PRESERVER 属性定义的事件最后一次执行后，事件直接就不存在了，不能修改。<br>语法如下：<br>ALTER<br>    [DEFINER = { user | current_user}]<br>    EVENT event_name<br>    [ON SCHEDULE schedule]<br>    [ON COMPLETION [NOT] PERSERVER]<br>    [RENAME TO new_event_name]<br>    [ENABLE | DISABLE | DISABLE ON SLAVE]<br>    [COMMENT ‘comment’]<br>    [DO event_body]</p><p>例如：<br>修改上面例子3.3.3每分钟启动事件为每30秒启动<br>alter event test.event_minute<br>on schedule<br>every 30 second<br>do insert into events_list values(‘event_now’,now());</p><p>alter event test.event_minute<br>rename to test.event_second;</p><p>alter event test.event_second disable;<br>alter event test.event_second enable;</p><p>删除事件<br>如果一个事件不再需要，我们可以使用一条drop event语句删除它。使用这条语句我们不需要等到最后一次事件调用。</p><p>基本语法<br>drop event [IF EXISTS] event_name</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb-galera集群优缺点</title>
      <link href="/2018/05/19/mariadb-galera%E9%9B%86%E7%BE%A4%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2018/05/19/mariadb-galera%E9%9B%86%E7%BE%A4%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="MariaDB-Galera-Cluster集群优缺点"><a href="#MariaDB-Galera-Cluster集群优缺点" class="headerlink" title="MariaDB Galera Cluster集群优缺点"></a>MariaDB Galera Cluster集群优缺点</h2><p>MariaDB Galera Cluster 是一套在mysql innodb存储引擎上面实现multi-master及数据实时同步的系统架构，业务层面无需做读写分离工作，数据库读写压力都能按照既定的规则分发到 各个节点上去。在数据方面完全兼容 MariaDB 和 MySQL。</p><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p> (1).同步复制 Synchronous replication<br> (2).Active-active multi-master 拓扑逻辑<br> (3).可对集群中任一节点进行数据读写<br> (4).自动成员控制，故障节点自动从集群中移除<br> (5).自动节点加入<br> (6).真正并行的复制，基于行级<br> (7).直接客户端连接，原生的 MySQL 接口<br> (8).每个节点都包含完整的数据副本<br> (9).多台数据库中数据同步由 wsrep 接口实现</p><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><p> (1).目前的复制仅仅支持InnoDB存储引擎,任何写入其他引擎的表，包括mysql.*表将不会复制,但是DDL语句会被复制的,因此创建用户将会被复制,但是insert into mysql.user…将不会被复制的.<br> (2).DELETE操作不支持没有主键的表,没有主键的表在不同的节点顺序将不同,如果执行SELECT…LIMIT… 将出现不同的结果集.<br> (3).在多主环境下LOCK/UNLOCK TABLES不支持,以及锁函数GET_LOCK(), RELEASE_LOCK()…<br> (4).查询日志不能保存在表中。如果开启查询日志，只能保存到文件中。<br> (5).允许最大的事务大小由wsrep_max_ws_rows和wsrep_max_ws_size定义。任何大型操作将被拒绝。如大型的LOAD DATA操作。<br> (6).由于集群是乐观的并发控制，事务commit可能在该阶段中止。如果有两个事务向在集群中不同的节点向同一行写入并提交，失败的节点将中止。对 于集群级别的中止，集群返回死锁错误代码(Error: 1213 SQLSTATE: 40001 (ER_LOCK_DEADLOCK)).<br> (7).XA事务不支持，由于在提交上可能回滚。<br> (8).整个集群的写入吞吐量是由最弱的节点限制，如果有一个节点变得缓慢，那么整个集群将是缓慢的。为了稳定的高性能要求，所有的节点应使用统一的硬件。</p><a id="more"></a> <p>二、InnoDB的锁机制——行级锁定</p><p>不光InnoDB存储引擎，MySQL的分布式存储引擎NDB Cluster都使用行级锁定。InnoDB的行级锁定同样分为两种，一种是共享锁，一种是排它锁。</p><p>1、当一个事务需要给某份资源加锁的时候，主要情况有如下：<br>（1）如果遇到一个共享锁正锁定着资源，那么事务只能再加上一个共享锁，而不能加排它锁。<br>（2）如果遇到一个排他锁正锁定着资源，那么事务只能等待该锁定释放资源后他才能获得资源并添加自己的锁定。</p><p>2、InnoDB锁机制的实现与弊端</p><p>InnoDB锁机制是基于索引实现的，通过在指向数据记录的第一个索引键之前与最后一个索引键之后的空域空间（间隙或着说是范围）标记锁定信息实现，被称为间隙锁。</p><p>间隙锁的弊端：会在执行范围查询时，对范围内所有键值加锁，即使键值不存在，这会造成在加锁后无法插入锁定键值范围内的任何数据，影响性能。比如：</p><p>[sql] view plain copy<br>SELECT *<br>FROM user<br>WHERE user_id BETWEEM 1 AND 100<br>执行这个查询时，会对1-100范围内所有索引键值（1-100）加间隙锁，即使并不存在user_id为10的用户信息，所以在加锁后，要想插入一条user_id为10的用户信息是不可行的，这对于行级锁来说并不符合常理。InnoDB给出的解释是：为了防止幻读的出现。<br>当没有索引时或无法利用索引时，InnoDB会弃用行级锁，改用表级锁，并发处理性能降低。</p><p>另外，因为InnoDB的行级锁与事务处理特性，一定会产生死锁现象，对于如何降低死锁产生概率，我在第四部分InnoDB行级锁定优化建议中详述。 </p><p>四、InnoDB行级锁定优化建议<br>InnoDB的行级锁最大的优势就是增强了高并发的处理能力，缺点就是复杂性较高、易死锁，且基于索引实现有一定弊端。我们要做的就是扬长避短，合理利用InnoDB行级锁定，为此我们就应该做的：</p><p>1、尽可能让所有的数据检索都通过索引实现，因为InnoDB行级锁是基于索引实现的，没有索引或无法使用索引系统会改为使用表级锁。</p><p>2、合理设计索引，以缩小加锁范围，避免“间隙锁”造成不该锁定的键值被锁定。</p><p>3、尽量控制事务的大小，因为行级锁的复杂性会加大资源量以及锁定时间。</p><p>4、使用较低级别的事务隔离，以减少因实现事务隔离而付出的成本。</p><p>5、避免死锁，可以通过如下方式实现：</p><p>（1）类似的业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁。</p><p>（2）同一个事务中，尽量做到一次性锁定需要的所有资源。</p><p>（3）对于易产生死锁的业务部分，增大处理颗粒度，升级为表级锁以降低死锁产生的概率</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galera-cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb-galera-cluster-10.3</title>
      <link href="/2018/04/15/mariadb-galera-cluster-10-3/"/>
      <url>/2018/04/15/mariadb-galera-cluster-10-3/</url>
      
        <content type="html"><![CDATA[<h1 id="在centos7-4-1708部署mariadb-10-3-5-galera-cluster集群"><a href="#在centos7-4-1708部署mariadb-10-3-5-galera-cluster集群" class="headerlink" title="在centos7.4.1708部署mariadb-10.3.5 galera cluster集群"></a>在centos7.4.1708部署mariadb-10.3.5 galera cluster集群</h1><p>本人在阿里云ECS云主机上配置，cpu核数2  内存2G 带宽1M，3台阿里云主机所在的安全组要开放全部协议的所有端口（针对mariadb-galera-cluster集群中同步用到的端口来开放比较麻烦，涉及端口TCP 3306 4567 4568,4444,由于一些端口用的是tcp协议，一些端口用的UDP协议，所以建议这后面三个端口把tcp，udp都开放，如果你嫌麻烦，就索性开放所有协议所有端口）。</p><h2 id="1-ssh链接到三台云主机后，关闭SELinux-阿里云主机默认是已经关闭的-，通过配置文件来关闭-关闭防火墙，默认开启不启用。"><a href="#1-ssh链接到三台云主机后，关闭SELinux-阿里云主机默认是已经关闭的-，通过配置文件来关闭-关闭防火墙，默认开启不启用。" class="headerlink" title="1.ssh链接到三台云主机后，关闭SELinux(阿里云主机默认是已经关闭的)，通过配置文件来关闭,关闭防火墙，默认开启不启用。"></a>1.ssh链接到三台云主机后，关闭SELinux(阿里云主机默认是已经关闭的)，通过配置文件来关闭,关闭防火墙，默认开启不启用。</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sed</span> -i <span class="token string">"s/SELINUX=enforcing/SELINUX=disabled/g"</span> /etc/selinux/configsystemctl stop firewalld.servicesystemctl disable firewalld.serviceyum clean all</code></pre><a id="more"></a><h2 id="2-对三台云主机的-etc-hosts文件进行修改"><a href="#2-对三台云主机的-etc-hosts文件进行修改" class="headerlink" title="2.对三台云主机的/etc/hosts文件进行修改"></a>2.对三台云主机的/etc/hosts文件进行修改</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF47.75.71.94     node147.75.73.200    node247.75.74.157    node3EOF</span></code></pre><h3 id="在node1节点上测试ping"><a href="#在node1节点上测试ping" class="headerlink" title="在node1节点上测试ping"></a>在node1节点上测试ping</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">ping</span> -c 3 node2<span class="token function">ping</span> -c 3 node3</code></pre><h3 id="3-三节点都配置mariadb的yum源仓库，并安装软件包"><a href="#3-三节点都配置mariadb的yum源仓库，并安装软件包" class="headerlink" title="3.三节点都配置mariadb的yum源仓库，并安装软件包."></a>3.三节点都配置mariadb的yum源仓库，并安装软件包.</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/yum.repos.d/mariadb.repos <span class="token operator">&lt;&lt;</span><span class="token string">EOFname = MariaDBbaseurl = http://yum.mariadb.org/10.3.5/centos74-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1EOF</span></code></pre><h3 id="安装软件包："><a href="#安装软件包：" class="headerlink" title="安装软件包："></a>安装软件包：</h3><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y MariaDB-server MariaDB-client galera</code></pre><h3 id="4-mariadb初始化三台节点（通过mysql-secure-installation命令配置密码）"><a href="#4-mariadb初始化三台节点（通过mysql-secure-installation命令配置密码）" class="headerlink" title="4.mariadb初始化三台节点（通过mysql-secure_installation命令配置密码）"></a>4.mariadb初始化三台节点（通过mysql-secure_installation命令配置密码）</h3><pre class=" language-bash"><code class="language-bash">systemctl start mariadbmysql_secure_installation（设置root密码为cntsp）mysql -uroot -pcntspgrant all privileges on *.* to root@<span class="token string">"%"</span> identified by <span class="token string">"cntsp"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#grant all privileges on *.* to sst_user@"%" identified by "cntsp";</span>flush privileges<span class="token punctuation">;</span>quitsystemctl stop mariadb  <span class="token punctuation">(</span>三台节点都stop<span class="token punctuation">)</span></code></pre><h3 id="5-配置galera"><a href="#5-配置galera" class="headerlink" title="5.配置galera"></a>5.配置galera</h3><p>node1节点配置在/etc/my.cnf.d/service.cnf中的galera块添加如下配置</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>galera<span class="token punctuation">]</span>wsrep_on<span class="token operator">=</span>ON wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address<span class="token operator">=</span><span class="token string">"gcomm://47.75.71.94,47.75.73.200,47.75.74.157"</span>wsrep_node_name<span class="token operator">=</span> node1wsrep_node_address<span class="token operator">=</span>47.75.71.94binlog_format<span class="token operator">=</span>rowdefault_storage_engine<span class="token operator">=</span>InnoDBwsrep_slave_threads<span class="token operator">=</span>1wsrep_sst_method<span class="token operator">=</span>rsync<span class="token comment" spellcheck="true">#wsrep_sst_auth=sst_user:cntsp</span></code></pre><p>node2节点配置在/etc/my.cnf.d/service.cnf中的galera块添加如下配置</p><pre class=" language-bash"><code class="language-bash">wsrep_on<span class="token operator">=</span>ON wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address<span class="token operator">=</span><span class="token string">"gcomm://47.75.71.94,47.75.73.200,47.75.74.157"</span>wsrep_node_name<span class="token operator">=</span> node2wsrep_node_address<span class="token operator">=</span>47.75.73.200binlog_format<span class="token operator">=</span>rowdefault_storage_engine<span class="token operator">=</span>InnoDBwsrep_slave_threads<span class="token operator">=</span>1wsrep_sst_method<span class="token operator">=</span>rsync<span class="token comment" spellcheck="true">#wsrep_sst_auth=sst_user:cntsp</span></code></pre><p>node3节点配置在/etc/my.cnf.d/service.cnf中的galera块添加如下配置</p><pre class=" language-bash"><code class="language-bash">wsrep_on<span class="token operator">=</span>ON wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address<span class="token operator">=</span><span class="token string">"gcomm://47.75.71.94,47.75.73.200,47.75.74.157"</span>wsrep_node_name<span class="token operator">=</span> node3wsrep_node_address<span class="token operator">=</span>47.75.74.157binlog_format<span class="token operator">=</span>rowdefault_storage_engine<span class="token operator">=</span>InnoDBwsrep_slave_threads<span class="token operator">=</span>1wsrep_sst_method<span class="token operator">=</span>rsync<span class="token comment" spellcheck="true">#wsrep_sst_auth=sst_user:cntsp</span></code></pre><h3 id="6-启动集群服务"><a href="#6-启动集群服务" class="headerlink" title="6.启动集群服务"></a>6.启动集群服务</h3><pre class=" language-bash"><code class="language-bash">在node1节点上执行：galera_new_cluster在node2、node3上依次执行：service mysql start初次启动要等大概15分钟，（我理解的是因为要做SST全量备份）<span class="token punctuation">(</span>20分钟后查看3306端口和4567端口是否起来<span class="token punctuation">)</span><span class="token function">netstat</span> -lntp</code></pre><h3 id="7-验证集群状态"><a href="#7-验证集群状态" class="headerlink" title="7.验证集群状态"></a>7.验证集群状态</h3><p>进入node1</p><pre class=" language-bash"><code class="language-bash">mysql -uroot -pcntspshow status like <span class="token string">'wsrep_ready'</span><span class="token punctuation">;</span>show status like <span class="token string">'wsrep_cluster_size'</span><span class="token punctuation">;</span>show status like <span class="token string">'wsrep%'</span><span class="token punctuation">;</span>在node1上创建数据库，看看node2 node3是否同步（已经验证过了）create database test1<span class="token punctuation">;</span></code></pre><h3 id="8-模拟脑裂后的处理"><a href="#8-模拟脑裂后的处理" class="headerlink" title="8.模拟脑裂后的处理"></a>8.模拟脑裂后的处理</h3><p>下面模拟在网络抖动发生丢包的情况下，两个节点失联导致脑裂。在node2和node3两个节点上分别执行：(这个centos7是用的firewalld防火墙)</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --sport 4567 -j DROPiptables -A INPUT -p tcp --dport 4567 -j DROP</code></pre><p>以上命令用来禁止wsrep全同步复制4567端口通信</p><h3 id="9-因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）"><a href="#9-因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）" class="headerlink" title="9.因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）"></a>9.因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）</h3><h3 id="10-异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）"><a href="#10-异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）" class="headerlink" title="10.异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）"></a>10.异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）</h3><pre class=" language-bash"><code class="language-bash">第1步：开启galera集群的群主主机的mariadb服务。第2步：开启galera集群的成员主机的mariadb服务。异常处理：galera集群的群主主机和成员主机的mysql服务无法启动，如何处理？解决方法一：第1步、删除garlera群主主机的/var/lib/mysql/grastate.dat状态文件/bin/galera_new_cluster启动服务。启动正常。登录并查看wsrep状态。第2步：删除galera成员主机中的/var/lib/mysql/grastate.dat状态文件systemctl restart mariadb重启服务。启动正常。登录并查看wsrep状态。解决方法二：第1步、修改garlera群主主机的/var/lib/mysql/grastate.dat状态文件中的0为1/bin/galera_new_cluster启动服务。启动正常。登录并查看wsrep状态。第2步：修改galera成员主机中的/var/lib/mysql/grastate.dat状态文件中的0为1systemctl restart mariadb重启服务。启动正常。登录并查看wsrep状态。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mariadb </tag>
            
            <tag> galera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb-galera-cluster</title>
      <link href="/2018/03/22/mariadb-galera-cluster/"/>
      <url>/2018/03/22/mariadb-galera-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="How-To-Create-a-Galera-Cluster-with-MariaDB-10-2-on-Aliyun-ECS-CentOS-Linux-release-7-2-1511-Core"><a href="#How-To-Create-a-Galera-Cluster-with-MariaDB-10-2-on-Aliyun-ECS-CentOS-Linux-release-7-2-1511-Core" class="headerlink" title="How To Create a Galera Cluster with MariaDB 10.2 on Aliyun ECS (CentOS Linux release 7.2.1511 (Core))"></a>How To Create a Galera Cluster with MariaDB 10.2 on Aliyun ECS (CentOS Linux release 7.2.1511 (Core))</h2><p>Aliyun ECS of Node (47.75.71.94、47.75.74.157、47.75.73.200)</p><h3 id="1-Check-the-SELINUX-the-default-of-ECS-is-the-disable-SELINUX"><a href="#1-Check-the-SELINUX-the-default-of-ECS-is-the-disable-SELINUX" class="headerlink" title="1) Check the SELINUX.(the default of ECS is the disable SELINUX )"></a>1) Check the SELINUX.(the default of ECS is the disable SELINUX )</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span>getenforceDisabled<span class="token operator">>></span><span class="token punctuation">(</span>if the results is enforcing or permissive,you need to change it to Disabled.<span class="token punctuation">)</span><span class="token operator">>></span>sed -i <span class="token string">'s#SELINUX=enforcing#SELINUX=disabled#g'</span> /etc/selinux/config</code></pre><h3 id="2-Disable-Firewall-or-open-required-ports-each-node"><a href="#2-Disable-Firewall-or-open-required-ports-each-node" class="headerlink" title="2) Disable Firewall or open required ports(each node)"></a>2) Disable Firewall or open required ports(each node)</h3><p>You can disable the firewall for now and enable it later and open the required ports or You can open the required ports.</p><h3 id="i-if-you-decieded-to-total-disable-firewall-for-now-use-below-statement"><a href="#i-if-you-decieded-to-total-disable-firewall-for-now-use-below-statement" class="headerlink" title="i)if you decieded to total disable firewall for now , use below statement"></a>i)if you decieded to total disable firewall for now , use below statement</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> systemctl stop    firewalld.service<span class="token operator">>></span> systemctl disable firewalld.service</code></pre><h4 id="ii-if-you-have-decieded-to-keep-the-firewall-enabled-then-you-have-to-run-below-commands-to-open-required-ports"><a href="#ii-if-you-have-decieded-to-keep-the-firewall-enabled-then-you-have-to-run-below-commands-to-open-required-ports" class="headerlink" title="ii)if you have decieded to keep the firewall enabled,then you have to run below commands to open required ports."></a>ii)if you have decieded to keep the firewall enabled,then you have to run below commands to open required ports.</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>3306/tcp --permanent<span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>4567/tcp --permanent<span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>4568/tcp --permanent<span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>4444/tcp --permanent</code></pre><a id="more"></a><h3 id="3-Install-MariaDB-10-2-on-Each-Node"><a href="#3-Install-MariaDB-10-2-on-Each-Node" class="headerlink" title="3) Install MariaDB 10.2 on Each Node"></a>3) Install MariaDB 10.2 on Each Node</h3><p>first of all you need to install MariaDB 10.2 on each of the node.</p><h4 id="i-Check-the-Linux-Version"><a href="#i-Check-the-Linux-Version" class="headerlink" title="i)Check the Linux Version:"></a>i)Check the Linux Version:</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">cat</span> /etc/redhat-releaseCentOS Linux release 7.2.1511 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span></code></pre><h4 id="ii-Create-or-Edit-mariadb-repo-each-node"><a href="#ii-Create-or-Edit-mariadb-repo-each-node" class="headerlink" title="ii)Create or Edit mariadb.repo (each node):"></a>ii)Create or Edit mariadb.repo (each node):</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span>Create mariadb.repo <span class="token function">file</span> <span class="token keyword">in</span> /etc/yum.repos.d/<span class="token operator">>></span> <span class="token function">cat</span> <span class="token operator">>></span>/etc/yum.repos.d/mariadb.repo <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">>></span> <span class="token punctuation">[</span>mariadb<span class="token punctuation">]</span><span class="token operator">>></span> name <span class="token operator">=</span> MariaDB<span class="token operator">>></span> baseurl <span class="token operator">=</span> http://yum.mariadb.org/10.2/centos7-amd64<span class="token operator">>></span> gpgkey<span class="token operator">=</span>https://yum.mariadb.org/RPM-GPG-KEY-MariaDB<span class="token operator">>></span> gpgcheck<span class="token operator">=</span>1<span class="token operator">>></span> EOF</code></pre><h4 id="iii-Install-MariaDB-server-and-MariaDB-client-each-node"><a href="#iii-Install-MariaDB-server-and-MariaDB-client-each-node" class="headerlink" title="iii)Install MariaDB server and MariaDB client (each node)"></a>iii)Install MariaDB server and MariaDB client (each node)</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> yum <span class="token function">install</span> -y MariaDB-server MariaDB-client </code></pre><h4 id="iv-Start-MariaDB-service-each-node"><a href="#iv-Start-MariaDB-service-each-node" class="headerlink" title="iv)Start MariaDB service (each node)"></a>iv)Start MariaDB service (each node)</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> systemctl start mariadb.service</code></pre><h4 id="v-Run-Secure-Installation-each-node"><a href="#v-Run-Secure-Installation-each-node" class="headerlink" title="v) Run Secure Installation(each node)"></a>v) Run Secure Installation(each node)</h4><p>run the secure installation by using below statment to configure root password and other features.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> mysql_secure_installation</code></pre><h4 id="vi-Login-to-mariadb-by-using-root-each-node"><a href="#vi-Login-to-mariadb-by-using-root-each-node" class="headerlink" title="vi)Login to mariadb by using root.(each node)"></a>vi)Login to mariadb by using root.(each node)</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> mysql -uroot -p<span class="token operator">>></span> password：cntsp</code></pre><h4 id="vii-Stop-mariadb-service"><a href="#vii-Stop-mariadb-service" class="headerlink" title="vii)Stop mariadb service"></a>vii)Stop mariadb service</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> systemctl stop mariadb.service</code></pre><h3 id="4-Make-changes-to-etc-my-cnf-d-server-cnf-file-each-one"><a href="#4-Make-changes-to-etc-my-cnf-d-server-cnf-file-each-one" class="headerlink" title="4) Make changes to /etc/my.cnf.d/server.cnf  file (each one)."></a>4) Make changes to /etc/my.cnf.d/server.cnf  file (each one).</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf.d/server.cnf <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">>></span> <span class="token punctuation">[</span>galera<span class="token punctuation">]</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#Mandatory settings</span><span class="token operator">>></span> wsrep_on<span class="token operator">=</span>ON<span class="token operator">>></span> wsrep_cluster_address<span class="token operator">=</span>gcomm://mariadb-a1,mariadb-a2,mariadb-a3<span class="token operator">>></span> wsrep_node_address<span class="token operator">=</span>This Node IP<span class="token operator">>></span> wsrep_node_incoming_address<span class="token operator">=</span>This Node IP<span class="token operator">>></span> <span class="token comment" spellcheck="true"># wsrep_sst_donor =</span><span class="token operator">>></span> binlog_format<span class="token operator">=</span>row<span class="token operator">>></span> default_storage_engine<span class="token operator">=</span>InnoDB<span class="token operator">>></span> innodb_autoinc_lock_mode<span class="token operator">=</span>2<span class="token operator">>></span> innodb_buffer_pool_size<span class="token operator">=</span>122M<span class="token operator">>></span> wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.so<span class="token operator">>></span> wsrep_cluster_name<span class="token operator">=</span><span class="token string">"YourClusterName"</span><span class="token operator">>></span> wsrep_slave_threads<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_certify_nonPK<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_max_ws_rows<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_max_ws_size<span class="token operator">=</span>2147483647<span class="token operator">>></span> wsrep_debug<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_convert_LOCK_to_trx<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_retry_autocommit<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_auto_increment_control<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_drupal_282555_workaround<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_causal_reads<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_notify_cmd<span class="token operator">=</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># Allow server to accept connections on all interfaces.</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#</span><span class="token operator">>></span> bind-address<span class="token operator">=</span>0.0.0.0<span class="token operator">>></span> <span class="token comment" spellcheck="true"># Optional setting</span><span class="token operator">>></span> wsrep_slave_threads<span class="token operator">=</span>1<span class="token operator">>></span> innodb_flush_log_at_trx_commit<span class="token operator">=</span>0<span class="token operator">>></span> <span class="token comment" spellcheck="true"># this is only for embedded server</span><span class="token operator">>></span> <span class="token punctuation">[</span>embedded<span class="token punctuation">]</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># This group is only read by MariaDB servers, not by MySQL.</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># If you use the same .cnf file for MySQL and MariaDB,</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># you can put MariaDB-only options here</span><span class="token operator">>></span> <span class="token punctuation">[</span>mariadb<span class="token punctuation">]</span><span class="token operator">>></span>EOF</code></pre><h3 id="5-Start-Service-on-first-node"><a href="#5-Start-Service-on-first-node" class="headerlink" title="5)Start Service on first node:"></a>5)Start Service on first node:</h3><p>To start the mariadb service on first Node, you will be using below command.DON’T USE SYSTEMCTL start mriadb.service or service mysql start</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> /usr/bin/galera_new_cluster</code></pre><p>service should start successfully.Once the mariadb service is started on first node,you can check the cluster information by connecting to mariadb.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> mysql -uroot -p<span class="token operator">>></span> password:cntsp<span class="token operator">>></span> MariaDB<span class="token operator">>></span> show status like <span class="token string">'wsrep_cluster_size%'</span><span class="token punctuation">;</span><span class="token operator">>></span> you should see the output as shown below.<span class="token operator">>></span> -------------------------<span class="token operator">>></span> Variable_name       Value<span class="token operator">>></span> -------------------------<span class="token operator">>></span> wsrep_cluster_size    1<span class="token operator">>></span> -------------------------</code></pre><h3 id="6-Join-2nd-and-3third-node"><a href="#6-Join-2nd-and-3third-node" class="headerlink" title="6)Join 2nd and 3third node"></a>6)Join 2nd and 3third node</h3><p>You are all set to join other nodes to Galera Cluster. Connect to second node and then start MariaDB service by using below statment.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> systemctl start mariadb.service</code></pre><p>if the command line has some error,<br>like:Job for mariadb.service failed because a fatal signal was delivered to the control process. See “systemctl status mariadb.service” and “journalctl -xe” for details.<br>journalctl -xe<br>WSREP: Failed to prepare for incremental state transfer: Local state UUID (00000000-0000-0000-0000-000000000000) does not match group state UUID (a25a4592-2c4<br>repeat the commands on all the nodes.Once the mariadb service is started on all the Nodes, you can check Galera cluster size again to make sure all the nodes are part of cluster by running below statment.<br>mysql -uroot -p -e “SHOW STATUS LIKE ‘wsrep_cluster_size’”</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mariadb集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vpn-classification</title>
      <link href="/2017/11/04/vpn-classification/"/>
      <url>/2017/11/04/vpn-classification/</url>
      
        <content type="html"><![CDATA[<p>VPN(虚拟专用网络)发展至今已经不在是一个单纯的经过加密的访问隧道了，它已经融合了访问控制、传输管理、加密、路由选择、可用性管理等多种功能，并在全球的 信息安全体系中发挥着重要的作用。也在网络上，有关各种VPN协议优缺点的比较是仁者见仁，智者见智，很多技术人员由于出于使用目的考虑，包括访问控制、 安全和用户简单易用，灵活扩展等各方面，权衡利弊，难以取舍;尤其在VOIP语音环境中，网络安全显得尤为重要，因此现在越来越多的网络电话和语音网关支 持VPN协议。</p><a id="more"></a><h1 id="PPTP"><a href="#PPTP" class="headerlink" title="PPTP"></a>PPTP</h1><h2 id="PPTP协议是点对点隧道协议"><a href="#PPTP协议是点对点隧道协议" class="headerlink" title="PPTP协议是点对点隧道协议"></a>PPTP协议是点对点隧道协议</h2><p>　　其将控制包与数据包分开，控制包采用TCP控制，用于严格的状态查询及信令信息；数据包部分先封装在PPP协议中，然后封装到GRE V2协议中。<br>　　点对点隧道协议(PPTP)是由包括微软和3Com等公司组成的PPTP论坛开发的一种点对点隧道协，基于拨号使用的PPP协议使用PAP或CHAP之类的加密算法，或者使用 Microsoft的点对点加密算法MPPE。其通过跨越基于 TCP/IP 的数据网络创建 VPN 实现了从远程客户端到专用企业服务器之间数据的安全传输。PPTP 支持通过公共网络(例如 Internet)建立按需的、多协议的、虚拟专用网络。PPTP允许加密IP通讯，然后在要跨越公司IP网络或公共IP网络(如 Internet)发送的IP头中对其进行封装。</p><h1 id="L2TP"><a href="#L2TP" class="headerlink" title="L2TP"></a>L2TP</h1><h2 id="L2TP是国际标准隧道协议"><a href="#L2TP是国际标准隧道协议" class="headerlink" title="L2TP是国际标准隧道协议"></a>L2TP是国际标准隧道协议</h2><p>　　它结合了PPTP协议以及第二层转发L2F协议的优点，能以隧道方式使PPP包通过各种网络协议，包括ATM、SONET和帧中继。但是L2TP没有任何加密措施，更多是和IPSec协议结合使用，提供隧道验证。<br>　　L2TP第2层隧道协议(L2TP)是IETF基于L2F(Cisco的第二层转发协议)开发的PPTP的后续版本。是一种工业标准 Internet 隧道协议，其可以为跨越面向数据包的媒体发送点到点协议(PPP)框架提供封装。PPTP和L2TP都使用PPP协议对数据进行封装，然后添加附加包头用于数据在互联网络上的传输。PPTP只能在两端点间建立单一隧道。 L2TP支持在两端点间使用多隧道，用户可以针对不同的服务质量创建不同的隧道。L2TP可以提供隧道验证，而PPTP则不支持隧道验证。但是当L2TP 或PPTP与IPSEC共同使用时，可以由IPSEC提供隧道验证，不需要在第2层协议上验证隧道使用L2TP。 PPTP要求互联网络为IP网络。L2TP只要求隧道媒介提供面向数据包的点对点的连接，L2TP可以在IP(使用UDP)，桢中继永久虚拟电路(PVCs),X.25虚拟电路(VCs)或ATM VCs网络上使用。</p><h1 id="PPTP和L2TP两者的联系与区别"><a href="#PPTP和L2TP两者的联系与区别" class="headerlink" title="PPTP和L2TP两者的联系与区别"></a>PPTP和L2TP两者的联系与区别</h1><p>　  联系：PPTP和L2TP都使用PPP协议对数据进行封装，然后添加附加包头用于数据在互联网络上的传输。尽管两个协议非常相似，但是仍存在以下几方面的不同<br>　　区别：<br>　　1）PPTP要求互联网络为IP网络。L2TP只要求隧道媒介提供面向数据包的点对点的连接。L2TP可以在IP（使用UDP），桢中继永久虚拟电路（PVCs），X.25虚拟电路（VCs）或ATM VCs网络上使用。<br>　　2）PPTP只能在两端点间建立单一隧道。L2TP支持在两端点间使用多隧道。使用L2TP，用户可以针对不同的服务质量创建不同的隧道。<br>　　3）L2TP可以提供包头压缩。当压缩包头时，系统开销（overhead）占用4个字节，而PPTP协议下要占用6个字节。<br>　　4）L2TP可以提供隧道验证，而PPTP不支持隧道验证。但当L2TP或PPTP与IPSEC共同使用时，可由IPSEC提供隧道验证，不需在第2层协议上验证隧道。</p><h1 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h1><p>　　IPSec VPN即指采用IPSec协议来实现远程接入的一种VPN技术,IPSec是IETF(Internet Engineer Task Force)正在完善的安全标准，IPSec协议是一个范围广泛、开放的虚拟专用网安全协议,它提供所有在网络层上的数据保护，提供透明的安全通信。 IPSec是基于网络层的，不能穿越通常的NAT、防火墙。<br>　　首先先具体介绍一下IPsec协议：<br>　　IP_SECURITY协议(IPSec)，通过相应的隧道技术，可实现VPN。IPSec有两种模式：隧道模式和传输模式。IPSec协议不是一个单独的协议，它给出了应用于IP层上网络数据安全的一整套体系结构，包括网络认证协议Authentication Header(AH)、封装安全载荷协议Encapsulating Security Payload(ESP)、密钥管理协议Internet Key Exchange(IKE)和用于网络认证及加密的一些算法等。IPSec规定了如何在对等层之间选择安全协议、确定安全算法和密钥交换，向上提供了访问控制、数据源认证、数据加密等网络安全服务。<br>　　IPSec的安全特性主要有：<br>　　不可否认性：”不可否认性”可以证实消息发送方是唯一可能的发送者，发送者不能否认发送过消息。”不可否认性”是采用公钥技术的一个特征，当使用公钥技术时，发送方用私钥产生一个数字签名随消息一起发送，接收方用发送者的公钥来验证数字签名。由于在理论上只有发送者才唯一拥有私钥，也只有发送者才可能产生该数字签名，所以只要数字签名通过验证，发送者就不能否认曾发送过该消息。但”不可否认性”不是基于认证的共享密钥技术的特征，因为在基于认证的共享密钥技术中，发送方和接收方掌握相同的密钥。<br>　　反重播性：”反重播”确保每个IP包的唯一性，保证信息万一被截取复制后，不能再被重新利用、重新传输回目的地址。该特性可以防止攻击者截取破译信息后，再用相同的信息包冒取非法访问权（即使这种冒取行为发生在数月之后）。<br>　　数据完整性：防止传输过程中数据被篡改，确保发出数据和接收数据的一致性。IPSec利用Hash函数为每个数据包产生一个加密检查和，接收方在打开包前先计算检查和，若包遭篡改导致检查和不相符，数据包即被丢弃。<br>　　数据可靠性（加密）：在传输前，对数据进行加密，可以保证在传输过程中，即使数据包遭截取，信息也无法被读。该特性在IPSec中为可选项，与IPSec策略的具体设置相关。 　　<br>　　认证：数据源发送信任状，由接收方验证信任状的合法性，只有通过认证的系统才可以建立通信连接。</p><p>本文链接于<a href="http://www.mike.org.cn/articles/pptp-l2tp-ipsec-sslvpn-difference/" target="_blank" rel="noopener">http://www.mike.org.cn/articles/pptp-l2tp-ipsec-sslvpn-difference/</a></p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
            <tag> 种类 </tag>
            
            <tag> 区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module-logging</title>
      <link href="/2017/10/30/python-module-logging/"/>
      <url>/2017/10/30/python-module-logging/</url>
      
        <content type="html"><![CDATA[<h1 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h1><p>很多程序都有记录日志的需求，并且日志中包含的信息即有正常的访问日志，还可能有错误、警告等信息输出，python的logging模块提供了标准的日志接口，我们可以通过它存储各种格式的日志，logging的日志可以分为debug(),info(),warning(),error(),critical() 5个级别</p><h1 id="简单将日志打印到屏幕上："><a href="#简单将日志打印到屏幕上：" class="headerlink" title="简单将日志打印到屏幕上："></a>简单将日志打印到屏幕上：</h1><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> loggingloggin.debug<span class="token punctuation">(</span><span class="token string">'debug message'</span><span class="token punctuation">)</span>logging.info<span class="token punctuation">(</span><span class="token string">'info message'</span><span class="token punctuation">)</span>logging.warning<span class="token punctuation">(</span><span class="token string">'warning message'</span><span class="token punctuation">)</span>logging.error<span class="token punctuation">(</span><span class="token string">'error message'</span><span class="token punctuation">)</span>logging.critical<span class="token punctuation">(</span><span class="token string">'critical message'</span><span class="token punctuation">)</span></code></pre><a id="more"></a><p>输出：<br>WARNING:root:warning message<br>ERROR:root:error message<br>CRITICAL:root:critical message<br>可见，默认情况下python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为：<code>日志级别</code>：<code>Logger名称</code>：<code>用户输出消息</code></p><h1 id="灵活配置日志级别，日志格式，输出位置"><a href="#灵活配置日志级别，日志格式，输出位置" class="headerlink" title="灵活配置日志级别，日志格式，输出位置"></a>灵活配置日志级别，日志格式，输出位置</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> logginglogging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span>                    format<span class="token operator">=</span><span class="token string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span><span class="token punctuation">,</span>                    datefmt<span class="token operator">=</span><span class="token string">'%a, %d %b %Y %H:%M:%S'</span><span class="token punctuation">,</span>                    filename<span class="token operator">=</span><span class="token string">'test.log'</span><span class="token punctuation">,</span>                    filemode<span class="token operator">=</span><span class="token string">'w'</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'debug message'</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'info message'</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'warning message'</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>error<span class="token punctuation">(</span><span class="token string">'error message'</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>critical<span class="token punctuation">(</span><span class="token string">'critical message'</span><span class="token punctuation">)</span></code></pre><p>查看输出：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> test.logMon, 30 Oct 2017 15:08:24 module_logging.py<span class="token punctuation">[</span>line:11<span class="token punctuation">]</span> DEBUG debug messageMon, 30 Oct 2017 15:08:24 module_logging.py<span class="token punctuation">[</span>line:12<span class="token punctuation">]</span> INFO info messageMon, 30 Oct 2017 15:08:24 module_logging.py<span class="token punctuation">[</span>line:13<span class="token punctuation">]</span> WARNING warning messageMon, 30 Oct 2017 15:08:24 module_logging.py<span class="token punctuation">[</span>line:14<span class="token punctuation">]</span> ERROR error messageMon, 30 Oct 2017 15:08:24 module_logging.py<span class="token punctuation">[</span>line:15<span class="token punctuation">]</span> CRITICAL critical message</code></pre><p>可见在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：</p><blockquote><ul><li>filename: 用指定的文件名创建FileHandler(后边会具体讲解handler的概念)，这样日志会被存储在指定的文件中</li><li>filemode: 文件打开的方式，在制定了filename时使用这个参数，默认值为’a’</li><li>format: 指定handler使用的日志显示格式</li><li>datefmt: 指定日期时间格式</li><li>level: 设置rootlogger（后面会讲解具体概念）的日志级别</li><li>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件，默认为sys.stderr.若同时列出了filename和stream两个参数，则stream参数会被忽略</li></ul></blockquote><p>format参数中可能用到的格式化字串：</p><blockquote><ul><li>%(name)s Logger的名字</li><li>%(levelno)s 数字形式的日志级别</li><li>%(levelname)s 文本形式的日志级别</li><li>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</li><li>%(filename)s 调用日志输出函数的模块的文件名</li><li>%(module)s 调用日志输出函数的模块名</li><li>%(funcName)s 调用日志输出函数的函数名<br>&lt; * %(lineno)d 调用日志输出函数的语句所在的代码行</li><li>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</li><li>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</li><li>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</li><li>%(thread)d 线程ID。可能没有</li><li>%(threadName)s 线程名。可能没有</li><li>%(process)d 进程ID。可能没有</li><li>%(message)s 用户输出的消息</li></ul></blockquote><p>如果同时把log打印在屏幕和文件日志里，就需要了解一点复杂的知识<br>Python 使用logging模块记录日志涉及四个主要类，使用官方文档中的概括最为合适：</p><blockquote><ul><li>logger提供了应用程序可以直接使用的接口；</li><li>handler将(logger创建的)日志记录发送到合适的目的输出；</li><li>filter提供了细度设备来决定输出哪条日志记录；</li><li>formatter决定日志记录的最终输出格式。</li></ul></blockquote><p>logger<br>每个程序在输出信息之前都要获得一个Logger。Logger通常对应了程序的模块名，比如聊天工具的图形界面模块可以这样获得它的Logger：<br>LOG=logging.getLogger(”chat.gui”)<br>而核心模块可以这样：<br>LOG=logging.getLogger(”chat.kernel”)</p><p>Logger.setLevel(lel):指定最低的日志级别，低于lel的级别将被忽略。debug是最低的内置级别，critical为最高<br>Logger.addFilter(filt)、Logger.removeFilter(filt):添加或删除指定的filter<br>Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)：增加或删除指定的handler<br>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()：可以设置的日志级别</p><p>handler</p><p>handler对象负责发送相关的信息到指定目的地。Python的日志系统有多种Handler可以使用。有些Handler可以把信息输出到控制台，有些Logger可以把信息输出到文件，还有些 Handler可以把信息发送到网络上。如果觉得不够用，还可以编写自己的Handler。可以通过addHandler()方法添加多个多handler<br>Handler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略<br>Handler.setFormatter()：给这个handler选择一个格式<br>Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象</p><p>每个Logger可以附加多个Handler。接下来我们就来介绍一些常用的Handler：</p><p>1) logging.StreamHandler<br>使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息。它的构造函数是：<br>StreamHandler([strm])<br>其中strm参数是一个文件对象。默认是sys.stderr</p><p>2) logging.FileHandler<br>和StreamHandler类似，用于向一个文件输出日志信息。不过FileHandler会帮你打开这个文件。它的构造函数是：<br>FileHandler(filename[,mode])<br>filename是文件名，必须指定一个文件名。<br>mode是文件的打开方式。参见Python内置函数open()的用法。默认是’a’，即添加到文件末尾。</p><p>3) logging.handlers.RotatingFileHandler<br>这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把 文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。它的构造函数是：<br>RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])<br>其中filename和mode两个参数和FileHandler一样。<br>maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。<br>backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。</p><p>4) logging.handlers.TimedRotatingFileHandler<br>这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。它的构造函数是：<br>TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])<br>其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。<br>interval是时间间隔。<br>when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：<br>S 秒<br>M 分<br>H 小时<br>D 天<br>W 每星期（interval==0时代表星期一）<br>midnight 每天凌晨</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> logging<span class="token comment" spellcheck="true">#create logger</span>logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span><span class="token string">'TEST-LOG'</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># create console handler and set level to debug</span>ch <span class="token operator">=</span> logging<span class="token punctuation">.</span>StreamHandler<span class="token punctuation">(</span><span class="token punctuation">)</span>ch<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># create file handler and set level to warning</span>fh <span class="token operator">=</span> logging<span class="token punctuation">.</span>FileHandler<span class="token punctuation">(</span><span class="token string">"access.log"</span><span class="token punctuation">)</span>fh<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>WARNING<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># create formatter</span>formatter <span class="token operator">=</span> logging<span class="token punctuation">.</span>Formatter<span class="token punctuation">(</span><span class="token string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># add formatter to ch and fh</span>ch<span class="token punctuation">.</span>setFormatter<span class="token punctuation">(</span>formatter<span class="token punctuation">)</span>fh<span class="token punctuation">.</span>setFormatter<span class="token punctuation">(</span>formatter<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># add ch and fh to logger</span>logger<span class="token punctuation">.</span>addHandler<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>logger<span class="token punctuation">.</span>addHandler<span class="token punctuation">(</span>fh<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 'application' code</span>logger<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'debug message'</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'info message'</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span>warn<span class="token punctuation">(</span><span class="token string">'warn message'</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span>error<span class="token punctuation">(</span><span class="token string">'error message'</span><span class="token punctuation">)</span>logger<span class="token punctuation">.</span>critical<span class="token punctuation">(</span><span class="token string">'critical message'</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> module </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module-hashlib</title>
      <link href="/2017/10/30/python-module-hashlib/"/>
      <url>/2017/10/30/python-module-hashlib/</url>
      
        <content type="html"><![CDATA[<p>hashlib模块：用于加密相关的操作，代替了md5模块和sha模块，主要提供了SHA1，SHA224，SHA256,SHA383,SHA512，MD5算法，在python3中已经废弃了md5和sha模块<br>1.哈希简介</p><p>使用标准库中的 hashlib 模块可以用来处理安全哈希算法或者消息摘要算法。<br>这个模块包含了符合 FIPS（美国联邦信息处理标准）的安全哈希算法，例如 SHA1，SHA224，SHA256，SHA384，SHA512 以及 RSA 的 MD5 算法。<br>哈希的最常见的用法是，存储密码的哈希值而非密码本身。这时候使用哈希函数需要稳健一点，否则容易被破解。另一个常见的用法是，计算一个文件的哈希值，然后将这个文件和它的哈希值分别发送。接收到文件的人可以计算文件的哈希值，检验是否与接收到的哈希值相符——以此来检验文件是否被篡改。</p><a id="more"></a><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> hashlibm <span class="token operator">=</span> hashlib.md5<span class="token punctuation">(</span><span class="token punctuation">)</span>m.update<span class="token punctuation">(</span>b<span class="token string">'hello'</span><span class="token punctuation">)</span>m.updae<span class="token punctuation">(</span>b<span class="token string">'It'</span>s me<span class="token string">')print(m.digest())m.update(b'</span>It<span class="token string">'s been a long time since last time we ...'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>m.digest<span class="token punctuation">(</span><span class="token punctuation">))</span>  <span class="token comment" spellcheck="true"># 2进制格式hash</span>print<span class="token punctuation">(</span>len<span class="token punctuation">(</span>m.hexdigest<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 16进制格式hash</span><span class="token string">''</span><span class="token string">'def digest(self, *args, **kwargs): # real signature unknown    """ Return the digest value as a string of binary data. """    passdef hexdigest(self, *args, **kwargs): # real signature unknown    """ Return the digest value as a string of hexadecimal digits. """    pass'</span><span class="token string">''</span><span class="token function">import</span> hashlib<span class="token comment" spellcheck="true"># ######## md5 ########</span><span class="token function">hash</span> <span class="token operator">=</span> hashlib.md5<span class="token punctuation">(</span><span class="token punctuation">)</span>hash.update<span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>hash.hexdigest<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token comment" spellcheck="true"># ######## sha1 ########</span><span class="token function">hash</span> <span class="token operator">=</span> hashlib.sha1<span class="token punctuation">(</span><span class="token punctuation">)</span>hash.update<span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>hash.hexdigest<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token comment" spellcheck="true"># ######## sha256 ########</span><span class="token function">hash</span> <span class="token operator">=</span> hashlib.sha256<span class="token punctuation">(</span><span class="token punctuation">)</span>hash.update<span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>hash.hexdigest<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token comment" spellcheck="true"># ######## sha384 ########</span><span class="token function">hash</span> <span class="token operator">=</span> hashlib.sha384<span class="token punctuation">(</span><span class="token punctuation">)</span>hash.update<span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>hash.hexdigest<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token comment" spellcheck="true"># ######## sha512 ########</span><span class="token function">hash</span> <span class="token operator">=</span> hashlib.sha512<span class="token punctuation">(</span><span class="token punctuation">)</span>hash.update<span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>hash.hexdigest<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> module </tag>
            
            <tag> hashlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module-configparser</title>
      <link href="/2017/10/30/python-module-configparser/"/>
      <url>/2017/10/30/python-module-configparser/</url>
      
        <content type="html"><![CDATA[<p>python3-configparser模块<br><code>configparser</code>用于配置文件解析，可以解析特定格式的配置文件，此类文件格式为：<code>xxx.ini</code>。在python3中，该模块名为<code>configparser</code>，在python2中使用的模块名为<code>ConfigParser</code>,<code>configparser</code>是解析器，那么解析对象ini文件具有什么格式呢：<br><code>ini</code>文件结构特点：</p><blockquote><ul><li>键值对可用=或者:进行分隔</li><li><code>section</code>(节点)的名字是区分大小写的，而<code>key</code>的名字是不区分大小写的</li><li>键值对头部和尾部的空白符会被去掉</li><li>值可以为多行</li><li>配置文件可以包含注释，注释以<code>#</code>或者<code>;</code>为前缀</li></ul></blockquote><p><strong>注意</strong>：configparser有default_section的概念，默认为<code>[DEFAULT]</code>节，也就是之后所有的section都有该默认section中的键值对</p><a id="more"></a><p>下面我们用程序来创建一个ini文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token function">import</span> configparser<span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> configparser.ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 创建对象</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.                 <span class="token string">'ServerAliveInterval'</span> <span class="token keyword">:</span> <span class="token string">'60'</span>,<span class="token punctuation">..</span>.                 <span class="token string">'Compression'</span> <span class="token keyword">:</span> <span class="token string">'yes'</span>,<span class="token punctuation">..</span>.                 <span class="token string">'CompressionLevel'</span> <span class="token keyword">:</span> <span class="token string">'6'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'User'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hg'</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'1080'</span><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'no'</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'yes'</span><span class="token operator">>></span><span class="token operator">></span> with open<span class="token punctuation">(</span><span class="token string">'example.ini'</span>,<span class="token string">'w'</span>,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> as configfile:<span class="token punctuation">..</span>.    config.write<span class="token punctuation">(</span>configfile<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span></code></pre><p>运行之后生成一个example.ini的配置文件内容如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>DEFAULT<span class="token punctuation">]</span>ServerAliveInterval <span class="token operator">=</span> 60Compression <span class="token operator">=</span> <span class="token function">yes</span>CompressionLevel <span class="token operator">=</span> 6ForwardX11 <span class="token operator">=</span> <span class="token function">yes</span><span class="token punctuation">[</span>bitbucket.org<span class="token punctuation">]</span>User <span class="token operator">=</span> <span class="token function">hg</span><span class="token punctuation">[</span>topsecret.server.com<span class="token punctuation">]</span>Port <span class="token operator">=</span> 1080ForwardX11 <span class="token operator">=</span> no</code></pre><p>我们对example.ini配置文件进行读取：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token function">import</span> configparser<span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> configparser.ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> config.sections<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> config.read<span class="token punctuation">(</span><span class="token string">'example.ini'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'example.ini'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> config.sections<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span>, <span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'bitbucket.org'</span> <span class="token keyword">in</span> configTrue<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'bytebong.com'</span> <span class="token keyword">in</span> configFalse<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'User'</span><span class="token punctuation">]</span><span class="token string">'hg'</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Compression'</span><span class="token punctuation">]</span><span class="token string">'yes'</span><span class="token operator">>></span><span class="token operator">></span> topsecret <span class="token operator">=</span> config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span><span class="token string">'no'</span><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span><span class="token string">'1080'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> key <span class="token keyword">in</span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span>: print<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">..</span>.usercompressionlevelserveraliveintervalcompressionforwardx11<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span><span class="token string">'yes'</span></code></pre><p>获取key值的方法除了列表之外，还可以通过section级别的get()方法获取，同时该函数可以指定默认值</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span>.get<span class="token punctuation">(</span><span class="token string">'User'</span><span class="token punctuation">)</span><span class="token string">'hg'</span><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span>.get<span class="token punctuation">(</span><span class="token string">'ForwardX11'</span><span class="token punctuation">)</span><span class="token string">'no'</span></code></pre><blockquote><blockquote><blockquote><p>topsecret.get(‘CompressionLevel’)<br>‘6’<br>topsecret.get(‘Aipher’,’4des’)<br>‘4des’</p></blockquote></blockquote></blockquote><pre><code>而解析器级别的`get()`函数的默认值是通过`fallback`参数指定的：``` bash&gt;&gt;&gt; config.get(&#39;bitbucket.org&#39;, &#39;monster&#39;,fallback=&#39;No such things as monster&#39;)</code></pre><p>** 注意 ** 无论是通过列表方式获取值，还是通过<code>get()</code>方法获取值，获取到的数据都是字符串类型的，如果想要获取指定类型的值，可以使用下面方法：</p><blockquote><ul><li><code>getint()</code></li><li><code>getfloat()</code></li><li><code>getboolean()</code><br>同时注意<code>getboolean()</code>方法能判断True/False的值有：’yes’/‘no’,’on’/‘off’,’true’/‘false’ 和 ‘1’/‘0’</li></ul></blockquote><p>config.ini文件实例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>section1<span class="token punctuation">]</span>name <span class="token operator">=</span> cntspage <span class="token operator">=</span> 18<span class="token punctuation">[</span>section2<span class="token punctuation">]</span>school <span class="token keyword">:</span> python-school<span class="token function">date</span> <span class="token keyword">:</span> 2017-01-01<span class="token comment" spellcheck="true">###文件格式说明###</span><span class="token punctuation">[</span>xxx<span class="token punctuation">]</span> 代表节点xx <span class="token operator">=</span> xx 或者 xxx <span class="token keyword">:</span> xxx 代表键值对</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token function">import</span> configparser<span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> configparser.ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 常见对象</span><span class="token operator">>></span><span class="token operator">></span> config.read<span class="token punctuation">(</span><span class="token string">'config.ini'</span>,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 读取配置文件，如果配置文件不存在，则创建</span><span class="token operator">>></span><span class="token operator">></span> secs <span class="token operator">=</span> config.sections<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 获取所有节点名称</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>secs<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'section1'</span>,<span class="token string">'section2'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> options <span class="token operator">=</span> config.options<span class="token punctuation">(</span><span class="token string">'section1'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取指定节点的所有key</span><span class="token punctuation">[</span><span class="token string">'name'</span>,<span class="token string">'age'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> item_list <span class="token operator">=</span> config.items<span class="token punctuation">(</span><span class="token string">'section1'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取指定节点的键值对</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>item_list<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span>,<span class="token string">'cntsp'</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">'age'</span>,<span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> val <span class="token operator">=</span> config.getint<span class="token punctuation">(</span><span class="token string">'section1'</span>,<span class="token string">'age'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 获取指定节点指定key的value,由于age属性，所有我们选择了getint()方法。</span>18<span class="token operator">>></span><span class="token operator">></span> va2 <span class="token operator">=</span> config.has_section<span class="token punctuation">(</span><span class="token string">'section1'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 检查指定节点是否存在，返回True或False</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>va2<span class="token punctuation">)</span>True<span class="token operator">>></span><span class="token operator">></span> va3 <span class="token operator">=</span> config.has_option<span class="token punctuation">(</span><span class="token string">'section1'</span>,<span class="token string">'age'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 检查指定节点中是否存在某个key，返回True或False</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>va3<span class="token punctuation">)</span>True<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true">###增删改</span><span class="token operator">>></span><span class="token operator">></span> config.add_section<span class="token punctuation">(</span><span class="token string">'node'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 添加一个新节点node,此时节点尚未写入文件</span><span class="token operator">>></span><span class="token operator">></span> config.write<span class="token punctuation">(</span>open<span class="token punctuation">(</span><span class="token string">'config.ini'</span>,<span class="token string">'w'</span>,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">))</span> <span class="token comment" spellcheck="true"># 将添加的节点node写入配置文件</span><span class="token operator">>></span><span class="token operator">></span> config.remove_section<span class="token punctuation">(</span><span class="token string">'node'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 删除node节点，此时删除了内存中的节点node</span><span class="token operator">>></span><span class="token operator">></span> config.write<span class="token punctuation">(</span>open<span class="token punctuation">(</span><span class="token string">'config.ini'</span>,<span class="token string">'w'</span>,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">))</span> <span class="token comment" spellcheck="true"># 将删除节点node后的文件内容回写到配置文件</span><span class="token operator">>></span><span class="token operator">></span> config.set<span class="token punctuation">(</span><span class="token string">'section1'</span>,<span class="token string">'key1'</span>,<span class="token string">'val1'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 在已经存在的节点中添加一个键值对key1 = val1，如果节点不存在则报错，如果key已经存在，则修改value值</span><span class="token operator">>></span><span class="token operator">></span> config.write<span class="token punctuation">(</span>open<span class="token punctuation">(</span><span class="token string">'config.ini'</span>,<span class="token string">'w'</span>,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">))</span></code></pre><p>本文参考于<br><a href="https://xin053.github.io/2016/07/18/configparser%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">https://xin053.github.io/2016/07/18/configparser%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</a><br><a href="http://www.cnblogs.com/wang-yc/p/5620944.html" target="_blank" rel="noopener">http://www.cnblogs.com/wang-yc/p/5620944.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> module </tag>
            
            <tag> configparser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module-random-os-sys</title>
      <link href="/2017/10/29/python-module-random-os-sys-json/"/>
      <url>/2017/10/29/python-module-random-os-sys-json/</url>
      
        <content type="html"><![CDATA[<p>random()方法返回随机生成的一个实数，它在[0,1]范围内</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> randomrandom.random<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>random.randint<span class="token punctuation">(</span>1,2<span class="token punctuation">))</span>print<span class="token punctuation">(</span>random.randrange<span class="token punctuation">(</span>1,10<span class="token punctuation">))</span></code></pre><p>注意：random()是不能直接访问的，需要导入random模块，然后通过random静态对象调用该方法<br>生成随机验证码</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> randomcheckcode <span class="token operator">=</span> <span class="token string">''</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>4<span class="token punctuation">)</span>:    current <span class="token operator">=</span> random.randrange<span class="token punctuation">(</span>0,4<span class="token punctuation">)</span>    <span class="token keyword">if</span> current <span class="token operator">!=</span>i:        temp <span class="token operator">=</span> chr<span class="token punctuation">(</span>random.randint<span class="token punctuation">(</span>65,90<span class="token punctuation">))</span>    else:        temp <span class="token operator">=</span> random.randint<span class="token punctuation">(</span>0,9<span class="token punctuation">)</span>    checkcode +<span class="token operator">=</span> str<span class="token punctuation">(</span>temp<span class="token punctuation">)</span>print<span class="token punctuation">(</span>checkcode<span class="token punctuation">)</span></code></pre><a id="more"></a><p>os模块：提供对操作系统进行调用的接口</p><pre class=" language-bash"><code class="language-bash">os.getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span> 获取当前工作目录，即当前python脚本工作的目录路径os.chdir<span class="token punctuation">(</span><span class="token string">"dirname"</span><span class="token punctuation">)</span>  改变当前脚本工作目录；相当于shell下cdos.curdir  返回当前目录: <span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>os.pardir  获取当前目录的父目录字符串名：<span class="token punctuation">(</span><span class="token string">'..'</span><span class="token punctuation">)</span>os.makedirs<span class="token punctuation">(</span><span class="token string">'dirname1/dirname2'</span><span class="token punctuation">)</span>    可生成多层递归目录os.removedirs<span class="token punctuation">(</span><span class="token string">'dirname1'</span><span class="token punctuation">)</span>    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推os.mkdir<span class="token punctuation">(</span><span class="token string">'dirname'</span><span class="token punctuation">)</span>    生成单级目录；相当于shell中mkdir <span class="token function">dirname</span>os.rmdir<span class="token punctuation">(</span><span class="token string">'dirname'</span><span class="token punctuation">)</span>    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir <span class="token function">dirname</span>os.listdir<span class="token punctuation">(</span><span class="token string">'dirname'</span><span class="token punctuation">)</span>    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印os.remove<span class="token punctuation">(</span><span class="token punctuation">)</span>  删除一个文件os.rename<span class="token punctuation">(</span><span class="token string">"oldname"</span>,<span class="token string">"newname"</span><span class="token punctuation">)</span>  重命名文件/目录os.stat<span class="token punctuation">(</span><span class="token string">'path/filename'</span><span class="token punctuation">)</span>  获取文件/目录信息os.sep    输出操作系统特定的路径分隔符，win下为<span class="token string">"\\"</span>,Linux下为<span class="token string">"/"</span>os.linesep    输出当前平台使用的行终止符，win下为<span class="token string">"\t\n"</span>,Linux下为<span class="token string">"\n"</span>os.pathsep    输出用于分割文件路径的字符串os.name    输出字符串指示当前使用平台。win-<span class="token operator">></span><span class="token string">'nt'</span><span class="token punctuation">;</span> Linux-<span class="token operator">></span><span class="token string">'posix'</span>os.system<span class="token punctuation">(</span><span class="token string">"bash command"</span><span class="token punctuation">)</span>  运行shell命令，直接显示os.environ  获取系统环境变量os.path.abspath<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  返回path规范化的绝对路径os.path.split<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  将path分割成目录和文件名二元组返回os.path.dirname<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  返回path的目录。其实就是os.path.split<span class="token punctuation">(</span>path<span class="token punctuation">)</span>的第一个元素os.path.basename<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split<span class="token punctuation">(</span>path<span class="token punctuation">)</span>的第二个元素os.path.exists<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  如果path存在，返回True；如果path不存在，返回Falseos.path.isabs<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  如果path是绝对路径，返回Trueos.path.isfile<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  如果path是一个存在的文件，返回True。否则返回Falseos.path.isdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  如果path是一个存在的目录，则返回True。否则返回Falseos.path.join<span class="token punctuation">(</span>path1<span class="token punctuation">[</span>, path2<span class="token punctuation">[</span>, <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略os.path.getatime<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  返回path所指向的文件或者目录的最后存取时间os.path.getmtime<span class="token punctuation">(</span>path<span class="token punctuation">)</span>  返回path所指向的文件或者目录的最后修改时间</code></pre><p>sys模块</p><pre class=" language-bash"><code class="language-bash">sys.argv           命令行参数List，第一个元素是程序本身路径sys.exit<span class="token punctuation">(</span>n<span class="token punctuation">)</span>        退出程序，正常退出时exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span>sys.version        获取Python解释程序的版本信息sys.maxint         最大的Int值sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform       返回操作系统平台名称sys.stdout.write<span class="token punctuation">(</span><span class="token string">'please:'</span><span class="token punctuation">)</span>val <span class="token operator">=</span> sys.stdin.readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>:-1<span class="token punctuation">]</span></code></pre><p>json &amp;&amp; pickle模块<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</p><p>数据格式可以简单地理解为键值对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。<br>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。<br>Pyhton的Json模块提供了把内存中的对象序列化的方法。<br>json.dumps<br>dump的功能就是把Python对象encode为json对象，一个编码过程。注意json模块提供了json.dumps和json.dump方法，区别是dump直接到文件，而dumps到一个字符串，这里的s可以理解为string。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>import json<span class="token operator">>></span><span class="token operator">></span>date <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token keyword">:</span><span class="token string">'cntsp'</span>,<span class="token string">'age'</span>:23,<span class="token string">'homeland'</span><span class="token keyword">:</span><span class="token string">'henan'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span><span class="token string">"date:%s date's type:%s"</span> %<span class="token punctuation">(</span>date,type<span class="token punctuation">(</span>date<span class="token punctuation">))</span><span class="token punctuation">)</span>date:<span class="token punctuation">{</span><span class="token string">'age'</span><span class="token keyword">:</span> 23, <span class="token string">'name'</span><span class="token keyword">:</span> <span class="token string">'cntsp'</span>, <span class="token string">'homeland'</span><span class="token keyword">:</span> <span class="token string">'henan'</span><span class="token punctuation">}</span> <span class="token function">date</span><span class="token string">'s type:&lt;type '</span>dict<span class="token string">'>>>>date_string = json.dumps(date)>>>print("date_string:%s date_string type is:%s" %(date_string,type(date_string)))date_string:{"age": 23, "name": "cntsp", "homeland": "henan"} date_string type is:&lt;type '</span>str'<span class="token operator">></span></code></pre><p>json.dump<br>不仅可以把Python对象编码为string，还可以写入文件。因为我们不能把Python对象直接写入文件，这样会报错TypeError: expected a string or other character buffer object，我们需要将其序列化之后才可以。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>date <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token keyword">:</span><span class="token string">'cntsp'</span>,<span class="token string">'age'</span>:23,<span class="token string">'homeland'</span><span class="token keyword">:</span><span class="token string">'henan'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>with open<span class="token punctuation">(</span><span class="token string">'output.json'</span>,<span class="token string">'w'</span>,encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> as f1:<span class="token operator">>></span><span class="token operator">></span>    json.dump<span class="token punctuation">(</span>date,f1<span class="token punctuation">)</span></code></pre><p>json.loads<br>从Python内置对象dump为json对象我们知道如何操作了，那如何从json对象decode解码为Python可以识别的对象呢？是的用json.loads方法，当然这个是基于string的，如果是文件，我们可以用json.load方法</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>decoded_json <span class="token operator">=</span> json.loads<span class="token punctuation">(</span>date_string<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>print<span class="token punctuation">(</span>type<span class="token punctuation">(</span>decoded_json<span class="token punctuation">))</span></code></pre><p>json.load<br>可以直接load文件</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>with open<span class="token punctuation">(</span><span class="token string">'output.json'</span>,<span class="token string">'r'</span>,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> as f1:<span class="token operator">>></span><span class="token operator">></span>    print<span class="token punctuation">(</span>type<span class="token punctuation">(</span>f1<span class="token punctuation">))</span><span class="token operator">>></span><span class="token operator">></span>    loaded_json <span class="token operator">=</span> json.load<span class="token punctuation">(</span>fp<span class="token punctuation">)</span></code></pre><p>本文参考链接<a href="http://www.jianshu.com/p/e29611244810]" target="_blank" rel="noopener">http://www.jianshu.com/p/e29611244810</a></p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> module </tag>
            
            <tag> random </tag>
            
            <tag> os </tag>
            
            <tag> sys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module-time</title>
      <link href="/2017/10/29/python-module-time/"/>
      <url>/2017/10/29/python-module-time/</url>
      
        <content type="html"><![CDATA[<h1 id="Python中处理时间的模块主要有：time、datetime、和calendar等，本节主讲time模块。"><a href="#Python中处理时间的模块主要有：time、datetime、和calendar等，本节主讲time模块。" class="headerlink" title="Python中处理时间的模块主要有：time、datetime、和calendar等，本节主讲time模块。"></a>Python中处理时间的模块主要有：time、datetime、和calendar等，本节主讲time模块。</h1><p><strong>1</strong>  python中，通常有三种方式来表示时间：（1）时间戳（2）格式化的时间字符串（3）元组（struct_time）[元组有九个元素]<br><strong>2</strong>  UTC（Coordinated Universal Time, 世界协调时）亦即格林威治天文时间，世界标准时间,在中国为UTC+8. DST(Daylight Saving Time)即夏令时。<br><strong>3</strong>  时间戳（timestamp）的方式：通常来说，时间戳表示是从<strong>1970年1月1日00:00:00</strong>开始按秒计算的偏移量。type(time.time())为float类型。<br><strong>4</strong>  元组（struct_time)方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime(),localtime(),strptime()</p><h1 id="time模块中常用的函数："><a href="#time模块中常用的函数：" class="headerlink" title="time模块中常用的函数："></a>time模块中常用的函数：</h1><a id="more"></a><p>time.localtime([secs]):将一个时间戳转换为当前时区的struct_time.secs参数未给出，则以当前的time.time()时间为准。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token function">import</span> <span class="token function">time</span><span class="token operator">>></span><span class="token operator">></span> time.localtime<span class="token punctuation">(</span><span class="token punctuation">)</span>time.struct_time<span class="token punctuation">(</span>tm_year<span class="token operator">=</span>2017, tm_mon<span class="token operator">=</span>10, tm_mday<span class="token operator">=</span>29, tm_hour<span class="token operator">=</span>22, tm_min<span class="token operator">=</span>1, tm_sec<span class="token operator">=</span>43, tm_wday<span class="token operator">=</span>6, tm_yday<span class="token operator">=</span>302, tm_isdst<span class="token operator">=</span>0<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> time.localtime<span class="token punctuation">(</span>time.time<span class="token punctuation">(</span><span class="token punctuation">))</span>time.struct_time<span class="token punctuation">(</span>tm_year<span class="token operator">=</span>2017, tm_mon<span class="token operator">=</span>10, tm_mday<span class="token operator">=</span>29, tm_hour<span class="token operator">=</span>22, tm_min<span class="token operator">=</span>1, tm_sec<span class="token operator">=</span>53, tm_wday<span class="token operator">=</span>6, tm_yday<span class="token operator">=</span>302, tm_isdst<span class="token operator">=</span>0<span class="token punctuation">)</span></code></pre><p>time.gmtime([secs]):和localtime()方式类似，gmtime()方法是将一个时间戳转换未UTC时区(0时区)的struct_time.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> time.gmtime<span class="token punctuation">(</span><span class="token punctuation">)</span>time.struct_time<span class="token punctuation">(</span>tm_year<span class="token operator">=</span>2017, tm_mon<span class="token operator">=</span>10, tm_mday<span class="token operator">=</span>29, tm_hour<span class="token operator">=</span>14, tm_min<span class="token operator">=</span>5, tm_sec<span class="token operator">=</span>20, tm_wday<span class="token operator">=</span>6, tm_yday<span class="token operator">=</span>302, tm_isdst<span class="token operator">=</span>0<span class="token punctuation">)</span></code></pre><p>time.time():返回当前时间的时间戳。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> time.time<span class="token punctuation">(</span><span class="token punctuation">)</span>1509286008.533818<span class="token operator">>></span><span class="token operator">></span> </code></pre><p>time.mktime():将一个struct_time转化为时间戳。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> time.mktime<span class="token punctuation">(</span>time.localtime<span class="token punctuation">(</span><span class="token punctuation">))</span>1509286082.0<span class="token operator">>></span><span class="token operator">></span> </code></pre><p>time.sleep(secs):线程推迟指定的时间运行。单位为秒</p><p>time.ctime([secs]):把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> time.ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'Sun Oct 29 22:12:25 2017'</span><span class="token operator">>></span><span class="token operator">></span> time.ctime<span class="token punctuation">(</span>time.time<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token string">'Sun Oct 29 22:12:37 2017'</span></code></pre><p>time.strftime(format[,t]):把一个代表时间的元组或者struct_time(如由time.localtime()和time.gmtime()返回)转化为格式化的时间字符串。如果t未指定，将传入time.localtime().如果元组中任何一个元素越界，ValueError的错误将会被抛出</p><table><thead><tr><th>格式</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>%a</td><td>本地（local）简化星期名称</td><td></td></tr><tr><td>%A</td><td>本地完整星期名称</td><td></td></tr><tr><td>%b</td><td>本地简化月份名称</td><td></td></tr><tr><td>%B</td><td>本地完整月份名称</td><td></td></tr><tr><td>%c</td><td>本地相应的日期和时间表示</td><td></td></tr><tr><td>%d</td><td>一个月中的第几天（01-31）</td><td></td></tr><tr><td>%H</td><td>一天中的第几个小时（24小时制，00-23）</td><td></td></tr><tr><td>%l</td><td>第几个小时（12小时制，01-12）</td><td></td></tr><tr><td>%j</td><td>一年中的第几天（001-365）</td><td></td></tr><tr><td>%m</td><td>月份（01-12）</td><td></td></tr><tr><td>%M</td><td>分钟数（00-61）</td><td></td></tr><tr><td>%p</td><td>本地am或者pm的相应符</td><td>一</td></tr><tr><td>%S</td><td>秒（01-59）</td><td>二</td></tr><tr><td>%U</td><td>一年中的星期数。（00-53星期天是一个星期的开始）第一个星期天之前的所有天数都放在第0周</td><td>三</td></tr><tr><td>%w</td><td>一个星期中的第几天（0-6，0是星期天）</td><td></td></tr><tr><td>%W</td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td><td></td></tr><tr><td>%x</td><td>本地相应日期</td><td></td></tr><tr><td>%X</td><td>本地相应时间</td><td></td></tr><tr><td>%y</td><td>去掉世纪的年份（00-99）</td><td></td></tr><tr><td>%Y</td><td>完整的年份</td><td></td></tr><tr><td>%Z</td><td>时区的名字（如果不存在为空字符）</td><td></td></tr><tr><td>%%</td><td>‘%’字符</td><td></td></tr></tbody></table><p>备注</p><ol><li>%p只有与%l配合使用才有效果</li><li>文档中强调确实是0-61，而不是59，闰年秒占两秒</li><li>当使用strptime()函数时，只有当在这年中的周数和天数被确定的时候%U和%W才会被算</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> time.localtime<span class="token punctuation">(</span><span class="token punctuation">)</span>time.struct_time<span class="token punctuation">(</span>tm_year<span class="token operator">=</span>2017, tm_mon<span class="token operator">=</span>10, tm_mday<span class="token operator">=</span>29, tm_hour<span class="token operator">=</span>22, tm_min<span class="token operator">=</span>42, tm_sec<span class="token operator">=</span>34, tm_wday<span class="token operator">=</span>6, tm_yday<span class="token operator">=</span>302, tm_isdst<span class="token operator">=</span>0<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> time.strftime<span class="token punctuation">(</span><span class="token string">"%b %d %Y %H:%M:%S"</span>,time.localtime<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token string">'Oct 29 2017 22:42:38'</span></code></pre><p>time.strptime(string[,format]):把一个格式化时间字符串转化为struct_time.实际上就是strftime()的逆操作。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> time.strptime<span class="token punctuation">(</span><span class="token string">'2017-10-29 22:45:45'</span>,<span class="token string">'%Y-%m-%d %X'</span><span class="token punctuation">)</span>time.struct_time<span class="token punctuation">(</span>tm_year<span class="token operator">=</span>2017, tm_mon<span class="token operator">=</span>10, tm_mday<span class="token operator">=</span>29, tm_hour<span class="token operator">=</span>22, tm_min<span class="token operator">=</span>45, tm_sec<span class="token operator">=</span>45, tm_wday<span class="token operator">=</span>6, tm_yday<span class="token operator">=</span>302, tm_isdst<span class="token operator">=</span>-1<span class="token punctuation">)</span></code></pre><p>例如：7天后的格式为：xxxx-xx-xx 日期</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> time<span class="token punctuation">,</span>datetime<span class="token operator">>></span><span class="token operator">></span>severdayafter <span class="token operator">=</span> <span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>timestamp <span class="token operator">=</span> int<span class="token punctuation">(</span>time<span class="token punctuation">.</span>mktime<span class="token punctuation">(</span>severdayafter<span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>date <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y-%m-%d"</span><span class="token punctuation">,</span>time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token string">'2017-11-10'</span></code></pre><p>对time模块进行一个总结。在Python中共有三种表达方式：1）timestamp 2）tuple或者struct_time 3）格式化字符串。<br><img src="https://github.com/cntsp/cntsp.github.io/blob/master/images/time.png" alt="GitHub" title="python三种时间转化" width="50" height="50"></p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> module </tag>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadowsocks</title>
      <link href="/2017/10/02/vpn-shadowsocks/"/>
      <url>/2017/10/02/vpn-shadowsocks/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7-2-64位安装shadowsocks服务端"><a href="#centos7-2-64位安装shadowsocks服务端" class="headerlink" title="centos7.2 64位安装shadowsocks服务端"></a>centos7.2 64位安装shadowsocks服务端</h1><pre class=" language-bash"><code class="language-bash">$ curl <span class="token string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="token string">"get-pip.py"</span>$ python get-pip.py$ pip <span class="token function">install</span> --upgrade pip$ pip <span class="token function">install</span> shadowsocks$ <span class="token function">vi</span> /etc/shadowsocks.json<span class="token punctuation">{</span>    <span class="token string">"server"</span><span class="token keyword">:</span><span class="token string">"0.0.0.0"</span>,    <span class="token string">"server_port"</span>:8586,    <span class="token string">"local_address"</span><span class="token keyword">:</span> <span class="token string">"127.0.0.1"</span>,    <span class="token string">"local_port"</span>:1080,    <span class="token string">"password"</span><span class="token keyword">:</span><span class="token string">"cntsp"</span>,    <span class="token string">"timeout"</span>:600,    <span class="token string">"method"</span><span class="token keyword">:</span><span class="token string">"aes-256-cfb"</span>,    <span class="token string">"fast_open"</span><span class="token keyword">:</span> true,    <span class="token string">"workers"</span><span class="token keyword">:</span> 1<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># method为加密方法，可选aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</span><span class="token comment" spellcheck="true"># server_port为服务监听端口</span><span class="token comment" spellcheck="true"># password为密码，可使用密码生成工具生成一个随机密码</span>$ <span class="token function">vi</span>  /etc/systemd/system/shadowsocks.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Shadowsocks<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>TimeoutStartSec<span class="token operator">=</span>0ExecStart<span class="token operator">=</span>/usr/bin/ssserver -c /etc/shadowsocks.json<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><a id="more"></a><p>执行以下命令启动 shadowsocks 服务：</p><pre class=" language-bash"><code class="language-bash">$ systemctl <span class="token function">enable</span> shadowsocks$ systemctl start shadowsocks</code></pre><p>如果服务启动成功，则控制台显示的信息可能类似这样：<br>为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：</p><pre class=" language-bash"><code class="language-bash">systemctl status shadowsocks -l● shadowsocks.service - Shadowsocks   Loaded: loaded <span class="token punctuation">(</span>/etc/systemd/system/shadowsocks.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Fri 2017-09-29 14:27:30 CST<span class="token punctuation">;</span> 44s ago Main PID: 18957 <span class="token punctuation">(</span>ssserver<span class="token punctuation">)</span>   CGroup: /system.slice/shadowsocks.service           └─18957 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.jsonSep 29 14:27:30 iZj6c9klzk45d0qfxy88znZ systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Started Shadowsocks.Sep 29 14:27:30 iZj6c9klzk45d0qfxy88znZ systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Starting Shadowsocks<span class="token punctuation">..</span>.Sep 29 14:27:30 iZj6c9klzk45d0qfxy88znZ ssserver<span class="token punctuation">[</span>18957<span class="token punctuation">]</span>: INFO: loading config from /etc/shadowsocks.jsonSep 29 14:27:30 iZj6c9klzk45d0qfxy88znZ ssserver<span class="token punctuation">[</span>18957<span class="token punctuation">]</span>: 2017-09-29 14:27:30 INFO     loading libcrypto from libcrypto.so.10Sep 29 14:27:30 iZj6c9klzk45d0qfxy88znZ ssserver<span class="token punctuation">[</span>18957<span class="token punctuation">]</span>: 2017-09-29 14:27:30 INFO     starting server at 0.0.0.0:8586</code></pre><h1 id="centos7-2-64位安装shadowsocks客户端"><a href="#centos7-2-64位安装shadowsocks客户端" class="headerlink" title="centos7.2 64位安装shadowsocks客户端"></a>centos7.2 64位安装shadowsocks客户端</h1><pre class=" language-bash"><code class="language-bash">$ curl <span class="token string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="token string">"get-pip.py"</span>$ python get-pip.py$ pip <span class="token function">install</span> --upgrade pip$ pip <span class="token function">install</span> shadowsocks$ <span class="token function">vi</span> /etc/shadowsocks.json<span class="token punctuation">{</span>  <span class="token string">"server"</span><span class="token keyword">:</span><span class="token string">"x.x.x.x"</span>,             <span class="token comment" spellcheck="true">#你的 ss 服务器 ip</span>  <span class="token string">"server_port"</span>:8586,                <span class="token comment" spellcheck="true">#你的 ss 服务器端口</span>  <span class="token string">"local_address"</span><span class="token keyword">:</span> <span class="token string">"127.0.0.1"</span>,   <span class="token comment" spellcheck="true">#本地ip</span>  <span class="token string">"local_port"</span>:1080,              <span class="token comment" spellcheck="true">#本地端口</span>  <span class="token string">"password"</span><span class="token keyword">:</span><span class="token string">"cntsp"</span>,             <span class="token comment" spellcheck="true">#连接 ss 密码</span>  <span class="token string">"timeout"</span>:300,                  <span class="token comment" spellcheck="true">#等待超时</span>  <span class="token string">"method"</span><span class="token keyword">:</span><span class="token string">"aes-256-cfb"</span>,         <span class="token comment" spellcheck="true">#加密方式</span>  <span class="token string">"workers"</span><span class="token keyword">:</span> 1                    <span class="token comment" spellcheck="true">#工作线程数</span><span class="token punctuation">}</span></code></pre><p>启动：</p><pre class=" language-bash"><code class="language-bash">sslocal -c /etc/shadowsocks.json -d start </code></pre><p>测试是否连上ss的服务端<br>运行 curl –socks5 127.0.0.1:1080 <a href="http://httpbin.org/ip，如果返回你的" target="_blank" rel="noopener">http://httpbin.org/ip，如果返回你的</a> ss 服务器 ip 则测试成功：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"origin"</span><span class="token keyword">:</span> <span class="token string">"x.x.x.x"</span>       <span class="token comment" spellcheck="true">#你的 ss 服务器 ip</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻墙工具 </tag>
            
            <tag> shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day5</title>
      <link href="/2017/07/22/python-Day5/"/>
      <url>/2017/07/22/python-Day5/</url>
      
        <content type="html"><![CDATA[<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><h2 id="常用的正则表达式符号"><a href="#常用的正则表达式符号" class="headerlink" title="常用的正则表达式符号"></a>常用的正则表达式符号</h2><pre class=" language-python"><code class="language-python"><span class="token string">'.'</span>          默认匹配除\n之外的任意单个字符，若指定flag DOTALL，则匹配任意字符，包括换行<span class="token string">'^'</span>          匹配字符串开头<span class="token string">'$'</span>          匹配字符串的结尾，或e<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"foo$"</span><span class="token punctuation">,</span><span class="token string">"bfoo\nsdfsf"</span><span class="token punctuation">,</span>flags<span class="token operator">=</span>re<span class="token punctuation">.</span>MULTILINE<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>也可以<span class="token string">'*'</span>          匹配<span class="token operator">*</span>号前的字符<span class="token number">0</span>次或多次，re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"ab*"</span><span class="token punctuation">,</span><span class="token string">"cabb3abcbbac"</span><span class="token punctuation">)</span> 结果为<span class="token punctuation">[</span>‘abb’<span class="token punctuation">,</span><span class="token string">'ab'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token string">'+'</span>          匹配前一个字符<span class="token number">1</span>次或多次，re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"ab+"</span><span class="token punctuation">,</span><span class="token string">"ab+cd+abb+bba"</span><span class="token punctuation">)</span> 结果为<span class="token punctuation">[</span><span class="token string">'ab'</span><span class="token punctuation">,</span><span class="token string">'abb'</span><span class="token punctuation">]</span><span class="token string">'?'</span>          匹配前一个字符<span class="token number">1</span>次或<span class="token number">0</span>次<span class="token string">'{m}'</span>        匹配前一个字符m次<span class="token string">'{n,m}'</span>      匹配前一个字符n到m次，re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"ab{1,3}"</span><span class="token punctuation">,</span><span class="token string">"abb abc abbcbbb"</span><span class="token punctuation">)</span> 结果<span class="token punctuation">[</span><span class="token string">'abb'</span><span class="token punctuation">,</span><span class="token string">'ab'</span><span class="token punctuation">,</span><span class="token string">'abb'</span><span class="token punctuation">]</span><span class="token string">'|'</span>          匹配<span class="token operator">|</span>左或<span class="token operator">|</span>右的字符，re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"abc|ABC"</span><span class="token punctuation">,</span><span class="token string">"ABCBabcCD"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span> 结果 <span class="token string">'ABC'</span><span class="token string">'(...)'</span>      分组匹配，re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"(abc){2}a(123|456)c"</span><span class="token punctuation">,</span><span class="token string">"abcabc456c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span> 结果 abcabca456c<span class="token string">'\A'</span>         只从字符开头匹配，re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"\Aabc"</span><span class="token punctuation">,</span><span class="token string">"alexabc"</span><span class="token punctuation">)</span>是匹配不到的<span class="token string">'\Z'</span>         匹配字符结尾，同$<span class="token string">'\d'</span>         匹配数字<span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token string">'\D'</span>         匹配非数字<span class="token string">'\w'</span>         匹配<span class="token punctuation">[</span>A<span class="token operator">-</span>Za<span class="token operator">-</span>z0<span class="token number">-9</span><span class="token punctuation">]</span><span class="token string">'\W'</span>         匹配非<span class="token punctuation">[</span>A<span class="token operator">-</span>Za<span class="token operator">-</span>z0<span class="token number">-9</span><span class="token punctuation">]</span><span class="token string">'s'</span>          匹配空白字符、\t、\n、\r，re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"\s+"</span><span class="token punctuation">,</span><span class="token string">"ab\tc1\n3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span> 结果 <span class="token string">'\t'</span><span class="token string">'(?P&lt;name>...)'</span>  分组匹配 re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"(?P&lt;province>[0-9]{4})(?P&lt;city>[0-9]{2})(?P&lt;birthday>[0-9]{4})"</span><span class="token punctuation">,</span><span class="token string">"371481199306143242"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groupdict<span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">)</span> 结果<span class="token punctuation">{</span><span class="token string">'province'</span><span class="token punctuation">:</span> <span class="token string">'3714'</span><span class="token punctuation">,</span> <span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'81'</span><span class="token punctuation">,</span> <span class="token string">'birthday'</span><span class="token punctuation">:</span> <span class="token string">'1993'</span><span class="token punctuation">}</span></code></pre><a id="more"></a><p>python中的 \ 困惑</p><p>正则表达式里使用”&quot;作为转义字符，这就可能造成一些问题，比如我们需要匹配文件中的字符”&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\“表示。同样，匹配一个数字的”\d”可以写成r”\d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><h2 id="re模块中常用的方法"><a href="#re模块中常用的方法" class="headerlink" title="re模块中常用的方法"></a>re模块中常用的方法</h2><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h3><p>re.search 方法会在字符串内查找模式匹配，直到找到第一个匹配立刻返回，如果字符串中没有匹配，则返回None</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>help<span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">)</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>string<span class="token punctuation">,</span>flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>通过扫描字符串查找与正则表达式模式相匹配的第一个位置，并返回相应的匹配对象，如果字符串中没有位置匹配到模式，就返回None；注意这不同于在字符串中的某一点找到零长度匹配</p><p>第一个参数：正则匹配规则</p><p>第二个参数：表示要匹配的字符串</p><p>第三个参数：标志位，用于控制正则表达式的匹配方式</p><p>举例：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>name <span class="token operator">=</span> <span class="token string">"Hello world, I am coming!"</span><span class="token operator">>></span><span class="token operator">></span>s <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>r<span class="token string">'(\w+) (\w+)'</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">if</span> s<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'\n'</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"not search"</span><span class="token punctuation">)</span>Hello world Hello</code></pre><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><p>re.match(pattern,string,flags=0)</p><p>如果在字符串的开始有0或更多字符匹配于正则表达式模式，就返回一个<code>匹配对象</code>，如果字符串的开始不匹配于模式，就返回<code>None</code>; 注意这不同于一个0长度的匹配</p><p>Note that even in MULTILINE mode, re.match() will only match at the beginning of the string and not at the beginning of each line.</p><p>If you want to locate a match anywhere in string, use search() instead</p><p>第一个参数：匹配规则</p><p>第二个参数：表示要匹配的字符串</p><p>第三个参数：标志位，用于控制正则表达式的匹配方式</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>name <span class="token operator">=</span> <span class="token string">"Hello world, I am coming!"</span><span class="token operator">>></span><span class="token operator">></span>s <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">'(H..)'</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">if</span> s<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'\n'</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"not match!"</span><span class="token punctuation">)</span>HelHel</code></pre><p>re.match与re.search的不同：re.match按照模式只匹配字符串的开始，匹配到返回一个<code>match object</code>,匹配不到返回<code>None</code>,而re.search从开始往后扫描搜索整个字符串开始匹配，直到匹配到第一个莫斯字串</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h3><p>re.findall(pattern,string,flags=0)</p><p>返回字串中全部的非重叠的匹配模式，作为一个字串的列表，这字符串从左到右开始扫描，匹配到的按照找到的次序返回。如果模式中存在一个或多个组，则返回组的列表，如果模式有多个组，这将是一个元组的列表。</p><p><code>Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match</code></p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>mail <span class="token operator">=</span> <span class="token string">'&lt;user01@gmail.com &lt;user02@gmail.com> user03@gmail.com'</span>  <span class="token comment" spellcheck="true">#注意字符串</span><span class="token operator">>></span><span class="token operator">></span>s <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'(\w+@gm....[a-z]{3})'</span><span class="token punctuation">,</span>mail<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token string">'user01@gmail.com'</span><span class="token punctuation">,</span><span class="token string">'user02@gmail.com'</span><span class="token punctuation">,</span><span class="token string">'user03@gmail.com'</span><span class="token punctuation">]</span></code></pre><h3 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub"></a>re.sub</h3><p><code>re.sub(pattern,repl,string,count=0,flags=0)</code></p><p>Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, <code>\n</code>is converted to a single newline character,<code>\r</code> is converted to a carriage return, and so forth. Unknown escapes such as <code>\j</code>are left alone. Backreferences, such as<code>\6</code>, are replaced with the substring matched by group 6 in the pattern.</p><p> For example:</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):'</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        r<span class="token string">'static PyObject*\npy_\1(void)\n{'</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token string">'def myfunc():'</span><span class="token punctuation">)</span><span class="token string">'static PyObject*\npy_myfunc(void)\n{'</span></code></pre><p>If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single match object argument, and returns the replacement string. </p><p>For example:</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">dashrepl</span><span class="token punctuation">(</span>matchobj<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> matchobj<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">'-'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'-{1,2}'</span><span class="token punctuation">,</span> dashrepl<span class="token punctuation">,</span> <span class="token string">'pro----gram-files'</span><span class="token punctuation">)</span><span class="token string">'pro--gram files'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'\sAND\s'</span><span class="token punctuation">,</span> <span class="token string">' &amp; '</span><span class="token punctuation">,</span> <span class="token string">'Baked Beans And Spam'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">)</span><span class="token string">'Baked Beans &amp; Spam'</span></code></pre><p><code>The pattern may be a string or an RE object.</code></p><p>第一个参数：匹配规则</p><p>第二个参数：替换后的字符串</p><p>第三个参数： 字符串</p><p>第四个参数： 替换个数。默认为0，表示每个匹配项都替换</p><p>第五个参数： 标志位</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> test<span class="token operator">=</span><span class="token string">"Hi, nice to meet you where are you from?"</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'\s'</span><span class="token punctuation">,</span><span class="token string">'-'</span><span class="token punctuation">,</span>test<span class="token punctuation">)</span><span class="token string">'Hi,-nice-to-meet-you-where-are-you-from?'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'\s'</span><span class="token punctuation">,</span><span class="token string">'-'</span><span class="token punctuation">,</span>test<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true">#替换至第5个</span><span class="token string">'Hi,-nice-to-meet-you-where are you from?'</span></code></pre><h3 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h3><p><code>re.split(pattern,string,maxsplit=0)</code></p><p>第一个参数：匹配规则</p><p>第二个参数：字符串</p><p>第三个参数：最大分割字符串，默认为0，表示每项都分隔</p><p><code>Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list.</code></p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> test<span class="token operator">=</span><span class="token string">"Hi, nice to meet you where are you from?"</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">"\s+"</span><span class="token punctuation">,</span>test<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Hi,'</span><span class="token punctuation">,</span> <span class="token string">'nice'</span><span class="token punctuation">,</span> <span class="token string">'to'</span><span class="token punctuation">,</span> <span class="token string">'meet'</span><span class="token punctuation">,</span> <span class="token string">'you'</span><span class="token punctuation">,</span> <span class="token string">'where'</span><span class="token punctuation">,</span> <span class="token string">'are'</span><span class="token punctuation">,</span> <span class="token string">'you'</span><span class="token punctuation">,</span> <span class="token string">'from?'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">"\s+"</span><span class="token punctuation">,</span>test<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">#分割前5个</span><span class="token punctuation">[</span><span class="token string">'Hi,'</span><span class="token punctuation">,</span> <span class="token string">'nice'</span><span class="token punctuation">,</span> <span class="token string">'to'</span><span class="token punctuation">,</span> <span class="token string">'meet'</span><span class="token punctuation">,</span> <span class="token string">'you'</span><span class="token punctuation">,</span> where are you <span class="token keyword">from</span>?'<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\W+'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'(\W+)'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\W+'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">'words, words.'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'[a-f]+'</span><span class="token punctuation">,</span> <span class="token string">'0a3B9'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">]</span></code></pre><p><code>If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:</code></p><p>如果分隔符中存在捕获组，并且在字符串开头匹配，则结果将以空字符串开头。 字符串的结尾同样适用：</p><p>for example:</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'(\W+)'</span><span class="token punctuation">,</span> <span class="token string">'...words, words...'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span></code></pre><p><code>Note that split will never split a string on an empty pattern match. For example:</code></p><p>请注意，split不会在空模式匹配上拆分字符串。 例如：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'x*'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"(?m)^$"</span><span class="token punctuation">,</span> <span class="token string">"foo\n\nbar\n"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'foo\n\nbar\n'</span><span class="token punctuation">]</span></code></pre><h3 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile"></a>re.compile</h3><p><code>re.complie(pattern,flags=0)</code></p><p>Compile a regular expression pattern into a <code>regular expression object</code>, which can be used for matching using its <code>match()</code>and <code>search()</code>methods, described below.</p><p>The expression’s behaviour can be modified by specifying a flags value. Values can be any of the following variables, combined using bitwise OR (the | operator).</p><p>The sequence</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>prog <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>result <span class="token operator">=</span> prog<span class="token punctuation">.</span>match<span class="token punctuation">(</span>string<span class="token punctuation">)</span></code></pre><p>is equivalent to</p><pre class=" language-python"><code class="language-python">result <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">)</span></code></pre><p><code>but using re.compile() and saving the resulting regular expression object for reuse is more efficient when the expression will be used several times in a single program.</code></p><p>但是当单个程序中的表达式被多次使用时，使用re.compile（）和保存生成的正则表达式对象进行重用会更有效率。</p><p><code>Note The compiled versions of the most recent patterns passed to re.compile() and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn’t worry about compiling regular expressions.</code></p><p>注意传递给re.compile（）和模块级匹配函数的最新模式的编译版本被缓存，因此一次只使用少数正则表达式的程序不必担心编译正则表达式。</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> module </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-firewall</title>
      <link href="/2017/07/10/centos7-firewall/"/>
      <url>/2017/07/10/centos7-firewall/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7系统上firewalld的坑"><a href="#centos7系统上firewalld的坑" class="headerlink" title="centos7系统上firewalld的坑"></a>centos7系统上firewalld的坑</h1><p>事故：线上环境中部署的是docker(事先不知道容器的ip地址转发依赖于防火墙)容器，并使用rancher(docker web管理工具)管理的，当自己由于部署zabbix_agentd把防火墙关闭时，容器里的resin服务都不可以访问了<br>处理过程：立即启动防火墙，然后在rancher web管理界面重启容器</p><h1 id="在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd-command-或firewall-config-gui-来动态的管理kernel-netfilter的临时或永久的接口规则，并实时生效而无需重启服务"><a href="#在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd-command-或firewall-config-gui-来动态的管理kernel-netfilter的临时或永久的接口规则，并实时生效而无需重启服务" class="headerlink" title="在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd(command)或firewall-config(gui)来动态的管理kernel netfilter的临时或永久的接口规则，并实时生效而无需重启服务"></a>在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd(command)或firewall-config(gui)来动态的管理kernel netfilter的临时或永久的接口规则，并实时生效而无需重启服务</h1><a id="more"></a><h2 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h2><p>Firewall 能将不同的网络连接归类到不同的信任级别，Zone提供了一下几个级别</p><blockquote><ul><li>drop:丢弃所有进入的包，而不给出任何响应</li><li>block:拒绝所有外部发起的连接，允许内部发起的连接</li><li>public:允许指定的进入连接</li><li>external:同上，对伪装的进入连接，一般用于路由转发</li><li>dmz:允许受限制的进入连接</li><li>work:允许受信任的计算机被限制的进入连接，类似workgroup</li><li>home:同上，类似homegroup</li><li>internal:同上，范围针对所有互联网用户</li><li>trusted:信任所有连接</li></ul></blockquote><h2 id="过滤规则"><a href="#过滤规则" class="headerlink" title="过滤规则"></a>过滤规则</h2><blockquote><ul><li>source:根据源地址过滤</li><li>interface:根据网卡过滤</li><li>service:根据服务名过滤</li><li>port:根据端口过滤</li><li>icmp-block:icmp报文过滤，按照icmp类型配置</li><li>masquerade:ip地址伪装</li><li>forward-port:端口转发</li><li>rule:自定义规则<br>其中，过滤规则的优先级遵循如下顺序</li></ul><p>1.source<br>2.interface<br>3.firewalld.conf</p></blockquote><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><pre class=" language-bash"><code class="language-bash">systemctl start   firewalld    <span class="token comment" spellcheck="true">#启动</span>systemctl <span class="token function">enable</span>  firewalld    <span class="token comment" spellcheck="true">#开机启动</span>systemctl stop    firewalld    <span class="token comment" spellcheck="true">#关闭</span>systemctl disable firewalld    <span class="token comment" spellcheck="true">#取消开机启动</span></code></pre><p>具体的规则管理，可以使用firewall-cmd，具体的使用方法可以</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --help--zone<span class="token operator">=</span>NAME       <span class="token comment" spellcheck="true">#指定 zone</span>--permanent       <span class="token comment" spellcheck="true">#永久修改，--reload 后生效</span>--timeout<span class="token operator">=</span>seconds <span class="token comment" spellcheck="true">#持续效果，到期后自动移除，用于调试，不能与--permanent 同时使用</span></code></pre><h2 id="1-查看规则"><a href="#1-查看规则" class="headerlink" title="1 查看规则"></a>1 查看规则</h2><p>查看运行状态</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --state</code></pre><p>查看已被激活的Zone信息</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-active-zonepublic   interfaces:eth0 eth1</code></pre><p>查看指定级别的接口</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-interfaceseth0</code></pre><p>查看指定级别的所有信息，譬如public</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-allpublic <span class="token punctuation">(</span>default,active<span class="token punctuation">)</span>  interfaces：eth0  sources:  ports:  masquerade:no  forward-ports:  icmp-blocks:  rich rules:</code></pre><p>查看所有级别被允许的信息</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-service</code></pre><p>查看重启后所有Zones级别中被允许的服务，即永久放行的服务</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-service --permanent</code></pre><h2 id="2-管理规则"><a href="#2-管理规则" class="headerlink" title="2 管理规则"></a>2 管理规则</h2><pre class=" language-bash"><code class="language-bash">firewall-cmd --panic-on          <span class="token comment" spellcheck="true">#丢弃</span>firewall-cmd --panic-off         <span class="token comment" spellcheck="true">#取消丢弃</span>firewall-cmd --reload            <span class="token comment" spellcheck="true">#更新规则，不重启服务</span>firewall-cmd --complete-reload   <span class="token comment" spellcheck="true">#更新规则，重启服务</span></code></pre><p>添加某接口至某信任等级，譬如添加eth0至public，永久修改</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>public --add-interface<span class="token operator">=</span>eth0 --permanent</code></pre><p>设置public为默认的信任级别</p><h3 id="a-管理端口"><a href="#a-管理端口" class="headerlink" title="a 管理端口"></a>a 管理端口</h3><p>列出dmz 级别的被允许的进入端口</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>dmz --list-ports</code></pre><p>允许tcp端口8080至dmz级别</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>dmz --add-port<span class="token operator">=</span>8080/tcp</code></pre><p>允许某范围的udp端口至public级别，并永久生效</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>10050-10051/udp --permanent</code></pre><h3 id="b-网卡接口"><a href="#b-网卡接口" class="headerlink" title="b 网卡接口"></a>b 网卡接口</h3><p>列出public zone所有网卡</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-interfaces</code></pre><p>将eth0添加至public zone,永久</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --permanent --add-interface<span class="token operator">=</span>eth0</code></pre><p>eth0存在与public zone，将该网卡添加至work zone，并将之从public zone中删除</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>work --permanent --change-interface<span class="token operator">=</span>eth0</code></pre><p>删除public zone中的eth0，永久</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --permanent --remove-interface<span class="token operator">=</span>eth0</code></pre><h3 id="c-管理服务"><a href="#c-管理服务" class="headerlink" title="c 管理服务"></a>c 管理服务</h3><p>添加smtp服务至work zone</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>work --add-service<span class="token operator">=</span>smtp</code></pre><p>移除work zone中的smtp服务</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>work --remove-service<span class="token operator">=</span>smtp</code></pre><h3 id="d-配置external-zone中的ip地址伪装"><a href="#d-配置external-zone中的ip地址伪装" class="headerlink" title="d 配置external zone中的ip地址伪装"></a>d 配置external zone中的ip地址伪装</h3><p>查看</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>external --query-masquerade</code></pre><p>打开伪装</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>external --add-masquerade</code></pre><p>关闭伪装</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>external --remove-masquerade</code></pre><h3 id="e-配置public-zone的端口转发"><a href="#e-配置public-zone的端口转发" class="headerlink" title="e 配置public zone的端口转发"></a>e 配置public zone的端口转发</h3><p>打开端口转发，则需要先</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-forward-port<span class="token operator">=</span>port<span class="token operator">=</span>22:proto<span class="token operator">=</span>tcp:toport<span class="token operator">=</span>3753</code></pre><p>转发22端口数据至另一个ip相同端口上</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-forward-port<span class="token operator">=</span>port<span class="token operator">=</span>22:proto<span class="token operator">=</span>tcp:toaddr<span class="token operator">=</span>192.168.1.100</code></pre><p>转发 22 端口数据至另一 ip 的 2055 端口上</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-forward-port<span class="token operator">=</span>port<span class="token operator">=</span>22:proto<span class="token operator">=</span>tcp:toport<span class="token operator">=</span>2055:toaddr<span class="token operator">=</span>192.168.1.100</code></pre><h3 id="f-配置public-zone的icmp"><a href="#f-配置public-zone的icmp" class="headerlink" title="f 配置public zone的icmp"></a>f 配置public zone的icmp</h3><p>查看所有支持的icmp类型</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-icmptypesdestination-unreachable echo-reply echo-request parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded</code></pre><p>列出</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-icmp-blocks</code></pre><p>添加echo-request屏蔽</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-icmp-block<span class="token operator">=</span>echo-request <span class="token punctuation">[</span>--timeout<span class="token operator">=</span>seconds<span class="token punctuation">]</span></code></pre><p>移除 echo-reply 屏蔽</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --remove-icmp-block<span class="token operator">=</span>echo-reply</code></pre><h3 id="g-IP封禁"><a href="#g-IP封禁" class="headerlink" title="g IP封禁"></a>g IP封禁</h3><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --add-rich-rule<span class="token operator">=</span><span class="token string">"rule family='ipv4' source address='222.222.222.222' reject"</span></code></pre><p>当然，我们仍然可以通过 ipset 来封禁 ip<br>封禁 ip</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --zone<span class="token operator">=</span>public --new-ipset<span class="token operator">=</span>blacklist --type<span class="token operator">=</span>hash:ipfirewall-cmd --permanent --zone<span class="token operator">=</span>public --ipset<span class="token operator">=</span>blacklist --add-entry<span class="token operator">=</span>222.222.222.222</code></pre><p>封禁网段</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --zone<span class="token operator">=</span>public --new-ipset<span class="token operator">=</span>blacklist --type<span class="token operator">=</span>hash:netfirewall-cmd --permanent --zone<span class="token operator">=</span>public --ipset<span class="token operator">=</span>blacklist --add-entry<span class="token operator">=</span>222.222.222.0/24</code></pre><p>倒入 ipset 规则</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --zone<span class="token operator">=</span>public --new-ipset-from-file<span class="token operator">=</span>/path/blacklist.xml``<span class="token variable"><span class="token variable">`</span> <span class="token function">bash</span>然后封禁 blacklist<span class="token variable">`</span></span>`` <span class="token function">bash</span>firewall-cmd --permanent --zone<span class="token operator">=</span>public --add-rich-rule<span class="token operator">=</span><span class="token string">'rule source ipset=blacklist drop'</span></code></pre><p>重新载入以生效</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --reload</code></pre><p><a href="https://havee.me/linux/2015-01/using-firewalls-on-centos-7.html" target="_blank" rel="noopener">文章转载至：</a></p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firewall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day4</title>
      <link href="/2017/07/04/python-Day4/"/>
      <url>/2017/07/04/python-Day4/</url>
      
        <content type="html"><![CDATA[<p>装饰器：<br>定义：本质是函数,(装饰其他函数)就是为其它函数添加附加功能<br>原则：1.不能修改被装饰的函数的源代码<br>      2.不能修改被装饰函数的的调用方式</p><p>实现装饰器知识储备：<br>1.函数即”变量”<br>2.高阶函数<br>    a: 把一个函数名当作实参传给另外一个函数(不修改被装饰函数源代码的情况下，为其添加功能)<br>    b: 返回值中包含函数名(不修改函数的调用方式)<br>    (语法糖)<br>3.嵌套函数</p><p>高阶函数+嵌套函数=&gt;&gt;装饰器</p><p>生成器：只有在调用时才会生成相应的数据<br>只记录当前位置<br>只有一个<strong>next</strong>方法</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day3</title>
      <link href="/2017/06/22/python-Day3/"/>
      <url>/2017/06/22/python-Day3/</url>
      
        <content type="html"><![CDATA[<p>定义：函数是指将一组语句的集合通过一个名字(函数名)封装起来，要想执行这个函数，只需调用其函数名即可<br>特性：<br>1 减少重复代码<br>2 使程序变的可扩展<br>3 使程序变得易维护<br>语法定义:</p><pre class=" language-bash"><code class="language-bash">def sayhi<span class="token punctuation">(</span><span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#函数名</span>    print<span class="token punctuation">(</span><span class="token string">"hello, I'm nobody!"</span><span class="token punctuation">)</span>sayhi<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用函数</span>def calc<span class="token punctuation">(</span>x,y<span class="token punctuation">)</span>:    res <span class="token operator">=</span> x**y    <span class="token keyword">return</span> resc <span class="token operator">=</span> calc<span class="token punctuation">(</span>a,b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#结果赋值给c变量</span>print<span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><a id="more"></a><h1 id="函数参数与局部变量"><a href="#函数参数与局部变量" class="headerlink" title="函数参数与局部变量"></a>函数参数与局部变量</h1><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元，因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量<br>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，他们都必须有确定的值，以便这些值传送给形参。因此应预先用赋值，输入等办法使参数获得确定值</p><pre class=" language-bash"><code class="language-bash">def calc<span class="token punctuation">(</span>x,y<span class="token punctuation">)</span>:    res <span class="token operator">=</span> x**y    <span class="token keyword">return</span> resc <span class="token operator">=</span> calc<span class="token punctuation">(</span>a,b<span class="token punctuation">)</span>print<span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><p>默认参数<br>def stu_register(name,age,country,course):<br>    print(“—–注册学生信息—–”)<br>    print(“姓名:”,name)<br>    print(“age:”,age)<br>    print(“国籍:”,country)<br>    print(“课程:”,course)<br>stu_register(“wangshanpao”,25,”CN”,”python_devops”)<br>像国籍这种信息，你不填写，默认就会是中国，这就是通过默认参数实现的，把country变成默认参数非常简单<br>def stu_register(name,age,course,country=”CN”):<br>不指定country，就是默认就是CN，把country变成默认参数后，移动位置参数后面<br>关键参数<br>正常情况下，给函数传参数要按顺序，不想按顺序就可以用关键参数，只需指定参数名即可，但记住一个要求是，关键参数必须放在位置参数之后<br>stu_register(age=22,name=’alex’,course=”python”)<br>非固定参数<br>若你的函数在定义时不确定用户想传入多少个参数，就可以使用非固定参数</p><pre class=" language-bash"><code class="language-bash">def stu_register<span class="token punctuation">(</span>name,age,*args<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#*args会把多传入的参数变成一个元组形式</span>    print<span class="token punctuation">(</span>name,age,args<span class="token punctuation">)</span>stu_register<span class="token punctuation">(</span><span class="token string">"Alex"</span>,22<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出</span><span class="token comment" spellcheck="true">#Alex 22 ()#后面这个()就是args，只是因为没传值，所以为空</span>``` <span class="token function">bash</span>stu_register<span class="token punctuation">(</span><span class="token string">"Jack"</span>,32,<span class="token string">"CN"</span>,<span class="token string">"Python"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出</span><span class="token comment" spellcheck="true">#Jack 32 ('CN','Python')</span></code></pre><p>还可以有一个**kwargs</p><pre class=" language-bash"><code class="language-bash">def stu_register<span class="token punctuation">(</span>name,age,*args,**kwargs<span class="token punctuation">)</span>:    print<span class="token punctuation">(</span>name,age,args,kwargs<span class="token punctuation">)</span>stu_register<span class="token punctuation">(</span><span class="token string">"Alex"</span>,22<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出</span><span class="token comment" spellcheck="true">#Alex 22 () #后面这个()就是kwargs,只是因为没传值，所以为空</span>stu_register<span class="token punctuation">(</span><span class="token string">"Jack"</span>,32,<span class="token string">"CN"</span>,<span class="token string">"Python"</span>,sex<span class="token operator">=</span><span class="token string">"Male"</span>,provice<span class="token operator">=</span><span class="token string">"ShanDong"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出</span><span class="token comment" spellcheck="true"># Jack 32 ('CN','Python') {'provice':'ShanDong','sex':'Male'}</span></code></pre><h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><pre class=" language-bash"><code class="language-bash">name <span class="token operator">=</span> <span class="token string">"Alex Li"</span>def change_name<span class="token punctuation">(</span>name<span class="token punctuation">)</span>:    print<span class="token punctuation">(</span><span class="token string">"before change:"</span>,name<span class="token punctuation">)</span>    name <span class="token operator">=</span> <span class="token string">"金角大王，一个有Tesla的男人"</span>    print<span class="token punctuation">(</span><span class="token string">"after change"</span>,name<span class="token punctuation">)</span>change_name<span class="token punctuation">(</span>name<span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"在外面看看name改了吗"</span>,name<span class="token punctuation">)</span></code></pre><h1 id="全局与局部变量"><a href="#全局与局部变量" class="headerlink" title="全局与局部变量"></a>全局与局部变量</h1><p>在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量<br>全局变量作用域时整个程序，局部变量作用域是定义该变量的子程序<br>当全局变量与局部变量同名时<br>在定义局部变量的子程序内，局部变量起作用；在其它地方局部变量起作用<br>返回值<br>要想获取函数的执行结果，就可以用return语句把结果返回<br>注意:<br>1 函数在执行过程中只要遇到return语句，就回停止执行并返回结果，so也可以理解为return语句代表着函数的结束<br>2 如果未在函数中指定return，那这个函数的返回值未None</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>在函数内部，可以调用其它函数，如果一个函数在内部调用自身，这个函数就是递归函数</p><pre class=" language-bash"><code class="language-bash">def calc<span class="token punctuation">(</span>n<span class="token punctuation">)</span>:    print<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">if</span> int<span class="token punctuation">(</span>n/2<span class="token punctuation">)</span> <span class="token operator">==</span> 0:        <span class="token keyword">return</span> n    <span class="token keyword">return</span> calc<span class="token punctuation">(</span>int<span class="token punctuation">(</span>n/2<span class="token punctuation">))</span>calc<span class="token punctuation">(</span>10<span class="token punctuation">)</span></code></pre><p>递归特性：<br>1 必须有一个明确的结束条件<br>2 每次进入更深一层递归时，问题规模相比上次递归都应有所减少<br>3 递归效率不高，递归层次过多会导致栈溢出(在计算机中，函数调用是通过栈(stack)这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限，所以，递归调用的次数过多，会导致栈溢出)<br>匿名函数<br>匿名函数就是不需要显示的指定函数<br>def calc(n):<br>    return n**n<br>print(calc(10))</p><p>#换成匿名函数<br>calc = lambda n:n**n<br>print(calc(10))</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day2</title>
      <link href="/2017/06/18/python-Day2/"/>
      <url>/2017/06/18/python-Day2/</url>
      
        <content type="html"><![CDATA[<h1 id="列表、元组操作"><a href="#列表、元组操作" class="headerlink" title="列表、元组操作"></a>列表、元组操作</h1><p>列表不同于元组和字符串的地方：列表是可变的–可以改变列表的内容，并且列表有很多有用的、专门的方法。<br>基本的列表操作</p><h2 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>list<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'h'</span>,<span class="token string">'e'</span>,<span class="token string">'l'</span>,<span class="token string">'l'</span>,<span class="token string">'0'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#注意，list函数适用于所有类型的序列，而不只是字符串</span></code></pre><h2 id="改变列表：元素赋值"><a href="#改变列表：元素赋值" class="headerlink" title="改变列表：元素赋值"></a>改变列表：元素赋值</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token operator">=</span> 5<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>1,5,3<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#注意 不能为一个位置不存在的元素进行赋值。如果的列表长度为2，那么不能为索引为100的元素进行赋值。如果要那样做，就必须创建一个长度为101(或者更长)的列表</span></code></pre><a id="more"></a><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>从列表中删除元素很容易，使用del语句：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Alice'</span>,<span class="token string">'Beth'</span>,<span class="token string">'Cecil'</span>,<span class="token string">'Dee-Dee'</span>,<span class="token string">'Earl'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> del names<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> names<span class="token punctuation">[</span><span class="token string">'Alice'</span>,<span class="token string">'Beth'</span>,<span class="token string">'Dee-Dee'</span>,<span class="token string">'Earl'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#注意 Cecil是如何彻底消失的，并且列表的长度也变成了4.del除了可以删除列表中的元素，还可以删除字典元素，甚至是其它变量</span></code></pre><h2 id="分片赋值"><a href="#分片赋值" class="headerlink" title="分片赋值"></a>分片赋值</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> name <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token string">'Perl'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> name<span class="token punctuation">[</span><span class="token string">'P'</span>,<span class="token string">'e'</span>,<span class="token string">'r'</span>,<span class="token string">'l'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> name<span class="token punctuation">[</span>2:<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token string">'ar'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> name<span class="token punctuation">[</span><span class="token string">'P'</span>,<span class="token string">'e'</span>,<span class="token string">'a'</span>,<span class="token string">'r'</span><span class="token punctuation">]</span></code></pre><p>列表方法</p><h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><p>append方法用于在列表末尾追加新的对象</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> lst <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> lst.append<span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> lst<span class="token punctuation">[</span>1,2,3,4<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#为啥我选择了如此糟糕的变量名lst，而不是使用list来表示一个列表呢？原因在于list是一个内键函数[^LaTeX].如果使用list作为变量名，我就无法调用list函数了。根据给定的应用程序可以定义更好的变量名，像lst这种变量名是毫无益处的。如果要定义一个价格的列表，那么就应该使用prices、prices_of_eggs，或者priceOfEggs作为变量名</span>注意：<span class="token punctuation">[</span>^LaTeX<span class="token punctuation">]</span>从python2.2开始，list就是一个类型而不是一个函数了。<span class="token punctuation">(</span>tuple和str也是如此<span class="token punctuation">)</span></code></pre><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>count方法统计某个元素在列表中出现的次数：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">[</span><span class="token string">'to'</span>,<span class="token string">'be'</span>,<span class="token string">'or'</span>,<span class="token string">'not'</span>,<span class="token string">'to'</span>,<span class="token string">'be'</span><span class="token punctuation">]</span>.count<span class="token punctuation">(</span><span class="token string">'to'</span><span class="token punctuation">)</span>2<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>1,2<span class="token punctuation">]</span>,1,1,<span class="token punctuation">[</span>2,1,<span class="token punctuation">[</span>1,2<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x.count<span class="token punctuation">(</span>1<span class="token punctuation">)</span>2<span class="token operator">>></span><span class="token operator">></span> x.count<span class="token punctuation">(</span><span class="token punctuation">[</span>1,2<span class="token punctuation">]</span><span class="token punctuation">)</span>1</code></pre><h2 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h2><p>extend方法可以在列表的末尾一次性追加另一个序列中的多个值。换句话，可以用新列表扩展原有的列表：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">[</span>4,5,6<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a.extend<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span>1,2,3,4,5,6<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#这个操作看起来很像链接操作，两者最主要的区别在于：extend方法修改了被扩展的序列(在这个例子中，就是a)而原始的链接操作则不然，它会返回一个全新的列表：</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">[</span>4,5,6<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a + b<span class="token punctuation">[</span>1,2,3,4,5,6<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#我们可以看到被连接的列表与之前例子中被扩展的列表是一样的，但是这一次它并没有被修改。这是因为原始的连接操作创建了一个包含了a和b副本的新列表</span></code></pre><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>index方法用于从列表中找出某个值第一个匹配项的索引位置:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> knights <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'We'</span>,<span class="token string">'are'</span>,<span class="token string">'the'</span>,<span class="token string">'knights'</span>,<span class="token string">'who'</span>,<span class="token string">'say'</span>,<span class="token string">'ni'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> knights.index<span class="token punctuation">(</span><span class="token string">'who'</span><span class="token punctuation">)</span>4<span class="token operator">>></span><span class="token operator">></span> knights.index<span class="token punctuation">(</span><span class="token string">'hering'</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>innermost last<span class="token punctuation">)</span>: File <span class="token string">"&lt;pyshell#76>"</span>,line 1.in ?  knights.index<span class="token punctuation">(</span><span class="token string">'hering'</span><span class="token punctuation">)</span>ValueError: list.index<span class="token punctuation">(</span>x<span class="token punctuation">)</span>: x not <span class="token keyword">in</span> list</code></pre><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5,6<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> numbers.insert<span class="token punctuation">(</span>3,<span class="token string">'four'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> numbers<span class="token punctuation">[</span>1, 2, 3, <span class="token string">'four'</span>, 4, 5, 6<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5,6,,7<span class="token punctuation">]</span>  File <span class="token string">"&lt;stdin>"</span>, line 1    numbers <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5,6,,7<span class="token punctuation">]</span>                           ^SyntaxError: invalid syntax<span class="token operator">>></span><span class="token operator">></span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5,6,7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> numbers<span class="token punctuation">[</span>3:3<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'four'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> numbers<span class="token punctuation">[</span>1, 2, 3, <span class="token string">'four'</span>, 4, 5, 6, 7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> </code></pre><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>pop方法会移除列表中的一个元素(默认是最后一个)，并且返回该元素的值：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> numbers<span class="token punctuation">[</span>1, 2, 3, <span class="token string">'four'</span>, 4, 5, 6, 7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> numbers<span class="token punctuation">[</span>1, 2, 3, <span class="token string">'four'</span>, 4, 5, 6, 7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> numbers.pop<span class="token punctuation">(</span><span class="token punctuation">)</span>7<span class="token operator">>></span><span class="token operator">></span> numbers<span class="token punctuation">[</span>1, 2, 3, <span class="token string">'four'</span>, 4, 5, 6<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#注意: pop方法是唯一一个既能修改列表又返回元素值(除了None)的列表方法</span><span class="token comment" spellcheck="true">#使用pop方法可以实现一种常见的数据结构--栈。栈的原理就像堆放盘子那样。只能在顶部放一个#盘子，同样，也只能从顶部那走一个盘子，最后放入堆栈的最先被移除(这个原则称为LIFO，即后#进先出)</span></code></pre><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove方法用于移除列表中某个值的第一个匹配项：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'to'</span>,<span class="token string">'be'</span>,<span class="token string">'or'</span>,<span class="token string">'not'</span>,<span class="token string">'to'</span>,<span class="token string">'be'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x.remove<span class="token punctuation">(</span><span class="token string">'be'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span><span class="token string">'to'</span>,<span class="token string">'be'</span>,<span class="token string">'or'</span>,<span class="token string">'not'</span>,<span class="token string">'to'</span><span class="token punctuation">]</span></code></pre><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>reverse方法将列表中的元素反向存放</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x.reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>3, 2, 1<span class="token punctuation">]</span></code></pre><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>4,5,2,4,9,6,0<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x.sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>0, 2, 4, 4, 5, 6, 9<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>2,1,6,3,9,7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x.sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> print yNone<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>3,4,1,7,5,0<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">[</span>:<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y.sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span>0, 1, 3, 4, 5, 7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>3, 4, 1, 7, 5, 0<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token operator">>></span><span class="token operator">></span> y.sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>0, 1, 3, 4, 5, 7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span>0, 1, 3, 4, 5, 7<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>4,6,2,1,7,9<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> sorted<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>4, 6, 2, 1, 7, 9<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span>1, 2, 4, 6, 7, 9<span class="token punctuation">]</span>sorted函数实际上可以用于任何序列，却总是返回一个列表<span class="token operator">>></span><span class="token operator">></span> </code></pre><h2 id="补充列表的复制copy-python2-7中list没有copy属性，python3-x中有"><a href="#补充列表的复制copy-python2-7中list没有copy属性，python3-x中有" class="headerlink" title="补充列表的复制copy(python2.7中list没有copy属性，python3.x中有)"></a>补充列表的复制copy(python2.7中list没有copy属性，python3.x中有)</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> name1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> name2 <span class="token operator">=</span> name1.copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>name1,<span class="token string">"\n"</span>,name2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> name1<span class="token punctuation">[</span>2<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"CNTSW"</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>name1,<span class="token string">"\n"</span>,name2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token string">"CNTSW"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> name3 <span class="token operator">=</span>  <span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token punctuation">[</span><span class="token string">"wang"</span>,<span class="token string">"jack"</span><span class="token punctuation">]</span>,<span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> name4 <span class="token operator">=</span> name3.copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>name3,<span class="token string">"\n"</span>,name4<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token punctuation">[</span><span class="token string">"wang"</span>,<span class="token string">"jack"</span><span class="token punctuation">]</span><span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"cntsp"</span>,<span class="token string">"cnhsh"</span>,<span class="token punctuation">[</span><span class="token string">"wang"</span>,<span class="token string">"jack"</span><span class="token punctuation">]</span><span class="token string">"cntsw"</span>,<span class="token string">"cnlhq"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> name3<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"CNHSH"</span><span class="token operator">>></span><span class="token operator">></span> name3<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"WANG"</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>name3,<span class="token string">"\n"</span>,name4<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'cntsp'</span>, <span class="token string">'CNHSH'</span>, <span class="token punctuation">[</span><span class="token string">'WANG'</span>, <span class="token string">'jack'</span><span class="token punctuation">]</span>, <span class="token string">'cntsw'</span>, <span class="token string">'cnlhq'</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">'cntsp'</span>, <span class="token string">'cnhsh'</span>, <span class="token punctuation">[</span><span class="token string">'WANG'</span>, <span class="token string">'jack'</span><span class="token punctuation">]</span>, <span class="token string">'cntsw'</span>, <span class="token string">'cnlhq'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># copy.copy() copy.deepcopy()的区别</span></code></pre><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><h2 id="基本字符串操作"><a href="#基本字符串操作" class="headerlink" title="基本字符串操作"></a>基本字符串操作</h2><p>所有标准的序列操作(索引、分片、乘法、判断成员资格、求长度、取最小值和最大值)对字符串同样适用</p><h2 id="字符串格式化：精简版"><a href="#字符串格式化：精简版" class="headerlink" title="字符串格式化：精简版"></a>字符串格式化：精简版</h2><blockquote><blockquote><blockquote><p>format = “hello, %s, %s enough for ya?”<br>values = (“world”,”hot”)<br>print(format,% values)<br>hello, world, hot enough for ya?</p><p>format = “Pi with three decimals: %.3f”<br>from math import pi<br>print(format % pi)<br>Pi with three decimals: 3.142<br>#格式化实数(浮点数),可以使用f说明转换说明符的类型，同时提供所需要的精度:一个句点再加上希望保留的小数位数。因为格式化转换说明符总是以表示类型的字符结束，所有精度应该放到类型字符前面</p></blockquote></blockquote></blockquote><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><h3 id="1-find方法"><a href="#1-find方法" class="headerlink" title="1 find方法"></a>1 find方法</h3><p>find方法可以在一个较长的字符串中查找子串。它返回子串所在位置的最左端索引。如果没有周到则返回-1.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span><span class="token string">"with a moo-moo here, and a moo-moo there"</span>.find<span class="token punctuation">(</span><span class="token string">'moo'</span><span class="token punctuation">)</span>7<span class="token operator">>></span><span class="token operator">></span>title <span class="token operator">=</span> <span class="token string">"Monty Python's Flying Circus"</span><span class="token operator">>></span><span class="token operator">></span>title.find<span class="token punctuation">(</span><span class="token string">'Monty'</span><span class="token punctuation">)</span>0</code></pre><h2 id="2-join-方法"><a href="#2-join-方法" class="headerlink" title="2 join 方法"></a>2 join 方法</h2><p>join方法是非常重要的字符串方法，它是split方法的逆方法，用来连接序列中的元素：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token function">seq</span> <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5<span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> sep <span class="token operator">=</span> <span class="token string">"+"</span><span class="token operator">>></span><span class="token operator">></span> sep.join<span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#连接数字列表 </span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"&lt;stdin>"</span>, line 1, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>TypeError: sequence item 0: expected string, int found<span class="token operator">>></span><span class="token operator">></span> <span class="token function">seq</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span>,<span class="token string">"2"</span>,<span class="token string">"3"</span>,<span class="token string">"4"</span>,<span class="token string">"5"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> sep.join<span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#连接字符串列表</span><span class="token string">'1+2+3+4+5'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token function">dirs</span> <span class="token operator">=</span> <span class="token string">''</span>,<span class="token string">'usr'</span>,<span class="token string">'bin'</span>,<span class="token string">'env'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'/'</span>.join<span class="token punctuation">(</span>dirs<span class="token punctuation">)</span><span class="token string">'/usr/bin/env'</span><span class="token operator">>></span><span class="token operator">></span> print <span class="token string">'C:'</span> + <span class="token string">'\\'</span>.join<span class="token punctuation">(</span>dirs<span class="token punctuation">)</span>C:\usr\bin\env<span class="token comment" spellcheck="true">#需要被连接的元素都必须是字符串，注意最后两个例子中使用了目录的列表，unix,windows不同</span></code></pre><h2 id="3-lower方法"><a href="#3-lower方法" class="headerlink" title="3 lower方法"></a>3 lower方法</h2><pre><code>lower方法返回字符串的小写字符&gt;&gt;&gt; &#39;Trondheim Hammer Dance&#39;.lower()&#39;trondheim hammer dance&#39;#islower\capitalize\swapcase\title\istitle\upper\isupper</code></pre><h2 id="4-replace-方法"><a href="#4-replace-方法" class="headerlink" title="4 replace 方法"></a>4 replace 方法</h2><p>replace方法返回某字符串的所有匹配项均被替换之后得到字符串</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'This is a test'</span>.replace<span class="token punctuation">(</span><span class="token string">'is'</span>,<span class="token string">'eez'</span><span class="token punctuation">)</span><span class="token string">'Theez eez a test'</span></code></pre><h2 id="5-split"><a href="#5-split" class="headerlink" title="5 split"></a>5 split</h2><p>这是一个非常重要的字符串方法，它是join的逆方法，用来将字符串分隔成序列</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1+2+3+4+5'</span>.split<span class="token punctuation">(</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'1'</span>, <span class="token string">'2'</span>, <span class="token string">'3'</span>, <span class="token string">'4'</span><span class="token punctuation">]</span>如果不提供任何分隔符，程序会把所有空格作为分隔符<span class="token punctuation">(</span>空格、制表、换行等<span class="token punctuation">)</span></code></pre><h2 id="6-strip"><a href="#6-strip" class="headerlink" title="6 strip"></a>6 strip</h2><p>strip方法返回去除两侧(不包括内部)空格的字符串:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   internal whitespace is kept     '</span>.strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'internal whitespace is kept'</span></code></pre><h1 id="字典操作"><a href="#字典操作" class="headerlink" title="字典操作"></a>字典操作</h1><p>字典是一种key-value的数据类型</p><h2 id="定义字典"><a href="#定义字典" class="headerlink" title="定义字典"></a>定义字典</h2><pre class=" language-bash"><code class="language-bash">phonebook <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Alice'</span><span class="token keyword">:</span><span class="token string">'1234'</span>,<span class="token string">'Beth'</span><span class="token keyword">:</span><span class="token string">'912'</span>,<span class="token string">'Cecil'</span><span class="token keyword">:</span><span class="token string">'1231'</span><span class="token punctuation">}</span></code></pre><h2 id="dic函数"><a href="#dic函数" class="headerlink" title="dic函数"></a>dic函数</h2><p>可以用dict函数，通过其它映射(比如其它字典)或者(键，值)对的序列建立字典</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span>,<span class="token string">'Gumby'</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">'age'</span>,42<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">{</span><span class="token string">'age'</span><span class="token keyword">:</span> 42, <span class="token string">'name'</span><span class="token keyword">:</span> <span class="token string">'Gumby'</span><span class="token punctuation">}</span></code></pre><p>dict函数也可以通过关键字参数来创建字典如：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Gumby'</span>,age<span class="token operator">=</span>42<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">{</span><span class="token string">'age'</span><span class="token keyword">:</span> 42, <span class="token string">'name'</span><span class="token keyword">:</span> <span class="token string">'Gumby'</span><span class="token punctuation">}</span>注意：dict函数根本不是真正的函数。它是一个类型，就像list、tuple和str一样</code></pre><h2 id="基本字典操作"><a href="#基本字典操作" class="headerlink" title="基本字典操作"></a>基本字典操作</h2><p>字典的基本行为在很多方面与序列(sequence)类似:</p><blockquote><ul><li>len(d)返回d中项(键-值对)的数量</li><li>d[k]返回关联到建k上的值</li><li>d[k] = v 将值v关联到键k上</li><li>del d[k]删除键为k的项</li><li>k in d 检查d中是否有含有键为k的项<br>字典与列表的区别：</li><li>键类型： 字典的键不一定为整型数据，键可以是任意的不可变类型，比如浮点类型、字符串或者元组</li><li>自动添加： 字典中可以随时添加键值对，从而建立新字典,而(在不使用append方法或者其他类型他操作的情况下)不能将值关联到列表之外的索引上</li><li>成员资格判断：表达式k in d(d为字典)查找的是键，而不是值，表达式v in l(l为列表)，则用来查找值，而不是索引。<br>注意：在字典中检查键的成员资格比在列表中检查值的成员资格更高效，数据结构的规模越大，两者的效率差距越明显</li></ul></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>43<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"fools"</span><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span>42<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'fools'</span><span class="token comment" spellcheck="true">#有没有发现什么啊？</span></code></pre><h2 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h2><h3 id="1-clear方法"><a href="#1-clear方法" class="headerlink" title="1 clear方法"></a>1 clear方法</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Gumby'</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span> <span class="token operator">=</span> 42<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">{</span><span class="token string">'age'</span>:42,<span class="token string">'name'</span><span class="token keyword">:</span><span class="token string">'Gumby'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> returned_value <span class="token operator">=</span> d.clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>returned_value<span class="token punctuation">)</span>None</code></pre><h3 id="2-copy方法"><a href="#2-copy方法" class="headerlink" title="2 copy方法"></a>2 copy方法</h3><p>copy方法返回一个具有相同键-值对的新字典(这个方法实现的是浅复制(shallow copy)),因为值本身就是相同的，而不是副本</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'username'</span><span class="token keyword">:</span><span class="token string">'admin'</span>,<span class="token string">'machines'</span>:<span class="token punctuation">{</span><span class="token string">'foo'</span>,<span class="token string">'bar'</span>,<span class="token string">'barz'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x.copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'mlh'</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span><span class="token string">'machines'</span><span class="token punctuation">]</span>.remove<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">{</span><span class="token string">'username'</span><span class="token keyword">:</span> <span class="token string">'mlh'</span>, <span class="token string">'machines'</span><span class="token keyword">:</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'barz'</span>, <span class="token string">'bar'</span>, <span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">{</span><span class="token string">'username'</span><span class="token keyword">:</span> <span class="token string">'admin'</span>, <span class="token string">'machines'</span><span class="token keyword">:</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'barz'</span>, <span class="token string">'bar'</span>, <span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>可以看到，挡在副本中替换值的时候，原始字典不受影响，但是，如果修改了某个值(原地修改，而不是替换),原始的字典也会改变，因为同样的值也存储在原字典中(就像上面例子中machines列表一样)<br>#接下来我们试试深度复制(deep copy)</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> from copy <span class="token function">import</span> deepcopy<span class="token operator">>></span><span class="token operator">></span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>d<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Alfred"</span>,<span class="token string">"Bertrand"</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span>c <span class="token operator">=</span> d.copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>dc <span class="token operator">=</span> deepcopy<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>.append<span class="token punctuation">(</span><span class="token string">'Clive'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>c<span class="token punctuation">{</span><span class="token string">'name'</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">'Alfred'</span>, <span class="token string">'Bertrand'</span>, <span class="token string">'Clive'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>dc<span class="token punctuation">{</span><span class="token string">'name'</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">'Alfred'</span>, <span class="token string">'Bertrand'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="3-fromkeys"><a href="#3-fromkeys" class="headerlink" title="3 fromkeys"></a>3 fromkeys</h2><p>fromkeys 方法使用给定的键建立新字典，每个键都对应一个默认值none</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span>.fromkeys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'name'</span>,<span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'age'</span>:None,<span class="token string">'name'</span><span class="token keyword">:</span> None<span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict.fromkeys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'name'</span>,<span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'age'</span>:None,<span class="token string">'name'</span><span class="token keyword">:</span> None<span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>dict.fromkeys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'name'</span>,<span class="token string">'age'</span><span class="token punctuation">]</span>,<span class="token string">'know'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'age'</span><span class="token keyword">:</span><span class="token string">'know'</span>,<span class="token string">'name'</span><span class="token keyword">:</span><span class="token string">'know'</span><span class="token punctuation">}</span></code></pre><h2 id="4-get"><a href="#4-get" class="headerlink" title="4 get"></a>4 get</h2><p>get方法是个更宽松的访问字典项的方法。一般来说，如果试图访问字典中不存在的项时会出错：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>print<span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"&lt;stdin>"</span>, line 1, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>KeyError: <span class="token string">'name'</span><span class="token operator">>></span><span class="token operator">></span>print<span class="token punctuation">(</span>d.get<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">))</span>None<span class="token operator">>></span><span class="token operator">></span>d.get<span class="token punctuation">(</span><span class="token string">'name'</span>,<span class="token string">'N/A'</span><span class="token punctuation">)</span><span class="token string">'N/A'</span><span class="token operator">>></span><span class="token operator">></span>d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'alice'</span><span class="token operator">>></span><span class="token operator">></span>d.get<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token string">'alice'</span></code></pre><h2 id="5-has-key"><a href="#5-has-key" class="headerlink" title="5 has_key"></a>5 has_key</h2><p>has_key方法可以检查字典中是否含有特定的键，表达式d.has_key(k)相当于表达式k in d.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>d.has_key<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>False<span class="token operator">>></span><span class="token operator">></span>d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'eric'</span><span class="token operator">>></span><span class="token operator">></span>d.has_key<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>True</code></pre><h2 id="6-items和iteritems"><a href="#6-items和iteritems" class="headerlink" title="6 items和iteritems"></a>6 items和iteritems</h2><p>items方法将字典所有的项以列表方式返回，列表中的每一项都表示为(键-值)对的形式。但是项在返回时并没有遵循特定的次序</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'title'</span><span class="token keyword">:</span><span class="token string">'python is good'</span>,<span class="token string">'url'</span><span class="token keyword">:</span><span class="token string">'http://www.python.org'</span>,<span class="token string">'spam'</span>:0<span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>d.items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'url'</span>,<span class="token string">'http://www.python.org'</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">'spam'</span>,0<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">'title'</span>,<span class="token string">'python is good'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>iteritems方法的作用大致相同，但是会返回一个迭代器对象而不是列表<span class="token operator">>></span><span class="token operator">></span>it <span class="token operator">=</span> d.iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>it<span class="token operator">&lt;</span>dictionary-itemiterator object at 0x7f92b867ec00<span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#Convert the iterator to a list</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'url'</span>, <span class="token string">'http://www.python.org'</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token string">'spam'</span>, 0<span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token string">'title'</span>, <span class="token string">'python is good'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>在很多情况下使用iteriterms会更加高效<span class="token punctuation">(</span>尤其是想要迭代结果的情况下<span class="token punctuation">)</span></code></pre><h2 id="7-keys和iterkeys"><a href="#7-keys和iterkeys" class="headerlink" title="7 keys和iterkeys"></a>7 keys和iterkeys</h2><p>keys方法将字典中的键以列表的形式返回，而iterkeys则返回针对键的迭代器</p><h2 id="8-pop"><a href="#8-pop" class="headerlink" title="8 pop"></a>8 pop</h2><p>pop方法用来获得对应于给定键的值，然后将这个键-值对从字典中移除。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'x'</span>:1,<span class="token string">'y'</span>:2<span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span>d.pop<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>1<span class="token operator">>></span><span class="token operator">></span>d<span class="token punctuation">{</span><span class="token string">'y'</span>:2<span class="token punctuation">}</span></code></pre><h2 id="9-setdefault"><a href="#9-setdefault" class="headerlink" title="9 setdefault"></a>9 setdefault</h2><p>setdefault方法在某种程度上类似于get方法，能够获得给定键相关联的值，除此之外，setdefault还能在字典中不含有给地ing键的情况下设定相应的键值</p><blockquote><blockquote><blockquote><p>d = {}<br>d.setdefault(‘name’,’N/A’)<br>‘N/A’<br>d<br>{‘name’:’N/A’}<br>d[‘name’] = ‘Gumby’<br>d.setdefault(‘name’,’N/A’)<br>‘Gumby’<br>d<br>{‘name’:’Gumby’}</p></blockquote></blockquote></blockquote><pre><code>可以看到，当键不存在的时候，setdefault返回默认值并且相应地更新字典。如果键存在，那么就返回与其对应地值，但不改变字典。默认值可选，这点和get一样，如果不设定，会默认使用None## 10 updateupdate方法可以利用一个字典项更新另外一个字典``` bash&gt;&gt;&gt;d = {&#39;python&#39;:&#39;oldboy&#39;,&#39;java&#39;:&#39;oldgirls&#39;,&#39;c++&#39;:&#39;oldman&#39;}&gt;&gt;&gt;t = {&#39;c#&#39;:&#39;oldwomen&#39;} &gt;&gt;&gt;d.update(t){&#39;python&#39;: &#39;oldboy&#39;, &#39;c#&#39;: &#39;oldwomen&#39;, &#39;java&#39;: &#39;oldgirls&#39;, &#39;c++&#39;: &#39;oldman&#39;}</code></pre><h2 id="11-values和itervalues"><a href="#11-values和itervalues" class="headerlink" title="11 values和itervalues"></a>11 values和itervalues</h2><p>values方法以列表地形式返回字典中地值(itervalues返回值地迭代器)。与返回键不同，列表中可以有重复值，因为字典中地值不是唯一的</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'1'</span>:1,<span class="token string">'2'</span>:2,<span class="token string">'3'</span>:3,<span class="token string">'4'</span>:1<span class="token punctuation">}</span><span class="token punctuation">[</span>1, 3, 2, 1<span class="token punctuation">]</span></code></pre><h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><p>天然去重，且无序<br>list_1 = {1,3,4,5,6,9}<br>list_2 = {1,3,7,8,34,0}</p><h1 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h1><p>list_1.intersection(list_2)</p><h1 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h1><p>print(list-1.union(list_2))<br>#差集<br>print(list_1.difference(list_2))<br>print(list_2.difference(list_1)<br>#子集<br>print(list_1.issubset)</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>文件操作流程</p><blockquote><ul><li>打开文件，得到文件句柄并赋值给一个变量</li><li>通过句柄对文件进行操作</li><li>关闭文件<br>基本操作<br>f = open(“cntsp”) #打开文件<br>first_line = f.readline() #读一行<br>fire_line = f.readlines() #把文件中的内容全部读入到一个列表中，文件中的每行作为列表的一个元素<br>fire_line = f.read()      #读取剩下的所有内容，文件大时不要用<br>f.close()   #关闭文件<br>打开文件的模式有：</li><li>r,只读模式(默认)</li><li>w,只写模式[不可读；不存在则创建；存在则删除内容;]</li><li>a,追加模式[可读；不存在则创建；存在则追加内容;]</li></ul></blockquote><ul><li>“+” 表示可以同时读写某个文件<blockquote><ul><li>r+,可读写文件</li><li>w+,写读</li><li>a+,同a<br>“U”表示在读取时，可以将\r \n \r\n自动转换成\n(与r或r+模式同使用)</li><li>rU</li><li>r+U<br>“b”表示处理二进制文件(如；FTP发送上传ISO镜像文件，linux可忽略，windows处理二进制文件时需标注)</li><li>rb</li><li>wb</li><li>ab<br>with 语句<br>为了避免打开文件后忘记关闭，可以通过管理上下文，即：</li></ul></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> with open<span class="token punctuation">(</span><span class="token string">"log"</span><span class="token punctuation">)</span> as f:<span class="token operator">></span>     pass<span class="token operator">></span> with open<span class="token punctuation">(</span><span class="token string">"logs1"</span><span class="token punctuation">)</span> as obj1, open<span class="token punctuation">(</span><span class="token string">"log2"</span><span class="token punctuation">)</span> as obj2:<span class="token operator">></span>     pass</code></pre>在python2.7后，with又支持同时对多个文件的上下文进行管理，即：</li></ul><h1 id="字符编码与转码"><a href="#字符编码与转码" class="headerlink" title="字符编码与转码"></a>字符编码与转码</h1><p>须知：</p><blockquote><ul><li>在python2默认编码时ASCII,python3里默认是unicode</li><li>unicode 分为utf-32(占4个字节)，utf-16(占两个字节)，utf-8(占1-4个字节)，so utf-16就是现在最常用的unicode版本，不过在文件里存的还是utf-8，因为utf8省空间</li><li>在py3中encode，在转码的同时还会把string变成bytes类型，decode在解码的同时还会把bytes变回string<br>GBK需要转换为UTF-8格式流程<br>首先通过解码[decode]转换为Unicode编码<br>然后通过通过编码[encode]转换为UTF-8的编码<br>UTF-8需要转为GBK格式流程：<br>首先通过解码[decode]转换为Unicode编码<br>然后通过编码[encode]转换为GBK的编码</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day1</title>
      <link href="/2017/06/17/python-Day1/"/>
      <url>/2017/06/17/python-Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h1><p>在centos6.x系统自带了python2.6版本，cmd中输入python：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span>hello, world</code></pre><p>或者通过vim编辑hello.py<br>vim hello.py</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token keyword">print</span><span class="token punctuation">(</span>hello<span class="token punctuation">,</span>world<span class="token punctuation">)</span></code></pre><p>(cmd)命令行中输入</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>python hello.shhello,world</code></pre><a id="more"></a><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义的规则："><a href="#变量定义的规则：" class="headerlink" title="变量定义的规则："></a>变量定义的规则：</h2><blockquote><ul><li>变量名只能是 <strong>字母</strong>、<strong>数字</strong>或<strong>下划线</strong>的任意组合</li><li>变量名的<strong>第一个字母数字</strong></li><li>一下关键字不能声明为变量名<br>[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</li></ul></blockquote><h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> name1<span class="token operator">=</span> <span class="token string">"cntsp"</span><span class="token operator">>></span><span class="token operator">></span> name2<span class="token operator">=</span> name1<span class="token operator">>></span><span class="token operator">></span> id<span class="token punctuation">(</span>name1<span class="token punctuation">)</span>140391323080624<span class="token operator">>></span><span class="token operator">></span> id<span class="token punctuation">(</span>name2<span class="token punctuation">)</span>140391323080624<span class="token operator">>></span><span class="token operator">></span> name1<span class="token operator">=</span> <span class="token string">"cnhsh"</span><span class="token operator">>></span><span class="token operator">></span> id<span class="token punctuation">(</span>name1<span class="token punctuation">)</span>140391323080912<span class="token operator">>></span><span class="token operator">></span> id<span class="token punctuation">(</span>name2<span class="token punctuation">)</span>140391323080624<span class="token operator">>></span><span class="token operator">></span> print<span class="token punctuation">(</span>name2<span class="token punctuation">)</span>cntsp<span class="token operator">>></span><span class="token operator">></span> </code></pre><p>上面的打印说明了：name1和name2开始都引用了内存中的一个值，当name1=”cnhsh”时，变量name1引用了内存中的另一个值，然而对name2的引用没有任何影响</p><h1 id="用户输入和格式化打印"><a href="#用户输入和格式化打印" class="headerlink" title="用户输入和格式化打印"></a>用户输入和格式化打印</h1><p>在linux系统vim编辑input.py文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true">#-*- coding:utf-8 -*-</span><span class="token comment" spellcheck="true">#name = raw_input("please enter your name: ") #only on python2.x</span>name <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"please enter your name: "</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#python2.x和python3.x</span>print<span class="token punctuation">(</span><span class="token string">"hello "</span> + name<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#print("hello %s" % name)或者print("hello {name1}".format(name1=name))</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> python input.pyplease enter your name: cntsphello cntsp</code></pre><p>输入密码时，隐藏密码，要利用getpass模块中的getpass方法，即：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true">#-*- coding:utf-8 -*-</span><span class="token keyword">import</span> getpass<span class="token comment" spellcheck="true">#将用户输入内容赋值给passwd变量</span>passwd <span class="token operator">=</span> getpass<span class="token punctuation">.</span>getpass<span class="token punctuation">(</span><span class="token string">"请输入密码："</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#打印密码</span><span class="token keyword">print</span><span class="token punctuation">(</span>paswd<span class="token punctuation">)</span></code></pre><h1 id="模块初识"><a href="#模块初识" class="headerlink" title="模块初识"></a>模块初识</h1><p>python的强大之处正是在于丰富而强大的标准库和第三方库，几乎你想实现的任何功能都有相应的python库支持。<br>sys模块<br>os模块<br>python tab键补全模块</p><h1 id="pyc解释"><a href="#pyc解释" class="headerlink" title=".pyc解释"></a>.pyc解释</h1><h2 id="1-Python是一门解释型语言？"><a href="#1-Python是一门解释型语言？" class="headerlink" title="1. Python是一门解释型语言？"></a>1. Python是一门解释型语言？</h2><p>我初学Python时，听到的关于Python的第一句话就是，Python是一门解释性语言，我就这样一直相信下去，直到发现了<em>.pyc文件的存在。如果是解释型语言，那么生成的</em>.pyc文件是什么呢？c应该是compiled的缩写才对啊！</p><h2 id="2-解释型语言和编译型语言"><a href="#2-解释型语言和编译型语言" class="headerlink" title="2. 解释型语言和编译型语言"></a>2. 解释型语言和编译型语言</h2><p>计算机是不能够识别高级语言的，所以当我们运行一个高级语言程序的时候，就需要一个“翻译机”来从事把高级语言转变成计算机能读懂的机器语言的过程。这个过程分成两类，第一种是编译，第二种是解释。</p><p>编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了。最典型的例子就是C语言。</p><p>解释型语言就没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行作出解释，然后直接运行，最典型的例子是Ruby。</p><p>通过以上的例子，我们可以来总结一下解释型语言和编译型语言的优缺点，因为编译型语言在程序运行之前就已经对程序做出了“翻译”，所以在运行时就少掉了“翻译”的过程，所以效率比较高。但是我们也不能一概而论，一些解释型语言也可以通过解释器的优化来在对程序做出翻译时对整个程序做出优化，从而在效率上超过编译型语言。</p><p>此外，随着Java等基于虚拟机的语言的兴起，我们又不能把语言纯粹地分成解释型和编译型这两种。</p><p>用Java来举例，Java首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件。所以我们说Java是一种先编译后解释的语言。</p><h2 id="3-Python到底是什么"><a href="#3-Python到底是什么" class="headerlink" title="3. Python到底是什么"></a>3. Python到底是什么</h2><p>其实Python和Java/C#一样，也是一门基于虚拟机的语言，我们先来从表面上简单地了解一下Python程序的运行过程吧。</p><p>当我们在命令行中输入python hello.py时，其实是激活了Python的“解释器”，告诉“解释器”：你要开始工作了。可是在“解释”之前，其实执行的第一项工作和Java一样，是编译。</p><p>熟悉Java的同学可以想一下我们在命令行中如何执行一个Java的程序：<br>javac hello.java<br>java hello</p><p>只是我们在用Eclipse之类的IDE时，将这两部给融合成了一部而已。其实Python也一样，当我们执行python hello.py时，他也一样执行了这么一个过程，所以我们应该这样来描述Python，Python是一门先编译后解释的语言。</p><h2 id="4-简述Python的运行过程"><a href="#4-简述Python的运行过程" class="headerlink" title="4. 简述Python的运行过程"></a>4. 简述Python的运行过程</h2><p>在说这个问题之前，我们先来说两个概念，PyCodeObject和pyc文件。<br>我们在硬盘上看到的pyc自然不必多说，而其实PyCodeObject则是Python编译器真正编译成的结果。我们先简单知道就可以了，继续向下看。<br>当python程序运行时，编译的结果则是保存在位于内存中的PyCodeObject中，当Python程序运行结束时，Python解释器则将PyCodeObject写回到pyc文件中。<br>当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入，否则就重复上面的过程。所以我们应该这样来定位PyCodeObject和pyc文件，我们说pyc文件其实是PyCodeObject的一种持久化保存方式</p><h1 id="数据类型和数据运算"><a href="#数据类型和数据运算" class="headerlink" title="数据类型和数据运算"></a>数据类型和数据运算</h1><h2 id="数据的基本类型"><a href="#数据的基本类型" class="headerlink" title="数据的基本类型"></a>数据的基本类型</h2><h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1 数字"></a>1 数字</h3><h3 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2 布尔值"></a>2 布尔值</h3><h3 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3 字符串"></a>3 字符串</h3><h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4 列表"></a>4 列表</h3><h3 id="5-元组"><a href="#5-元组" class="headerlink" title="5 元组"></a>5 元组</h3><h3 id="6-字典"><a href="#6-字典" class="headerlink" title="6 字典"></a>6 字典</h3><h2 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h2><h3 id="1-算术运算"><a href="#1-算术运算" class="headerlink" title="1 算术运算"></a>1 算术运算</h3><table><thead><tr><th>运算符</th><th align="right">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td>+</td><td align="right">加- 两个对象相加</td><td align="center">10+20 输出结果30</td></tr><tr><td>-</td><td align="right">减- 得到负数或是一个数减去另一个数</td><td align="center">1-11b 输出结果-10</td></tr><tr><td>*</td><td align="right">乘- 两个数相乘或是返回一个被重复若个次的字符串</td><td align="center">10*20 输出结果200</td></tr><tr><td>/</td><td align="right">除- x除以y</td><td align="center">4/2输出结果2</td></tr><tr><td>%</td><td align="right">取模- 返回除法的余数</td><td align="center">3%2 输出结果为0</td></tr><tr><td>**</td><td align="right">幂-返回x的y次幂</td><td align="center">2**4为16</td></tr><tr><td>//</td><td align="right">取整数-返回商的整数部分</td><td align="center">9//2 输出结果为2，9.0//2.0结果为4.0</td></tr><tr><td>### 2 比较运算</td><td align="right"></td><td align="center"></td></tr><tr><td>运算符</td><td align="right">描述</td><td align="center">实例</td></tr><tr><td>——–</td><td align="right">—–:</td><td align="center">:—-:</td></tr><tr><td>==</td><td align="right">等于-比较对象是否相等</td><td align="center">相等返回ture</td></tr><tr><td>!=</td><td align="right">不等于-比较两个对象是否不相等</td><td align="center">不等返回ture</td></tr><tr><td>&gt;</td><td align="right">大于-x是否大于y</td><td align="center">3&gt;2,返回ture</td></tr><tr><td>&lt;</td><td align="right">小于-x是否小于y</td><td align="center">3&lt;2,返回false</td></tr><tr><td>&gt;=</td><td align="right">大于等于</td><td align="center">23&gt;=23,返回ture</td></tr><tr><td>&lt;=</td><td align="right">小于等于</td><td align="center">‘abcd’&lt;’efgh’,返回</td></tr></tbody></table><h3 id="3-赋值运算"><a href="#3-赋值运算" class="headerlink" title="3 赋值运算"></a>3 赋值运算</h3><table><thead><tr><th>运算符</th><th align="right">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td>=</td><td align="right">简单的赋值运算符</td><td align="center">c =a+b</td></tr><tr><td>+=</td><td align="right">加法赋值运算符</td><td align="center">c +=a等效于c = c+a</td></tr><tr><td>### 4 逻辑运算</td><td align="right"></td><td align="center"></td></tr><tr><td>运算符</td><td align="right">描述</td><td align="center">实例</td></tr><tr><td>——–</td><td align="right">—–:</td><td align="center">:—-:</td></tr><tr><td>and</td><td align="right">布尔”与”，同真为真</td><td align="center">1 and 1 ,返回true</td></tr><tr><td>or</td><td align="right">布尔”或”，只要有一个为真就是真</td><td align="center">1 or 0,返回true</td></tr><tr><td>not</td><td align="right">布尔”非”</td><td align="center">not(1),返回false</td></tr><tr><td>### 5 成员运算</td><td align="right"></td><td align="center"></td></tr><tr><td>运算符</td><td align="right">描述</td><td align="center">实例</td></tr><tr><td>——–</td><td align="right">—–:</td><td align="center">:—-:</td></tr><tr><td>in</td><td align="right">如果指定的序列中找到值返回True,否则返回False</td><td align="center">x in y ,x在y序列中，返回True</td></tr><tr><td>not in</td><td align="right">如果在指定的序列中没有找到值返回True,否则返回False</td><td align="center">x不在y序列中，x not in y ,就为True</td></tr><tr><td>### 6 身份运算</td><td align="right"></td><td align="center"></td></tr><tr><td>运算符</td><td align="right">描述</td><td align="center">实例</td></tr><tr><td>——–</td><td align="right">—–:</td><td align="center">:—-:</td></tr><tr><td>is</td><td align="right">is是判断两个标识符是不是引用自一个对象</td><td align="center">x is y,如果id(x)等于id(y),is 返回结果1</td></tr><tr><td>is not</td><td align="right">is not 是判断两个标识符是不是引用自不同的对象</td><td align="center">x is not y,如果id(x)不等于id(y),is not返回值为1</td></tr><tr><td>### 7 位运算</td><td align="right"></td><td align="center"></td></tr><tr><td>运算符</td><td align="right">描述</td><td align="center">实例</td></tr><tr><td>——–</td><td align="right">—–:</td><td align="center">:—-:</td></tr><tr><td>&amp;</td><td align="right">按位与运算</td><td align="center">1111&amp;0000</td></tr><tr><td>^</td><td align="right">按位异或运算符</td><td align="center">1010^0101</td></tr><tr><td>~</td><td align="right">按位取反运算符</td><td align="center">~5</td></tr><tr><td>&lt;&lt;</td><td align="right">左移</td><td align="center">a&lt;&lt;2</td></tr><tr><td>&gt;&gt;</td><td align="right">右移</td><td align="center">b&gt;&gt;3</td></tr><tr><td>### 8 补充:运算符优先级</td><td align="right"></td><td align="center"></td></tr><tr><td>运算符</td><td align="right">描述</td><td align="center"></td></tr><tr><td>——–</td><td align="right">—–:</td><td align="center"></td></tr><tr><td>^^</td><td align="right">指数(最高级)</td><td align="center"></td></tr><tr><td>~ + -</td><td align="right">按位翻转，一元加号和减号</td><td align="center"></td></tr><tr><td>* / % //</td><td align="right">乘 除 取模 取整除</td><td align="center"></td></tr><tr><td>+ -</td><td align="right">加法 减法</td><td align="center"></td></tr><tr><td>&gt;&gt; &lt;&lt;</td><td align="right">左移 右移</td><td align="center"></td></tr><tr><td>&amp;</td><td align="right">位 “AND”</td><td align="center"></td></tr><tr><td>^</td><td align="right">位运算</td><td align="center"></td></tr><tr><td>&lt; &gt; &lt;= &gt;=</td><td align="right">比较运算</td><td align="center"></td></tr><tr><td>= %= /=</td><td align="right">赋值运算</td><td align="center"></td></tr><tr><td>is is not</td><td align="right">身份运算</td><td align="center"></td></tr><tr><td>in not in</td><td align="right">成员运算</td><td align="center"></td></tr><tr><td>not or and</td><td align="right">逻辑运算</td><td align="center"></td></tr><tr><td># 流程控制语句和循环</td><td align="right"></td><td align="center"></td></tr><tr><td>## if/else</td><td align="right"></td><td align="center"></td></tr><tr><td>vim if.py</td><td align="right"></td><td align="center"></td></tr><tr><td>``` bash</td><td align="right"></td><td align="center"></td></tr><tr><td>name = input(“What is your name?: “)</td><td align="right"></td><td align="center"></td></tr><tr><td>if name.endswith(“Gumby”)</td><td align="right"></td><td align="center"></td></tr><tr><td>print(“Hello, Mr. Gumby”)</td><td align="right"></td><td align="center"></td></tr><tr><td>else:</td><td align="right"></td><td align="center"></td></tr><tr><td>print(“Hello,stranger”)</td><td align="right"></td><td align="center"></td></tr><tr><td>```</td><td align="right"></td><td align="center"></td></tr><tr><td>如果需要检测多个条件，就可以是由elif:</td><td align="right"></td><td align="center"></td></tr><tr><td>``` bash</td><td align="right"></td><td align="center"></td></tr><tr><td>num = input(“Enter a number:”)</td><td align="right"></td><td align="center"></td></tr><tr><td>if num&gt;0:</td><td align="right"></td><td align="center"></td></tr><tr><td>print(“The number is positive”)</td><td align="right"></td><td align="center"></td></tr><tr><td>elif num&lt;0:</td><td align="right"></td><td align="center"></td></tr><tr><td>print(“The number is negative”)</td><td align="right"></td><td align="center"></td></tr><tr><td>else:</td><td align="right"></td><td align="center"></td></tr><tr><td>print(“The number is zero”)</td><td align="right"></td><td align="center"></td></tr><tr><td>```</td><td align="right"></td><td align="center"></td></tr><tr><td>## for循环</td><td align="right"></td><td align="center"></td></tr><tr><td>### 循环遍历一个序列</td><td align="right"></td><td align="center"></td></tr><tr><td>``` bash</td><td align="right"></td><td align="center"></td></tr><tr><td>words = [“this”, “is”, “an”, “parrot”]</td><td align="right"></td><td align="center"></td></tr><tr><td>for word in words:</td><td align="right"></td><td align="center"></td></tr><tr><td>print(word)</td><td align="right"></td><td align="center"></td></tr><tr><td>或者</td><td align="right"></td><td align="center"></td></tr><tr><td>numbers = [1,2,3,4,5,6]</td><td align="right"></td><td align="center"></td></tr><tr><td>for num in numbers:</td><td align="right"></td><td align="center"></td></tr><tr><td>print(“num”)</td><td align="right"></td><td align="center"></td></tr><tr><td>```</td><td align="right"></td><td align="center"></td></tr><tr><td>### 循环遍历字典元素</td><td align="right"></td><td align="center"></td></tr><tr><td>一个简单的for语句就能遍历字典的所有键，就像遍历序列一样</td><td align="right"></td><td align="center"></td></tr><tr><td>``` bash</td><td align="right"></td><td align="center"></td></tr></tbody></table><blockquote><blockquote><blockquote><p>d = {‘x’:12, ‘y’:13, ‘z’=14}<br>for key in d:<br>       print key, ‘corresponds to’,d[key]<br>d.items方法会将键-值对作为元组返回，for循环的一大好处就是可以循环中使用序列解包：<br>for key, value in d.items():<br>       print(key,’correspond to’, value)<br>x correspond to 12<br>y correspond to 13<br>z correspond to 14</p></blockquote></blockquote></blockquote><p>```</p><h3 id="一些迭代工具"><a href="#一些迭代工具" class="headerlink" title="一些迭代工具"></a>一些迭代工具</h3><p>1 并行迭代<br>2 按索引迭代<br>3 翻转和排序迭代</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>1 break<br>2 continue<br>3 while True/break</p><h1 id="作业需求"><a href="#作业需求" class="headerlink" title="作业需求"></a>作业需求</h1><h2 id="作业一：博客"><a href="#作业一：博客" class="headerlink" title="作业一：博客"></a>作业一：博客</h2><h2 id="编写登陆接口"><a href="#编写登陆接口" class="headerlink" title="编写登陆接口"></a>编写登陆接口</h2><blockquote><ul><li>输入用户名密码</li><li>认证成功后显示欢迎信息</li><li>输出三次后锁定</li></ul></blockquote><h2 id="多级菜单"><a href="#多级菜单" class="headerlink" title="多级菜单"></a>多级菜单</h2><blockquote><ul><li>三级菜单</li><li>可依次选择进入各个菜单</li><li>所需新知识点：列表、字典</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2017/06/14/python-lesson1/"/>
      <url>/2017/06/14/python-lesson1/</url>
      
        <content type="html"><![CDATA[<h1 id="Python课程介绍"><a href="#Python课程介绍" class="headerlink" title="Python课程介绍"></a>Python课程介绍</h1><h2 id="python-擅长的领域"><a href="#python-擅长的领域" class="headerlink" title="python 擅长的领域"></a>python 擅长的领域</h2><blockquote><ul><li>WEB开发</li><li>Django\pyramid\Tornado\Bottle\Flask\WebPy</li><li>网络编程</li><li>Twisted\Requests\Scrapy\Paramiko</li><li>科学运算</li><li>SciPy\Pandas\lpython</li><li>GUI图形开发</li><li>wxPython\PyQT\Kivy</li><li><strong>运维自动化</strong></li><li>OpenStack\SaltStack\Ansible\腾讯蓝鲸</li></ul></blockquote><a id="more"></a><h2 id="前戏阶段-疗程1"><a href="#前戏阶段-疗程1" class="headerlink" title="前戏阶段-疗程1"></a>前戏阶段-疗程1</h2><p>语言基础（5-6周）</p><blockquote><ul><li>数据类型</li><li>流程控制</li><li>常用模块</li><li>函数、迭代器、装饰器</li><li>递归、迭代、反射</li><li>面向对象编程</li><li>购物车程序</li><li>ATM信用卡程序开发</li><li>计算器程序开发</li><li>模拟人生游戏开发</li></ul></blockquote><h2 id="轻撸怡情-疗程2"><a href="#轻撸怡情-疗程2" class="headerlink" title="轻撸怡情-疗程2"></a>轻撸怡情-疗程2</h2><p>网络编程（4-5周）</p><blockquote><ul><li>Socket c/s编程、Twisted异步网络框架、网络爬虫开发</li><li>多线程、多进程、协程gevent、select\poll\epoll</li><li>生产者消费者模型</li><li>审计堡垒机系统开发</li><li>FTP服务器开发</li><li>批量命令、文件分布工具</li><li>RabbitMQ消息队列、SqlAlchemy ORM</li><li>类SaltStack配置管理工具开发</li><li>Reids\MemCache\MongoDB 缓存数据库</li></ul></blockquote><h2 id="重则伤身-疗程3"><a href="#重则伤身-疗程3" class="headerlink" title="重则伤身-疗程3"></a>重则伤身-疗程3</h2><p>web基础开发（3-4）</p><blockquote><ul><li>Html/CSS基础</li><li>Dom编程</li><li>原生JS学习</li><li>Jquery/Easy/AngulaJS</li><li>Ajax 异步加载</li><li>Highchart</li><li>Bootstrap</li></ul></blockquote><h2 id="继续伤身-疗程4"><a href="#继续伤身-疗程4" class="headerlink" title="继续伤身-疗程4"></a>继续伤身-疗程4</h2><p>算法&amp;设计模式(1周)</p><blockquote><ul><li>冒泡、二叉树、哈希、折半等常见算法学习</li><li>工厂模式、单例模式、亨元模式、代理模式等常用设计模式学习</li></ul></blockquote><h2 id="灰飞烟灭-疗程5"><a href="#灰飞烟灭-疗程5" class="headerlink" title="灰飞烟灭-疗程5"></a>灰飞烟灭-疗程5</h2><p>PY WEB 框架(5周)</p><blockquote><ul><li>MVC架构讲解</li><li>自行开发一个WEB框架</li><li>Django\Tornado\Flask\Bottle\WebPy框架学习</li><li>Session\中间件\ORM\Cookie\CSRF\FORM..</li><li>Restful API框架</li><li>权限管理后台开发</li><li>开发BBS论坛</li><li>开发WEB聊天室</li></ul></blockquote><h2 id="放弃治疗-疗程6"><a href="#放弃治疗-疗程6" class="headerlink" title="放弃治疗-疗程6"></a>放弃治疗-疗程6</h2><p>项目实战篇（8周）</p><blockquote><ul><li>购物商城开发</li><li>主机管理+任务编排+运维审计堡垒机</li><li>分布式类Nagios/Zabbix监控产品开发</li><li>CMDB资产管理开发</li><li>基于用户视角的网站访问质量监测分析平台开发</li><li>Docker 自动化管理平台开发</li><li>OpenStack二次开发</li></ul></blockquote><h1 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h1><h2 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h2><p>通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言<br>(1)动态类型语言：动态类型语言是指运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其它的各种脚本语言如VBScipt也多少属于动态类型语言。</p><p>静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型时在编译期间检查的，也就是说写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其它的静态类型语言还有C#，JAVA等。</p><p>强类型定义语言和弱类型定义语言<br>(1)强类型定义语言：强制数据类型定义的语言。也就说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子，如果你定义了一个整型变量a,那么程序根本不可能将a当作字符类型处理。强类型定义语言是类型安全的语言。<br>(2)弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反，一个变量可以赋不同数据类型的值</p><p>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，这门语言是不是动态语言与这门语言是否类型安全之间是完全没有联系的<br>例如：python是动态语言，是强类型语言(类型安全的语言)；VBScript是动态语言，是弱类型定义语言(类型不安全的语言)；JAVA是静态语言，是强类型定义语言(类型安全的语言)<br>通过上面介绍得出： python是一门动态解释性的强类型定义语言。</p><p>ASCII 255 1bytes<br>        –&gt; 1980 gb2312  7xxx<br>            –&gt; 1995 GBK1.0 2w+<br>                –&gt; 2000 GB18030 27xxx<br>            –&gt; uniode 2bytes<br>                —&gt;utf-8 en:1byte,zh:3bytes</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串内置函数之-strip、split函数</title>
      <link href="/2017/06/10/python-strip-split/"/>
      <url>/2017/06/10/python-strip-split/</url>
      
        <content type="html"><![CDATA[<h1 id="strip函数解析"><a href="#strip函数解析" class="headerlink" title="strip函数解析"></a>strip函数解析</h1><p>声明: s为字符串，rm为要删除的字符序列</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> s.strip<span class="token punctuation">(</span>rm<span class="token punctuation">)</span>:  删除s字符串中开头、结尾处，位于rm删除序列的字符<span class="token operator">>></span><span class="token operator">></span> s.lstrip<span class="token punctuation">(</span>rm<span class="token punctuation">)</span>: 删除s字符串中开头处，位于rm删除序列的字符<span class="token operator">>></span><span class="token operator">></span> s.rstrip<span class="token punctuation">(</span>rm<span class="token punctuation">)</span>: 删除s字符串中结尾处，位于rm删除序列的字符</code></pre><a id="more"></a><p>例如：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"hello,world,hel"</span><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> s.strip<span class="token punctuation">(</span><span class="token string">"hel"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">'o,world,'</span></code></pre><p>1 当rm为空格时，默认删除空白符(包括’\n’,’\r’,’\t’,’ ‘)</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token string">'  a\n\r\tbcd'</span><span class="token operator">>></span><span class="token operator">></span> s1<span class="token string">'  a\n\r\tbcd'</span><span class="token operator">>></span><span class="token operator">></span> print s1  a    bcd<span class="token operator">>></span><span class="token operator">></span> s1.strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'a\n\r\tbcd'</span><span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token string">'\n\t\rabc'</span><span class="token operator">>></span><span class="token operator">></span> s2.strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'abc'</span><span class="token operator">>></span><span class="token operator">></span> s3 <span class="token operator">=</span> <span class="token string">'abc\n\t\r'</span><span class="token operator">>></span><span class="token operator">></span> s3.strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'abc'</span></code></pre><p>2 当rm为非空时，只要rm中要删除的字符序列的字符在字符串s的开头或结尾出现，就删除</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">'123abc'</span><span class="token operator">>></span><span class="token operator">></span> a.strip<span class="token punctuation">(</span><span class="token string">'21c'</span><span class="token punctuation">)</span><span class="token string">'3ab'</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'123abc'</span><span class="token operator">>></span><span class="token operator">></span> a.strip<span class="token punctuation">(</span><span class="token string">'c21'</span><span class="token punctuation">)</span><span class="token string">'3ab'</span><span class="token operator">>></span><span class="token operator">></span> a.strip<span class="token punctuation">(</span>c21<span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"&lt;stdin>"</span>, line 1, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>NameError: name <span class="token string">'c21'</span> is not defined<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># split函数解析：</span>split是分隔函数，将字符串分隔成<span class="token string">"字符"</span>，保存在一个类表中``` <span class="token function">bash</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">"1 2 3 4 5"</span><span class="token operator">>></span><span class="token operator">></span> a.split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'1'</span>, <span class="token string">'2'</span>, <span class="token string">'3'</span>, <span class="token string">'4'</span>, <span class="token string">'5'</span><span class="token punctuation">]</span> //默认不带参数以空格分隔，之所以为双引号的字符，因为实际python没有字符类型的<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token string">"abc efg hij klm"</span><span class="token operator">>></span><span class="token operator">></span> b.split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'abc'</span>, <span class="token string">'efg'</span>, <span class="token string">'hij'</span>, <span class="token string">'klm'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token string">"name=cntsp|age=25|sex=male"</span>   //带参数根据实际需求进行分隔<span class="token operator">>></span><span class="token operator">></span> c.split<span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'name=cntsp'</span>, <span class="token string">'age=25'</span>, <span class="token string">'sex=male'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> c.split<span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token string">'name=cntsp'</span><span class="token operator">>></span><span class="token operator">></span> c.split<span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'name'</span>, <span class="token string">'cntsp'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token string">'a b c d e f'</span><span class="token operator">>></span><span class="token operator">></span> d.split<span class="token punctuation">(</span><span class="token string">''</span>,1<span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"&lt;stdin>"</span>, line 1, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>ValueError: empty separator<span class="token operator">>></span><span class="token operator">></span> d.split<span class="token punctuation">(</span><span class="token string">' '</span>,1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'a'</span>, <span class="token string">'b c d e f'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d.split<span class="token punctuation">(</span><span class="token string">' '</span>,3<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'a'</span>, <span class="token string">'b'</span>, <span class="token string">'c'</span>, <span class="token string">'d e f'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d.split<span class="token punctuation">(</span><span class="token string">' '</span>,-1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'a'</span>, <span class="token string">'b'</span>, <span class="token string">'c'</span>, <span class="token string">'d'</span>, <span class="token string">'e'</span>, <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d.split<span class="token punctuation">(</span><span class="token string">' '</span>,-2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'a'</span>, <span class="token string">'b'</span>, <span class="token string">'c'</span>, <span class="token string">'d'</span>, <span class="token string">'e'</span>, <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d.split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'a'</span>, <span class="token string">'b'</span>, <span class="token string">'c'</span>, <span class="token string">'d'</span>, <span class="token string">'e'</span>, <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> string </tag>
            
            <tag> strip </tag>
            
            <tag> split </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queens</title>
      <link href="/2017/06/01/python-queens/"/>
      <url>/2017/06/01/python-queens/</url>
      
        <content type="html"><![CDATA[<h1 id="八皇后问题，回溯和递归"><a href="#八皇后问题，回溯和递归" class="headerlink" title="八皇后问题，回溯和递归"></a>八皇后问题，回溯和递归</h1><pre class=" language-bash"><code class="language-bash">$ <span class="token comment" spellcheck="true"># -*- coding:utf-8 -*-</span>$ <span class="token comment" spellcheck="true">#python默认为ascii编码，中文编码可以用utf-8</span>$$ <span class="token function">import</span> random$ def conflict<span class="token punctuation">(</span>state,col<span class="token punctuation">)</span>:$     row<span class="token operator">=</span>len<span class="token punctuation">(</span>state<span class="token punctuation">)</span>$     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span>:$          <span class="token keyword">if</span> abs<span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span>-col<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span>0,row-i<span class="token punctuation">)</span>:$              <span class="token keyword">return</span> True$     <span class="token keyword">return</span>    False$$ def queens<span class="token punctuation">(</span>num<span class="token operator">=</span>8,state<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">))</span>:$     <span class="token keyword">for</span> pos <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token punctuation">)</span>:$          <span class="token keyword">if</span> not conflict<span class="token punctuation">(</span>state,pos<span class="token punctuation">)</span>:$              <span class="token keyword">if</span> len<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token operator">==</span>num-1:$                   yield<span class="token punctuation">(</span>pos,<span class="token punctuation">)</span>$             else:$                 <span class="token keyword">for</span> result <span class="token keyword">in</span> queens<span class="token punctuation">(</span>num,state+<span class="token punctuation">(</span>pos,<span class="token punctuation">))</span>:$                       yield <span class="token punctuation">(</span>pos,<span class="token punctuation">)</span>+result$$ def queenprint<span class="token punctuation">(</span>soultion<span class="token punctuation">)</span>:   $     def line<span class="token punctuation">(</span>pos,length<span class="token operator">=</span>len<span class="token punctuation">(</span>solution<span class="token punctuation">))</span>:$          <span class="token keyword">return</span> <span class="token string">'. '</span>*<span class="token punctuation">(</span>pos<span class="token punctuation">)</span>+<span class="token string">'X'</span>+<span class="token string">'. '</span>*<span class="token punctuation">(</span>length-pos-1<span class="token punctuation">)</span>$     <span class="token keyword">for</span> pos <span class="token keyword">in</span> solution:$          print line<span class="token punctuation">(</span>pos<span class="token punctuation">)</span>$        $ <span class="token keyword">for</span> solution <span class="token keyword">in</span> list<span class="token punctuation">(</span>queens<span class="token punctuation">(</span>8<span class="token punctuation">))</span>:$     print solution$$ print <span class="token string">' total number is '</span>+str<span class="token punctuation">(</span>len<span class="token punctuation">(</span>list<span class="token punctuation">(</span>queens<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">))</span><span class="token string">'$ print '</span> one of the range is:\n'$ $ queenprint<span class="token punctuation">(</span>random.choice<span class="token punctuation">(</span>list<span class="token punctuation">(</span>queens<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">))</span></code></pre><a id="more"></a><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="主要利用冲突函数检测冲突，如果冲突则回溯，递归用到python的yield语句，该语句涉及python的生成器"><a href="#主要利用冲突函数检测冲突，如果冲突则回溯，递归用到python的yield语句，该语句涉及python的生成器" class="headerlink" title="主要利用冲突函数检测冲突，如果冲突则回溯，递归用到python的yield语句，该语句涉及python的生成器"></a>主要利用冲突函数检测冲突，如果冲突则回溯，递归用到python的yield语句，该语句涉及python的生成器</h2><h3 id="冲突函数"><a href="#冲突函数" class="headerlink" title="冲突函数"></a>冲突函数</h3><pre class=" language-bash"><code class="language-bash">$ def  conflict<span class="token punctuation">(</span>state,col<span class="token punctuation">)</span>:$     <span class="token comment" spellcheck="true">#冲突函数，row为行，col为列(不论行和列都是从0开始的)</span>$    row<span class="token operator">=</span>len<span class="token punctuation">(</span>state<span class="token punctuation">)</span>$     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span>:$          <span class="token keyword">if</span> abs<span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span>-col<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span>0,row-i<span class="token punctuation">)</span>:$             <span class="token keyword">return</span> True$    <span class="token keyword">return</span> False$注释:state为已知的皇后的状态，类型是一个元组，例如<span class="token punctuation">(</span>7,3,0,2,5,1,6,4<span class="token punctuation">)</span>,元组是不可变对象，一经创建不能修改，元组是创建生成器的一种方法<span class="token punctuation">(</span>第一行的皇后在第七列，第二行的皇后在第三列，等等<span class="token punctuation">)</span></code></pre><p>假设第一行到第三行的皇后都没冲突，这个时候要检测第四行皇后是否冲突。如第一行皇后在第五列，第二行皇后在第八列，第三行皇后在第四列，检验第四行皇后放在哪一列不会冲突。</p><pre class=" language-bash"><code class="language-bash">$ * * * * X * * *$ * * * * * * * X$ * * * X * * * *$ 这时state<span class="token operator">=</span><span class="token punctuation">(</span>4,7,3<span class="token punctuation">)</span>,col<span class="token operator">=</span>?</code></pre><p>1 得出目前没冲突的行数row</p><pre class=" language-bash"><code class="language-bash">$ row <span class="token operator">=</span> len<span class="token punctuation">(</span>state<span class="token punctuation">)</span></code></pre><p>2 从1~row行依次检测已知的皇后是否与row+1行皇后有冲突</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span>:</code></pre><p>3 如果row+1行皇后所在的列col与其它行皇后的列相同或处于对角线，则冲突</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">if</span> abs<span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span>-col<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span>0,row-i<span class="token punctuation">)</span>:<span class="token comment" spellcheck="true">#判断是否冲突</span>$    <span class="token keyword">return</span> True</code></pre><p>以上语句翻译为(其它已知的皇后所在的列-要求检测的皇后所在的列)等于0或者等于(row-i)则冲突</p><p>傻瓜式教学：第一行与第四行冲突，要么在同一列，要么在对角线，当对角线列数相差3，因为第一行与第二行对角线相差1，第二行与第三行对角线相差1，则第一行与第三行对角线相差2，以此类推，第一行与第四行冲突，则相差3</p><p>当第四行所在列col=4,这时abs(state[0]-4) in (0,3-0)为真，因为4-4=0，如图：</p><pre class=" language-bash"><code class="language-bash">$ * * * * X * * *$ * * * * * * * X$ * * * X * * * *$ * * * * X * * *     同列冲突</code></pre><p>当第四行所在列col=2,这时abs(state[2]-2) in (0,3-2)为真，因为abs(3-2)=1，如：</p><pre class=" language-bash"><code class="language-bash">$ * * * * X * * *$ * * * * * * * X$ * * * X * * * *$ * * X * * * * *     对角线冲突</code></pre><h1 id="生成器函数："><a href="#生成器函数：" class="headerlink" title="生成器函数："></a>生成器函数：</h1><pre class=" language-bash"><code class="language-bash">$ def queen<span class="token punctuation">(</span>num<span class="token operator">=</span>8,state<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">))</span>:$     <span class="token comment" spellcheck="true">#生成器函数</span>$     <span class="token keyword">for</span> pos <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token punctuation">)</span>:$         <span class="token keyword">if</span> not conflict<span class="token punctuation">(</span>state,pos<span class="token punctuation">)</span>:$            <span class="token keyword">if</span> len<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token operator">==</span>num-1:$                yield<span class="token punctuation">(</span>pos,<span class="token punctuation">)</span>$            else:$                <span class="token keyword">for</span> result <span class="token keyword">in</span> queens<span class="token punctuation">(</span>num,state+<span class="token punctuation">(</span>pos,<span class="token punctuation">))</span>:$                    yield <span class="token punctuation">(</span>pos,<span class="token punctuation">)</span>+result</code></pre><p>生成器:通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且，创建一个包含100万个元素的列表，不仅占用很到的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了，所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，python中，这种一遍循环一边计算的机制，称为生成器</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1 下面该语句为构建所有皇后摆放情况打下基础，可以尝试所有情况</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">for</span> pos <span class="token keyword">in</span> range<span class="token punctuation">(</span>num<span class="token punctuation">)</span>:</code></pre><p>2 如果不冲突，则递归构造棋盘</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">if</span> not conflict<span class="token punctuation">(</span>state,pos<span class="token punctuation">)</span>:</code></pre><p>3 如果棋盘状态state已经等于num-1,即到达倒数第二行，而这时最后一行皇后又没冲突，直接yield，打出其位置(pos,),python在显示只有1个元素的元组时，也会加上一个逗号，以免你误解成数学计算意义上的括号，否则递归，打印(pos,)+result</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">if</span> len<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token operator">==</span>num-1:$     yield<span class="token punctuation">(</span>pos,<span class="token punctuation">)</span>$ else:$    <span class="token keyword">for</span> result <span class="token keyword">in</span> queens<span class="token punctuation">(</span>num,state+<span class="token punctuation">(</span>pos,<span class="token punctuation">))</span>:$        yield <span class="token punctuation">(</span>pos,<span class="token punctuation">)</span>+result</code></pre><p>傻瓜式教学:例如pos=0，第0行放在第0列，这时不会冲突，但是不会进入if，因为还没到达倒数第二行，进入else后，再调用queens(num,state+(pos,)),这时进入第二行，再次递归展开则是queens(num,state+(pos,)+(pos,)),到达最后一行时返回(pos,),再返回倒数第二行，再返回倒数第三行，最后到达最开始那层(pos,)+result, pos为第0行皇后所在列，result包含第一行皇后和另一个result</p><h1 id="打印所有结果"><a href="#打印所有结果" class="headerlink" title="打印所有结果"></a>打印所有结果</h1><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">for</span> solution <span class="token keyword">in</span> queens<span class="token punctuation">(</span>8<span class="token punctuation">)</span>:$     print solution</code></pre><p>queens(8)因为生成器函数的for循环，每一次循环都会yield一个元组出来，所以有很多种情况，可以把它全部打印出来<br>也可以用list包装列表在统计一下多少种数目</p><pre class=" language-bash"><code class="language-bash">$ print <span class="token string">'total number is '</span>+str<span class="token punctuation">(</span>len<span class="token punctuation">(</span>list<span class="token punctuation">(</span>queens<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">))</span></code></pre><h1 id="随机优美打印一个棋盘情况"><a href="#随机优美打印一个棋盘情况" class="headerlink" title="随机优美打印一个棋盘情况"></a>随机优美打印一个棋盘情况</h1><pre class=" language-bash"><code class="language-bash">$ print <span class="token string">' one of the range is:\n'</span>$ queenprint<span class="token punctuation">(</span>random.choice<span class="token punctuation">(</span>list<span class="token punctuation">(</span>quees<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">))</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python异常</title>
      <link href="/2017/04/14/python-excesice/"/>
      <url>/2017/04/14/python-excesice/</url>
      
        <content type="html"><![CDATA[<p>python异常<br>python的运行时错误称作异常<br>语法错误；软件的结构上有错误而导致不能被解释器解释或不能被编译器编译<br>逻辑错误：由于不完整或不合法的输入所致，也可能是逻辑无法生成、计算或者输出结果需要的过程无法执行等<br>python异常是一个对象，表示错误或意外情况<br>在python检测到一个错误时，将触发一个异常<br>python可以通过异常传导机制传递一个异常对象，发出一个异常情况出现的信号<br>程序员也可以在代码中手动触发异常</p><a id="more"></a><p>python异常也可以理解为：程序出现了错误而在正常控制流以外采取的行为<br>第一阶段：解释器触发异常，此时当前程序流将被打断<br>第二阶段：异常处理，如忽略非致命性错误、减轻错误带来的影响等<br>错误处理<br>    python的默认处理：停止程序，打印错误消息<br>    使用try语句处理异常并从异常中恢复<br>事件通知<br>    用于发出有效状态信号<br>特殊情况处理<br>    无法调整代码去处理的场景<br>终止行为<br>    try/finally语句课确保执行必须的结束处理机制<br>非常规控制流程<br>    异常是一种高级跳转(goto)机制<br>异常通过try语句来检测<br>    任何在try语句块里的代码都会被检测，以检查有无异常发生<br>try语句主要有两种形式<br>    try-execpt：检测和处理异常<br>        可以有多个except<br>        支持使用else子句处理没有探测异常的执行的代码<br>    try-finally：仅检查异常并做一些必要的清理工作<br>        仅能有一个finally<br>try语句的复合形式<br>    try-except-finally<br>try-except语句<br>定义了进行异常监控的一段代码，并且提供了处理异常的机制<br>语法<br>try:<br>    try_suite<br>except Exception[,reason]:<br>    except_suite</p><p>例如：<br>    try:<br>        f1 = open(‘/tmp/hello/abc.txt’,’r+’)<br>    except IOError,e:<br>       print “Could not open file /tmp/hello/abc.txt”,e<br>Could not open file /tmp/hello/abc.txt [Errno 2] No such file or directory: ‘/tmp/hello/abc.txt’</p><p>try-except-else语句<br>try语句可以带多个except子句，还可以有一个可选的else子句，语法格式如下<br>try:<br>    try_suite<br>except Exception1[,reason]:<br>    suite_exception1<br>except (Exception2,Exception3,…)[,reason]: //一次捕获多个异常时要用到元组<br>    suite_exception2<br>….<br>except:               //空except语句用于捕获一切异常<br>    suite_<br>else:<br>    else_suite<br>except分句个数没有限制，但else只能有一个<br>没有异常发生时，else分句才会执行<br>没有符合的except分句时，异常会向上传递到程序中的之前的try中或者到进程的顶层</p><p>try-finally语句<br>无论异常是否发生，finally子句都会执行<br>    常用于定义必需进行的清理动作，如关闭文件或断开服务器连接等<br>finally中的所有代码执行完毕后会继续向上一层引发异常<br>语法：<br>try:<br>    try_suite<br>finally:<br>    finally_suite</p><p>异常对象<br>自定义异常<br>raise [SomeException [,args [,traceback]]]<br>    SomeException:可选，异常的名字，仅能使用字符串、类或实例<br>    args:可选，以元组的形式传递给异常的参数<br>    traceback：可选，异常触发时新生成的一个用于异常-正常化的跟踪记录，多用于重新引发异常时<br>def CrossProduct(seq1,seq2):<br>    if not seq1 or not seq2:<br>        raise ValueError, “Sequence argements must be non-empty”<br>    return [(x1,x2) for x1 in seq1 for x2 in seq2]<br>seq1=[]<br>seq2=[]<br>CrossProduct(seq1,seq2)</p><p>python异常是内置的经典类Exception的子类的实例<br>    为了向后兼容，python还允许使用字符串或任何经典类实例<br>    python2.5之后，Exception是从BaseException继承的新式类<br>python自身引发的所有异常都是Exception的子类的实例<br>大多标准异常都是由StandardError派生的，其有3个抽象的子类<br>ArithmeticError<br>由于算术错误而引发的异常基类<br>OverflowError,ZeroDivisionError,FloatingPointError<br>LookupError<br>容器在接收到一个无效键或索引时引发的异常的基类<br>IndexError,KeyError<br>EnvironmentError<br>由于外部原因而导致的异常的基类<br>IOError,OSError,WindowsError</p><p>标准异常类<br>AssertionError 断言语句失败<br>AttributeError 属性引用或赋值失效<br>FloatingPointError 浮点型运算失败<br>IOError          I/O操纵失败<br>ImportError      import语句不能找到要导入的模块，或者不能找到该模块特别请求的名称<br>IndentationError 解析器遇到一个由于错误的缩进而引发的语法错误<br>IndexError       用来索引序列的整数超出了范围<br>KeyError 用来索引映射的键不再映射中<br>KeyboardInterrupt 用户按了中断键(Ctrl+c,Ctrl+Break或Delete键)<br>MemoryError   运算耗尽内存<br>NameError   引用了一个不存在的变量名<br>NotImplementedError 由抽象基类引发的异常，用于指示一个具体的子类必须覆盖一个方法<br>OSError 由模块os中的函数引发的异常，用来指示平台的错误<br>OverflowError 整数运算的结果太大导致溢出<br>SyntaxError 语法错误<br>SystemError Python本身或某些扩展模块中的内部错误<br>TypeError 对某对象执行了不支持的操作<br>UnboundLocalError 引用未绑定值的本地变量<br>UnicodeError在Unicode的字符串之间进行转换时发生的错误<br>ValueError 应用于某个对象的操作或函数，这个对象具有正确的类型，但确有不适合的值<br>WindowsError 模块os中的函数引发的异常，用来指示与Windows相关的错误<br>ZeroDivisionError 除数为0<br>自定义异常类<br>自定义异常和多重继承<br>较有效的方法是从自定义异常类和标准异常类进行多重继承，例如<br>class CustomAttributeError(CustomException,AttributeError):<br>    pass<br>标准库中使用的其它异常<br>python标准库中的许多模块都定义了自己的异常类，如socket中的socket.error</p><p>assert语句用于在程序中引入调试代码<br>assert condition[,expression]<br>如果condition条件满足，则assert不做任何操纵<br>如果condition条件不满足，则assert使用expression作为参数实例化AssertionError并引发结果实例<br>注意：如果运行python时使用了-O优化选项，则assert将是一个空操作：编译器不为assert语句生成代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> exceptions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python函数</title>
      <link href="/2017/04/07/python-function/"/>
      <url>/2017/04/07/python-function/</url>
      
        <content type="html"><![CDATA[<p>函数基础概念<br>    函数是Python为了代码最大程度地重用和最小化代码冗余而提供地基本程序结构<br>    函数是一种设计工具，它能让程序员将复杂地系统分解为可管理地部件<br>    函数用于将相关功能打包并参数化<br>    在Python中可以创建4种函数：<br>        全局函数：定义在模块中<br>        局部函数：嵌套于其它函数中<br>        lambda函数：表达式<br>        方法：与特定数据类型关联地函数，并且只能与数据类型关联一起使用<br>    Python提供了很多内置函数<br>    语法<br>        def functionName(parameters):<br>            suite</p><a id="more"></a><pre><code>一些相关地概念    def是一个可执行语句    因此可以出现在任何能够使用语句的地方，甚至可以嵌套于其它语句，例如if或while中def创建了一个对象并将其赋值给一个变量名(即函数名)return用于返回结果对象，其为可选；无return语句的函数自动返回None对象    返回多个值时，彼此间使用逗号分隔，且组合为元组形式返回一个对象def语句运行之后，可以在程序中通过函数后附加括号进行调用Python创建、改变或查找变量名都是在名称空间中进行在代码中变量名被赋值的位置决定了其能被访问到的范围函数定义了本地作用域，而模块定义了全局作用域每个模块都是一个全局作用域，因此，全局作用域的范围仅限于单个程序文件每次对函数的调用都会创建一个新的本地作用域，赋值的变量除非声明为全局变量，否则均为本地变量所有的变量名都可以归纳为本地、全局或内置的(由__builtin__模块提供)变量名解析：LEGB原则变量名引用分三个作用域进行：首先是本地、之后是函数内、接着是全局，最后是内置</code></pre><p>函数：<br>    def funcName(arg1,arg2,…):<br>    参数传递形式：<br>    默认情况下，参数通过其位置进行传递，从左至右，这意味着，必须精确地传递和函数头部参数一样多的参数<br>    但也可以通过关键字参数、默认参数或参数容器等改变这种机制<br>    位置：从左至右<br>    关键字参数：使用”name=value”的语法通过参数名进行匹配<br>    默认参数：定义函数时使用”name=value”的语法直接给变量一个值，从而传入的值可以少于参数个数<br>    可变参数：定义函数时使用<em>开头的参数，可用于收集任意多基于位置或关键字的参数<br>    可变参数解包：调用函数时，使用</em>开头的参数，可用于将参数集合打散，从而传递任意多基于位置或关键字的参数</p><p>匿名函数lambda<br>    lambda运算符<br>        lambda args:expression<br>        args:以逗号分隔的参数列表<br>        expression:用到args中各参数的表达式<br>        lambda语句定义的代码必须是合法的表达式，不能出现多条件语句(可使用if的三元表达式)和其它非表达式语句，如for和while等<br>        lambda的首要用途是指定短小的回调函数<br>        lambda将返回一个函数而不是将函数赋值给某变量名<br>    注意<br>        lambda是一个表达式而非语句<br>        lambda是一个单个表达式，而不是一个代码块<br>    def语句创建的函数将赋值给某变量名，而lambda表达式则直接返回函数<br>    lambda也支持使用默认函数<br>    def testFunc(x,y,z): return x + y +z<br>    testFunc(4,5,6)<br>    &gt;&gt;15<br>    f = lambda x,y,x: x+y+z<br>    f(4,5,6)<br>    &gt;&gt;15<br>    f2 = (lambda x,y,z=10: x+y+z)<br>    f2(4,5)<br>    &gt;&gt;19</p><p>python函数式编程<br>    函数式编程也称作泛函编程，是一种编程范型<br>    它将电脑运算视为数学上的函数计算，并且避免状态以及可变数据<br>    函数式编程语言最重要的基础是lambda演算，而且lambda演算的函数可以接受函数当作输入和输出<br>    python支持有限的函数式编程功能<br>        filter(func,seq) :调用一个布尔函数func来迭代遍历每个seq中的元素，返回一个使func返回值为ture的元素的序列<br>        map(func,seq) :将函数func作用于给定序列(s)的每个元素，并用一个列表来提供返回值：如果func为none，func表现为一个身份函数，返回一个含有每个序列中元素集合的n个元组的列表<br>        reduce(func,seq[,init]):将二元函数作用于seq序列的元素，每次携带一对(先前的结果以及下一个序列元素)，连续地将现有的结果和下一个值作用在获得地随后地结果上，最后减少我们地序列为一个单一地返回值；如果初始值init给定，第一个比较会是init和第一个序列元素而不是序列地头两个元素</p><pre><code>练习1：返回/etc/passwd中包含了/bin/bash字串的所有用户名为一个列表练习2：将/etc/passwd文件中的每一行都分割为一个列表练习3；将任意文件按用户指定的分隔符把每一行都分隔为一个列表练习4：用折叠的方式(reduce)求阶乘</code></pre><p>python闭包：闭包叫lexical closure<br>    例1：<br>        def startPos(m,n):<br>            def newPos(x,y):<br>                print “The old position is (%d,%d),and the new position is (%d,%d).” % (m,n,m+x,n+y)<br>            return newPos<br>        action = startPos(10,10)<br>        action(1,2)<br>        运行结果：<br>            The old position is (10,10), and the new position is (11,12)</p><pre><code>例2：    def genNum(n):        i = 1        while i&lt;=n:            yield i ** 2            i +=1    g1 = genNum(10) //生成一个生成器    for i in g1:        print i,    运行结果：1 4 9 16 25 36 49 64 81 100函数中使用yield，会返回一个生成器对象。</code></pre><p>装饰器：<br>    1 装饰器本身是一个函数，用于装饰其他函数<br>    2 增强被装饰函数的功能：<br>    装饰器一般接受一个函数对象作为参数<br>    例1；<br>        def deco(func):<br>            def wrapper(x):<br>                print(“Please say someting”)<br>                func(x)<br>                print “no zuo no die”<br>            return wrapper<br>        @deco<br>        def show(x):<br>            print x<br>        show(‘hello, mars’)<br>        运行结果：<br>        please say someting<br>        hello, mars<br>        no zuo no die</p><p>递归函数：<br>        递归需要边界条件，递归前进段和递归返回段<br>        def fact(n):<br>            if n&lt;=1:<br>                return 1<br>            else:<br>                return n * fact(n-1)<br>        fact(3)<br>        运行结果：6<br>    斐波那契数列：<br>        def feibo(n):<br>            if n == 0:<br>                return 0<br>            elif n == 1:<br>                return 1<br>            else:<br>                return feibo(n-1) + feibo(n-2)<br>        feibo(0)<br>        feibo(1)<br>        feibo(2)<br>        运行结果：0,1,1<br>        费波那契数列（意大利语：Successione di Fibonacci），又译为费波拿契数、斐波那契数列、费氏数列、黄金分割数列。<br>        在数学上，费波那契数列是以递归的方法来定义：<br>        F_{0}=0<br>        F_{1}=1<br>        F_{n}=F_NaN+F_NaN（n≧2）<br>        用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。<br>        首几个费波那契系数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……<br>函数的设计规范：<br>    耦合性：<br>        1 通过参数接受输入，以及通过return产生输出以保证函数的独立性：<br>        2 尽量减少使用全局变量进行函数间通信<br>        3 不要在函数中修改可变类型参数<br>        4 避免直接改变定义在另一个模块中的变量<br>    聚合性：<br>        1 每个函数都应该有一个单一的、统一的目标<br>        2 每个函数的功能都应该相对简单<br>面向对象的基础概念：<br>    程序 = 指令+数据<br>        代码可以选择以指令为核心或以数据为核心进行编写<br>    两种范型<br>        以指令为核心：围绕”正在发生什么”进行编写<br>            面向过程编程：程序具有一系列线性步骤；主题思想是代码作用于数据<br>        以数据为核心：围绕”将影响谁”进行编写<br>            面向对象编程(OOP):围绕数据及为数据严格定义的接口来组织程序，用数据控制对代码的访问<br>    类型由状态集合(数据)和转换这些状态的操作集合组成</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件对象</title>
      <link href="/2017/04/07/python-file-object/"/>
      <url>/2017/04/07/python-file-object/</url>
      
        <content type="html"><![CDATA[<p>文件对象：<br>    文件系统和文件<br>    文件系统是0S用于明确磁盘或分区上的文件的方法和数据结构–即在磁盘上组织文件的方法<br>    计算机文件(或称文件、电脑档案)，是存储在某种长期存储设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理下<br>    概括来讲<br>    文件是计算机中由OS管理的具有名字的存储区域<br>    在linux系统上，文件被看做是字节序列<br>    Python内置函数open()用于打开文件和创建文件对象<br>    open(name[,mode[,bufsize]])<br>    open方法可以接收三个参数：文件名、模式和缓冲区参数<br>        open函数返回的是一个文件对象<br>        mode：指定文件的打开模式<br>        bufsize:定义输出缓存<br>            0表示无输出缓存<br>            1表示使用缓冲<br>            负数表示使用系统默认设置<br>            整数表示使用近似指定大小的缓冲</p><a id="more"></a><pre><code>文件打开模式简单模式    r；只读        open(&#39;/var/log/message.log&#39;,&#39;r&#39;)    w: 写入    a: 附加在模式后使用&quot;+&quot;表示同时支持输入、输出操作    如r+、w+和a+在模式后附加&quot;b&quot;表示以二进制方式打开    如rb、wb+var_name = open(ifle_name[mode,bufsize])    mode: r w a r+ w+ a+        b：表示以二进制模式打开文件 rb wb ab rb+ wb+ ab+缓冲：    0：禁用  负数：使用系统默认缓冲 1：使用缓冲，只缓冲一行数据 2：从文件尾部file.seek(offset[whence])    whence:起点        0:从文件头        1：从当前位置        2：从文件尾部    offset:偏移量</code></pre><p>文件系统功能：os<br>    目录：<br>        chdir()/fchdir() 改变当前工作目录<br>        chroot():设定当前进程的的根目录<br>        listdir():列出指定目录下的所有文件名<br>        mkdir():创建指定目录<br>        makedirs:创建多级目录<br>        getcwd：获取工作目录<br>        rmdir():<br>        removedirs():删除多级目录<br>    文件：<br>        mkfifo()<br>        mknod()<br>        remove()<br>        unlink()<br>        rename():重命名<br>        stat():<br>        symlink():<br>        utime():更新文件时间戳<br>        tmpfile():创建并打开一个新的临时文件<br>    访问权限：<br>        access():<br>        chmod():修改权限<br>        chown:改变所属主、所属组<br>        umask():设置默认权限模式<br>    文件描述符：<br>        open():<br>        read():<br>        write():<br>    设备文件：<br>        mkdev():<br>        major():<br>        write():</p><pre><code>os.path：跟文件路径相关    basename():路径基名    dirname():路径目录名    join():    split():返回dirname(),basename()元组    splitext():返回(filename,extension)元组信息:    getatime()     getctime()    getmtime()    getsize():返回文件的大小    查询：    exists():判断指定文件是否存在    isabs():判断指定路径是否为绝对路径    isdir():是否为目录    isfile():是否为文件    islink():    ismount():是否为挂载点    samefile():两个路径是否指向了同一个文件练习：判断文件是否存在，存在则打开，让用户通过键盘反复输入多行数据，追加保存至此文件中对象持久存储：    pickle    marshal    DBM接口:    shelve模块</code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器-列表解析-生成器</title>
      <link href="/2017/04/07/python-iter-List-analysis-builder/"/>
      <url>/2017/04/07/python-iter-List-analysis-builder/</url>
      
        <content type="html"><![CDATA[<h1 id="python迭代"><a href="#python迭代" class="headerlink" title="python迭代"></a>python迭代</h1><pre><code>迭代：重复做一件事iterable(可迭代)对象    支持每次返回自己所包含的一个成员的对象    对象实现了__iter__方法        序列类型， 如： list,str,tuple        非序列类型, 如：dict,file        用户自定义的一些包含了__iter__或__getitem__()方法的类迭代器(iterator)又称游标(cursor),它是程序设计的软件设计模式，是一种可在容器物件(container,如列表等)上实现元素遍历的接口迭代器是一种特殊的数据结构，当然在Python中，它也是以对象的形式存在的简单理解方式：对于一个集体中的每一个元素，想要执行遍历，那么针对这个集体的迭代器定义了遍历集体中每一个元素的顺序或者方法在Python中，迭代器是遵循迭代协议的对象使用iter()可从任何序列对象中得到迭代器若要实现迭代器，需要在类中定义next()方法(Python 3中是__next__())要使得迭代器指向下一个元素，则使用成员函数next()在Python中，是函数next(),而非成员函数当没有元素时，则引发StopIteration异常for 循环可用于任何可迭代对象for循环开始时，会通过迭代协议传递给iter()内置函数，从而能够从可迭代对象中获得一个迭代器，返回的对象含有需要的next方法</code></pre><a id="more"></a>        <h1 id="python列表解析"><a href="#python列表解析" class="headerlink" title="python列表解析"></a>python列表解析</h1><pre><code>列表解析是python迭代机制的一种应用，它常用于实现创建新的列表，因此要放置于[]中语法：    [expression for iter_var in iterable]    [expression for iter_var in iterable if cond_expr]    l = [x**2 for x in range(9)]    l    [0,1,4,9,16,25,36,49,64]列表解析：根据已有列表快速生成新列表求1-10所有整数的平方除以2的结果代码如下：for i in [i**2 for i in range(1,11)]:    print i/2,l1 = [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;] l2 = [1,2,3]l3 = [(i,j) for i in l1 for j in l2]</code></pre><h1 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h1><pre><code>生成器表达式并不真正创建数字列表，而是返回一个生成器对象，此对象在每次计算出一个条目后，把这个条目&quot;产生&quot;(yield)出来生成器表达式使用了&quot;惰性计算&quot;或称作&quot;延迟求值&quot;的机制序列过长，并且每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析生成器表达式于python 2.4引入语法    (expr for iter_var in iterable)    (expr for iter_var in iterable if cond_expr)for j in (i**2 for i in range(1,11)): print j/2生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数据的时候使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）。以下示例演示了生成器可以很简单的创建出来:def reverse(data):    for index in range(len(data)-1,-1,-1):        yield data[index]for char in reverse(&#39;hello&#39;):    print(char),运行结果：o l l e h关于迭代器和生成器的区别，生成器能做到迭代器能做的所有事,而且因为自动创建了__iter__()和 next()方法,生成器显得特别简洁,而且生成器也是高效的。除了创建和保存程序状态的自动方法,当发生器终结时,还会自动抛出StopIteration异常。一个带有yield的函数就是一个 生成器,它和普通函数不同,生成一个 generator 看起来像函数调用,但不会执行任何函数代码,直到对其调用next()(在 for 循环中会自动调用next())才开始执行。虽然执行流程仍按函数的流程执行,但每执行到一个yield语句就会中断,并返回一个迭代值,下次执行时从yield的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被yield中断了数次,每次中断都会通过yield返回当前的迭代值（yield暂停一个函数，next()从其暂停处恢复其运行）。另外对于生成器，python还提供了一个生成器表达式：类似与一个yield值的匿名函数。表达式本身看起来像列表推到, 但不是用方括号而是用圆括号包围起来：s =  {&#39;E&#39;, &#39;D&#39;, &#39;M&#39;, &#39;O&#39;, &#39;N&#39;, &#39;S&#39;, &#39;R&#39;, &#39;Y&#39;}g = (ord(c) for c in s)                          //生成器g&lt;generator object &lt;genexpr&gt; at 0x7f00535c11e0&gt;for i in g:    print (i),运行结果：69 68 77 79 78 83 82 89s =  {&#39;E&#39;, &#39;D&#39;, &#39;M&#39;, &#39;O&#39;, &#39;N&#39;, &#39;S&#39;, &#39;R&#39;, &#39;Y&#39;}g = [ord(c) for c in s]                          //列表解析g运行结果：[69, 68, 77, 79, 78, 83, 82, 89]如果需要，可以将生成器表达式传给tuple、list或是set来迭代所有的值并且返回元组、列表或是集合。在这种情况下，不需要一对额外的括号直接将生成器表达式 ord(c) for c in unique_characters传给tuple()等函数就可以了, Python 会推断出它是一个生成器表达式。使用生成器是因为效率。使用生成器表达式取代列表解析可以同时节省 cpu 和 内存(ram)。如果你构造一个列表的目的仅仅是传递给别的函数,(比如 传递给tuple()或者set()), 那就用生成器表达式替代吧!</code></pre><h1 id="产生偏移和元素"><a href="#产生偏移和元素" class="headerlink" title="产生偏移和元素"></a>产生偏移和元素</h1><p>enumerate<br>        range可在非完备遍历中用于生成索引偏移，而非偏移处的元素<br>        如果同时需要偏移索引和偏移元素，则可以使用enumerate()函数<br>        此内置函数返回一个生成器对象<br>        S = ‘hello world’<br>        E = enumerate(S)<br>        E.next()<br>        (0,’h’)<br>        E.next()<br>        (1,’e’)</p><pre><code>url = &#39;www.magedu.com&#39;g1 = enumerate(url)g1.next()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
            <tag> 列表解析 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python循环语句</title>
      <link href="/2017/04/06/python-if-while-for/"/>
      <url>/2017/04/06/python-if-while-for/</url>
      
        <content type="html"><![CDATA[<h1 id="if-测试的语法结构"><a href="#if-测试的语法结构" class="headerlink" title="if 测试的语法结构"></a>if 测试的语法结构</h1><p>if boolean_expression1:<br>    suite1<br>elif boolean_expression2:<br>    suite2<br>…<br>else:<br>    else_suite<br>elif语句是可选的<br>仅用于占位，而后再填充相关语句时，可以使用pass</p><p>if/else三元表达式<br>通常在为某变量设定默认值时通常用到的如下格式<br>if x:<br>    a=y<br>else:<br>    a=z<br>可以改写为如下简短格式<br>a = y if x else z<br>其通用条件表达式语法格式为<br>expression1 if boolean_expression else expression2<br>    如果boolean_expression的值为True,则条件表达式的结果为expression1,否则为expression2</p><a id="more"></a><h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><pre><code>    用于编写通用迭代结构    顶端测试为真即会执行循环体，并会重复多次测试直到为假后执行循环后的其他语句</code></pre><p>for 循环<br>        一个通用的序列迭代器，用于遍历任何有序的序列对象内的元素<br>        可用于字符串、元组、列表和其它的内置可迭代对象，以及通过类所创建的新对象<br>python也提供了一些能够进行隐性迭代的工具<br>    in成员关系测试<br>    列表解析<br>    map、reduce和filter函数</p><p>while 循环<br>语法格式<br>while boolean_expression:<br>    while…suite<br>else:<br>    else…suite</p><p>else分支为可选部分<br>只要boolean_expression的结果为True，循环就回执行；<br>boolean_expression的结果为False时终止循环，此时如果有else分支，则会执行</p><p>url = ‘<a href="http://www.magedu.com&#39;" target="_blank" rel="noopener">www.magedu.com&#39;</a><br>while url:<br>    print url<br>    url = url[:-1]<br>else:<br>    print “game over”</p><p>输出结果为：<br><a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a><br><a href="http://www.magedu.co" target="_blank" rel="noopener">www.magedu.co</a><br><a href="http://www.magedu.c" target="_blank" rel="noopener">www.magedu.c</a><br><a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a>.<br><a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a><br><a href="http://www.maged" target="_blank" rel="noopener">www.maged</a><br><a href="http://www.mage" target="_blank" rel="noopener">www.mage</a><br><a href="http://www.mag" target="_blank" rel="noopener">www.mag</a><br><a href="http://www.ma" target="_blank" rel="noopener">www.ma</a><br><a href="http://www.m" target="_blank" rel="noopener">www.m</a><br>www.<br>www<br>ww<br>w<br>game over</p><p>url = ‘<a href="http://www.magedu.com&#39;" target="_blank" rel="noopener">www.magedu.com&#39;</a><br>while url:<br>    print url<br>    url = url[:-1]<br>    x +=1<br>    if x &gt;7:<br>        break<br>else:<br>    print “game over”</p><p>输出结果为：<br><a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a><br><a href="http://www.magedu.co" target="_blank" rel="noopener">www.magedu.co</a><br><a href="http://www.magedu.c" target="_blank" rel="noopener">www.magedu.c</a><br><a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a>.<br><a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a><br><a href="http://www.maged" target="_blank" rel="noopener">www.maged</a><br><a href="http://www.mage" target="_blank" rel="noopener">www.mage</a></p><p>while:<br>    while bool_expression:<br>        while_suite<br>    else:<br>        else_suite</p><pre><code>break:跳出最内层的循环：continue:跳到所处的最近层循环的开始处：pass:点位语句else代码块：循环正常终止才会执行：如果循环终止是由break跳出导致的，则else不会执行：</code></pre><p>练习题：<br>    练习1：逐一显示指定列表中的所有元素：<br>    代码如下：<br>        l1 = [1,2,3,4,5,6]<br>        while l1:<br>            print l1.pop(0),</p><pre><code>    运行结果：1 2 3 4 5 6    l2 = [&#39;abc&#39;,&#39;bcd&#39;,&#39;cde&#39;]    count = 0    while count &lt;len(l2):        print l2[count]        count +=1    while l2:        print l2[0]        l2=l2[1:]练习2：求100以内所有偶数之和：代码如下：    i = 1;sum = 0    while i&lt;=100:        if i%2==0:            sum += i            i += 2        else:            i +=1    print sum    运行结果：2550    i = 0;sum = 0    while i&lt;=100:        if i%2==0:            sum += i            i += 2    print sum    运行结果：2550    扩展题：求num以内所有奇数之和：        num = int(raw_input(&#39;请输入一个num:&#39;))        i = 1;sum =0        while i&lt;=num:            if i%2!=0:                sum += i                i += 2            else:                i +=1        print sum        运行结果：2500练习3：逐一显示指定字典的所有建：并显示结束后说明总键数：运行代码：    d1 = {&#39;xiaohao&#39;:78,&#39;xiaoming&#39;:89,&#39;wangwu&#39;:100}    count = 0    x = d1.keys()    while count &lt;len(x):        print x[count]        count +=1    print count    运行结果：            xiaohao            xiaoming            wangwu            3    练习4：创建一个包含了100以内所有奇数的列表：运行代码：        i = 1;sum = 0        while i&lt;=100:            if i%2!=0:                sum += i                i +=2            else:                i +=1        print sum        运行结果；2500练习5：逆序逐一显示一个列表的所有元素运行代码：        l1 = [&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;]        i = 0        while i&lt;len(l1):            l1.reverse()            print l1[i]            i +=1        运行结果：        Sun        Tue        Fri        Thu        Wed        Sat        Mon练习6：列表l1=[0,1,2,3,4,5,6],列表l2=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;],以第一个列表中的元素为键，以第二个列表中的元素为值生成字典d1:运行代码：    l1=[0,1,2,3,4,5,6]    l2=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;]    d1= {}    count = 0    if len(l1)==len(l2):        while count &lt;len(l1):            d1[l1[count]]=l2[count]            count +=1    print d1    运行结果：    {0: &#39;Sun&#39;, 1: &#39;Mon&#39;, 2: &#39;Tue&#39;, 3: &#39;Wed&#39;, 4: &#39;Thu&#39;, 5: &#39;Fri&#39;, 6: &#39;Sat&#39;}</code></pre><p>死循环<br>        while True:</p><h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><pre><code>语法格式for expression1 in iterable:    for_suiteelse:    else_suite通常，expression或是一个单独的变量，或是一个变量序列，一般以元组的形式给出如果以元组或列表用于expression,则其中的每个数据项都会拆分到表达式的项，例如T=[(1,2),(3,4),(5,6),(7,8)]for (a,b) in T    print a bfor i in range(1,101):    sum +=iprint sumfor i in xrange(1,101):    sum +=i</code></pre><p>for 循环形式扩展<br>    语法格式<br>    for expression in iterable:<br>        for_suite<br>        if boolean_expression2:break<br>        if boolean_expression3:continue<br>    else:<br>        else_suite</p><p>编写循环的技巧<br>    for 循环比while循环执行速度快<br>    python提供了两个内置函数，用于在for循环中定制特殊的循环<br>        range或xrange<br>            range:一次性地返回连续地整数列表<br>            xrange:一次产生一个数据元素，相较于range更节约空间<br>        range函数<br>            非完备遍历<br>                用于每隔一定的个数元素挑选一个元素<br>                S = ‘How are you these days?’<br>                range(0,len(S),2)<br>                &gt;&gt; [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]<br>                for i in range(0,len(S),2):print S[i],<br>                &gt;&gt;H w a e y u t e e d y ?<br>            修改列表<br>                L  = [1,2,3,4,5]<br>                for i in range(len(L)):L[i]+=1<br>                L<br>                &gt;&gt;[2,3,4,5,6]</p><pre><code>    zip        返回并行地元素元组的列表，常用于在for循环中遍历数个序列        取得一个或多个序列为参数，将给定序列中的并排的元素配成元组，返回这些元组的列表        当参数长度不同时，zip会以最短序列的长度为准        可在for循环中用于实现并行迭代        l1 = [1,2,3,4,5,6,7]        l2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;]        zip(l1,l2)        运行结果：        [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;), (5, &#39;e&#39;), (6, &#39;f&#39;), (7, &#39;g&#39;)]        zip也常用于动态构造字典        keys = [1,2,3,4,5,6,7]        values = [&#39;Mon&#39;,&#39;Tus&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;,&#39;Sun&#39;]        D={}        for (k,v) in zip(keys,values): D[k] = v        print D        运行结果：        {1: &#39;Mon&#39;, 2: &#39;Tus&#39;, 3: &#39;Wed&#39;, 4: &#39;Thu&#39;, 5: &#39;Fri&#39;, 6: &#39;Sat&#39;, 7: &#39;Sun&#39;}</code></pre><p>for 循环练习：<br>            练习1：逐一分开显示指定字典d1中的所有元素，类似如下<br>            代码如下：<br>            d1 = {‘a’:12,’b’:23,’c’:34}<br>            for (k,v) in d1.items():print k,v<br>            运行结果：<br>            &gt;&gt;<br>                a 12<br>                c 34<br>                b 23</p><pre><code>        练习2：逐一显示列表中l1=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;]中的索引为奇数的元素：        l1=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;]        i = 1        for i in range(1,len(l1),2)            print l1[i],        运行结果：        &gt;&gt; Mon Wed Fri        练习3：将属于列表l1=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;],但不属于列表l2=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;]的所有元素定义为一个新列表l3;        代码如下：        l1=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;]        l2=[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;]        l3 = []        for i in l1:            if i not i l2:                l3.append(i)        print l3        运行结果：            [&#39;Fri&#39;, &#39;Sat&#39;]        练习4：已知列表namelist=[&#39;stu1&#39;,&#39;stu2&#39;,&#39;stu3&#39;,&#39;stu4&#39;,&#39;stu5&#39;,&#39;stu6&#39;,&#39;stu7&#39;],删除列表removelist=[&#39;stu3&#39;,&#39;stu7&#39;,&#39;stu9&#39;]:请将属于removelist列表中的每个元素从namelist中移除(属于removelist,但不属于namelist的忽略即可)：        代码如下：        namelist=[&#39;stu1&#39;,&#39;stu2&#39;,&#39;stu3&#39;,&#39;stu4&#39;,&#39;stu5&#39;,&#39;stu6&#39;,&#39;stu7&#39;]        removelist=[&#39;stu3&#39;,&#39;stu7&#39;,&#39;stu9&#39;]        for i in removelist:            if i in namelist:                namelist.remove(i)        print namelist        运行结果：            [&#39;stu1&#39;, &#39;stu2&#39;, &#39;stu4&#39;, &#39;stu5&#39;, &#39;stu6&#39;]</code></pre><h1 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h1><pre><code>1 动态语言    sys.getrefcount()    增加对象的引用计数场景：        对象创建时        将对象添加到容器时；类似list.append()        当对象被当作参数传递给函数时        为对象创建另外变量名    减少引用计数：        引用此对象的某变量名被显式销毁： del x        给引用此对象的某变量名重新赋值        从容器中移除对象时，类似list.pop()        容器本身被销毁2 if    if boolean_expression:        ...    elif bool_expression:        ...    else:        ...3 while    while bool_expression:        while_suite        if bool_expression2:continue        if bool_expression3:break    else:        else_suite4 for     for expression in object:        for_suite        if bool_expression2:continue        if bool_expression3:break    else:        else_suite</code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if </tag>
            
            <tag> while </tag>
            
            <tag> for </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
