<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker部署rancher1.6</title>
      <link href="/2019/12/06/docker%E9%83%A8%E7%BD%B2rancher1-6/"/>
      <url>/2019/12/06/docker%E9%83%A8%E7%BD%B2rancher1-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos7系统部署rancher1-6-28版本"><a href="#Centos7系统部署rancher1-6-28版本" class="headerlink" title="Centos7系统部署rancher1.6.28版本"></a>Centos7系统部署rancher1.6.28版本</h2><h3 id="首先安装docker"><a href="#首先安装docker" class="headerlink" title="首先安装docker"></a>首先安装docker</h3><p>如果想要安装指定版本的docker，请移步<a href="https://cntsp.github.io/2019/11/14/centos7%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2docker-ce/">安装指定版本docker</a></p><p>本次操作安装默认版本的docker(1.13.1):</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> docker</code></pre><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p><strong>单机部署，不使用外置的数据库</strong></p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld.servicedocker pull rancher/server:v1.6.26docker run --name rancher --restart<span class="token operator">=</span>unless-stopped  -d -p 8080:8080 rancher/server:v1.6.26</code></pre><p>访问rancher UI界面：</p><pre class=" language-bash"><code class="language-bash">http://IP:8080</code></pre><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>单机部署，使用外置的数据库</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 关闭防火墙</span>systemctl stop firewalld.service<span class="token comment" spellcheck="true"># 下载mariadb镜像tag为10.1</span>docker pull mariadb:10.1<span class="token comment" spellcheck="true"># 下载rancher/server的镜像tag为v1.6.28</span>docker pull rancher/server:v1.6.28<span class="token comment" spellcheck="true"># 启动数据库容器，名字为mariadb2,root密码为nihaoma</span>docker run -d --name maridb2 -p 3306:3306 -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>nihaoma  mariadb:10.1 <span class="token comment" spellcheck="true"># 进入mariadb2数据库容器</span>docker <span class="token function">exec</span> -it mariadb2 /bin/bash<span class="token comment" spellcheck="true"># 进入数据库</span>mysql -uroot -pnihaoma<span class="token operator">></span> CREATE DATABASE IF NOT EXISTS cattle COLLATE <span class="token operator">=</span> <span class="token string">'utf8_general_ci'</span> CHARACTER SET <span class="token operator">=</span> <span class="token string">'utf8'</span><span class="token punctuation">;</span><span class="token operator">></span> GRANT ALL ON cattle.* TO <span class="token string">'cattle'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'cattle'</span><span class="token punctuation">;</span><span class="token operator">></span> FLUSH PRIVILEGES<span class="token punctuation">;</span><span class="token operator">></span> EXIT<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 启动rancher/server容器连接外置的数据库容器</span>docker run --name rancher2 --restart<span class="token operator">=</span>unless-stopped -d -p 18080:8080 rancher/server:v1.6.28 \--db-host xxx.xxx.xxx.xxx --db-port 3306 --db-user cattle --db-pass cattle --db-name cattle</code></pre><p>如果出现链接不到数据库的情况，请重启一下docker服务</p><pre class=" language-bash"><code class="language-bash">systemctl restart docker.service</code></pre><pre class=" language-bash"><code class="language-bash">http://IP:8080</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> rancher1.6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/05/hello-world/"/>
      <url>/2019/12/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-固定节点</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E5%9B%BA%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E5%9B%BA%E5%AE%9A%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="指定调度节点"><a href="#指定调度节点" class="headerlink" title="指定调度节点"></a>指定调度节点</h2><p><strong>I、Pod.spec.nodeName 将 Pod 直接调度到指定的Node节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">7</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeName</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>node1      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p><strong>II、Pod.spec.nodeSelector: 通过kubernetes 的 label-selector 机制选择节点，由调度器调度策略匹配label，而后调度Pod到目标节点，该匹配规则属于强制约束</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">disk</span><span class="token punctuation">:</span> ssd      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 固定节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-污点</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%B1%A1%E7%82%B9/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%B1%A1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Tain-和-Toleration"><a href="#Tain-和-Toleration" class="headerlink" title="Tain 和  Toleration"></a>Tain 和  Toleration</h2><p><strong>节点亲和性，是 pod 的一种属性（偏好或硬性要求），它使 pod 被吸引到一类特定的节点。Taint 则相反，它使节点能够排斥一类特定的pod</strong></p><p><strong>Taint 和 toleration 相互配合，可以用来避免 pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个taint，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。如果将 toleration 应用与pod上，则表示这些 pod 可以 （但不要求）被调度到具有匹配 taint 的节点上</strong></p><h2 id="污点-Taint"><a href="#污点-Taint" class="headerlink" title="污点(Taint)"></a>污点(Taint)</h2><p><strong>I、污点（Taint）的组成</strong></p><p><strong>使用 <code>kubectl taint</code> 命令可以给某个Node节点设置污点，Node 被设置上污点之后就和Pod 之间存在了一种相斥的关系，可以让Node拒绝Pod的调度执行，甚至将Node已经存在的Pod驱逐出去</strong></p><p><strong>每个污点的组成如下：</strong></p><pre class=" language-yaml"><code class="language-yaml">key=value<span class="token punctuation">:</span>effect</code></pre><p><strong>每个污点有一个Key和value作为污点的标签，其中value可以为空，effect描述污点的作用。当前taint effect 支持如下三个选项：</strong></p><ul><li><code>NoSchedule</code>: <strong>表示K8S将不会将Pod调度到具有该污点的Node上</strong></li><li><code>PreferNoSchedule</code>:<strong>表示k8s将尽量避免Pod调度到具有该污点的Node上</strong></li><li><code>NoExecute</code>:<strong>表示k8s将不会将Pod调度到具有该污点的Node上，同时会将Node上已经存在的Pod驱逐出去</strong></li></ul><p><strong>II、污点的设置、查看和去除</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置污点</span>kubectl taint nodes node1 key1<span class="token operator">=</span>value1:NoSchedule<span class="token comment" spellcheck="true"># 节点说明中，查找 Taints 字段</span>kubectl describe pod pod-name<span class="token comment" spellcheck="true"># 去除污点</span>kubectl taint nodes node1 key1:NoSchedule-</code></pre><h2 id="容忍（Tolerations）"><a href="#容忍（Tolerations）" class="headerlink" title="容忍（Tolerations）"></a>容忍（Tolerations）</h2><p><strong>设置了污点的Node将根据 taint 的effect: NoSchedule、PreferNoSchedule、NoExecute和Pod之间产生互斥的关系，Pod将在一定程度上不会被调度到Node上。但我们可以在Pod上设置容忍(Toleration)，意思是设置了容忍的Pod将可以容忍污点的存在，可以被调度到存在污点的Node上</strong></p><p><strong>pod.spec.tolerations</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key1"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>  <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span>  <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">3600</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key1"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>  <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoExecute"</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key2"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span></code></pre><ul><li><strong>其中 key,value,effect 要与 Node上设置的 taint 保持一致</strong></li><li><strong>operator 的值为Exists将会忽略 value 值</strong></li><li><strong>tolerationsSeconds</strong>：<strong>用于描述当Pod需要被驱逐时可以在Pod上继续保留运行的时间</strong></li></ul><p><strong>I、当不指定 key 值时，表示容忍所有的污点key:</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span></code></pre><p><strong>II、当不指定effect值时，表示容忍所有的污点作用</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span></code></pre><p><strong>III、有多个Master存在时，防止资源浪费，可以如下设置</strong></p><pre class=" language-bash"><code class="language-bash">kubectl taint nodes Node-Name node-role.kubernetes.io/master<span class="token operator">=</span>:PreferNoSchedule</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> taint </tag>
            
            <tag> toleration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-调度亲和性</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E4%BA%B2%E5%92%8C%E6%80%A7/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E4%BA%B2%E5%92%8C%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="节点的亲和性"><a href="#节点的亲和性" class="headerlink" title="节点的亲和性"></a>节点的亲和性</h2><p><strong>pod.spec.nodeAffinity</strong></p><ul><li><strong>preferredDuringSchedulinglgnoredDuringExecution:软策略</strong></li><li><strong>requireDuringSchedulinglgnoredDuringExecution:硬策略</strong></li></ul><p><strong>requiredDuringSchedulinglgnoredDuringExecution</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> affinity  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname            <span class="token key atrule">operator</span><span class="token punctuation">:</span> NotIn            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>node2</code></pre><p><strong>preferredDuringSchedulingIgnoredDuringExecution</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> affinity1  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">preference</span><span class="token punctuation">:</span>          <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>node3</code></pre><h2 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: affinity  labels:    app: node-affinity-podspec:  containers:  - name: with-node-affinity    image: harbor.bwingame8.com/library/myapp:v1  affinity:    nodeAffinity:      requiredDuringSchedulingIgnoredDuringExecution:        nodeSelectorTerms:        - matchExpressions:          - key: kubernetes.io/hostname            operator: NotIn            values:            - k8s-node2      preferredDuringSchedulingIgnoredDuringExecution:      - weight: 1        preference:          matchExpressions:          - key: <span class="token function">source</span>            operator: In            values:            - k8s-node2</code></pre><p><strong>键值运算关系</strong></p><ul><li><strong>In: label的值在某个列表中</strong></li><li><strong>NotIn:label的值不在某个列表中</strong></li><li><strong>Gt: label的值大于某个值</strong></li><li><strong>Lt: label的值小于某个值</strong></li><li><strong>Exists：某个label存在</strong></li><li><strong>DoesNotExist：某个label不存在</strong></li></ul><!--如果`nodeSeletorTerms`下面有多个选项的话，满足任何一个条件就可以了；如果`matchExpressions`有多个选项的话，则必须同时满足这些条件才能正常调度 POD--><h2 id="Pod-亲和性"><a href="#Pod-亲和性" class="headerlink" title="Pod 亲和性"></a>Pod 亲和性</h2><p><strong>pod.spec.affinity.podAffinity/podAntiAffinity</strong></p><ul><li><strong>preferredDuringSchedulingIgnoredDuringExecution: 软策略</strong></li><li><strong>requiredDuringSchedulingIgnoredDuringExecution:硬策略</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">podAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app          <span class="token key atrule">operator</span><span class="token punctuation">:</span> In          <span class="token key atrule">values</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> pod<span class="token punctuation">-</span><span class="token number">1</span>        <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">podAffinityTerm</span><span class="token punctuation">:</span>          <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app              <span class="token key atrule">operator</span><span class="token punctuation">:</span> In              <span class="token key atrule">values</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> pod<span class="token punctuation">-</span><span class="token number">2</span>          <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname</code></pre><p><strong>亲和性/反亲和性调度策略比较如下：</strong></p><table>    <tr><th>调度策略</th><th>匹配标签</th><th>操作符</th><th>拓扑域支持</th><th>调度目</th</tr>    <tr><td>nodeAffinity</td><td>主机</td><td>In,NotIn,Exists,DoesNotExist,Gt,Lt</td><td>否</td><td>指定主机</td></tr>    <tr><td>podAffinity</td><td>POD</td><td>In,NotIn,Exists,DoesNotExist</td><td>是</td><td>POD与指定POD同一拓扑域</td></tr>    <tr><td>podAnitAffinity</td><td>POD</td><td>In,NotIn,Exists,DoesNotExist</td><td>是</td><td>POD与指定POD不再同一个拓扑域</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 亲和性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-调度说明</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Scheduler 是kubernetes的调度器，主要的任务是把定义的Pod分配到集群的节点上。听起来非常简单，单有很多要考虑的问题</strong></p><ul><li><strong>公平：如何保证每个节点都能被分配资源</strong></li><li><strong>资源高效利用：集群所有资源最大化被使用</strong></li><li><strong>效率：调度的性能要好，能够尽快地对大批量的Pod 完成调度工作</strong></li><li><strong>灵活：允许用户根据自己的需求控制调度的逻辑</strong></li></ul><p><strong>Scheduler 是作为单独的程序运行的，启动之后会一直监听API Server，获取 <code>PodSpec.Nodename</code>为空的pod,对每个pod都会创建一个binding,表明该Pod应该放到哪个节点上</strong></p><h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><p><strong>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程为<code>predicate</code>；然后对通过的几点按照优先级排序，这个是<code>priority</code>;最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误</strong></p><p><strong>Predicate 有一系列的算法可以使用：</strong></p><ul><li><code>PodFitsResources</code>:<strong>节点上剩余的资源是否大于pod请求的资源</strong></li><li><code>PodFitHost</code>:<strong>如果pod指定了NodeName,检查节点名称是否和NodeName匹配</strong></li><li><code>PodFitsHostPorts</code>:<strong>节点上已经使用的port是否和pod申请的port冲突</strong></li><li><code>PodSelectorMatches</code>: <strong>过滤掉和pod指定的label不匹配的节点</strong></li><li><code>NoDiskConflict</code>:<strong>已经mount的volume和pod指定的volume不冲突，除非它们都是只读</strong></li></ul><p><strong>如果在predicate过程中没有合适的节点，pod会一直在<code>pending</code>状态，不断重试调度，直到有节点满足条件。经过这个步骤，如果有多个节点满足条件，就继续priorities过程：安装优先级大小对节点排序</strong></p><ul><li><code>LeastRequestedPriority</code>：<strong>通过计算CPU和Memory使用率越接近，权重越高。这个应该和上面的一起使用，不应该单独使用</strong></li><li><code>ImageLocalityPriority</code>:<strong>倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高</strong></li></ul><p><strong>通过算法对所有的优先级项目和权重进行计算，得出最终的结果</strong></p><h2 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h2><p><strong>除了kubernetes自带的调度器，你也可以编写自己的调度器。通过<code>spec:schedulername</code>参数指定调度器的名字，可以为pod选择某个调度器进行调度。比如下面的pod选择<code>my.scheduler</code>进行调度，而不是默认的<code>default.scheduler</code>;</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> annotation<span class="token punctuation">-</span>second<span class="token punctuation">-</span>scheduler  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> multischeduler<span class="token punctuation">-</span>example<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedulername</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>scheduler  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>with<span class="token punctuation">-</span>second<span class="token punctuation">-</span>annotation<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> gcr.io/google_containers/pause<span class="token punctuation">:</span><span class="token number">2.0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 调度器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-volume</title>
      <link href="/2019/12/01/kubernetes-persistent-volume/"/>
      <url>/2019/12/01/kubernetes-persistent-volume/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong><code>PersistentVolume</code>（PV）</strong></p><p><strong>是由管理员设置的存储，它是集群中的一部分。就像节点是集群中的资源一样，PV也是集群中的资源。PV是Volume之类的卷插件，但具有独立于使用PV的Pod的生命周期。此 API 对象包含存储实现的细节，即NFS、iSCSI或特定于云供应商的存储系统</strong></p><p><strong><code>PersistentVolumeClaim</code> （PVC）</strong></p><p><strong>是用户存储的请求。它与Pod相似。Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源(CPU和内存)。声明可以请求特定的大小和访问模式(例如，可以以读/写一次或只读多次模式挂载)</strong></p><p><strong>静态pv</strong></p><p><strong>集群管理员创建一些PV。它们带有可供集群用户使用的实际存储的细节。它们存在与Kubernetes API中，可用于消费</strong></p><p><strong>动态</strong></p><p><strong>当管理员创建的静态PV都不匹配用户的<code>PersistentVolumeClaim</code>时，集群可能会尝试动态地为PVC创建卷。此配置基于<code>StorageClasses</code>:   PVC必须请求[存储类]，并且管理员必须创建并配置该类才能进行动态创建。声明该类为<code>&quot;&quot;</code>可以有效地禁用其动态配置</strong></p><p><strong>要启用基于存储级别的动态存储配置，集群管理员需要启用API server 上的<code>DefaultStorageClass</code>[准入控制器]。例如，通过确保<code>DefaultStorageClass</code>位于 API server 组件的<code>--admission-control</code>标志，使用逗号分割的有序值列表中，可以完成此操作</strong></p><p><strong>绑定</strong></p><p><strong>master中的控制环路监视新的PVC，寻找匹配的PV（如果可能），并将它们绑定在一起。如果为新的PVC动态调配PV，则该环路将始终将该PV绑定到PVC。否则，用户总会得到他们所请求的存储，但是容量可能超出要求的数量。一旦PV和PVC绑定后，<code>PersistentVolumeClaim</code>绑定是排他性的，不管它们是如何绑定的。PVC跟PV绑定是一对一的映射</strong></p><h2 id="持久化卷声明的保护"><a href="#持久化卷声明的保护" class="headerlink" title="持久化卷声明的保护"></a>持久化卷声明的保护</h2><p><strong>PVC保护的目的是确保由Pod正在使用的PVC不会从系统中移除，因为如果被移除的话可能会导致数据丢失</strong></p><!--注意： 当 pod 状态为 `Pending` 并且 pod 已经分配给节点或 pod 为 `Running` 状态时，PVC处于活动状态 --><p><strong>当启用PVC包含alpha功能时，如果用户删除了一个Pod正在使用的PVC，则该PVC不会被立即删除。PVC的删除将被推迟，直到PVC不再被任何pod使用</strong></p><p><strong>持久化卷类型</strong></p><p><code>PersistenVolume</code>类型以插件形式实现。Kubernetes目前支持以下插件类型：</p><ul><li>GCEPersistentDisk AWSElasticBlockStore AzureFile AzureDisk FC(Fibre Channel)</li><li>FlexVolume Flocker NFS iSCSI RBD(Ceph Block Device) CephFS</li><li>Cinder(OpenStack block storage) Glusterfs VsphereVolume Quobyte Volumes</li><li>HostPath VMware Photom Portworx Volumes ScaleIO Volumes StorageOS</li></ul><p><strong>持久卷演示代码</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv0003<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 5Gi  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> slow  <span class="token key atrule">mountOptions</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> hard    <span class="token punctuation">-</span> nfsvers=4.1  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /tmp    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.17.0.2</code></pre><h2 id="PV-访问模式"><a href="#PV-访问模式" class="headerlink" title="PV 访问模式"></a>PV 访问模式</h2><p><code>PersistentVolume</code>可以以资源提供者支持的任何方式挂载到主机上。如下表表示，供应商具有不同的功能，每个PV的访问模式都将设置为该卷支持的特定模式。例如，NFS可以支持多个读/写客户端，但特定的NFS PV可能以只读方式导出到服务器上。每个PV都有一套自己的用来描述特定功能的访问模式</p><ul><li>ReadWriteOne – 该卷可以被单个节点以读/写模式挂载</li><li>ReadOnlyMany– 该卷可以被多个节点以只读模式挂载</li><li>ReadWriteMany– 该卷可以被多个节点以读/写模式挂载</li></ul><p><strong>在命令行中，访问模式缩写为：</strong></p><ul><li><strong>RWO - ReadWriteOnce</strong></li><li><strong>ROX - ReadOnlyMany</strong></li><li><strong>RWX- ReadWriteMany</strong></li></ul><!-- 一个卷一次只能使用一种访问模式挂载，即使它支持很多访问模式。例如， GCEPersistentDisk 可以由单个节点作为 ReadWriteOnce 模式挂载，或由多个节点以 ReadOnlyMany 模式挂载，但不能同时挂载 --><table>    <tr><th>Volume 插件</th><th>ReadWriteOnce</th><th>ReadOnlyMany</th><th>ReadWriteMany</th></tr>    <tr><td>AWSElasticBlockStoreAWSElasticBlockStore</td><td>√</td><td>-</td><td>-</td</tr>    <tr><td>AzureFile</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>AzureDisk</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>CephFS</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>Cinder</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>FC</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>FlexVolume</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>Flocker</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>GCEPersistentDisk</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>Glusterfs</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>HostPath</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>iSCSI</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>PhotonPersistentDisk</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>Quobyte</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>NFS</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>RBD</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>VsphereVolume</td><td>√</td><td>-</td><td>-(当Pod并列时有效)</td></tr>    <tr><td>PorworxVolume</td><td>√</td><td>-</td><td>√</td></tr>    <tr><td>ScaleIO</td><td>√</td><td>√</td><td>-</td></tr></table><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><ul><li><strong>Retain（保留）– 手动回收</strong></li><li><strong>Recycle（回收）–基本擦除(<code>rm -rf /thevolume/*</code>) 最新版的服务已经不支持该回收策略了</strong></li><li><strong>Delete（删除）– 关联的存储资产（例如AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder卷)将被删除</strong></li><li><strong>当前，只有 NFS 和HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk和Cinder卷支持删除策略</strong></li></ul><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>卷可以处于以下的某种状态:</p><ul><li><p><strong>Available(可用) – 一块空闲资源还没有被任何声明绑定</strong></p></li><li><p><strong>Bound(已绑定)– 卷已经被声明绑定</strong></p></li><li><p><strong>Released（已释放）–声明被删除，但是资源还未被集群重新声明</strong></p></li><li><p><strong>Faild(失败) – 该卷的自动回收失败</strong></p></li></ul><p>*<em>命令行会显示绑定到 PV 的 PVC 的名称 *</em></p><h2 id="持久化演示说明-NFS"><a href="#持久化演示说明-NFS" class="headerlink" title="持久化演示说明 - NFS"></a>持久化演示说明 - NFS</h2><p><strong>I、安装 NFS 服务器</strong></p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y nfs-common nfs-utils rpcbind<span class="token function">mkdir</span> /nfsdata<span class="token function">chmod</span> 666 /nfsdata<span class="token function">chown</span> nfsnobody /nfsdata<span class="token function">cat</span> /etc/exports    /nfsdata *<span class="token punctuation">(</span>rw,no_root_squash,no_all_squash,sync<span class="token punctuation">)</span>systemctl start rpcbindsystemctl start nfs</code></pre><p><strong>II、部署 PV</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfspv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassNmae</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/nfs    <span class="token key atrule">server</span><span class="token punctuation">:</span> 10.66.66.10</code></pre><p><strong>III、创建服务并使用 PVC</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> web  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> web        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> www    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"nfs"</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi</code></pre><h2 id="关于StatefulSet"><a href="#关于StatefulSet" class="headerlink" title="关于StatefulSet"></a>关于StatefulSet</h2><ul><li><strong>匹配 Pod name（网络标识）的模式为：(statefulset名称)-(序号),比如上面的示例： web-0,web-1,web-2</strong></li><li><strong>StatefulSet为每一个Pod副本创建了一个DNS域名，这个域名的格式为：$(podname).(headless server name),也就意味着服务间是通过Pod域名来通信而非Pod IP,因为当Pod所在Node发生故障时，Pod会被漂移到其它Node上，Pod IP会发生变化，但是Pod域名不会有变化</strong></li><li><strong>StatefulSet 使用 Headless 服务来控制Pod的域名，这个域名的FQDN为：(servicename).(namespace).svc.cluster.local,其中,“cluster.local”指的是集群的域名</strong></li><li><strong>根据 volumeClaimTemplates，为每个 Pod创建一个pvc,pvc的命名规则匹配模式：（volumeClaimTemplates.name)-(pod_name),比如上面的volumeMounts.name=www,Pod name=web-[0-2],因此创建出来的PVC是www-web-0、www-web-1、www-web-2</strong></li><li><span style="color: red;"><strong>删除 Pod 不会删除其pvc，手动删除pvc将自动释放pv</strong></span></li></ul><p><strong>StatefulSet的启停顺序:</strong></p><ul><li><strong>有序部署： 部署StatefulSet时，如果有多个Pod副本，它们会被顺序地创建(从0到N-1)并且，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态</strong></li><li><strong>有序删除：当Pod被删除时，它们被终止的顺序是N-1到0</strong></li><li><strong>有序扩展：当对Pod执行扩展操作时，与部署一样，它前面的Pod必须都处于Running和Ready状态</strong></li></ul><p><strong>StatefulSet使用场景：</strong></p><ul><li><strong>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现。</strong></li><li><strong>稳定的网络标识符，即Pod重新调度后其Podname和Hostname不变。</strong></li><li><strong>有序部署，有序扩展，基于 init containers来实现。</strong></li><li><strong>有序收缩</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-volume</title>
      <link href="/2019/12/01/kubernetes-volume/"/>
      <url>/2019/12/01/kubernetes-volume/</url>
      
        <content type="html"><![CDATA[<p><strong>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet会重启它，但是容器中的文件将丢失–容器以干净的状态(镜像最初的状态)重新启动。其次，在<code>Pod</code>中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes中的<code>Volume</code>抽象就很好的解决了这些问题</strong></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Kubernetes中的卷有明确的寿命 <code>--</code> 与封装它的Pod相同。所以，卷的生命比Pod中的所有容器都长，当这个容器重启时数据仍然得以保存。当然 Pod 不再存在时，卷也将不复存在。也许更重要的是，<code>Kubernetes</code>支持多种类型的卷，Pod可以同时使用任意数量的卷</strong></p><h2 id="卷的类型"><a href="#卷的类型" class="headerlink" title="卷的类型"></a>卷的类型</h2><p><strong>Kubernetes 支持一下类型的卷：</strong></p><ul><li><code>awsElasticBlockStore</code> <code>azureFile</code> <code>cephfs</code> <code>csi</code> <code>downwardAPI</code> `emptyDir``</li><li><code>fc</code> <code>flocker</code> <code>gcePersistentDisk</code> <code>gitRepo</code> <code>glusterfs</code> <code>hostPath</code> <code>iscsi</code> <code>local</code> <code>nfs</code></li><li><code>persistentVolumeClaim</code> <code>projected</code> <code>portworxVolume</code> <code>quobyte</code> <code>rbd</code> <code>scaleIO</code> <code>secret</code></li><li><code>storageos</code> <code>vsphereVolume</code></li></ul><p><strong>emptyDir</strong></p><p>当Pod被分配给节点时，首先创建 <code>emptyDir</code> 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中容器可以读取和写入 <code>emptyDir</code> 卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时， <code>emptyDir</code> 中的数据将被永久删除</p><!-- 注意： 容器崩溃不会从节点中移除 pod ，因此 `emptyDir` 卷中的数据在容器崩溃时是安全的 --><p><code>emptyDir</code> 的用法有：</p><ul><li>暂存空间，例如用于基于磁盘的合并排序</li><li>用作长时间计算崩溃恢复时的检查点</li><li>web服务器容器提供数据时，保存内容管理器容器提取的文件</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pd<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/test<span class="token punctuation">-</span>webserver    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /cache      <span class="token key atrule">name</span><span class="token punctuation">:</span> cache<span class="token punctuation">-</span>volume  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cache<span class="token punctuation">-</span>volume    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><p><strong><code>hostPath</code> 卷将主机节点的文件系统中的文件或目录挂载到集群中</strong></p><p><code>hostPath</code> 的用途如下：</p><ul><li>运行需要访问 Docker 内部的容器： 使用 <code>/var/lib/docker</code>的 <code>hostPath</code></li><li>在容器中运行cAdvisor；使用 <code>/dev/cgroups</code>的 <code>hostPath</code></li></ul><p>除了所需的 <code>path</code> 属性之外，用户还可以为<code>hostPath</code>卷指定 <code>type</code></p><hr><table>    <tr><th>值</th><th>行为</th></tr>    <tr><td></td><td>空字符串(默认)用于向后兼容，这意味着在挂载hostPath 卷之前不会执行任何检查。</td></tr>    <tr><td>DirectoryOrCreate</td><td>如果在给定的路径上没有任何东西存在，那么将根据需要在那里创建一个空目录，权限设置为0755，与kubelet具有相同的组和所有权</td></tr>    <tr><td>Directory</td><td>给定的路径下必须存在目录</td></tr>    <tr><td>FileOrCreate</td><td>如果在给定的路径上没有任何东西存在，那么会根据需要创建在那里创建一个空文件，权限设置为0644，与Kubelete具有相同的组和所有权。</td></tr>    <tr><td>File</td><td>给定的路径下必须存在文件</td></tr>    <tr><td>Socket</td><td>给定的路径下必须存在 UNIX 套接字 </td></tr>    <tr><td>CharDevice</td><td>给定的路径下必须存在字符设备</td></tr>    <tr><td>BlockDevice</td><td>给定的路径下必须存在块设备</td></tr></table><p>使用这种卷类型是请注意，因为：</p><ul><li>由于每个节点上的文件都不同，具有相同配置(例如从podTemplate创建的)的 pod 在不同节点上的行为可能会有所不同</li><li>当Kubernetes 按照计划添加资源感知调度时，将无法考虑 <code>hostPath</code> 使用的资源</li><li>在底层主机上创建的文件或目录只能由 root 写入。您需要在特权容器以 root 身份运行进程，或修改主机上的文件权限以便写入 <code>hostPath</code> 卷</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pd<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/test<span class="token punctuation">-</span>webserver    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /test<span class="token punctuation">-</span>pd      <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>volume  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>volume    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># directory location on host</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data      <span class="token comment" spellcheck="true"># this field is optional</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> Directory</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> volume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-secret</title>
      <link href="/2019/12/01/kubernetes-secret/"/>
      <url>/2019/12/01/kubernetes-secret/</url>
      
        <content type="html"><![CDATA[<h2 id="Secret-存在意义"><a href="#Secret-存在意义" class="headerlink" title="Secret 存在意义"></a>Secret 存在意义</h2><p><strong>Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用</strong></p><p>Secret有三种类型：</p><ul><li><strong>Service Account: 用来访问Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount 目录中</strong></li><li><strong>Opaque: base64编码格式的Secret,用来存储密码、密钥等</strong></li><li><strong>kubernetes.io/dockerconfigjson:用来存储私有docker registry的认证信息</strong></li></ul><h3 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h3><p><strong>Service Account 用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount 目录中</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system</span>NAME                                 READY   STATUS    RESTARTS   AGEcoredns-5c98db65d4-pxl78             1/1     Running   0          8dcoredns-5c98db65d4-vdtsr             1/1     Running   0          8detcd-k8s-master                      1/1     Running   0          8dkube-apiserver-k8s-master            1/1     Running   0          8dkube-controller-manager-k8s-master   1/1     Running   0          8dkube-flannel-ds-amd64-852cl          1/1     Running   0          8dkube-flannel-ds-amd64-p5h64          1/1     Running   0          8dkube-flannel-ds-amd64-rglvq          1/1     Running   0          6d18hkube-proxy-6sp4j                     1/1     Running   0          8dkube-proxy-hbnkf                     1/1     Running   0          6d18hkube-proxy-ttjcn                     1/1     Running   0          8dkube-scheduler-k8s-master            1/1     Running   0          8d<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec kube-proxy-ttjcn -it -n kube-system -- /bin/sh</span><span class="token comment" spellcheck="true"># cd /run/secrets</span><span class="token comment" spellcheck="true"># ls</span>kubernetes.io<span class="token comment" spellcheck="true"># cd kubernetes.io</span><span class="token comment" spellcheck="true"># cd serviceaccount  </span><span class="token comment" spellcheck="true"># ls</span>ca.crt    namespace  token<span class="token comment" spellcheck="true"># cat ca.crt      </span>-----BEGIN CERTIFICATE-----MIICyDCCAbCgAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJlcm5ldGVzMB4XDTE5MTEyMzA2MjEzNVoXDTI5MTEyMDA2MjEzNVowFTETMBEGA1UEAxMKa3ViZXJuZXRlczCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALqjo541wpNZ42IyS4UXUOtpfgxS37vFo95D2oQoktzjE9hZetkdhDV3J262OVh9sysEUY0p/97A+E8Dex45KnfmqAAZdlG3hq7T5sGHtx/zP81wVs9hxf4SchCIRstCUrOxkErwViu8FOsN+tEPst3TgJaYbFz38zpK0N8769LiwLaVmQMcb07/n2k2uvbion7S6nlEVlS7yQ6fouEaoSULUrEm565A8mu2hloiSSNIlbQBJV8/mlzop4QdKRxvfYt2S3uqqYloenYdWOPAACpWzJn8kkUxBO8xJrzEiGHmUOXz75CmF5flgOQPtgedmWJaKegkvGSsl7Tp28Kv750CAwEAAaMjMCEwDgYDVR0PAQH/BAQDAgKkMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBALfpP6jWWtCdlAfCBXV49eLlIFURyVmsNs16uCxQQbOQLNHMp+3WoZLsyl2xkqwGkruLoG2opWL5ab7FnYlZJpa9QJ12ic6wee0uvb70HLRfc8W2Ep+blgU8nq5zMFknlHS9nEk5PfFkq4T3ZTxZdSbXewxPURl+NLXVVgjNcFDdPpv0srnerLhL7qWYYGEHENxkA60Ons0KIZMZQzabQ4VpXhmvCLhPdmdVL9GbsZcqPQWZD9o23afDHhxNTg3vBnX/8IVm8NO5a5QP9ixzRBVgGzmshr2y5/Xdaqm32FfVZs1R1BURzedwkqssqyRKghqePpdLQznImjJcSQ3bGcI<span class="token operator">=</span>-----END CERTIFICATE-----<span class="token comment" spellcheck="true"># cat token</span>eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJlLXByb3h5LXRva2VuLW54NzhwIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6Imt1YmUtcHJveHkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzZmViYjlhOC0yOTU2LTRjMzEtODU1Mi01Mzc2ZTMxOGE3NWIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06a3ViZS1wcm94eSJ9.xy-rX7AKuPzS6Z2ecFZRy32FHFJuR5WZZ5ziWEhG64rXV5Hcy9gA1ptatwLxQmGGkYFVZ5rEDTcNRGsM1ADHQKFjFhf5TpsXEUfk3U67JtnWUC_KDB8G2P1cBN7s6O1JKYVn-uWGq0LTcxoR62TpMgCFdLKR38CXIR-ItUTmpGVVKlhWgg3pIvvbQgFWOwpHxBM8Ce-Er8J6uhKuPvXfhO28K0ppf0OZFihWPhVs-BLAI855F7UC8dhi0_db10w_zmeaa_EcMRddrs0FYnup_kubevTc7geUOzAetMCfkON4EJv91xVtHVOctpdi2wX4WmhNs9mbuJhBqJPGkp-24Q<span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># ls    </span>ca.crt    namespace  token<span class="token comment" spellcheck="true"># cat namespace     </span>kube-system<span class="token comment" spellcheck="true"># </span></code></pre><h2 id="Opaque-Secret"><a href="#Opaque-Secret" class="headerlink" title="Opaque Secret"></a>Opaque Secret</h2><p><strong>I、创建说明</strong></p><p><strong>Opaque类型的数据是一个map类型，要求value是base65编码格式</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo -n "admin" |base64</span>YWRtaW4<span class="token operator">=</span><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo -n "adbdfes" | base64</span>YWRiZGZlcw<span class="token operator">==</span></code></pre><p><strong>secrets.yaml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">password</span><span class="token punctuation">:</span> YWRiZGZlcw==  <span class="token key atrule">username</span><span class="token punctuation">:</span> YWRtaW4=</code></pre><p><strong>II、使用方式</strong></p><p><strong>1. 将Secret 挂载到 Volume中</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>test  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>test<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets    <span class="token key atrule">secret</span><span class="token punctuation">:</span>      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> mysecret  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">name</span><span class="token punctuation">:</span> db    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/secrets"</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p><strong>2、将 Secret 导出到环境变量中</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>deployment    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">1</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> TEST_USER          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret              <span class="token key atrule">key</span><span class="token punctuation">:</span> username         <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> TEST_PASSWORD           <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>             <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>               <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret               <span class="token key atrule">key</span><span class="token punctuation">:</span> password</code></pre><h2 id="Kubernetes-io-dockerconfigjson"><a href="#Kubernetes-io-dockerconfigjson" class="headerlink" title="Kubernetes.io/dockerconfigjson"></a>Kubernetes.io/dockerconfigjson</h2><p><strong>使用 Kuberctl 创建 docker registry 认证的secret</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create secret docker-registry myregistrykey --docker-server<span class="token operator">=</span>DOCKER_REGISTRY_SERVER --docker-username<span class="token operator">=</span>DOCKER_USER --docker-password<span class="token operator">=</span>DOCKER_PASSWORD --docker-email<span class="token operator">=</span>DOCKER_EMAIL secret <span class="token string">"myregistrykey"</span> created</code></pre><p>*<em>在创建 Pod 的时候，通过 <code>imagePullSecrets</code> 来引用刚创建的<code>myregistrykey</code> *</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> foo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo      <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1   <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myregistrykey</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> secret </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-configMap</title>
      <link href="/2019/12/01/kubenetes-configMap/"/>
      <url>/2019/12/01/kubenetes-configMap/</url>
      
        <content type="html"><![CDATA[<h2 id="configMap-描述信息"><a href="#configMap-描述信息" class="headerlink" title="configMap 描述信息"></a>configMap 描述信息</h2><p><strong>ConfigMap 功能在 Kubernetes1.2版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象</strong></p><h2 id="ConfigMap-的创建"><a href="#ConfigMap-的创建" class="headerlink" title="ConfigMap 的创建"></a>ConfigMap 的创建</h2><p>I、使用目录创建</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/root/yaml/ceshi/configmap/config/docs/user-guide/configmap/kubectl<span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat game.properties </span>enemies<span class="token operator">=</span>alienslives<span class="token operator">=</span>3enemies.cheat<span class="token operator">=</span>trueenemies.cheat.level<span class="token operator">=</span>noGoodRottensecret.code.passphrase<span class="token operator">=</span>UUDDLRLRBABASsecret.code.allowed<span class="token operator">=</span>truesecret.code.lives<span class="token operator">=</span>30<span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat ui.properties </span>color.good<span class="token operator">=</span>purplecolor.bad<span class="token operator">=</span>yellowallow.textmode<span class="token operator">=</span>truehow.nice.to.look<span class="token operator">=</span>fairlyNice$ kubectl create configmap game-config --from-file<span class="token operator">=</span>docs/user-guide/configmap/kubectl</code></pre><p><strong><code>--from-file</code>  指定在目录下的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容</strong></p><p><strong>II 使用文件创建</strong></p><p><strong>只要指定为一个文件就可以从单个文件中创建 ConfigMap</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create configmap game-config-2 --from-file<span class="token operator">=</span>docs/user-\ guide/configmap/kubectl/game.properties$ kubectl get configmaps game-config-2 -o yaml</code></pre><p><strong><code>--from-file</code>这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，就跟指定整个目录是一样的</strong></p><p><strong>III、使用字面值创建</strong></p><p><strong>使用文字值创建，利用 <code>--from-literal</code>参数传递配置信息，该参数可以使用多次，格式如下</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create configmap special-config --from-literal<span class="token operator">=</span>special.how<span class="token operator">=</span>very --from-literal<span class="token operator">=</span>special.type<span class="token operator">=</span>charm</code></pre><h2 id="Pod中使用-ConfigMap"><a href="#Pod中使用-ConfigMap" class="headerlink" title="Pod中使用 ConfigMap"></a>Pod中使用 ConfigMap</h2><p><strong>I、使用 ConfigMap 来替代环境变量</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">log_level</span><span class="token punctuation">:</span> INFO</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> hubor.bwinagme8.com/library/myapp<span class="token punctuation">:</span>v1      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"env"</span><span class="token punctuation">]</span>      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_TYPE_KEY          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type      <span class="token key atrule">envForm</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">configMapRef</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>config  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><p><strong>II 用 ConfigMap 设置命令行参数</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod55<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)"</span><span class="token punctuation">]</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config            <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how       <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_TYPE_KEY         <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>           <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>             <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config             <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type   <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never </code></pre><p>*<em>III、通过数据卷插件使用 ConfigMap *</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><p><strong>在数据卷里面使用这个ConfigMap,有不同的选项。最基本的就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"cat /etc/config/special.how"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/config  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><h2 id="ConfigMap-的热更新"><a href="#ConfigMap-的热更新" class="headerlink" title="ConfigMap 的热更新"></a>ConfigMap 的热更新</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">log_level</span><span class="token punctuation">:</span> INFO<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/config      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume          <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>config</code></pre><pre class=" language-bash"><code class="language-bash">$ kubectl <span class="token function">exec</span> `kubectl get pods -l run<span class="token operator">=</span>my-nginx -o<span class="token operator">=</span>name<span class="token operator">|</span><span class="token function">cut</span> -d <span class="token string">"/"</span> -f2` <span class="token function">cat</span> /etc/config/log_levelINFO</code></pre><p><strong>修改 ConfigMap</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl edit configmap log-config</code></pre><p><strong>修改<code>log_level</code>的值为<code>DEBUG</code>等待大概10秒钟时间，再次查看环境变量的值</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl <span class="token function">exec</span> `kubectl get pods -l run<span class="token operator">=</span>my-nginx -o<span class="token operator">=</span>name<span class="token operator">|</span><span class="token function">cut</span> -d <span class="token string">"/"</span> -f2` <span class="token function">cat</span> /etc/config/log_level</code></pre><!--!!! 特别注意 configMap 如果以 ENV 的方式挂载至容器，修改 configMap 并不会实现热更新--><p>*<em>ConfigMap 更新后滚动更新Pod *</em></p><p>更新 ConfigMap 目前并不会触发相关Pod的滚动更新，可以通过修改pod annotations 的方式强制触发滚动更新</p><pre class=" language-bash"><code class="language-bash">$ kubectl patch deployment my-nginx --patch <span class="token string">'{"spec":{"template":{"metadata":{"annotations":{"version/config": "20190411"}}}}}'</span></code></pre><p>这个例子里我们在<code>.spec.template.metadata.annotations</code>中添加<code>version/config</code>,每次通过修改<code>version/config</code>来触发滚动更新</p><p><strong>！！！ 更新 ConfigMap 后：</strong></p><ul><li><strong>使用该 ConfigMap 挂载的 Env 不会同步更新</strong></li><li><strong>使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间(实测大概10秒) 才能同步更新</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> configmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-Ingress</title>
      <link href="/2019/11/29/kubernetes-Ingress/"/>
      <url>/2019/11/29/kubernetes-Ingress/</url>
      
        <content type="html"><![CDATA[<p><strong>Ingress-Nginx github 地址</strong><a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx</a></p><p><strong>Ingress-Nginx 官方网站：</strong><a href="https://kubernetes.github.io/ingress-nginx" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx</a></p><p><img src="./images/22.png" alt=""></p><p><img src="./images/21.png" alt=""></p><h2 id="部署-Ingress-Nginx"><a href="#部署-Ingress-Nginx" class="headerlink" title="部署 Ingress-Nginx"></a>部署 Ingress-Nginx</h2><pre class=" language-bash"><code class="language-bash">kubectl apply -f mandatory.yamlkubectl apply -f service-nodeport.yaml</code></pre><h2 id="Ingress-HTTP-代理访问"><a href="#Ingress-HTTP-代理访问" class="headerlink" title="Ingress HTTP 代理访问"></a>Ingress HTTP 代理访问</h2><p><strong>deployment、Service、Ingress Yaml文件</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-dmspec:  replicas: 2  template:    metadata:      labels:        name: nginx    spec:      containers:        - name: nginx          image: harbor.bwingame8.com/library/myapp:v1          imagePullPolicy: IfNotPresent          ports:            - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-svcspec:  ports:    - port: 80      targetPort: 80      protocol: TCP  selector:    name: nginx---apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-testspec:  rules:    - host: www1.bwingame8.com      http:        paths:        - path: /          backend:            serviceName: nginx-svc            servicePort: 80</code></pre><h2 id="Ingress-HTTPS-代理访问"><a href="#Ingress-HTTPS-代理访问" class="headerlink" title="Ingress HTTPS 代理访问"></a>Ingress HTTPS 代理访问</h2><p><strong>创建证书，以及 cert 存储方式</strong></p><pre class=" language-bash"><code class="language-bash">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="token string">"/CN=nginxsvc/0=nginxsvc"</span>kubectl create secret tls tls-secret --key tls.key --cert tls.crt</code></pre><p>deployment、Service、Ingress Yaml文件</p><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-testspec:  tls:    - hosts:      - www3.bwingame8.com      secretName: tls-secret  rules:    - host: www3.bwingame8.com      http:        paths:        - path: /          backend:            serviceName: svc-3            servicePort: 80</code></pre><h2 id="Nginx-进行-BasicAuth"><a href="#Nginx-进行-BasicAuth" class="headerlink" title="Nginx 进行 BasicAuth"></a>Nginx 进行 BasicAuth</h2><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> httpdhtpasswd -c auth fookubectl create secret generic basic-auth --from-file<span class="token operator">=</span>auth</code></pre><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: ingress-width-auth  annotations:    nginx.ingress.kubernetes.io/auth-type: basic    nginx.ingress.kubernetes.io/auth-secret: basic-auth    nginx.ingress.kubernetes.io/auth-realm: <span class="token string">'Authentication Required - foo'</span>spec:  rules:  - host: www4.bwingame8.com    http:      paths:      - path: /        backend:          serviceName: nginx-svc          servicePort: 80</code></pre><h2 id="Nginx-进行重写"><a href="#Nginx-进行重写" class="headerlink" title="Nginx 进行重写"></a>Nginx 进行重写</h2><table>    <tr><th>名称</th><th>描述</th><th>值</th></tr>    <tr><td>nginx.ingress.kubernetes.io/rewrite-target</td><td>必须重定向流量的目标URL</td><td>串</td></tr>    <tr><td>nginx.ingress.kubernetes.io/ssl-redirect</td><td>指示位置部分是否仅可访问SSL(当Ingress包含证书时默认为True)</td><td>布尔</td></tr>    <tr><td>nginx.ingress.kubernetes.io/force-ssl-redirect</td><td>即使Ingress未启用TLS，也强制重定向到HTTPS</td><td>布尔</td></tr>    <tr><td>nginx.ingress.kubernetes.io/app-root</td><td>定义Controller必须重定向的应用程序根，如果它在'/'上下文中</td><td>串</td></tr>    <tr><td>nginx.ingress.kubernetes.io/use-regex</td><td>指示Ingress上定义的路径是否使用正则表达式</td><td>布尔</td></tr></table><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-test  annotations:    nginx.ingress.kubernetes.io/rewrite-target: https://www3.bwingame8.com:31306/hostname.htmlspec:  rules:  - host: www3.bwingame8.com    http:      paths:      - path: /        backend:          serviceName: nginx-svc          servicePort: 80</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> ingress-nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Service</title>
      <link href="/2019/11/29/Kubernetes-Service/"/>
      <url>/2019/11/29/Kubernetes-Service/</url>
      
        <content type="html"><![CDATA[<h2 id="Service-的概念"><a href="#Service-的概念" class="headerlink" title="Service 的概念"></a>Service 的概念</h2><p><strong>Kubernetes service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 – 通常称为微服务。这一组 <code>Pod</code> 能够被<code>Service</code>访问到，通常是通过<code>Lable Selector</code></strong></p><p><img src="./images/14.png" alt=""></p><p><strong>Service能够提供负载均衡的能力，但是在使用上有以下限制：</strong></p><ul><li><strong>只提供4层负载均衡能力，而没有7层功能，但有时我们可能需要更多的匹配规则来转发请求，这点上4层负载均衡是不支持的</strong></li></ul><h2 id="Service-的类型"><a href="#Service-的类型" class="headerlink" title="Service 的类型"></a>Service 的类型</h2><p><strong>Service 在 K8s中有以下四种类型</strong></p><ul><li><strong>ClusterIp: 默认类型，自动分配一个仅Cluster内部可以访问的虚拟IP</strong></li><li><strong>NodePort: 在 ClusterIP基础上为Service 在每台机器上绑定一个端口，这样就可以通过<NodeIP>:</strong></li><li><strong>LoadBalancer:在NodePort的基础上，借助cloud provider创建一个外部负载均衡器，并将请求转发到<NodeIP>:NodePort</strong></li><li><strong>ExternalName: 把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有kubernetes1.7或更高版本的kube-dns才支持</strong></li></ul><p><img src="./images/15.png" alt=""></p><h2 id="VIP-和-Service-代理"><a href="#VIP-和-Service-代理" class="headerlink" title="VIP 和 Service 代理"></a>VIP 和 Service 代理</h2><p><strong>在 Kubernetes 集群中，每个 Node 运行一个 <code>kube-proxy</code>进程。<code>kube-proxy</code> 负责为 <code>Service</code>实现了一种VIP（虚拟IP）的形式，而不是 <code>ExternalName</code>的形式。在 Kubernetes v1.0 版本，代理完全在userspace。在Kubernetes v1.1版本，新增了 iptables 代理，但并不是默认的运行模式。从Kubernetes v1.2起，默认就是iptables代理。在Kubernetes v1.8.0-beta.0中，添加了ipvs代理</strong></p><p><strong>在kubernetes 1.14版本中开始默认使用 ipvs 代理</strong></p><p><strong>在 kubernetes v1.0 版本， <code>Service</code>是”4层”（TCP/UDP over IP）概念。在kubernetes v1.1版本，新增了 <code>Ingress</code> API(beta版)，用来表示“7层”(HTTP)服务</strong></p><p><strong>！为何不使用 round-robin DNS?</strong>（DNS缓存问题）</p><h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><p><img src="./images/16.png" alt=""></p><p><img src="./images/17.png" alt=""></p><h2>III、ipvs 代理模式</h2><p><strong>这种模式，kube-proxy会监视kubernetes <code>Service</code>对象和<code>Endpoints</code>，调用<code>netlink</code>接口以响应地创建 ipvs 规则并定期与Kubernetes <code>Service</code>对象和<code>Endpoints</code>对象同步ipvs规则，以确保ipvs状态与期望一致。访问服务时，流量将被重定向到其中一个后端Pod</strong></p><p>与iptables类似，ipvs于netfilter的hook功能，但使用哈希表作为底层数据结构并在内核空间中工作。这意味着ipvs可以更快地重定向流量，并且在同步代理规则时具有更好的性能。此外，ipvs为负载均衡算法提供了更好选项，例如：</p><ul><li><strong><code>rr</code>:  轮询调度</strong></li><li><strong><code>lc</code>:  最小连接数</strong></li><li><strong><code>dh</code>:  目标哈希</strong></li><li><strong><code>sh</code>:源哈希</strong></li><li><strong><code>sed</code>: 最短期望延迟</strong></li><li><strong><code>nq</code>: 不排队调度</strong></li></ul><!--注意： ipvs 模式假定在运行 kube-proxy 之前在节点上都已经安装了 IPVS 内核模块。当kube-proxy 以 ipvs 代理模式启动时，kube-proxy 将验证节点上是否安装了 IPVS 模块，如果未安装，则 kube-proxy 将回退到 iptables 代理模式--><p><img src="./images/18.png" alt=""></p><h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p><strong>clusterIP 主要在每个node节点使用iptables，将发向clusterIP对应端口的数据，转发到kube-proxy中。然后kube-proxy自己内部实现有负载均衡的方法，并可以查询到这个service下对应的pod的地址和端口，进而把数据转发给对应的pod的地址和端口</strong></p><p><img src="./images/19.png" alt=""></p><p><strong>为了实现图上的功能，主要需要以下几个组件协同工作：</strong></p><ul><li><strong>apiserver用户通过kubectl命令向apiserver发送创建service的命令，apiserver接收到请求后将数据存储到etcd中</strong></li><li><strong>kube-proxy kubernetes的每个节点中都有一个叫做kube-proxy的进程，这个进程负责感知service，pod的变化，并将变化的信息写入本地的iptables规则中</strong></li><li><strong>iptables 使用NAT等技术将virtualIP的流量转至endpoint中</strong></li></ul><p><strong>创建 myapp-deploy.yaml 文件</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> vim myapp-deploy.yamlapiVersion: apps/v1kind: Deploymentmetadata:  name: myapp-deploy  namespace: defaultspec:  replicas: 3  selector:    matchLabels:      app: myapp      release: stabel  template:    metadata:      labels:        app: myapp        release: stabel        env: <span class="token function">test</span>    spec:      containers:      - name: myapp        image: ikubernetes/myapp:v2        imagePullPolicy: ifNotPresent        ports:        - name: http          containerPort: 80</code></pre><p><strong>创建 Service 信息</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master root<span class="token punctuation">]</span>vim myapp-service.yamlapiVersion: v1kind: Servicemetadata:  name: myapp  namespace: defaultspec:  type: ClusterIP  selector:    app: myapp    release:  stabel  ports:  - name: http    port: 80    targetPort: 80</code></pre><h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p><strong>有时不需要或不想要负载均衡，以及单独的Service IP。遇到这种情况，可以通过指定ClusterIP(spec.clusterIP)的值为“None”来创建Headless Service。这类 Service并不会分配ClusterIP，kube-proxy不会处理他们，而且平台也不会为它们进行负载均衡和路由。</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim myapp-svc-headless.yaml</span>apiVersion: v1kind: Servicemetadata:  name: myapp-headless  namespace: defaultspec:  selector:    app: myapp  clusterIP: <span class="token string">"None"</span>  ports:  - port: 80    targetPort: 80<span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># dig -t A myapp-headless.default.svc.cluster.local.</span>@10.96.0.10</code></pre><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><strong>nodePort 的原理在于在node上开了一个端口,将向该端口的流量导入到kube-proxy，然后由kube-proxy进一步到给对应的Pod</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Servicemetadata:  name: myapp  namespace: defaultspec:  type: NodePort  selector:    app: myapp    release: stabel  ports:  - name: http    port: 80    targetPort: 80</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEkubernetes   ClusterIP   10.96.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          6d6htsgj-svc     NodePort    10.109.255.35   <span class="token operator">&lt;</span>none<span class="token operator">></span>        8080:30000/TCP   2d11h<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                               READY   STATUS    RESTARTS   AGEtsgj-deployment-855476f755-5l4qk   1/1     Running   0          34htsgj-deployment-855476f755-7rj8f   1/1     Running   0          34htsgj-deployment-855476f755-crkrn   1/1     Running   0          34h<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save |grep tsgj-svc</span>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SERVICES <span class="token operator">!</span> -s 10.244.0.0/16 -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-MARK-MASQ-A KUBE-SERVICES -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-SVC-X5UEB5AP7D73JSAI<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SVC-X5UEB5AP7D73JSAI</span>:KUBE-SVC-X5UEB5AP7D73JSAI - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SERVICES -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-ACY2NRHQXCLYF447-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-K7BRQOSBPSECSMB6-A KUBE-SVC-X5UEB5AP7D73JSAI -j KUBE-SEP-UBOJ6DEUKSFU7YBC<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-ACY2NRHQXCLYF447</span>:KUBE-SEP-ACY2NRHQXCLYF447 - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-ACY2NRHQXCLYF447 -s 10.244.1.36/32 -j KUBE-MARK-MASQ-A KUBE-SEP-ACY2NRHQXCLYF447 -p tcp -m tcp -j DNAT --to-destination 10.244.1.36:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-ACY2NRHQXCLYF447<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-K7BRQOSBPSECSMB6</span>:KUBE-SEP-K7BRQOSBPSECSMB6 - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-K7BRQOSBPSECSMB6 -s 10.244.1.37/32 -j KUBE-MARK-MASQ-A KUBE-SEP-K7BRQOSBPSECSMB6 -p tcp -m tcp -j DNAT --to-destination 10.244.1.37:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-K7BRQOSBPSECSMB6<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-UBOJ6DEUKSFU7YBC</span>:KUBE-SEP-UBOJ6DEUKSFU7YBC - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-UBOJ6DEUKSFU7YBC -s 10.244.3.24/32 -j KUBE-MARK-MASQ-A KUBE-SEP-UBOJ6DEUKSFU7YBC -p tcp -m tcp -j DNAT --to-destination 10.244.3.24:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -j KUBE-SEP-UBOJ6DEUKSFU7YBC</code></pre><h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><p>iptables  -t nat</p><h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><strong>loadBalancer 和 nodePort 其实是同一种方式。区别在于loadBalancer 比 nodePort多了以步，就是可以调用cloud provider 去创建LB来向节点导流</strong></p><p><img src="./images/20.png" alt=""></p><h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h2><p><strong>这种类型的 Service 通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容(例如：<code>harbor.bwingame8.com</code>)。ExternalName Service 是 Service 的特例，它没有selector，也没有定义任何的端口和 Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务。</strong></p><pre class=" language-bash"><code class="language-bash">kind: ServiceapiVersion: v1metadata:  name: my-service-1  namespace: defaultspec:  type: ExternalName  externalName: my.database.example.com</code></pre><p><strong>当查询主机 my-service.defalut.svc.cluster.local(SVC_NAME.NAMESPACE.svc.cluster.local)时，集群的DNS服务将返回一个值my.database.example.com的CNAME 记录。访问这个服务的工作方式和其它的相同，唯一不同的是重定向发生在DNS层，而且不会进行代理或转发</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-Daemonset-控制器</title>
      <link href="/2019/11/28/kubenetes-Daemonset-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/28/kubenetes-Daemonset-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-DaemonSet"><a href="#什么是-DaemonSet" class="headerlink" title="什么是 DaemonSet"></a>什么是 DaemonSet</h2><p>DaemonSet 确保全部(或者一些)Node上运行一个Pod的副本。当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod。</p><p>DaemonSet 的典型应用场景有：</p><p>（1）运行集群存储daemon，例如在每个Node上运行  glusterd、ceph。</p><p>（2）在每个Node上运行日志收集 daemon，例如 fluentd、logstash。</p><p>   (3)  在每个Node上运行监控 daemon，例如Prometheus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> daemonset<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1</code></pre><p>下面我们通过 kube-flannel-ds  这个 daemonset 来学习一下 DaemonSet。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel<span class="token punctuation">-</span>ds<span class="token punctuation">-</span>amd64  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">tier</span><span class="token punctuation">:</span> node    <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> node        <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">affinity</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>          <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>            <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> beta.kubernetes.io/os                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                      <span class="token punctuation">-</span> linux                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> beta.kubernetes.io/arch                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                      <span class="token punctuation">-</span> amd64      <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists        <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> flannel      <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install<span class="token punctuation">-</span>cni        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/coreos/flannel<span class="token punctuation">:</span>v0.11.0<span class="token punctuation">-</span>amd64        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> cp        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span>f        <span class="token punctuation">-</span> /etc/kube<span class="token punctuation">-</span>flannel/cni<span class="token punctuation">-</span>conf.json        <span class="token punctuation">-</span> /etc/cni/net.d/10<span class="token punctuation">-</span>flannel.conflist        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cni          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/cni/net.d        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/kube<span class="token punctuation">-</span>flannel/      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/coreos/flannel<span class="token punctuation">:</span>v0.11.0<span class="token punctuation">-</span>amd64        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> /opt/bin/flanneld        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>ip<span class="token punctuation">-</span>masq        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kube<span class="token punctuation">-</span>subnet<span class="token punctuation">-</span>mgr        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>iface=em1        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"50Mi"</span>          <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"50Mi"</span>        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>          <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>          <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>            <span class="token key atrule">add</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"NET_ADMIN"</span><span class="token punctuation">]</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAME          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAMESPACE          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /run/flannel        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/kube<span class="token punctuation">-</span>flannel/      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /run/flannel        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cni          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /etc/cni/net.d        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel<span class="token punctuation">-</span>cfg</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制器 </tag>
            
            <tag> kubenetes </tag>
            
            <tag> Daemonset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-JobCronJob-控制器</title>
      <link href="/2019/11/28/kubenetes-JobCronJob-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/28/kubenetes-JobCronJob-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</strong></p><p>特殊说明</p><ul><li><strong>spec.template 格式同Pod</strong></li><li><strong>RestartPolicy仅支持Never或OnFailure</strong></li><li><strong>单个Pod时，默认Pod成功运行后Job即结束</strong></li><li><strong><code>.spec.completions</code> 标志Job结束需要成功运行的Pod个数，默认为1</strong></li><li><strong><code>.spec.parallelism</code> 标志并行运行的Pod的个数，默认为1</strong></li><li><strong><code>spec.activeDeadlineSeconds</code> 标志这失败Pod的重试最大时间，超过这个时间不会继续重试</strong></li></ul><p><strong>Example</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      name<span class="token punctuation">:</span>pi    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pi        <span class="token key atrule">image</span><span class="token punctuation">:</span> perl        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"perl"</span><span class="token punctuation">,</span> <span class="token string">"-Mbignum=bpi"</span><span class="token punctuation">,</span> <span class="token string">"-wle"</span><span class="token punctuation">,</span> <span class="token string">"print bpi(2000)"</span><span class="token punctuation">]</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><!-- 查看日志，可以显示出答应的 2000 位 Π 值 --><h2 id="CronJob-Spec"><a href="#CronJob-Spec" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h2><ul><li>spec.template格式同Pod</li><li>RestartPolicy仅支持Nerver或OnFailure</li><li>单个Pod时，默认Pod成功运行后Job即结束</li><li><code>.spec.completions</code>标志Job结束需要成功运行的Pod的个数，默认为1</li><li><code>.spec.parallelism</code>标志并运行的Pod的个数，默认为1</li><li><code>spec.activeDeadlineSeconds</code>标志失败Pod的重试最大时间，超过这个时间不会继续重试</li></ul><h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p><strong>Cron Job管理基于时间的Job,即：</strong></p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p>使用条件： 当前使用的 Kubernetes 集群（&gt;=1.8版本）（对CronJob）</p><p>典型的用法如下所示：</p><ul><li>在给定的时间点调度Job运行</li><li>周期性运行的Job，例如：数据库备份、发送邮件</li></ul><h2 id="CronJob-Spec-1"><a href="#CronJob-Spec-1" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h2><ul><li><p><strong><code>.spec.schedule</code>:调度，必须字段，指定任务运行周期，格式同Cron</strong></p></li><li><p><strong><code>.spec.jobTemplate</code>：Job模板，必须自动，指定需要运行的任务，格式同Job</strong></p></li><li><p><strong><code>.spec.startingDeadlineSeconds</code>: 启动Job的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的Job将被认为是失败的。如果没有指定，则没有期限</strong></p></li><li><p><strong><code>.spec.concurrencyPolicy</code>:并发策略，该字段也是可选的。它制定了如果处理被 Cron Job创建的JOb的并发执行，只允许下面策略中的一种：</strong></p><ul><li><p><code>Allow</code>(默认)：允许并发运行Job</p></li><li><p><code>Forbid</code>: 禁止并发运行，如果前一个还没有完成，则直接跳过个</p></li><li><p><code>Replace</code>：取消当前正在运行的 Job,用一个新的来替换</p></li></ul><p><strong>注意，当前策略只能应用于同一个Cron Job创建的Job。如果存在多个Cron Job,它们创建的Job之间总是允许并发运行。</strong></p></li><li><p><strong><code>.spec.suspend</code>：挂起，该字段也是可选的。如果设置为<code>true</code>，后续所有执行都会被挂起。它对已经开始执行的Job不起作用。默认值为<code>false</code></strong>。</p></li><li><p><strong><code>.spec.successfulJobsHistoryLimit</code>和<code>.spec.failedJobsHistoryLimit</code>:历史限制，是可以选的字段。它们制定了可以保留多少完成和失败的Job。默认情况下，他们分别设置为<code>3</code>和<code>1</code>.设置限制的值为<code>0</code>,相关类型的Job完成后将不会被保留。</strong></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJobmetadata：  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"*/1 * * * *"</span>  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">template</span><span class="token punctuation">:</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>          <span class="token key atrule">containers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello            <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox            <span class="token key atrule">args</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> /bin/sh            <span class="token punctuation">-</span> <span class="token punctuation">-</span>c            <span class="token punctuation">-</span> date; echo Hello from the Kubernetes cluster          <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure</code></pre><pre class=" language-shell"><code class="language-shell">[root@k8s-master ceshi]# kubectl get cronjobNAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGEhello   */1 * * * *   False     0        34s             74s[root@k8s-master ceshi]# kubectl get jobNAME               COMPLETIONS   DURATION   AGEhello-1574992740   1/1           7s         74shello-1574992800   1/1           6s         14s[root@k8s-master ceshi]# kubectl get podNAME                               READY   STATUS      RESTARTS   AGEdaemonset-example-dkw6c            1/1     Running     0          12hdaemonset-example-zhqwq            1/1     Running     0          12hhello-1574992740-b6hhs             0/1     Completed   0          117shello-1574992800-7tcnv             0/1     Completed   0          57s[root@k8s-master ceshi]# kubectl logs hello-1574992740-b6hhsFri Nov 29 01:59:12 UTC 2019Hello from the Kubernetes cluster[root@k8s-master ceshi]# kubectl delete cronjob hellocronjob.batch "hello" deleted[root@k8s-master ceshi]# kubectl get cronjobNo resources found.[root@k8s-master ceshi]# kubectl get podNAME                               READY   STATUS    RESTARTS   AGEdaemonset-example-dkw6c            1/1     Running   0          12hdaemonset-example-zhqwq            1/1     Running   0          12h# 注意，删除 cronjob 的时候不会自动删除job，这些 job 可以用 kubectl delete job来删除$ kubectl delete cronjob hello</code></pre><h2 id="CrondJob本身的一些限制"><a href="#CrondJob本身的一些限制" class="headerlink" title="CrondJob本身的一些限制"></a>CrondJob本身的一些限制</h2><p><strong>创建Job操作应该是幂等的</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制器 </tag>
            
            <tag> kubenetes </tag>
            
            <tag> JobCronJob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-Deployment控制器</title>
      <link href="/2019/11/26/kubernetes-Deployment-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/26/kubernetes-Deployment-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RS-与-RC-与-Deployment-关联"><a href="#RS-与-RC-与-Deployment-关联" class="headerlink" title="RS 与 RC 与 Deployment 关联"></a>RS 与 RC 与 Deployment 关联</h2><p><strong>RC （ReplicationController）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替换；而如果异常多出来的容器也会自动回收</strong></p><p><strong>Kubernetes 官方建议使用 RS （ReplicaSet）替代 RC (ReplicationController) 进行部署，RS跟RC没有本质的不同，只是名字不一样，并且RS支持集合式的selector</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicaSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend      <span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>nginxv1          <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1          <span class="token key atrule">env</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GET_HOSTS_FROM            <span class="token key atrule">value</span><span class="token punctuation">:</span> dns          <span class="token key atrule">ports</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><h2 id="RS-与-Deployment-的关联"><a href="#RS-与-Deployment-的关联" class="headerlink" title="RS 与 Deployment 的关联"></a>RS 与 Deployment 的关联</h2><p><img src="./images/13.png" alt="RS-Deployment"></p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><strong>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</strong></p><ul><li><strong>定义Deployment创建Pod和ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容缩容</strong></li><li><strong>暂停和继续Deployment</strong></li></ul><p><strong>I 部署一个简单的Nginx应用</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><pre class=" language-bash"><code class="language-bash">kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record<span class="token comment" spellcheck="true">## --record参数可以记录命令，我们可以很方便的查看每次 revision 的变化</span></code></pre><p><strong>II 扩容</strong></p><pre class=" language-bash"><code class="language-bash">kubectl scale deployment nginx-deployment --replicas 10</code></pre><p><strong>III、如果集群支持horizontal pod autoscaling的话，还可以为Deployment设置自动扩展</strong></p><pre class=" language-bash"><code class="language-bash">kubectl autoscale deployment nginx-deployment --min-10 --max<span class="token operator">=</span>15 --cpu<span class="token operator">=</span>percent<span class="token operator">=</span>80</code></pre><p><strong>IV、更新镜像也比较简单</strong></p><pre class=" language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/nginx-deployment nginx<span class="token operator">=</span>nginx:1.9.1</code></pre><p><strong>V、回滚</strong></p><pre class=" language-bash"><code class="language-bash">kubectl rollout undo deployment/nginx-deployment</code></pre><h2 id="更新-Deployment"><a href="#更新-Deployment" class="headerlink" title="更新 Deployment"></a>更新 Deployment</h2><!--注意：Deployment 的 rollout 当且仅当 Deployment 的pod template（例如： spec.template）中的label更新或者镜像更改时被触发。其它更新，例如扩容Deployment 不会触发--><h2 id="Deployment-更新策略"><a href="#Deployment-更新策略" class="headerlink" title="Deployment 更新策略"></a>Deployment 更新策略</h2><p>Deployment 可以保证在升级时只有一定数量的 Pod 是down的。默认的，它会确保至少有比期望的Pod数量少一个是up状态(最多一个不可用)</p><p>Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的Pod数量多一个的Pod是up的(最多一个surge)</p><p>现在最新的Kubernetes版本中，将从1-1变成25%-25%</p><pre class=" language-bash"><code class="language-bash">$ kubectl describe deployment</code></pre><h2 id="Rollover（多个rollout并行）"><a href="#Rollover（多个rollout并行）" class="headerlink" title="Rollover（多个rollout并行）"></a>Rollover（多个rollout并行）</h2><p><strong>假如您创建了一个有5个 nginx:1.7.9 replica的Deployment，但是当还只有3个nginx:1.7.9的replica创建出来的时候您就开始更新含有5个nginx:1.9.1replica的Deployment。这种情况下，Deployment会立即杀掉已经创建的3个nginx:1.7.9的Pod,并开始创建nginx:1.9.1的Pod。它不会等到所有的5个nginx:1.7.9的Pod都创建完成后才开始改变航道。</strong></p><h2 id="回退Deployment"><a href="#回退Deployment" class="headerlink" title="回退Deployment"></a>回退Deployment</h2><!--只要 Deployment 的rollout 被触发就会创建一个 revision。也就是说当且仅当 Deployment 的 Pod template（如`.spec.template`）被更改，例如更新 template 中的 label 和容器镜像时，就会创建出一个新的 revision。其它的更新，比如扩容 Deployment 不会创建 revision --因此我们可以很方便的手动或者自动扩容。这意味着当您回退到历史revision时，只有 Deployment 中的 Pod template 部分才会回退 --><pre class=" language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/nginx-deployment nginx<span class="token operator">=</span>nginx:1.9.1kubectl rollout status deployments nginx-deploymentkubectl get podskubectl rollout <span class="token function">history</span> deployment/nginx-deploymentkubectl rollout undo deployment/nginx-deploymentkubectl rollout undo deployment/nginx-deployment --to-revison<span class="token operator">=</span>2  <span class="token comment" spellcheck="true">## 可以使用 --revision参数指定某个历史版本</span>kubectl rollout pause deployment/nginx-deployment  <span class="token comment" spellcheck="true">## 暂停 deployment 的更新</span></code></pre><p><strong>您可以用kubectl rollout status 命令查看 Deployment 是否完成。如果rollout 成功完成，kubectl rollout status 将返回一个0值的 Exit Code</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl rollout status deploy/nginxWaiting <span class="token keyword">for</span> rollout to finish: 2 of 3 updated replicas are available<span class="token punctuation">..</span>.deployment <span class="token string">"nginx"</span> successfully rolled out$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0</code></pre><h2 id="清理-Policy"><a href="#清理-Policy" class="headerlink" title="清理 Policy"></a>清理 Policy</h2><p><strong>您可以通过设置<code>.spec.revisonHistoryLimit</code>项来指定 deployment 最多保留多少revision历史记录。默认会保留所有的 revision；如果将该项设置为0，Deployment就不允许回退了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 控制器 </tag>
            
            <tag> deployment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Pod-控制器</title>
      <link href="/2019/11/25/Kubernetes-Pod-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/25/Kubernetes-Pod-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是控制器"><a href="#什么是控制器" class="headerlink" title="什么是控制器"></a>什么是控制器</h2><p>Kubernetes 中内建了很多controller(控制器)，这些相当于一个状态机，用来控制 Pod 的具体状态和行为</p><h2 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h2><ul><li><strong>ReplicationController 和 ReplicaSet</strong></li><li><strong>Deployment</strong></li><li><strong>DaemonSet</strong></li><li><strong>StateFulSet</strong></li><li><strong>Job/Cronjob</strong></li><li><strong>Horizontal Pod Autoscaling</strong></li></ul><p><strong>ReplicationController 和 ReplicaSet</strong></p><p><strong>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；</strong></p><p><strong>在新版本的Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController. ReplicaSet跟 ReplicationController 没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector；</strong></p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><strong>Deployment为 Pod 和 ReplicaSet 提供了一个声明式定义(declarative)方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</strong></p><ul><li><strong>定义 Deployment 来创建 Pod 和 ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容和缩容</strong></li><li><strong>暂停和继续 Deployment</strong></li></ul><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p><strong>DaemonSet 确保全部 (或者一些) Node上运行一个 Pod 的副本，当有 Node 加入集群时，也会为他们新增一个Pod,当有Node从集群移除时，这些 Pod 也会被撤回收，删除 DaemonSet 将会删除它创建的所有Pod</strong></p><ul><li>运行集群存储daemon，例如在每个Node上运行glusterd、ceph</li><li>在每个Node上运行日志收集daemon,例如fluentd、logstash</li><li>在每个Node上运行监控daemon，例如Promethus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond</li></ul><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><ul><li>job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</li></ul><h2 id="Cronjob"><a href="#Cronjob" class="headerlink" title="Cronjob"></a>Cronjob</h2><p>cronjob 管理基于时间的job,即：</p><ul><li>在给定时间点只运行一次</li><li>周期地在给定时间点运行</li></ul><p>使用前提条件：<strong>当前使用的kubernetes集群，版本&gt;=1.8(对Cronjob)。对于先前版本的集群，版本&lt;1.8，启动APIServer时，通过传递选项 –runtime-config=batch/v2alpha1=true 可以开启batch/v2alpha1 API</strong></p><p>典型用法如下所示：</p><ul><li>在给定的时间点调度job运行</li><li>创建周期性运行的job，例如：数据库备份、发送邮件</li></ul><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 作为 Controller  为 Pod 提供唯一的标识。它可以保证部署和scale的顺序</p><p>StatefulSet是为了解决有状态服务的问题(对应Deployment和ReplicaSets是为无状态服务而设计)，其应用场景包括：</p><ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后器PodName和HostName不变，基于Headless Service（即没有Cluster IP的 Service）来实现</li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义好的顺序依次进行(即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态)，基于init containers来实现</li><li>有序收缩，有序删除(即从N-1到0)</li></ul><h2 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h2><p>应用的资源使用率通常都有高峰和低估的时候，如果削峰填谷，提高集群的整体资源利用率，让service中的Pod个数自动调整呢？这就有来与Horizontal Pod Autoscaling了，顾名思义，使 Pod 水平缩放</p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> 控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-pod-探测</title>
      <link href="/2019/11/25/Kubernetes-pod-%E6%8E%A2%E6%B5%8B/"/>
      <url>/2019/11/25/Kubernetes-pod-%E6%8E%A2%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="init-模板"><a href="#init-模板" class="headerlink" title="init 模板"></a>init 模板</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: myapp-pod  labels:    app: myappspec:  containers:  - name: myapp-container    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'echo The app is running &amp;&amp; sleep 3600'</span><span class="token punctuation">]</span>  initContainers:  - name: init-myservice    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'until nslookup myservice; do echo waiting for myservice; sleep 2;done;'</span><span class="token punctuation">]</span>  - name: init-mydb    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span><span class="token punctuation">]</span></code></pre><pre class=" language-bash"><code class="language-bash">kind: ServiceapiVersion: v1metadata:  name: myservicespec:  ports:    - protocol: TCP      port: 80      targetPort: 19376--kind: ServiceapiVersion: v1metadata:  name: mydbspec:  ports:    - protocol: TCP      port: 80      targetPort: 19377</code></pre><h2 id="检测探针-就绪检测"><a href="#检测探针-就绪检测" class="headerlink" title="检测探针-就绪检测"></a>检测探针-就绪检测</h2><p><strong>readinessProbe-httpget</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: readiness-httpget-pod  namespace: defaultspec:  containers:  - name: readiness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    readinessProbe:      httpGet:        port: 80        path: /index1.html      initialDelaySeconds: 1      periodSecond: 3</code></pre><h2 id="检测探针-存活检测"><a href="#检测探针-存活检测" class="headerlink" title="检测探针-存活检测"></a>检测探针-存活检测</h2><p><strong>livenessProbe-exec</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-exec-pod  namespace: defaultspec:  containers:  - name: liveness-exec-container    image: harbor.bwingame8.com/library/busybox:v1    imagePullPolicy: IfNotPresent    command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"touch /tmp/live ; sleep 60; rm -rf /tmp/live; sleep 3600"</span><span class="token punctuation">]</span>    livenessProbe:      exec:        command: <span class="token punctuation">[</span><span class="token string">"test"</span>,<span class="token string">"-e"</span>,<span class="token string">"/tmp/live"</span><span class="token punctuation">]</span>      initialDelaySeconds: 1      periodSeconds: 3</code></pre><p><strong>livenessProbe-httpget</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    livenessProbe:      httpGet:        port: http        path: /index.html      initialDelaySeconds: 1      periodSeconds: 3      timeoutSeconds: 10</code></pre><p><strong>livenessProbe-tcp</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: probe-tcpspec:  containers:  - name: nginx    image: harbor.bwingame8.com/library/myapp:v1    livenessProbe:      initialDelaySeconds: 5      timeoutSeconds: 1      tcpSocket:        port: 80</code></pre><h2 id="检测探针-就绪-存活检测"><a href="#检测探针-就绪-存活检测" class="headerlink" title="检测探针-就绪+存活检测"></a>检测探针-就绪+存活检测</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    readinessProbe:      httpGet:        port: 80        path: /index1.html      initialDelaySeconds: 1      periodSecond: 3    livenessProbe:      httpGet:        port: http        path: /index.html      initialDelaySeconds: 1      periodSeconds: 3      timeoutSeconds: 10</code></pre><p><strong>用户通过 Liveness 探测可以告诉 kubernetes 什么时候通过重启容器实现自愈；Readiness 探测则是告诉 kubernetes 什么时候可以将容器加入到 Service 负载均衡池中，对外客户端提供服务</strong></p><p><strong>存活检测：如果不是存活状态，那么重启Pod.</strong></p><p><strong>就绪检测： 如果不是就绪状态，那么Pod的状态不是READY</strong></p><h2 id="启动、退出动作"><a href="#启动、退出动作" class="headerlink" title="启动、退出动作"></a>启动、退出动作</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: lifecycle-demospec:  containers:  - name: lifecycle-demo-container    image: nginx    lifecycle:      postStart:        exec:          command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"echo hello from the postStart handler > /usr/share/message"</span><span class="token punctuation">]</span>      preStop:        exec:          command: <span class="token punctuation">[</span><span class="token string">"/usr/sbin/nginx"</span>, <span class="token string">"-s"</span>, <span class="token string">"quit"</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> 探测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中常用字段</title>
      <link href="/2019/11/24/k8s%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5/"/>
      <url>/2019/11/24/k8s%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>必须存在的属性</strong></p><table>     <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>version</td><td>String</td><td>这里是指的是K8S API的版本，目前基本上是v1,可以用kubectl api-version命令查询</td></tr>    <tr><td>king</td><td>String</td><td>这里指的是yaml文件定义的资源类型和角色，比如： Pod</td></tr>    <tr><td>metadata</td><td>Object</td><td>元数据对象，固定值就写metadata</td></tr>    <tr><td>metadata.name</td><td>String</td><td>元数据对象的名字，这里由我们编写，比如命名Pod的名字</td></tr>    <tr><td>metadata.namespace</td><td>String</td><td>元数据对象的命名空间，由我们自身定义</td></tr>    <tr><td>Spec</td><td>Object</td><td>详细定义对象，固定值就写Spec</td></tr>    <tr><td>spec.containers[]</td><td>list</td><td>这里是Spec对象的容器列表定义，是个列表</td> </tr>    <tr><td>spec.containers[].name</td><td>String</td><td>这里定义容器的名字</td></tr>    <tr><td>spec.containers[].image</td><td>String</td><td>这里定义要用到的镜像名称</td></tr></table><p><strong>主要的对象</strong></p><table>    <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>spec.containers[].name</td><td>String</td><td>定义容器的名字</td></tr>    <tr><td>spec.containers[].image</td><td>String</td><td>定义要用到的镜像名称</td></tr>    <tr><td>spec.containers[].imagePullPolicy</td><td>String</td><td>定义镜像拉取策略，有Always、Never、ifNotPrent三个值可选(1) Always:意思是每次都尝试重新拉取镜像（2）Never:表示仅使用本地镜像（3）ifNotPresent:如果本地有镜像就使用本地镜像，没有就拉取在线镜像。上面三个值都没有设置的话，默认是Always</td></tr>    <tr><td>spec.containers[].command[]</td><td>List</td><td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令。</td></tr>    <tr><td>spec.containers[].args[]</td><td>List</td><td>指定容器启动命令参数，因为是数组可以指定多个。</td></tr>    <tr><td>spec.containers[].workingDir</td><td>String</td><td>指定容器的工作目录</td></tr>    <tr><td>spec.containers[].volumeMounts[]</td><td>List</td><td>指定容器内部的存储卷配置</td></tr>    <tr><td>spec.containers[].volumeMounts[].name</td><td>String</td><td>指定可以被容器挂载的存储卷的名称</td></tr>    <tr><td>spec.containers[].volumeMounts[].mountPath</td><td>String</td><td>指定可以被容器挂载的存储卷的路径</td></tr>    <tr><td>spec.containers[].volumeMounts[].readOnly</td><td>String</td><td>设置存储卷路径的读写模式，ture或者false,默认为读写模式</td></tr>    <tr><td>spec.containers[].ports[]</td><td>List</td><td>指定容器需要用到的端口列表</td</tr>    <tr><td>spec.containers[].ports[].name</td><td>String</td><td>指定端口名称</td></tr>    <tr><td>spec.containers[].ports[].containerPort</td><td>String</td><td>指定容器需要监听的端口号</td></tr>    <tr><td>spec.containers[].ports[].hostPort</td><td>String</td><td>指定容器所在主机需要监听的端口号，默认跟上面containerPort相同，注意设置了hostPort同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同，这样会冲突)</td></tr>    <tr><td>spec.containers[].ports[].protocol</td><td>String/td><td>指定端口协议，支持TCP和UDP，默认值为TCP</td></tr>    <tr><td>spec.containers[].env[]</td><td>List</td><td>指定容器运行前需设置的环境变量列表</td></tr>    <tr><td>spec.containers[].env[].name</td><td>String</td><td>指定环境变量名称</td></tr>       <tr><td>spec.containers[].env[].value</td><td>String</td><td>指定环境变量值</td></tr>    <tr><td>spec.containers[].resources</td><td>Object</td><td>指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td></tr>    <tr><td>spec.containers[].resources.limits</td><td>Object</td><td>指定设置容器运行时资源的运行上限</td></tr>    <tr><td>spec.containers[].resources.cpu</td><td>String</td><td>指定CPU的限制，单位为core数，将用于docker run --cpu-shares参数(这里前面文章Pod资源限制有讲过)</td></tr>    <tr><td>spec.containers[].resources.limits.memory</td><td>String</td><td>指定MEM内存的限制，单位为MIB、GiB</td></tr>    <tr><td>spec.containers[].resources.requests</td><td>Object</td><td>指定容器启动和调度时的限制设置</td></tr>    <tr><td>spec.containers[].resources.requests.cpu</td><td>String</td><td>CPU请求数，单位为core数，容器启动时初始可用数量</td></tr>    <tr><td>spec.containers[].resources.request.memory</td><td>String</td><td>内存请求，单位MIB、GiB,容器启动的初始化可用数量</td></tr></table><p><strong>额外的参数项</strong></p><table>    <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>spec.restartPoliy</td><td>String</td><td>定义Pod的重启策略，可选值为Always、OnFailure，默认值为Always。1 Always： Pod一旦终止运行，则无论容器是如何终止的，kubelet服务都将重启该Pod.2 OnFailure：只有Pod以非零退出码终止时，kubelet才会重启该容器。如果容器正常结束(退出码为0)，则kubelet将不会重启它。3.Never: Pod终止后，kubelet将退出码报告给Master，不会重启该Pod</td></tr>    <tr><td>spec.nodeSelector</td><td>Object</td><td>定义Node的Label过滤标签，以key:value格式指定</td></tr>    <tr><td>spec.imagePullSecrets</td><td>Object</td><td>定义pull镜像时使用secret名称，以name:secretkey格式指定</td></tr>    <tr><td>spec.hostNetwork</td><td>Boolean</td><td>定义是否使用主机网络模式，默认值为false.设置true表示使用宿主机网络，不适用docker网桥，同时设置了true将无法在同一台宿主机上启动第二个副本。</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 字段属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm搭建k8s三节点集群</title>
      <link href="/2019/11/24/kubeadm%E6%90%AD%E5%BB%BAk8s%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/"/>
      <url>/2019/11/24/kubeadm%E6%90%AD%E5%BB%BAk8s%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubeadm-部署3节点kubernetes-1-15-墙外环境"><a href="#Kubeadm-部署3节点kubernetes-1-15-墙外环境" class="headerlink" title="Kubeadm 部署3节点kubernetes 1.15(墙外环境)"></a>Kubeadm 部署3节点kubernetes 1.15(墙外环境)</h2><p>国内环境请参考：<br>(k8s第一步：)[<a href="https://www.cnblogs.com/fanqisoft/p/11498049.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/11498049.html]</a><br>(k8s第二步：)[<a href="https://www.cnblogs.com/fanqisoft/p/11498217.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/11498217.html]</a><br>kubeadm是Kubernetes官方提供的用于快速安装Kubernetes集群的工具，伴随Kubernetes每个版本的发布都会同步更新，kubeadm会对集群配置方面的一些实践做调整，通过实验kubeadm可以学习到Kubernetes官方在集群配置上一些新的最佳实践。<br>已经发布的Kubernetes 1.15中，kubeadm对HA集群的配置已经达到beta可用，说明kubeadm距离生产环境中可用的距离越来越近了。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>三节点分别对应设置系统主机名</p><pre class=" language-bash"><code class="language-bash">hostnamectl set-hostname k8s-masterhostnamectl set-hostname k8s-node1hostnamectl set-hostname k8s-node2</code></pre><p>三节点都添加hosts解析</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">>></span> /etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF192.168.1.85   k8s-master192.168.1.38   k8s-node1192.168.1.119  k8s-node2EOF</span></code></pre><p>三节点都安装依赖包</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token function">wget</span> vim net-tools <span class="token function">git</span></code></pre><p>三节点都设置防火墙为Iptables 并设置空规则</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld <span class="token operator">&amp;&amp;</span> systemctl disable firewalldyum -y <span class="token function">install</span> iptables-services <span class="token operator">&amp;&amp;</span> systemctl start iptables <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> iptables <span class="token operator">&amp;&amp;</span> iptables -F <span class="token operator">&amp;&amp;</span> <span class="token function">service</span> iptalbes save</code></pre><p>三节点都关闭swap虚拟内存和禁用SELINUX</p><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'/ swap / s/^\(.*\)$/#\1/g'</span> /etc/fstabsetenforce 0 <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'s/^SELINUX=.*/SELINUX=disabled/g'</span>  /etc/selinux/config</code></pre><p>三节点都调整内核参数，对于k8s</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/sysctl.d/kubernetes.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOFnet.bridge.bridge-nf-call-iptables=1    # 将桥接的IPv4流量传递到iptables的链中net.bridge.bridge-nf-call-ip6tables=1   # 将桥接的IPv4流量传递到iptables的链中net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它vm.overcommit_memory=1 # 不检查物理内存是否够用vm.panic_on_oom=0 # 开启 OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1   # 禁用ipv6net.netfilter.nf_conntrack_max=2310720EOF</span>执行下面命令让上面的文件生效sysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><p>三节点都设置rsyslogd和systemd journald</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /var/log/journal <span class="token comment" spellcheck="true"># 持久化保存日志的目录</span><span class="token function">mkdir</span> /etc/systemd/journald.conf.d<span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/journald.conf.d/99-prophet.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Journal]# 持久化保存到磁盘Storage=persistent# 压缩历史日志Compress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000# 最大占用空间 10GSystemMaxUse=10G# 单日志文件最大 200MSystemMaxFileSize=200M# 日志保存时间 2 周MaxRetentionSec=2week# 不将日志转发到 syslogForwardToSyslog=noEOF</span>重启 systemd-journald 服务systemctl restart systemd-journald</code></pre><p>我的三节点是远程机房，不宜重启，暂时没有升级内核为4.44.还是3.10内核，由于自己测试环境，自己玩就没有做升级内核的操作，对于在虚拟机上搭建的集群，可以升级内核，按照下面的操作进行，设置后，需要重启。重启后使用uname -r查看内核版本。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>----升级系统内核为4.44Centos7.x系统自带的3.10.x内核存在一些Bugs,导致运行的Docker、Kubernetes不稳定，例如：rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="token comment" spellcheck="true"># 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次</span>yum --enablerepo<span class="token operator">=</span>elrepo-kernel <span class="token function">install</span> -y kernel-lt<span class="token comment" spellcheck="true"># 设置开机从新内核启动</span>grub2-set-default <span class="token string">"CentOS Linux (4.4.202-1.el7.elrepo.x86_64) 7 (Core)"</span>----<span class="token operator">></span></code></pre><p>kube-proxy(主要解决SVC与POD之间的调度关系)开启ipvs(负载均衡能力更强)的前置条件<br>为了使用ipvs，而不是iptables来进行路由规则的创建,需要安装一些ipvs的依赖<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> ipset ipvsadm</code></pre><p>三节点都执行，由于ipvs已经加入到了内核的主干，所以为kube-proxy开启ipvs的前提需要加载以下的内核模块：</p><pre class=" language-bash"><code class="language-bash">modprobe br_netfilter<span class="token function">cat</span> <span class="token operator">></span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&lt;&lt;</span><span class="token string">EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF</span><span class="token function">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> lsmod <span class="token operator">|</span> <span class="token function">grep</span> -e ip_vs -e nf_conntrack_ipv4</code></pre><p>上面脚本创建了的/etc/sysconfig/modules/ipvs.modules文件，保证在节点重启后能自动加载所需模块。 使用lsmod | grep -e ip_vs -e nf_conntrack_ipv4命令查看是否已经正确加载所需的内核模块。<br>要确保各个节点上已经安装了ipset软件包 yum -y install ipset ,为了便于查看ipvs的代理规则，最好还要确认是否安装了管理工具ipvsadm, yum -y install ipvsadm。<br>如果以上前提条件如果不满足，则即使kube-proxy的配置开启了ipvs模式，也会退回到iptables模式。<br>三节点都安装Docker<br>Kubernetes从1.6开始使用CRI(Container Runtime Interface)容器运行时接口。默认的容器运行时仍然是Docker，使用的是kubelet中内置dockershim CRI实现<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo--查看最新的docker版本，以k8s-master节点为例：--<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum list docker-ce.x86_64  --showduplicates |sort -r</span></code></pre><p>Kubernetes 1.15当前支持的docker版本列表是1.13.1, 17.03, 17.06, 17.09, 18.06, 18.09,这里在各节点安装docker的18.09.7版本。</p><pre class=" language-bash"><code class="language-bash">yum makecache fastyum <span class="token function">install</span> -y --setopt<span class="token operator">=</span>obsoletes<span class="token operator">=</span>0 \  docker-ce-18.09.7-3.el7 systemctl start docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><p>确认一下iptables filter表中FOWARD链的默认策略(pllicy)为ACCEPT。<br>三节点都执行(以k8s-node1为例：)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables -nvL</span>----省略--------Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT 0 packets, 0 bytes<span class="token punctuation">)</span> pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token function">source</span>               destination             0     0 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0               0     0 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED    0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  docker0 <span class="token operator">!</span>docker0  0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0    ----省略--------</code></pre><p>三节点都修改docker cgroup driver为systemd<br>根据文档CRI installation中的内容，对于使用systemd作为init system的Linux的发行版，使用systemd作为docker的cgroup driver可以确保服务器节点在资源紧张的情况更加稳定，因此这里修改各个节点上docker的cgroup driver为systemd。<br>创建或修改/etc/docker/daemon.json：    </p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/docker/daemon.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "exec-opts": ["native.cgroupdriver=systemd"]}EOF</span><span class="token function">mkdir</span> -p /etc/systemd/system/docker.service.d/</code></pre><p>三节点都重新加载docker配置文件，启动docker,设置开机自启动:</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reload <span class="token operator">&amp;&amp;</span> systemctl restart docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><p>可以查看docker安装信息,以k8s-node1为例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker info</span></code></pre><h2 id="第二步kubeadm安装部署K8S"><a href="#第二步kubeadm安装部署K8S" class="headerlink" title="第二步kubeadm安装部署K8S"></a>第二步kubeadm安装部署K8S</h2><p>使用Kubeadm部署Kubernetes<br>安装kubeadm和kubelet<br>三节点上都安装kubeadm 和kubelet,由于墙外环境，不需要修改官方K8S的yum源，就是用GOOGLE k8s.gcr源。墙内环境，需要用阿里云的yum源，或者指定自己搭建的企业级DOCKER Registry仓库harbor(要保证仓库中你已经上传这些组件的镜像哦)，在初始化的时候kubeadm init需要加入–image参数，或者在配置文件kubeadmin-config.yaml指定需要安装组件阿里云镜像的来源地址。</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo<span class="token punctuation">[</span>kubernetes<span class="token punctuation">]</span>name<span class="token operator">=</span>Kubernetesbaseurl<span class="token operator">=</span>https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled<span class="token operator">=</span>1gpgcheck<span class="token operator">=</span>1repo_gpgcheck<span class="token operator">=</span>1gpgkey<span class="token operator">=</span>https://packages.cloud.google.com/yum/doc/yum-key.gpg        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOF</code></pre><p>测试地址<a href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64是否可用，如果不可用需要科学上网。" target="_blank" rel="noopener">https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64是否可用，如果不可用需要科学上网。</a><br>由于我们墙外环境，所以就不存在科学上网了，哈哈哈<br>(我们省略这部，测试也没关系，会访问网页内容滴)</p><pre class=" language-bash"><code class="language-bash">curl https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</code></pre><p>三节点都安装kubelet-1.15.1、kubeadm-1.15.1、kubectl-1.15.1</p><pre class=" language-bash"><code class="language-bash">yum makecache fastyum <span class="token function">install</span> -y kubelet-1.15.1 kubeadm-1.15.1 kubectl-1.15.1</code></pre><p>从安装结果可以看出还安装了cri-tools, kubernetes-cni, socat三个依赖：</p><blockquote><ul><li>官方从Kubernetes 1.14开始将cni依赖升级到了0.7.5版本</li><li>socat是kubelet的依赖</li><li>cri-tools是CRI(Container Runtime Interface)容器运行时接口的命令行工具</li></ul></blockquote><p>由于kubelet需要和容器接口交互，启动我们的容器，而我们的k8s通过kubeadm安装出来以后都是以Pod的方式存在，也就是底层以容器的方式运行，所以kubelet一定要开机自启的，否则重启后我们k8s集群可能起不来。<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> kubelet.service</code></pre><p>初始化主节点k8s-master<br>使用 kubeadm config print init-defaults 可以打印集群初始化默认的使用的配置看一下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> <span class="token function">cd</span> /usr/local/install-k8s/core<span class="token punctuation">[</span>root@k8s-master core<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm config print init-defaults</span>apiVersion: kubeadm.k8s.io/v1beta2bootstrapTokens:- groups:  - system:bootstrappers:kubeadm:default-node-token  token: abcdef.0123456789abcdef  ttl: 24h0m0s  usages:  - signing  - authenticationkind: InitConfigurationlocalAPIEndpoint:  advertiseAddress: 1.2.3.4     <span class="token comment" spellcheck="true"># 默认为1.2.3.4修改为本机内网IP  192.168.1.85</span>  bindPort: 6443nodeRegistration:  criSocket: /var/run/dockershim.sock  name: k8s-master               taints:  - effect: NoSchedule    <span class="token comment" spellcheck="true"># master节点不负责pod的调度，也就是master节点不充当work节点的角色</span>    key: node-role.kubernetes.io/master---apiServer:  timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta2certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: <span class="token punctuation">{</span><span class="token punctuation">}</span>dns:  type: CoreDNSetcd:  local:    dataDir: /var/lib/etcdimageRepository: k8s.gcr.io      <span class="token comment" spellcheck="true"># 默认安装镜像组件拉取的镜像源仓库地址</span>kind: ClusterConfigurationkubernetesVersion: v1.16.0    <span class="token comment" spellcheck="true"># 注意：生成配置文件和我们要安装的k8s版本不同，需要为v1.15.1</span>networking:  dnsDomain: cluster.local  podSubnet: <span class="token string">"10.244.0.0/16"</span>      <span class="token comment" spellcheck="true"># 新增pod的网段,默认的配置文件是没有这个pod子网的，我们新增它，如果不新增，需要在初始化指定pod的子网段</span>  serviceSubnet: 10.96.0.0/12               <span class="token comment" spellcheck="true"># SVC的子网</span>scheduler: <span class="token punctuation">{</span><span class="token punctuation">}</span>---                                              <span class="token comment" spellcheck="true">#以下为新增修改为ipvs模式</span>apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: kubeProxyConfigurationfeatureGates:  SupportIPVSProxyMode: <span class="token boolean">true</span>mode: ipvs</code></pre><p>k8s-master1上执行，生成kubeadm初始化配置文件kubeadm-config.yaml</p><pre class=" language-bash"><code class="language-bash">kubeadm config print init-defaults <span class="token operator">></span> kubeadm-config.yaml</code></pre><p>使用上面生成配置文件在master节点上进行初始化，这个kubeadm-init.log日志记录着node节点加入集群中的方式，不过也可以通过命令找到这个加入集群方式的</p><pre class=" language-bash"><code class="language-bash">kubeadm init --config<span class="token operator">=</span>kubeadm-config.yaml --experimental-upload-certs <span class="token operator">|</span> <span class="token function">tee</span> kubeadm-init.log</code></pre><p>使用指定的yaml文件进行初始化安装，自动颁发证书(v1.13后支持)把所有的信息都写入到 kubeadm-init.log中，其中<strong style="color: red">–experimental-upload-certs </strong>这个参数在最新版中已经被弃用了，官方推荐使用 <strong>–upload-certs </strong>替代，<a href="https://v1-15.docs.kubernetes.io/docs/setup/release/notes/" target="_blank" rel="noopener">官方公告：</a>。</p><p>上面记录了完成的初始化输出的内容，根据输出的内容基本上可以看出手动初始化安装一个Kubernetes集群所需要的关键步骤。 其中有以下关键内容：</p><blockquote><ul><li>init：指定版本进行初始化操作</li><li>preflight：初始化前的检查和下载所需要的 Docker 镜像文件</li><li>kubelet-start：生成 kubelet 的配置文件 var/lib/kubelet/config.yaml，没有这个文件 kubelet 无法启动，所以初始化之前的 kubelet 实际上启动不会成功</li><li>certificates：生成 Kubernetes 使用的证书，存放在 /etc/kubernetes/pki 目录中</li><li>kubeconfig：生成 KubeConfig 文件，存放在 /etc/kubernetes 目录中，组件之间通信需要使用对应文件</li><li>control-plane：使用 /etc/kubernetes/manifest 目录下的 YAML 文件，安装 Master 组件</li><li>etcd：使用 /etc/kubernetes/manifest/etcd.yaml 安装 Etcd 服务</li><li>wait-control-plane：等待 control-plan 部署的 Master 组件启动</li><li>apiclient：检查 Master 组件服务状态。</li><li>uploadconfig：更新配置</li><li>kubelet：使用 configMap 配置 kubelet</li><li>patchnode：更新 CNI 信息到 Node 上，通过注释的方式记录</li><li>mark-control-plane：为当前节点打标签，打了角色 Master，和不可调度标签，这样默认就不会使用 Master 节点来运行 Pod</li><li>bootstrap-token：生成 token 记录下来，后边使用 kubeadm join 往集群中添加节点时会用到</li><li>addons：安装附加组件 CoreDNS 和 kube-proxy</li></ul></blockquote><p>初始化完成后需要的工作，还是k8s-master1节点上<br>在当前的用户(我用的root)的Home目录下创建.kube目录(这个目录中保存我们的连接配置，kubectl和kubeApi进行https通讯，所以有一些缓存需要保存以及一些认证文件)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$HOME</span>/.kube  </code></pre><p>拷贝集群管理员的配置文件到这个目录下</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token variable">$HOME</span>/.kube/config  </code></pre><p>授予权限(所有者 所有组授予当前的用户)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token variable">$HOME</span>/.kube/config        </code></pre><p>查看 k8s 节点状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node</span>NAME         STATUS     ROLES    AGE     VERSIONk8s-master   NotReady   master   7m46s   v1.15.1</code></pre><p>此时主节点状态为NotReady，因为我们k8s集群要求一个扁平化的网络存在，由于我们还没构建flanneld网络插件。<br>下载flannel yaml文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> <span class="token function">cd</span> /usr/local/install-k8s/plugin/flannel<span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span> <span class="token function">wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>创建flannel</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl create -f kube-flannel.yml </span><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system # -n 命名空间  </span></code></pre><p>此时查看node状态应该为Ready状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node</span>NAME         STATUS   ROLES    AGE   VERSIONk8s-master   Ready    master   23m   v1.15.1</code></pre><p>查看一下集群状态，确认个组件都处于healthy状态：</p><pre class=" language-bash"><code class="language-bash">kubectl get cs<span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><p>获得 join命令参数方式有两种：<br>​    1 在我们上面kubeadm init初始化的那个kubeadm-init.log日志中也可以找到。</p><p>​    2 k8s-master 节点上执行下面命令。</p><pre class=" language-bash"><code class="language-bash">kubeadm token create --print-join-command</code></pre><p>在k8s-node1和k8s-node2上分别执行加入节点的命令：</p><pre class=" language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 192.168.1.85:6443 --token abcdef.0123456789abcdef \    --discovery-token-ca-cert-hash sha256:d3a817068b75095f3616f5dd029ee40960ab851a48162fc5e4a0808b8d786ad2 </code></pre><p>在k8s-master节点上查看：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system -o wide  # 可以在wide加入-w参数</span></code></pre><p>此时查看node节点应该有3个，但子节点状态为notReady，等待子节点的flannel初始化完成即可。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span></code></pre><p>*如果子节点执行加入主节点的命令报错的话，可以尝试执行kubeadm reset命令后重试</p><p>移除node节点以及之后的重新加入：</p><p>k8s-master节点上执行：</p><pre class=" language-bash"><code class="language-bash">kubectl delete node k8s-node2</code></pre><p>在k8s-node2节点上执行：</p><pre class=" language-bash"><code class="language-bash">kubeadm reset <span class="token function">ifconfig</span> cni0 downip <span class="token function">link</span> delete cni0<span class="token function">ifconfig</span> flannel.1 downip <span class="token function">link</span> delete flannel.1<span class="token function">rm</span> -rf /var/lib/cni/</code></pre><p>重新是node节点加入集群<br>如果我们忘记了Master节点的token，可以使用下面的命令来看：</p><pre class=" language-bash"><code class="language-bash">kubeadm token list<span class="token punctuation">[</span>root@k8s-master core<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm token list</span>TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION                                           EXTRA GROUPS5q91af.st35qitumttcwp7e   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-11-23T16:22:16+08:00   <span class="token operator">&lt;</span>none<span class="token operator">></span>                   Proxy <span class="token keyword">for</span> managing TTL <span class="token keyword">for</span> the kubeadm-certs secret   <span class="token operator">&lt;</span>none<span class="token operator">></span>abcdef.0123456789abcdef   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-11-24T14:22:16+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                system:bootstrappers:kubeadm:default-node-tokenuw6dfy.cye0w06s06dms8q8   4h          2019-11-25T17:59:15+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                system:bootstrapp</code></pre><p>默认情况下，token的有效期是24小时，如果token已经过期的话，可以使用以下命令重新生成：</p><pre class=" language-bash"><code class="language-bash">kubeadm token create</code></pre><p>如果你找不到–discovery-token-ca-cert-hash的值，可以使用以下命令生成：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master<span class="token punctuation">]</span> ~$ openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt <span class="token operator">|</span> openssl rsa -pubin -outform der 2<span class="token operator">></span>/dev/null <span class="token operator">|</span> openssl dgst -sha256 -hex <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.* //'</span>7845e6615fcae889eedd6fe55174d904ddd4d3ca5257f04c4438cc67cf06ba58</code></pre><p>除了上面通过两次命令找token和hash，也可以直接一次性执行如下命令来获取:</p><pre class=" language-bash"><code class="language-bash">kubeadm token create --print-join-command </code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> docker </tag>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm-kubenetes</title>
      <link href="/2018/10/23/kubeadm-kubenetes/"/>
      <url>/2018/10/23/kubeadm-kubenetes/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
