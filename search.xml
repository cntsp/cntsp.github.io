<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker部署rancher1.6</title>
      <link href="/2019/12/06/docker%E9%83%A8%E7%BD%B2rancher1-6/"/>
      <url>/2019/12/06/docker%E9%83%A8%E7%BD%B2rancher1-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos7系统部署rancher1-6-28版本"><a href="#Centos7系统部署rancher1-6-28版本" class="headerlink" title="Centos7系统部署rancher1.6.28版本"></a>Centos7系统部署rancher1.6.28版本</h2><h3 id="首先安装docker"><a href="#首先安装docker" class="headerlink" title="首先安装docker"></a>首先安装docker</h3><p>如果想要安装指定版本的docker，请移步<a href="https://cntsp.github.io/2019/11/14/centos7%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2docker-ce/">安装指定版本docker</a></p><p>本次操作安装默认版本的docker(1.13.1):</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> docker</code></pre><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p><strong>单机部署，不使用外置的数据库</strong></p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld.servicedocker pull rancher/server:v1.6.26docker run --name rancher --restart<span class="token operator">=</span>unless-stopped  -d -p 8080:8080 rancher/server:v1.6.26</code></pre><p>访问rancher UI界面：</p><pre class=" language-bash"><code class="language-bash">http://IP:8080</code></pre><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>单机部署，使用外置的数据库</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 关闭防火墙</span>systemctl stop firewalld.service<span class="token comment" spellcheck="true"># 下载mariadb镜像tag为10.1</span>docker pull mariadb:10.1<span class="token comment" spellcheck="true"># 下载rancher/server的镜像tag为v1.6.28</span>docker pull rancher/server:v1.6.28<span class="token comment" spellcheck="true"># 启动数据库容器，名字为mariadb2,root密码为nihaoma</span>docker run -d --name maridb2 -p 3306:3306 -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>nihaoma  mariadb:10.1 <span class="token comment" spellcheck="true"># 进入mariadb2数据库容器</span>docker <span class="token function">exec</span> -it mariadb2 /bin/bash<span class="token comment" spellcheck="true"># 进入数据库</span>mysql -uroot -pnihaoma<span class="token operator">></span> CREATE DATABASE IF NOT EXISTS cattle COLLATE <span class="token operator">=</span> <span class="token string">'utf8_general_ci'</span> CHARACTER SET <span class="token operator">=</span> <span class="token string">'utf8'</span><span class="token punctuation">;</span><span class="token operator">></span> GRANT ALL ON cattle.* TO <span class="token string">'cattle'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'cattle'</span><span class="token punctuation">;</span><span class="token operator">></span> FLUSH PRIVILEGES<span class="token punctuation">;</span><span class="token operator">></span> EXIT<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 启动rancher/server容器连接外置的数据库容器</span>docker run --name rancher2 --restart<span class="token operator">=</span>unless-stopped -d -p 18080:8080 rancher/server:v1.6.28 \--db-host xxx.xxx.xxx.xxx --db-port 3306 --db-user cattle --db-pass cattle --db-name cattle</code></pre><p>如果出现链接不到数据库的情况，请重启一下docker服务</p><pre class=" language-bash"><code class="language-bash">systemctl restart docker.service</code></pre><pre class=" language-bash"><code class="language-bash">http://IP:8080</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> rancher1.6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-固定节点</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E5%9B%BA%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E5%9B%BA%E5%AE%9A%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="指定调度节点"><a href="#指定调度节点" class="headerlink" title="指定调度节点"></a>指定调度节点</h2><p><strong>I、Pod.spec.nodeName 将 Pod 直接调度到指定的Node节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">7</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeName</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>node1      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p><strong>II、Pod.spec.nodeSelector: 通过kubernetes 的 label-selector 机制选择节点，由调度器调度策略匹配label，而后调度Pod到目标节点，该匹配规则属于强制约束</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> myweb    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">disk</span><span class="token punctuation">:</span> ssd      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myweb        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 固定节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-污点</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%B1%A1%E7%82%B9/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E6%B1%A1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Tain-和-Toleration"><a href="#Tain-和-Toleration" class="headerlink" title="Tain 和  Toleration"></a>Tain 和  Toleration</h2><p><strong>节点亲和性，是 pod 的一种属性（偏好或硬性要求），它使 pod 被吸引到一类特定的节点。Taint 则相反，它使节点能够排斥一类特定的pod</strong></p><p><strong>Taint 和 toleration 相互配合，可以用来避免 pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个taint，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。如果将 toleration 应用与pod上，则表示这些 pod 可以 （但不要求）被调度到具有匹配 taint 的节点上</strong></p><h2 id="污点-Taint"><a href="#污点-Taint" class="headerlink" title="污点(Taint)"></a>污点(Taint)</h2><p><strong>I、污点（Taint）的组成</strong></p><p><strong>使用 <code>kubectl taint</code> 命令可以给某个Node节点设置污点，Node 被设置上污点之后就和Pod 之间存在了一种相斥的关系，可以让Node拒绝Pod的调度执行，甚至将Node已经存在的Pod驱逐出去</strong></p><p><strong>每个污点的组成如下：</strong></p><pre class=" language-yaml"><code class="language-yaml">key=value<span class="token punctuation">:</span>effect</code></pre><p><strong>每个污点有一个Key和value作为污点的标签，其中value可以为空，effect描述污点的作用。当前taint effect 支持如下三个选项：</strong></p><ul><li><code>NoSchedule</code>: <strong>表示K8S将不会将Pod调度到具有该污点的Node上</strong></li><li><code>PreferNoSchedule</code>:<strong>表示k8s将尽量避免Pod调度到具有该污点的Node上</strong></li><li><code>NoExecute</code>:<strong>表示k8s将不会将Pod调度到具有该污点的Node上，同时会将Node上已经存在的Pod驱逐出去</strong></li></ul><p><strong>II、污点的设置、查看和去除</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置污点</span>kubectl taint nodes node1 key1<span class="token operator">=</span>value1:NoSchedule<span class="token comment" spellcheck="true"># 节点说明中，查找 Taints 字段</span>kubectl describe pod pod-name<span class="token comment" spellcheck="true"># 去除污点</span>kubectl taint nodes node1 key1:NoSchedule-</code></pre><h2 id="容忍（Tolerations）"><a href="#容忍（Tolerations）" class="headerlink" title="容忍（Tolerations）"></a>容忍（Tolerations）</h2><p><strong>设置了污点的Node将根据 taint 的effect: NoSchedule、PreferNoSchedule、NoExecute和Pod之间产生互斥的关系，Pod将在一定程度上不会被调度到Node上。但我们可以在Pod上设置容忍(Toleration)，意思是设置了容忍的Pod将可以容忍污点的存在，可以被调度到存在污点的Node上</strong></p><p><strong>pod.spec.tolerations</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key1"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>  <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span>  <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">3600</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key1"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Equal"</span>  <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoExecute"</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key2"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span>  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">"NoSchedule"</span></code></pre><ul><li><strong>其中 key,value,effect 要与 Node上设置的 taint 保持一致</strong></li><li><strong>operator 的值为Exists将会忽略 value 值</strong></li><li><strong>tolerationsSeconds</strong>：<strong>用于描述当Pod需要被驱逐时可以在Pod上继续保留运行的时间</strong></li></ul><p><strong>I、当不指定 key 值时，表示容忍所有的污点key:</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span></code></pre><p><strong>II、当不指定effect值时，表示容忍所有的污点作用</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">tolerations</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">"key"</span>  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">"Exists"</span></code></pre><p><strong>III、有多个Master存在时，防止资源浪费，可以如下设置</strong></p><pre class=" language-bash"><code class="language-bash">kubectl taint nodes Node-Name node-role.kubernetes.io/master<span class="token operator">=</span>:PreferNoSchedule</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> taint </tag>
            
            <tag> toleration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-调度亲和性</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E4%BA%B2%E5%92%8C%E6%80%A7/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E4%BA%B2%E5%92%8C%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="节点的亲和性"><a href="#节点的亲和性" class="headerlink" title="节点的亲和性"></a>节点的亲和性</h2><p><strong>pod.spec.nodeAffinity</strong></p><ul><li><strong>preferredDuringSchedulinglgnoredDuringExecution:软策略</strong></li><li><strong>requireDuringSchedulinglgnoredDuringExecution:硬策略</strong></li></ul><p><strong>requiredDuringSchedulinglgnoredDuringExecution</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> affinity  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname            <span class="token key atrule">operator</span><span class="token punctuation">:</span> NotIn            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>node2</code></pre><p><strong>preferredDuringSchedulingIgnoredDuringExecution</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> affinity1  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>affinity<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">preference</span><span class="token punctuation">:</span>          <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/hostname            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>node3</code></pre><h2 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: affinity  labels:    app: node-affinity-podspec:  containers:  - name: with-node-affinity    image: harbor.bwingame8.com/library/myapp:v1  affinity:    nodeAffinity:      requiredDuringSchedulingIgnoredDuringExecution:        nodeSelectorTerms:        - matchExpressions:          - key: kubernetes.io/hostname            operator: NotIn            values:            - k8s-node2      preferredDuringSchedulingIgnoredDuringExecution:      - weight: 1        preference:          matchExpressions:          - key: <span class="token function">source</span>            operator: In            values:            - k8s-node2</code></pre><p><strong>键值运算关系</strong></p><ul><li><strong>In: label的值在某个列表中</strong></li><li><strong>NotIn:label的值不在某个列表中</strong></li><li><strong>Gt: label的值大于某个值</strong></li><li><strong>Lt: label的值小于某个值</strong></li><li><strong>Exists：某个label存在</strong></li><li><strong>DoesNotExist：某个label不存在</strong></li></ul><!--如果`nodeSeletorTerms`下面有多个选项的话，满足任何一个条件就可以了；如果`matchExpressions`有多个选项的话，则必须同时满足这些条件才能正常调度 POD--><h2 id="Pod-亲和性"><a href="#Pod-亲和性" class="headerlink" title="Pod 亲和性"></a>Pod 亲和性</h2><p><strong>pod.spec.affinity.podAffinity/podAntiAffinity</strong></p><ul><li><strong>preferredDuringSchedulingIgnoredDuringExecution: 软策略</strong></li><li><strong>requiredDuringSchedulingIgnoredDuringExecution:硬策略</strong></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">3</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">podAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app          <span class="token key atrule">operator</span><span class="token punctuation">:</span> In          <span class="token key atrule">values</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> pod<span class="token punctuation">-</span><span class="token number">1</span>        <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">podAffinityTerm</span><span class="token punctuation">:</span>          <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> app              <span class="token key atrule">operator</span><span class="token punctuation">:</span> In              <span class="token key atrule">values</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> pod<span class="token punctuation">-</span><span class="token number">2</span>          <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> kubernetes.io/hostname</code></pre><p><strong>亲和性/反亲和性调度策略比较如下：</strong></p><table>    <tr><th>调度策略</th><th>匹配标签</th><th>操作符</th><th>拓扑域支持</th><th>调度目</th</tr>    <tr><td>nodeAffinity</td><td>主机</td><td>In,NotIn,Exists,DoesNotExist,Gt,Lt</td><td>否</td><td>指定主机</td></tr>    <tr><td>podAffinity</td><td>POD</td><td>In,NotIn,Exists,DoesNotExist</td><td>是</td><td>POD与指定POD同一拓扑域</td></tr>    <tr><td>podAnitAffinity</td><td>POD</td><td>In,NotIn,Exists,DoesNotExist</td><td>是</td><td>POD与指定POD不再同一个拓扑域</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 亲和性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-调度器-调度说明</title>
      <link href="/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/12/04/kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Scheduler 是kubernetes的调度器，主要的任务是把定义的Pod分配到集群的节点上。听起来非常简单，单有很多要考虑的问题</strong></p><ul><li><strong>公平：如何保证每个节点都能被分配资源</strong></li><li><strong>资源高效利用：集群所有资源最大化被使用</strong></li><li><strong>效率：调度的性能要好，能够尽快地对大批量的Pod 完成调度工作</strong></li><li><strong>灵活：允许用户根据自己的需求控制调度的逻辑</strong></li></ul><p><strong>Scheduler 是作为单独的程序运行的，启动之后会一直监听API Server，获取 <code>PodSpec.Nodename</code>为空的pod,对每个pod都会创建一个binding,表明该Pod应该放到哪个节点上</strong></p><h2 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h2><p><strong>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程为<code>predicate</code>；然后对通过的几点按照优先级排序，这个是<code>priority</code>;最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误</strong></p><p><strong>Predicate 有一系列的算法可以使用：</strong></p><ul><li><code>PodFitsResources</code>:<strong>节点上剩余的资源是否大于pod请求的资源</strong></li><li><code>PodFitHost</code>:<strong>如果pod指定了NodeName,检查节点名称是否和NodeName匹配</strong></li><li><code>PodFitsHostPorts</code>:<strong>节点上已经使用的port是否和pod申请的port冲突</strong></li><li><code>PodSelectorMatches</code>: <strong>过滤掉和pod指定的label不匹配的节点</strong></li><li><code>NoDiskConflict</code>:<strong>已经mount的volume和pod指定的volume不冲突，除非它们都是只读</strong></li></ul><p><strong>如果在predicate过程中没有合适的节点，pod会一直在<code>pending</code>状态，不断重试调度，直到有节点满足条件。经过这个步骤，如果有多个节点满足条件，就继续priorities过程：安装优先级大小对节点排序</strong></p><ul><li><code>LeastRequestedPriority</code>：<strong>通过计算CPU和Memory使用率越接近，权重越高。这个应该和上面的一起使用，不应该单独使用</strong></li><li><code>ImageLocalityPriority</code>:<strong>倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高</strong></li></ul><p><strong>通过算法对所有的优先级项目和权重进行计算，得出最终的结果</strong></p><h2 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h2><p><strong>除了kubernetes自带的调度器，你也可以编写自己的调度器。通过<code>spec:schedulername</code>参数指定调度器的名字，可以为pod选择某个调度器进行调度。比如下面的pod选择<code>my.scheduler</code>进行调度，而不是默认的<code>default.scheduler</code>;</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> annotation<span class="token punctuation">-</span>second<span class="token punctuation">-</span>scheduler  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> multischeduler<span class="token punctuation">-</span>example<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedulername</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>scheduler  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>with<span class="token punctuation">-</span>second<span class="token punctuation">-</span>annotation<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> gcr.io/google_containers/pause<span class="token punctuation">:</span><span class="token number">2.0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 调度器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-volume</title>
      <link href="/2019/12/01/kubernetes-persistent-volume/"/>
      <url>/2019/12/01/kubernetes-persistent-volume/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong><code>PersistentVolume</code>（PV）</strong></p><p><strong>是由管理员设置的存储，它是集群中的一部分。就像节点是集群中的资源一样，PV也是集群中的资源。PV是Volume之类的卷插件，但具有独立于使用PV的Pod的生命周期。此 API 对象包含存储实现的细节，即NFS、iSCSI或特定于云供应商的存储系统</strong></p><p><strong><code>PersistentVolumeClaim</code> （PVC）</strong></p><p><strong>是用户存储的请求。它与Pod相似。Pod消耗节点资源，PVC消耗PV资源。Pod可以请求特定级别的资源(CPU和内存)。声明可以请求特定的大小和访问模式(例如，可以以读/写一次或只读多次模式挂载)</strong></p><p><strong>静态pv</strong></p><p><strong>集群管理员创建一些PV。它们带有可供集群用户使用的实际存储的细节。它们存在与Kubernetes API中，可用于消费</strong></p><p><strong>动态</strong></p><p><strong>当管理员创建的静态PV都不匹配用户的<code>PersistentVolumeClaim</code>时，集群可能会尝试动态地为PVC创建卷。此配置基于<code>StorageClasses</code>:   PVC必须请求[存储类]，并且管理员必须创建并配置该类才能进行动态创建。声明该类为<code>&quot;&quot;</code>可以有效地禁用其动态配置</strong></p><p><strong>要启用基于存储级别的动态存储配置，集群管理员需要启用API server 上的<code>DefaultStorageClass</code>[准入控制器]。例如，通过确保<code>DefaultStorageClass</code>位于 API server 组件的<code>--admission-control</code>标志，使用逗号分割的有序值列表中，可以完成此操作</strong></p><p><strong>绑定</strong></p><p><strong>master中的控制环路监视新的PVC，寻找匹配的PV（如果可能），并将它们绑定在一起。如果为新的PVC动态调配PV，则该环路将始终将该PV绑定到PVC。否则，用户总会得到他们所请求的存储，但是容量可能超出要求的数量。一旦PV和PVC绑定后，<code>PersistentVolumeClaim</code>绑定是排他性的，不管它们是如何绑定的。PVC跟PV绑定是一对一的映射</strong></p><h2 id="持久化卷声明的保护"><a href="#持久化卷声明的保护" class="headerlink" title="持久化卷声明的保护"></a>持久化卷声明的保护</h2><p><strong>PVC保护的目的是确保由Pod正在使用的PVC不会从系统中移除，因为如果被移除的话可能会导致数据丢失</strong></p><!--注意： 当 pod 状态为 `Pending` 并且 pod 已经分配给节点或 pod 为 `Running` 状态时，PVC处于活动状态 --><p><strong>当启用PVC包含alpha功能时，如果用户删除了一个Pod正在使用的PVC，则该PVC不会被立即删除。PVC的删除将被推迟，直到PVC不再被任何pod使用</strong></p><p><strong>持久化卷类型</strong></p><p><code>PersistenVolume</code>类型以插件形式实现。Kubernetes目前支持以下插件类型：</p><ul><li>GCEPersistentDisk AWSElasticBlockStore AzureFile AzureDisk FC(Fibre Channel)</li><li>FlexVolume Flocker NFS iSCSI RBD(Ceph Block Device) CephFS</li><li>Cinder(OpenStack block storage) Glusterfs VsphereVolume Quobyte Volumes</li><li>HostPath VMware Photom Portworx Volumes ScaleIO Volumes StorageOS</li></ul><p><strong>持久卷演示代码</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv0003<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 5Gi  <span class="token key atrule">volumeMode</span><span class="token punctuation">:</span> Filesystem  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> slow  <span class="token key atrule">mountOptions</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> hard    <span class="token punctuation">-</span> nfsvers=4.1  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /tmp    <span class="token key atrule">server</span><span class="token punctuation">:</span> 172.17.0.2</code></pre><h2 id="PV-访问模式"><a href="#PV-访问模式" class="headerlink" title="PV 访问模式"></a>PV 访问模式</h2><p><code>PersistentVolume</code>可以以资源提供者支持的任何方式挂载到主机上。如下表表示，供应商具有不同的功能，每个PV的访问模式都将设置为该卷支持的特定模式。例如，NFS可以支持多个读/写客户端，但特定的NFS PV可能以只读方式导出到服务器上。每个PV都有一套自己的用来描述特定功能的访问模式</p><ul><li>ReadWriteOne – 该卷可以被单个节点以读/写模式挂载</li><li>ReadOnlyMany– 该卷可以被多个节点以只读模式挂载</li><li>ReadWriteMany– 该卷可以被多个节点以读/写模式挂载</li></ul><p><strong>在命令行中，访问模式缩写为：</strong></p><ul><li><strong>RWO - ReadWriteOnce</strong></li><li><strong>ROX - ReadOnlyMany</strong></li><li><strong>RWX- ReadWriteMany</strong></li></ul><!-- 一个卷一次只能使用一种访问模式挂载，即使它支持很多访问模式。例如， GCEPersistentDisk 可以由单个节点作为 ReadWriteOnce 模式挂载，或由多个节点以 ReadOnlyMany 模式挂载，但不能同时挂载 --><table>    <tr><th>Volume 插件</th><th>ReadWriteOnce</th><th>ReadOnlyMany</th><th>ReadWriteMany</th></tr>    <tr><td>AWSElasticBlockStoreAWSElasticBlockStore</td><td>√</td><td>-</td><td>-</td</tr>    <tr><td>AzureFile</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>AzureDisk</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>CephFS</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>Cinder</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>FC</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>FlexVolume</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>Flocker</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>GCEPersistentDisk</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>Glusterfs</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>HostPath</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>iSCSI</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>PhotonPersistentDisk</td><td>√</td><td>-</td><td>-</td></tr>    <tr><td>Quobyte</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>NFS</td><td>√</td><td>√</td><td>√</td></tr>    <tr><td>RBD</td><td>√</td><td>√</td><td>-</td></tr>    <tr><td>VsphereVolume</td><td>√</td><td>-</td><td>-(当Pod并列时有效)</td></tr>    <tr><td>PorworxVolume</td><td>√</td><td>-</td><td>√</td></tr>    <tr><td>ScaleIO</td><td>√</td><td>√</td><td>-</td></tr></table><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><ul><li><strong>Retain（保留）– 手动回收</strong></li><li><strong>Recycle（回收）–基本擦除(<code>rm -rf /thevolume/*</code>) 最新版的服务已经不支持该回收策略了</strong></li><li><strong>Delete（删除）– 关联的存储资产（例如AWS EBS、GCE PD、Azure Disk 和 OpenStack Cinder卷)将被删除</strong></li><li><strong>当前，只有 NFS 和HostPath 支持回收策略。AWS EBS、GCE PD、Azure Disk和Cinder卷支持删除策略</strong></li></ul><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>卷可以处于以下的某种状态:</p><ul><li><p><strong>Available(可用) – 一块空闲资源还没有被任何声明绑定</strong></p></li><li><p><strong>Bound(已绑定)– 卷已经被声明绑定</strong></p></li><li><p><strong>Released（已释放）–声明被删除，但是资源还未被集群重新声明</strong></p></li><li><p><strong>Faild(失败) – 该卷的自动回收失败</strong></p></li></ul><p>*<em>命令行会显示绑定到 PV 的 PVC 的名称 *</em></p><h2 id="持久化演示说明-NFS"><a href="#持久化演示说明-NFS" class="headerlink" title="持久化演示说明 - NFS"></a>持久化演示说明 - NFS</h2><p><strong>I、安装 NFS 服务器</strong></p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y nfs-common nfs-utils rpcbind<span class="token function">mkdir</span> /nfsdata<span class="token function">chmod</span> 666 /nfsdata<span class="token function">chown</span> nfsnobody /nfsdata<span class="token function">cat</span> /etc/exports    /nfsdata *<span class="token punctuation">(</span>rw,no_root_squash,no_all_squash,sync<span class="token punctuation">)</span>systemctl start rpcbindsystemctl start nfs</code></pre><p><strong>II、部署 PV</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nfspv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassNmae</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/nfs    <span class="token key atrule">server</span><span class="token punctuation">:</span> 10.66.66.10</code></pre><p><strong>III、创建服务并使用 PVC</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> web  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"nginx"</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v2        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> web        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> www          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html  <span class="token key atrule">volumeClaimTemplates</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> www    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">accessModes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">"ReadWriteOnce"</span> <span class="token punctuation">]</span>      <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> <span class="token string">"nfs"</span>      <span class="token key atrule">resources</span><span class="token punctuation">:</span>        <span class="token key atrule">requests</span><span class="token punctuation">:</span>          <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi</code></pre><h2 id="关于StatefulSet"><a href="#关于StatefulSet" class="headerlink" title="关于StatefulSet"></a>关于StatefulSet</h2><ul><li><strong>匹配 Pod name（网络标识）的模式为：(statefulset名称)-(序号),比如上面的示例： web-0,web-1,web-2</strong></li><li><strong>StatefulSet为每一个Pod副本创建了一个DNS域名，这个域名的格式为：$(podname).(headless server name),也就意味着服务间是通过Pod域名来通信而非Pod IP,因为当Pod所在Node发生故障时，Pod会被漂移到其它Node上，Pod IP会发生变化，但是Pod域名不会有变化</strong></li><li><strong>StatefulSet 使用 Headless 服务来控制Pod的域名，这个域名的FQDN为：(servicename).(namespace).svc.cluster.local,其中,“cluster.local”指的是集群的域名</strong></li><li><strong>根据 volumeClaimTemplates，为每个 Pod创建一个pvc,pvc的命名规则匹配模式：（volumeClaimTemplates.name)-(pod_name),比如上面的volumeMounts.name=www,Pod name=web-[0-2],因此创建出来的PVC是www-web-0、www-web-1、www-web-2</strong></li><li><span style="color: red;"><strong>删除 Pod 不会删除其pvc，手动删除pvc将自动释放pv</strong></span></li></ul><p><strong>StatefulSet的启停顺序:</strong></p><ul><li><strong>有序部署： 部署StatefulSet时，如果有多个Pod副本，它们会被顺序地创建(从0到N-1)并且，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态</strong></li><li><strong>有序删除：当Pod被删除时，它们被终止的顺序是N-1到0</strong></li><li><strong>有序扩展：当对Pod执行扩展操作时，与部署一样，它前面的Pod必须都处于Running和Ready状态</strong></li></ul><p><strong>StatefulSet使用场景：</strong></p><ul><li><strong>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现。</strong></li><li><strong>稳定的网络标识符，即Pod重新调度后其Podname和Hostname不变。</strong></li><li><strong>有序部署，有序扩展，基于 init containers来实现。</strong></li><li><strong>有序收缩</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-volume</title>
      <link href="/2019/12/01/kubernetes-volume/"/>
      <url>/2019/12/01/kubernetes-volume/</url>
      
        <content type="html"><![CDATA[<p><strong>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet会重启它，但是容器中的文件将丢失–容器以干净的状态(镜像最初的状态)重新启动。其次，在<code>Pod</code>中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes中的<code>Volume</code>抽象就很好的解决了这些问题</strong></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Kubernetes中的卷有明确的寿命 <code>--</code> 与封装它的Pod相同。所以，卷的生命比Pod中的所有容器都长，当这个容器重启时数据仍然得以保存。当然 Pod 不再存在时，卷也将不复存在。也许更重要的是，<code>Kubernetes</code>支持多种类型的卷，Pod可以同时使用任意数量的卷</strong></p><h2 id="卷的类型"><a href="#卷的类型" class="headerlink" title="卷的类型"></a>卷的类型</h2><p><strong>Kubernetes 支持一下类型的卷：</strong></p><ul><li><code>awsElasticBlockStore</code> <code>azureFile</code> <code>cephfs</code> <code>csi</code> <code>downwardAPI</code> `emptyDir``</li><li><code>fc</code> <code>flocker</code> <code>gcePersistentDisk</code> <code>gitRepo</code> <code>glusterfs</code> <code>hostPath</code> <code>iscsi</code> <code>local</code> <code>nfs</code></li><li><code>persistentVolumeClaim</code> <code>projected</code> <code>portworxVolume</code> <code>quobyte</code> <code>rbd</code> <code>scaleIO</code> <code>secret</code></li><li><code>storageos</code> <code>vsphereVolume</code></li></ul><p><strong>emptyDir</strong></p><p>当Pod被分配给节点时，首先创建 <code>emptyDir</code> 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中容器可以读取和写入 <code>emptyDir</code> 卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时， <code>emptyDir</code> 中的数据将被永久删除</p><!-- 注意： 容器崩溃不会从节点中移除 pod ，因此 `emptyDir` 卷中的数据在容器崩溃时是安全的 --><p><code>emptyDir</code> 的用法有：</p><ul><li>暂存空间，例如用于基于磁盘的合并排序</li><li>用作长时间计算崩溃恢复时的检查点</li><li>web服务器容器提供数据时，保存内容管理器容器提取的文件</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pd<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/test<span class="token punctuation">-</span>webserver    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /cache      <span class="token key atrule">name</span><span class="token punctuation">:</span> cache<span class="token punctuation">-</span>volume  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cache<span class="token punctuation">-</span>volume    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><p><strong><code>hostPath</code> 卷将主机节点的文件系统中的文件或目录挂载到集群中</strong></p><p><code>hostPath</code> 的用途如下：</p><ul><li>运行需要访问 Docker 内部的容器： 使用 <code>/var/lib/docker</code>的 <code>hostPath</code></li><li>在容器中运行cAdvisor；使用 <code>/dev/cgroups</code>的 <code>hostPath</code></li></ul><p>除了所需的 <code>path</code> 属性之外，用户还可以为<code>hostPath</code>卷指定 <code>type</code></p><hr><table>    <tr><th>值</th><th>行为</th></tr>    <tr><td></td><td>空字符串(默认)用于向后兼容，这意味着在挂载hostPath 卷之前不会执行任何检查。</td></tr>    <tr><td>DirectoryOrCreate</td><td>如果在给定的路径上没有任何东西存在，那么将根据需要在那里创建一个空目录，权限设置为0755，与kubelet具有相同的组和所有权</td></tr>    <tr><td>Directory</td><td>给定的路径下必须存在目录</td></tr>    <tr><td>FileOrCreate</td><td>如果在给定的路径上没有任何东西存在，那么会根据需要创建在那里创建一个空文件，权限设置为0644，与Kubelete具有相同的组和所有权。</td></tr>    <tr><td>File</td><td>给定的路径下必须存在文件</td></tr>    <tr><td>Socket</td><td>给定的路径下必须存在 UNIX 套接字 </td></tr>    <tr><td>CharDevice</td><td>给定的路径下必须存在字符设备</td></tr>    <tr><td>BlockDevice</td><td>给定的路径下必须存在块设备</td></tr></table><p>使用这种卷类型是请注意，因为：</p><ul><li>由于每个节点上的文件都不同，具有相同配置(例如从podTemplate创建的)的 pod 在不同节点上的行为可能会有所不同</li><li>当Kubernetes 按照计划添加资源感知调度时，将无法考虑 <code>hostPath</code> 使用的资源</li><li>在底层主机上创建的文件或目录只能由 root 写入。您需要在特权容器以 root 身份运行进程，或修改主机上的文件权限以便写入 <code>hostPath</code> 卷</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pd<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/test<span class="token punctuation">-</span>webserver    <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /test<span class="token punctuation">-</span>pd      <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>volume  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>volume    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># directory location on host</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data      <span class="token comment" spellcheck="true"># this field is optional</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> Directory</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> volume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-secret</title>
      <link href="/2019/12/01/kubernetes-secret/"/>
      <url>/2019/12/01/kubernetes-secret/</url>
      
        <content type="html"><![CDATA[<h2 id="Secret-存在意义"><a href="#Secret-存在意义" class="headerlink" title="Secret 存在意义"></a>Secret 存在意义</h2><p><strong>Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用</strong></p><p>Secret有三种类型：</p><ul><li><strong>Service Account: 用来访问Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount 目录中</strong></li><li><strong>Opaque: base64编码格式的Secret,用来存储密码、密钥等</strong></li><li><strong>kubernetes.io/dockerconfigjson:用来存储私有docker registry的认证信息</strong></li></ul><h3 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h3><p><strong>Service Account 用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount 目录中</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system</span>NAME                                 READY   STATUS    RESTARTS   AGEcoredns-5c98db65d4-pxl78             1/1     Running   0          8dcoredns-5c98db65d4-vdtsr             1/1     Running   0          8detcd-k8s-master                      1/1     Running   0          8dkube-apiserver-k8s-master            1/1     Running   0          8dkube-controller-manager-k8s-master   1/1     Running   0          8dkube-flannel-ds-amd64-852cl          1/1     Running   0          8dkube-flannel-ds-amd64-p5h64          1/1     Running   0          8dkube-flannel-ds-amd64-rglvq          1/1     Running   0          6d18hkube-proxy-6sp4j                     1/1     Running   0          8dkube-proxy-hbnkf                     1/1     Running   0          6d18hkube-proxy-ttjcn                     1/1     Running   0          8dkube-scheduler-k8s-master            1/1     Running   0          8d<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec kube-proxy-ttjcn -it -n kube-system -- /bin/sh</span><span class="token comment" spellcheck="true"># cd /run/secrets</span><span class="token comment" spellcheck="true"># ls</span>kubernetes.io<span class="token comment" spellcheck="true"># cd kubernetes.io</span><span class="token comment" spellcheck="true"># cd serviceaccount  </span><span class="token comment" spellcheck="true"># ls</span>ca.crt    namespace  token<span class="token comment" spellcheck="true"># cat ca.crt      </span>-----BEGIN CERTIFICATE-----MIICyDCCAbCgAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJlcm5ldGVzMB4XDTE5MTEyMzA2MjEzNVoXDTI5MTEyMDA2MjEzNVowFTETMBEGA1UEAxMKa3ViZXJuZXRlczCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALqjo541wpNZ42IyS4UXUOtpfgxS37vFo95D2oQoktzjE9hZetkdhDV3J262OVh9sysEUY0p/97A+E8Dex45KnfmqAAZdlG3hq7T5sGHtx/zP81wVs9hxf4SchCIRstCUrOxkErwViu8FOsN+tEPst3TgJaYbFz38zpK0N8769LiwLaVmQMcb07/n2k2uvbion7S6nlEVlS7yQ6fouEaoSULUrEm565A8mu2hloiSSNIlbQBJV8/mlzop4QdKRxvfYt2S3uqqYloenYdWOPAACpWzJn8kkUxBO8xJrzEiGHmUOXz75CmF5flgOQPtgedmWJaKegkvGSsl7Tp28Kv750CAwEAAaMjMCEwDgYDVR0PAQH/BAQDAgKkMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBALfpP6jWWtCdlAfCBXV49eLlIFURyVmsNs16uCxQQbOQLNHMp+3WoZLsyl2xkqwGkruLoG2opWL5ab7FnYlZJpa9QJ12ic6wee0uvb70HLRfc8W2Ep+blgU8nq5zMFknlHS9nEk5PfFkq4T3ZTxZdSbXewxPURl+NLXVVgjNcFDdPpv0srnerLhL7qWYYGEHENxkA60Ons0KIZMZQzabQ4VpXhmvCLhPdmdVL9GbsZcqPQWZD9o23afDHhxNTg3vBnX/8IVm8NO5a5QP9ixzRBVgGzmshr2y5/Xdaqm32FfVZs1R1BURzedwkqssqyRKghqePpdLQznImjJcSQ3bGcI<span class="token operator">=</span>-----END CERTIFICATE-----<span class="token comment" spellcheck="true"># cat token</span>eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJlLXByb3h5LXRva2VuLW54NzhwIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6Imt1YmUtcHJveHkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzZmViYjlhOC0yOTU2LTRjMzEtODU1Mi01Mzc2ZTMxOGE3NWIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06a3ViZS1wcm94eSJ9.xy-rX7AKuPzS6Z2ecFZRy32FHFJuR5WZZ5ziWEhG64rXV5Hcy9gA1ptatwLxQmGGkYFVZ5rEDTcNRGsM1ADHQKFjFhf5TpsXEUfk3U67JtnWUC_KDB8G2P1cBN7s6O1JKYVn-uWGq0LTcxoR62TpMgCFdLKR38CXIR-ItUTmpGVVKlhWgg3pIvvbQgFWOwpHxBM8Ce-Er8J6uhKuPvXfhO28K0ppf0OZFihWPhVs-BLAI855F7UC8dhi0_db10w_zmeaa_EcMRddrs0FYnup_kubevTc7geUOzAetMCfkON4EJv91xVtHVOctpdi2wX4WmhNs9mbuJhBqJPGkp-24Q<span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># ls    </span>ca.crt    namespace  token<span class="token comment" spellcheck="true"># cat namespace     </span>kube-system<span class="token comment" spellcheck="true"># </span></code></pre><h2 id="Opaque-Secret"><a href="#Opaque-Secret" class="headerlink" title="Opaque Secret"></a>Opaque Secret</h2><p><strong>I、创建说明</strong></p><p><strong>Opaque类型的数据是一个map类型，要求value是base65编码格式</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo -n "admin" |base64</span>YWRtaW4<span class="token operator">=</span><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo -n "adbdfes" | base64</span>YWRiZGZlcw<span class="token operator">==</span></code></pre><p><strong>secrets.yaml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">password</span><span class="token punctuation">:</span> YWRiZGZlcw==  <span class="token key atrule">username</span><span class="token punctuation">:</span> YWRtaW4=</code></pre><p><strong>II、使用方式</strong></p><p><strong>1. 将Secret 挂载到 Volume中</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>test  <span class="token key atrule">name</span><span class="token punctuation">:</span> secret<span class="token punctuation">-</span>test<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets    <span class="token key atrule">secret</span><span class="token punctuation">:</span>      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> mysecret  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">name</span><span class="token punctuation">:</span> db    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> secrets      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/etc/secrets"</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p><strong>2、将 Secret 导出到环境变量中</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>deployment    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span><span class="token number">1</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> TEST_USER          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret              <span class="token key atrule">key</span><span class="token punctuation">:</span> username         <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> TEST_PASSWORD           <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>             <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>               <span class="token key atrule">name</span><span class="token punctuation">:</span> mysecret               <span class="token key atrule">key</span><span class="token punctuation">:</span> password</code></pre><h2 id="Kubernetes-io-dockerconfigjson"><a href="#Kubernetes-io-dockerconfigjson" class="headerlink" title="Kubernetes.io/dockerconfigjson"></a>Kubernetes.io/dockerconfigjson</h2><p><strong>使用 Kuberctl 创建 docker registry 认证的secret</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create secret docker-registry myregistrykey --docker-server<span class="token operator">=</span>DOCKER_REGISTRY_SERVER --docker-username<span class="token operator">=</span>DOCKER_USER --docker-password<span class="token operator">=</span>DOCKER_PASSWORD --docker-email<span class="token operator">=</span>DOCKER_EMAIL secret <span class="token string">"myregistrykey"</span> created</code></pre><p>*<em>在创建 Pod 的时候，通过 <code>imagePullSecrets</code> 来引用刚创建的<code>myregistrykey</code> *</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> foo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> foo      <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1   <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myregistrykey</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> secret </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-configMap</title>
      <link href="/2019/12/01/kubenetes-configMap/"/>
      <url>/2019/12/01/kubenetes-configMap/</url>
      
        <content type="html"><![CDATA[<h2 id="configMap-描述信息"><a href="#configMap-描述信息" class="headerlink" title="configMap 描述信息"></a>configMap 描述信息</h2><p><strong>ConfigMap 功能在 Kubernetes1.2版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象</strong></p><h2 id="ConfigMap-的创建"><a href="#ConfigMap-的创建" class="headerlink" title="ConfigMap 的创建"></a>ConfigMap 的创建</h2><p>I、使用目录创建</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/root/yaml/ceshi/configmap/config/docs/user-guide/configmap/kubectl<span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat game.properties </span>enemies<span class="token operator">=</span>alienslives<span class="token operator">=</span>3enemies.cheat<span class="token operator">=</span>trueenemies.cheat.level<span class="token operator">=</span>noGoodRottensecret.code.passphrase<span class="token operator">=</span>UUDDLRLRBABASsecret.code.allowed<span class="token operator">=</span>truesecret.code.lives<span class="token operator">=</span>30<span class="token punctuation">[</span>root@k8s-master kubectl<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat ui.properties </span>color.good<span class="token operator">=</span>purplecolor.bad<span class="token operator">=</span>yellowallow.textmode<span class="token operator">=</span>truehow.nice.to.look<span class="token operator">=</span>fairlyNice$ kubectl create configmap game-config --from-file<span class="token operator">=</span>docs/user-guide/configmap/kubectl</code></pre><p><strong><code>--from-file</code>  指定在目录下的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容</strong></p><p><strong>II 使用文件创建</strong></p><p><strong>只要指定为一个文件就可以从单个文件中创建 ConfigMap</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create configmap game-config-2 --from-file<span class="token operator">=</span>docs/user-\ guide/configmap/kubectl/game.properties$ kubectl get configmaps game-config-2 -o yaml</code></pre><p><strong><code>--from-file</code>这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，就跟指定整个目录是一样的</strong></p><p><strong>III、使用字面值创建</strong></p><p><strong>使用文字值创建，利用 <code>--from-literal</code>参数传递配置信息，该参数可以使用多次，格式如下</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl create configmap special-config --from-literal<span class="token operator">=</span>special.how<span class="token operator">=</span>very --from-literal<span class="token operator">=</span>special.type<span class="token operator">=</span>charm</code></pre><h2 id="Pod中使用-ConfigMap"><a href="#Pod中使用-ConfigMap" class="headerlink" title="Pod中使用 ConfigMap"></a>Pod中使用 ConfigMap</h2><p><strong>I、使用 ConfigMap 来替代环境变量</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">log_level</span><span class="token punctuation">:</span> INFO</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> hubor.bwinagme8.com/library/myapp<span class="token punctuation">:</span>v1      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"env"</span><span class="token punctuation">]</span>      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_TYPE_KEY          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config              <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type      <span class="token key atrule">envForm</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">configMapRef</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>config  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><p><strong>II 用 ConfigMap 设置命令行参数</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod55<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)"</span><span class="token punctuation">]</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_LEVEL_KEY        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config            <span class="token key atrule">key</span><span class="token punctuation">:</span> special.how       <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> SPECIAL_TYPE_KEY         <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>           <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>             <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config             <span class="token key atrule">key</span><span class="token punctuation">:</span> special.type   <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never </code></pre><p>*<em>III、通过数据卷插件使用 ConfigMap *</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">special.how</span><span class="token punctuation">:</span> very  <span class="token key atrule">special.type</span><span class="token punctuation">:</span> charm</code></pre><p><strong>在数据卷里面使用这个ConfigMap,有不同的选项。最基本的就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dapi<span class="token punctuation">-</span>test<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"cat /etc/config/special.how"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume        <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/config  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> special<span class="token punctuation">-</span>config  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><h2 id="ConfigMap-的热更新"><a href="#ConfigMap-的热更新" class="headerlink" title="ConfigMap 的热更新"></a>ConfigMap 的热更新</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>config  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">log_level</span><span class="token punctuation">:</span> INFO<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/config      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> config<span class="token punctuation">-</span>volume          <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> log<span class="token punctuation">-</span>config</code></pre><pre class=" language-bash"><code class="language-bash">$ kubectl <span class="token function">exec</span> `kubectl get pods -l run<span class="token operator">=</span>my-nginx -o<span class="token operator">=</span>name<span class="token operator">|</span><span class="token function">cut</span> -d <span class="token string">"/"</span> -f2` <span class="token function">cat</span> /etc/config/log_levelINFO</code></pre><p><strong>修改 ConfigMap</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl edit configmap log-config</code></pre><p><strong>修改<code>log_level</code>的值为<code>DEBUG</code>等待大概10秒钟时间，再次查看环境变量的值</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl <span class="token function">exec</span> `kubectl get pods -l run<span class="token operator">=</span>my-nginx -o<span class="token operator">=</span>name<span class="token operator">|</span><span class="token function">cut</span> -d <span class="token string">"/"</span> -f2` <span class="token function">cat</span> /etc/config/log_level</code></pre><!--!!! 特别注意 configMap 如果以 ENV 的方式挂载至容器，修改 configMap 并不会实现热更新--><p>*<em>ConfigMap 更新后滚动更新Pod *</em></p><p>更新 ConfigMap 目前并不会触发相关Pod的滚动更新，可以通过修改pod annotations 的方式强制触发滚动更新</p><pre class=" language-bash"><code class="language-bash">$ kubectl patch deployment my-nginx --patch <span class="token string">'{"spec":{"template":{"metadata":{"annotations":{"version/config": "20190411"}}}}}'</span></code></pre><p>这个例子里我们在<code>.spec.template.metadata.annotations</code>中添加<code>version/config</code>,每次通过修改<code>version/config</code>来触发滚动更新</p><p><strong>！！！ 更新 ConfigMap 后：</strong></p><ul><li><strong>使用该 ConfigMap 挂载的 Env 不会同步更新</strong></li><li><strong>使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间(实测大概10秒) 才能同步更新</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> configmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-Ingress</title>
      <link href="/2019/11/29/kubernetes-Ingress/"/>
      <url>/2019/11/29/kubernetes-Ingress/</url>
      
        <content type="html"><![CDATA[<p><strong>Ingress-Nginx github 地址</strong><a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx</a></p><p><strong>Ingress-Nginx 官方网站：</strong><a href="https://kubernetes.github.io/ingress-nginx" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx</a></p><p><img src="./images/22.png" alt=""></p><p><img src="./images/21.png" alt=""></p><h2 id="部署-Ingress-Nginx"><a href="#部署-Ingress-Nginx" class="headerlink" title="部署 Ingress-Nginx"></a>部署 Ingress-Nginx</h2><pre class=" language-bash"><code class="language-bash">kubectl apply -f mandatory.yamlkubectl apply -f service-nodeport.yaml</code></pre><h2 id="Ingress-HTTP-代理访问"><a href="#Ingress-HTTP-代理访问" class="headerlink" title="Ingress HTTP 代理访问"></a>Ingress HTTP 代理访问</h2><p><strong>deployment、Service、Ingress Yaml文件</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-dmspec:  replicas: 2  template:    metadata:      labels:        name: nginx    spec:      containers:        - name: nginx          image: harbor.bwingame8.com/library/myapp:v1          imagePullPolicy: IfNotPresent          ports:            - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-svcspec:  ports:    - port: 80      targetPort: 80      protocol: TCP  selector:    name: nginx---apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-testspec:  rules:    - host: www1.bwingame8.com      http:        paths:        - path: /          backend:            serviceName: nginx-svc            servicePort: 80</code></pre><h2 id="Ingress-HTTPS-代理访问"><a href="#Ingress-HTTPS-代理访问" class="headerlink" title="Ingress HTTPS 代理访问"></a>Ingress HTTPS 代理访问</h2><p><strong>创建证书，以及 cert 存储方式</strong></p><pre class=" language-bash"><code class="language-bash">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="token string">"/CN=nginxsvc/0=nginxsvc"</span>kubectl create secret tls tls-secret --key tls.key --cert tls.crt</code></pre><p>deployment、Service、Ingress Yaml文件</p><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-testspec:  tls:    - hosts:      - www3.bwingame8.com      secretName: tls-secret  rules:    - host: www3.bwingame8.com      http:        paths:        - path: /          backend:            serviceName: svc-3            servicePort: 80</code></pre><h2 id="Nginx-进行-BasicAuth"><a href="#Nginx-进行-BasicAuth" class="headerlink" title="Nginx 进行 BasicAuth"></a>Nginx 进行 BasicAuth</h2><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> httpdhtpasswd -c auth fookubectl create secret generic basic-auth --from-file<span class="token operator">=</span>auth</code></pre><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: ingress-width-auth  annotations:    nginx.ingress.kubernetes.io/auth-type: basic    nginx.ingress.kubernetes.io/auth-secret: basic-auth    nginx.ingress.kubernetes.io/auth-realm: <span class="token string">'Authentication Required - foo'</span>spec:  rules:  - host: www4.bwingame8.com    http:      paths:      - path: /        backend:          serviceName: nginx-svc          servicePort: 80</code></pre><h2 id="Nginx-进行重写"><a href="#Nginx-进行重写" class="headerlink" title="Nginx 进行重写"></a>Nginx 进行重写</h2><table>    <tr><th>名称</th><th>描述</th><th>值</th></tr>    <tr><td>nginx.ingress.kubernetes.io/rewrite-target</td><td>必须重定向流量的目标URL</td><td>串</td></tr>    <tr><td>nginx.ingress.kubernetes.io/ssl-redirect</td><td>指示位置部分是否仅可访问SSL(当Ingress包含证书时默认为True)</td><td>布尔</td></tr>    <tr><td>nginx.ingress.kubernetes.io/force-ssl-redirect</td><td>即使Ingress未启用TLS，也强制重定向到HTTPS</td><td>布尔</td></tr>    <tr><td>nginx.ingress.kubernetes.io/app-root</td><td>定义Controller必须重定向的应用程序根，如果它在'/'上下文中</td><td>串</td></tr>    <tr><td>nginx.ingress.kubernetes.io/use-regex</td><td>指示Ingress上定义的路径是否使用正则表达式</td><td>布尔</td></tr></table><pre class=" language-bash"><code class="language-bash">apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: nginx-test  annotations:    nginx.ingress.kubernetes.io/rewrite-target: https://www3.bwingame8.com:31306/hostname.htmlspec:  rules:  - host: www3.bwingame8.com    http:      paths:      - path: /        backend:          serviceName: nginx-svc          servicePort: 80</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> ingress-nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Service</title>
      <link href="/2019/11/29/Kubernetes-Service/"/>
      <url>/2019/11/29/Kubernetes-Service/</url>
      
        <content type="html"><![CDATA[<h2 id="Service-的概念"><a href="#Service-的概念" class="headerlink" title="Service 的概念"></a>Service 的概念</h2><p><strong>Kubernetes service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 – 通常称为微服务。这一组 <code>Pod</code> 能够被<code>Service</code>访问到，通常是通过<code>Lable Selector</code></strong></p><p><img src="./images/14.png" alt=""></p><p><strong>Service能够提供负载均衡的能力，但是在使用上有以下限制：</strong></p><ul><li><strong>只提供4层负载均衡能力，而没有7层功能，但有时我们可能需要更多的匹配规则来转发请求，这点上4层负载均衡是不支持的</strong></li></ul><h2 id="Service-的类型"><a href="#Service-的类型" class="headerlink" title="Service 的类型"></a>Service 的类型</h2><p><strong>Service 在 K8s中有以下四种类型</strong></p><ul><li><strong>ClusterIp: 默认类型，自动分配一个仅Cluster内部可以访问的虚拟IP</strong></li><li><strong>NodePort: 在 ClusterIP基础上为Service 在每台机器上绑定一个端口，这样就可以通过<NodeIP>:</strong></li><li><strong>LoadBalancer:在NodePort的基础上，借助cloud provider创建一个外部负载均衡器，并将请求转发到<NodeIP>:NodePort</strong></li><li><strong>ExternalName: 把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有kubernetes1.7或更高版本的kube-dns才支持</strong></li></ul><p><img src="./images/15.png" alt=""></p><h2 id="VIP-和-Service-代理"><a href="#VIP-和-Service-代理" class="headerlink" title="VIP 和 Service 代理"></a>VIP 和 Service 代理</h2><p><strong>在 Kubernetes 集群中，每个 Node 运行一个 <code>kube-proxy</code>进程。<code>kube-proxy</code> 负责为 <code>Service</code>实现了一种VIP（虚拟IP）的形式，而不是 <code>ExternalName</code>的形式。在 Kubernetes v1.0 版本，代理完全在userspace。在Kubernetes v1.1版本，新增了 iptables 代理，但并不是默认的运行模式。从Kubernetes v1.2起，默认就是iptables代理。在Kubernetes v1.8.0-beta.0中，添加了ipvs代理</strong></p><p><strong>在kubernetes 1.14版本中开始默认使用 ipvs 代理</strong></p><p><strong>在 kubernetes v1.0 版本， <code>Service</code>是”4层”（TCP/UDP over IP）概念。在kubernetes v1.1版本，新增了 <code>Ingress</code> API(beta版)，用来表示“7层”(HTTP)服务</strong></p><p><strong>！为何不使用 round-robin DNS?</strong>（DNS缓存问题）</p><h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><p><img src="./images/16.png" alt=""></p><p><img src="./images/17.png" alt=""></p><h2>III、ipvs 代理模式</h2><p><strong>这种模式，kube-proxy会监视kubernetes <code>Service</code>对象和<code>Endpoints</code>，调用<code>netlink</code>接口以响应地创建 ipvs 规则并定期与Kubernetes <code>Service</code>对象和<code>Endpoints</code>对象同步ipvs规则，以确保ipvs状态与期望一致。访问服务时，流量将被重定向到其中一个后端Pod</strong></p><p>与iptables类似，ipvs于netfilter的hook功能，但使用哈希表作为底层数据结构并在内核空间中工作。这意味着ipvs可以更快地重定向流量，并且在同步代理规则时具有更好的性能。此外，ipvs为负载均衡算法提供了更好选项，例如：</p><ul><li><strong><code>rr</code>:  轮询调度</strong></li><li><strong><code>lc</code>:  最小连接数</strong></li><li><strong><code>dh</code>:  目标哈希</strong></li><li><strong><code>sh</code>:源哈希</strong></li><li><strong><code>sed</code>: 最短期望延迟</strong></li><li><strong><code>nq</code>: 不排队调度</strong></li></ul><!--注意： ipvs 模式假定在运行 kube-proxy 之前在节点上都已经安装了 IPVS 内核模块。当kube-proxy 以 ipvs 代理模式启动时，kube-proxy 将验证节点上是否安装了 IPVS 模块，如果未安装，则 kube-proxy 将回退到 iptables 代理模式--><p><img src="./images/18.png" alt=""></p><h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p><strong>clusterIP 主要在每个node节点使用iptables，将发向clusterIP对应端口的数据，转发到kube-proxy中。然后kube-proxy自己内部实现有负载均衡的方法，并可以查询到这个service下对应的pod的地址和端口，进而把数据转发给对应的pod的地址和端口</strong></p><p><img src="./images/19.png" alt=""></p><p><strong>为了实现图上的功能，主要需要以下几个组件协同工作：</strong></p><ul><li><strong>apiserver用户通过kubectl命令向apiserver发送创建service的命令，apiserver接收到请求后将数据存储到etcd中</strong></li><li><strong>kube-proxy kubernetes的每个节点中都有一个叫做kube-proxy的进程，这个进程负责感知service，pod的变化，并将变化的信息写入本地的iptables规则中</strong></li><li><strong>iptables 使用NAT等技术将virtualIP的流量转至endpoint中</strong></li></ul><p><strong>创建 myapp-deploy.yaml 文件</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> vim myapp-deploy.yamlapiVersion: apps/v1kind: Deploymentmetadata:  name: myapp-deploy  namespace: defaultspec:  replicas: 3  selector:    matchLabels:      app: myapp      release: stabel  template:    metadata:      labels:        app: myapp        release: stabel        env: <span class="token function">test</span>    spec:      containers:      - name: myapp        image: ikubernetes/myapp:v2        imagePullPolicy: ifNotPresent        ports:        - name: http          containerPort: 80</code></pre><p><strong>创建 Service 信息</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master root<span class="token punctuation">]</span>vim myapp-service.yamlapiVersion: v1kind: Servicemetadata:  name: myapp  namespace: defaultspec:  type: ClusterIP  selector:    app: myapp    release:  stabel  ports:  - name: http    port: 80    targetPort: 80</code></pre><h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p><strong>有时不需要或不想要负载均衡，以及单独的Service IP。遇到这种情况，可以通过指定ClusterIP(spec.clusterIP)的值为“None”来创建Headless Service。这类 Service并不会分配ClusterIP，kube-proxy不会处理他们，而且平台也不会为它们进行负载均衡和路由。</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim myapp-svc-headless.yaml</span>apiVersion: v1kind: Servicemetadata:  name: myapp-headless  namespace: defaultspec:  selector:    app: myapp  clusterIP: <span class="token string">"None"</span>  ports:  - port: 80    targetPort: 80<span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># dig -t A myapp-headless.default.svc.cluster.local.</span>@10.96.0.10</code></pre><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><strong>nodePort 的原理在于在node上开了一个端口,将向该端口的流量导入到kube-proxy，然后由kube-proxy进一步到给对应的Pod</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Servicemetadata:  name: myapp  namespace: defaultspec:  type: NodePort  selector:    app: myapp    release: stabel  ports:  - name: http    port: 80    targetPort: 80</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEkubernetes   ClusterIP   10.96.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          6d6htsgj-svc     NodePort    10.109.255.35   <span class="token operator">&lt;</span>none<span class="token operator">></span>        8080:30000/TCP   2d11h<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                               READY   STATUS    RESTARTS   AGEtsgj-deployment-855476f755-5l4qk   1/1     Running   0          34htsgj-deployment-855476f755-7rj8f   1/1     Running   0          34htsgj-deployment-855476f755-crkrn   1/1     Running   0          34h<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save |grep tsgj-svc</span>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SERVICES <span class="token operator">!</span> -s 10.244.0.0/16 -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-MARK-MASQ-A KUBE-SERVICES -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-SVC-X5UEB5AP7D73JSAI<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SVC-X5UEB5AP7D73JSAI</span>:KUBE-SVC-X5UEB5AP7D73JSAI - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="token string">"default/tsgj-svc:"</span> -m tcp --dport 30000 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SERVICES -d 10.109.255.35/32 -p tcp -m comment --comment <span class="token string">"default/tsgj-svc: cluster IP"</span> -m tcp --dport 8080 -j KUBE-SVC-X5UEB5AP7D73JSAI-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-ACY2NRHQXCLYF447-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-K7BRQOSBPSECSMB6-A KUBE-SVC-X5UEB5AP7D73JSAI -j KUBE-SEP-UBOJ6DEUKSFU7YBC<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-ACY2NRHQXCLYF447</span>:KUBE-SEP-ACY2NRHQXCLYF447 - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-ACY2NRHQXCLYF447 -s 10.244.1.36/32 -j KUBE-MARK-MASQ-A KUBE-SEP-ACY2NRHQXCLYF447 -p tcp -m tcp -j DNAT --to-destination 10.244.1.36:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-ACY2NRHQXCLYF447<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-K7BRQOSBPSECSMB6</span>:KUBE-SEP-K7BRQOSBPSECSMB6 - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-K7BRQOSBPSECSMB6 -s 10.244.1.37/32 -j KUBE-MARK-MASQ-A KUBE-SEP-K7BRQOSBPSECSMB6 -p tcp -m tcp -j DNAT --to-destination 10.244.1.37:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-K7BRQOSBPSECSMB6<span class="token punctuation">[</span>root@k8s-master ceshi<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables-save|grep KUBE-SEP-UBOJ6DEUKSFU7YBC</span>:KUBE-SEP-UBOJ6DEUKSFU7YBC - <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>-A KUBE-SEP-UBOJ6DEUKSFU7YBC -s 10.244.3.24/32 -j KUBE-MARK-MASQ-A KUBE-SEP-UBOJ6DEUKSFU7YBC -p tcp -m tcp -j DNAT --to-destination 10.244.3.24:8080-A KUBE-SVC-X5UEB5AP7D73JSAI -j KUBE-SEP-UBOJ6DEUKSFU7YBC</code></pre><h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><p>iptables  -t nat</p><h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><strong>loadBalancer 和 nodePort 其实是同一种方式。区别在于loadBalancer 比 nodePort多了以步，就是可以调用cloud provider 去创建LB来向节点导流</strong></p><p><img src="./images/20.png" alt=""></p><h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h2><p><strong>这种类型的 Service 通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容(例如：<code>harbor.bwingame8.com</code>)。ExternalName Service 是 Service 的特例，它没有selector，也没有定义任何的端口和 Endpoint。相反的，对于运行在集群外部的服务，它通过返回该外部服务的别名这种方式来提供服务。</strong></p><pre class=" language-bash"><code class="language-bash">kind: ServiceapiVersion: v1metadata:  name: my-service-1  namespace: defaultspec:  type: ExternalName  externalName: my.database.example.com</code></pre><p><strong>当查询主机 my-service.defalut.svc.cluster.local(SVC_NAME.NAMESPACE.svc.cluster.local)时，集群的DNS服务将返回一个值my.database.example.com的CNAME 记录。访问这个服务的工作方式和其它的相同，唯一不同的是重定向发生在DNS层，而且不会进行代理或转发</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-Daemonset-控制器</title>
      <link href="/2019/11/28/kubenetes-Daemonset-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/28/kubenetes-Daemonset-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-DaemonSet"><a href="#什么是-DaemonSet" class="headerlink" title="什么是 DaemonSet"></a>什么是 DaemonSet</h2><p>DaemonSet 确保全部(或者一些)Node上运行一个Pod的副本。当有Node加入集群时，也会为他们新增一个Pod。当有Node从集群移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod。</p><p>DaemonSet 的典型应用场景有：</p><p>（1）运行集群存储daemon，例如在每个Node上运行  glusterd、ceph。</p><p>（2）在每个Node上运行日志收集 daemon，例如 fluentd、logstash。</p><p>   (3)  在每个Node上运行监控 daemon，例如Prometheus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> daemonset<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> daemonset<span class="token punctuation">-</span>example        <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1</code></pre><p>下面我们通过 kube-flannel-ds  这个 daemonset 来学习一下 DaemonSet。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> DaemonSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel<span class="token punctuation">-</span>ds<span class="token punctuation">-</span>amd64  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">tier</span><span class="token punctuation">:</span> node    <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> node        <span class="token key atrule">app</span><span class="token punctuation">:</span> flannel    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">affinity</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>          <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>            <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> beta.kubernetes.io/os                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                      <span class="token punctuation">-</span> linux                  <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> beta.kubernetes.io/arch                    <span class="token key atrule">operator</span><span class="token punctuation">:</span> In                    <span class="token key atrule">values</span><span class="token punctuation">:</span>                      <span class="token punctuation">-</span> amd64      <span class="token key atrule">hostNetwork</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists        <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> flannel      <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install<span class="token punctuation">-</span>cni        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/coreos/flannel<span class="token punctuation">:</span>v0.11.0<span class="token punctuation">-</span>amd64        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> cp        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span>f        <span class="token punctuation">-</span> /etc/kube<span class="token punctuation">-</span>flannel/cni<span class="token punctuation">-</span>conf.json        <span class="token punctuation">-</span> /etc/cni/net.d/10<span class="token punctuation">-</span>flannel.conflist        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cni          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/cni/net.d        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/kube<span class="token punctuation">-</span>flannel/      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel        <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/coreos/flannel<span class="token punctuation">:</span>v0.11.0<span class="token punctuation">-</span>amd64        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> /opt/bin/flanneld        <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>ip<span class="token punctuation">-</span>masq        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>kube<span class="token punctuation">-</span>subnet<span class="token punctuation">-</span>mgr        <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>iface=em1        <span class="token key atrule">resources</span><span class="token punctuation">:</span>          <span class="token key atrule">requests</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"50Mi"</span>          <span class="token key atrule">limits</span><span class="token punctuation">:</span>            <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"100m"</span>            <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"50Mi"</span>        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>          <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>          <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>            <span class="token key atrule">add</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"NET_ADMIN"</span><span class="token punctuation">]</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAME          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAMESPACE          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>              <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /run/flannel        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /etc/kube<span class="token punctuation">-</span>flannel/      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /run/flannel        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cni          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /etc/cni/net.d        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flannel<span class="token punctuation">-</span>cfg          <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>flannel<span class="token punctuation">-</span>cfg</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制器 </tag>
            
            <tag> kubenetes </tag>
            
            <tag> Daemonset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubenetes-JobCronJob-控制器</title>
      <link href="/2019/11/28/kubenetes-JobCronJob-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/28/kubenetes-JobCronJob-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</strong></p><p>特殊说明</p><ul><li><strong>spec.template 格式同Pod</strong></li><li><strong>RestartPolicy仅支持Never或OnFailure</strong></li><li><strong>单个Pod时，默认Pod成功运行后Job即结束</strong></li><li><strong><code>.spec.completions</code> 标志Job结束需要成功运行的Pod个数，默认为1</strong></li><li><strong><code>.spec.parallelism</code> 标志并行运行的Pod的个数，默认为1</strong></li><li><strong><code>spec.activeDeadlineSeconds</code> 标志这失败Pod的重试最大时间，超过这个时间不会继续重试</strong></li></ul><p><strong>Example</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pi<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      name<span class="token punctuation">:</span>pi    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pi        <span class="token key atrule">image</span><span class="token punctuation">:</span> perl        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"perl"</span><span class="token punctuation">,</span> <span class="token string">"-Mbignum=bpi"</span><span class="token punctuation">,</span> <span class="token string">"-wle"</span><span class="token punctuation">,</span> <span class="token string">"print bpi(2000)"</span><span class="token punctuation">]</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never</code></pre><!-- 查看日志，可以显示出答应的 2000 位 Π 值 --><h2 id="CronJob-Spec"><a href="#CronJob-Spec" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h2><ul><li>spec.template格式同Pod</li><li>RestartPolicy仅支持Nerver或OnFailure</li><li>单个Pod时，默认Pod成功运行后Job即结束</li><li><code>.spec.completions</code>标志Job结束需要成功运行的Pod的个数，默认为1</li><li><code>.spec.parallelism</code>标志并运行的Pod的个数，默认为1</li><li><code>spec.activeDeadlineSeconds</code>标志失败Pod的重试最大时间，超过这个时间不会继续重试</li></ul><h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p><strong>Cron Job管理基于时间的Job,即：</strong></p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p>使用条件： 当前使用的 Kubernetes 集群（&gt;=1.8版本）（对CronJob）</p><p>典型的用法如下所示：</p><ul><li>在给定的时间点调度Job运行</li><li>周期性运行的Job，例如：数据库备份、发送邮件</li></ul><h2 id="CronJob-Spec-1"><a href="#CronJob-Spec-1" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h2><ul><li><p><strong><code>.spec.schedule</code>:调度，必须字段，指定任务运行周期，格式同Cron</strong></p></li><li><p><strong><code>.spec.jobTemplate</code>：Job模板，必须自动，指定需要运行的任务，格式同Job</strong></p></li><li><p><strong><code>.spec.startingDeadlineSeconds</code>: 启动Job的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的Job将被认为是失败的。如果没有指定，则没有期限</strong></p></li><li><p><strong><code>.spec.concurrencyPolicy</code>:并发策略，该字段也是可选的。它制定了如果处理被 Cron Job创建的JOb的并发执行，只允许下面策略中的一种：</strong></p><ul><li><p><code>Allow</code>(默认)：允许并发运行Job</p></li><li><p><code>Forbid</code>: 禁止并发运行，如果前一个还没有完成，则直接跳过个</p></li><li><p><code>Replace</code>：取消当前正在运行的 Job,用一个新的来替换</p></li></ul><p><strong>注意，当前策略只能应用于同一个Cron Job创建的Job。如果存在多个Cron Job,它们创建的Job之间总是允许并发运行。</strong></p></li><li><p><strong><code>.spec.suspend</code>：挂起，该字段也是可选的。如果设置为<code>true</code>，后续所有执行都会被挂起。它对已经开始执行的Job不起作用。默认值为<code>false</code></strong>。</p></li><li><p><strong><code>.spec.successfulJobsHistoryLimit</code>和<code>.spec.failedJobsHistoryLimit</code>:历史限制，是可以选的字段。它们制定了可以保留多少完成和失败的Job。默认情况下，他们分别设置为<code>3</code>和<code>1</code>.设置限制的值为<code>0</code>,相关类型的Job完成后将不会被保留。</strong></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJobmetadata：  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"*/1 * * * *"</span>  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">template</span><span class="token punctuation">:</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>          <span class="token key atrule">containers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello            <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox            <span class="token key atrule">args</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> /bin/sh            <span class="token punctuation">-</span> <span class="token punctuation">-</span>c            <span class="token punctuation">-</span> date; echo Hello from the Kubernetes cluster          <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure</code></pre><pre class=" language-shell"><code class="language-shell">[root@k8s-master ceshi]# kubectl get cronjobNAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGEhello   */1 * * * *   False     0        34s             74s[root@k8s-master ceshi]# kubectl get jobNAME               COMPLETIONS   DURATION   AGEhello-1574992740   1/1           7s         74shello-1574992800   1/1           6s         14s[root@k8s-master ceshi]# kubectl get podNAME                               READY   STATUS      RESTARTS   AGEdaemonset-example-dkw6c            1/1     Running     0          12hdaemonset-example-zhqwq            1/1     Running     0          12hhello-1574992740-b6hhs             0/1     Completed   0          117shello-1574992800-7tcnv             0/1     Completed   0          57s[root@k8s-master ceshi]# kubectl logs hello-1574992740-b6hhsFri Nov 29 01:59:12 UTC 2019Hello from the Kubernetes cluster[root@k8s-master ceshi]# kubectl delete cronjob hellocronjob.batch "hello" deleted[root@k8s-master ceshi]# kubectl get cronjobNo resources found.[root@k8s-master ceshi]# kubectl get podNAME                               READY   STATUS    RESTARTS   AGEdaemonset-example-dkw6c            1/1     Running   0          12hdaemonset-example-zhqwq            1/1     Running   0          12h# 注意，删除 cronjob 的时候不会自动删除job，这些 job 可以用 kubectl delete job来删除$ kubectl delete cronjob hello</code></pre><h2 id="CrondJob本身的一些限制"><a href="#CrondJob本身的一些限制" class="headerlink" title="CrondJob本身的一些限制"></a>CrondJob本身的一些限制</h2><p><strong>创建Job操作应该是幂等的</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制器 </tag>
            
            <tag> kubenetes </tag>
            
            <tag> JobCronJob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-Deployment控制器</title>
      <link href="/2019/11/26/kubernetes-Deployment-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/26/kubernetes-Deployment-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RS-与-RC-与-Deployment-关联"><a href="#RS-与-RC-与-Deployment-关联" class="headerlink" title="RS 与 RC 与 Deployment 关联"></a>RS 与 RC 与 Deployment 关联</h2><p><strong>RC （ReplicationController）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替换；而如果异常多出来的容器也会自动回收</strong></p><p><strong>Kubernetes 官方建议使用 RS （ReplicaSet）替代 RC (ReplicationController) 进行部署，RS跟RC没有本质的不同，只是名字不一样，并且RS支持集合式的selector</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicaSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend      <span class="token key atrule">spec</span><span class="token punctuation">:</span>        <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>nginxv1          <span class="token key atrule">image</span><span class="token punctuation">:</span> harbor.bwingame8.com/library/myapp<span class="token punctuation">:</span>v1          <span class="token key atrule">env</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GET_HOSTS_FROM            <span class="token key atrule">value</span><span class="token punctuation">:</span> dns          <span class="token key atrule">ports</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><h2 id="RS-与-Deployment-的关联"><a href="#RS-与-Deployment-的关联" class="headerlink" title="RS 与 Deployment 的关联"></a>RS 与 Deployment 的关联</h2><p><img src="./images/13.png" alt="RS-Deployment"></p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><strong>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</strong></p><ul><li><strong>定义Deployment创建Pod和ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容缩容</strong></li><li><strong>暂停和继续Deployment</strong></li></ul><p><strong>I 部署一个简单的Nginx应用</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><pre class=" language-bash"><code class="language-bash">kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record<span class="token comment" spellcheck="true">## --record参数可以记录命令，我们可以很方便的查看每次 revision 的变化</span></code></pre><p><strong>II 扩容</strong></p><pre class=" language-bash"><code class="language-bash">kubectl scale deployment nginx-deployment --replicas 10</code></pre><p><strong>III、如果集群支持horizontal pod autoscaling的话，还可以为Deployment设置自动扩展</strong></p><pre class=" language-bash"><code class="language-bash">kubectl autoscale deployment nginx-deployment --min-10 --max<span class="token operator">=</span>15 --cpu<span class="token operator">=</span>percent<span class="token operator">=</span>80</code></pre><p><strong>IV、更新镜像也比较简单</strong></p><pre class=" language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/nginx-deployment nginx<span class="token operator">=</span>nginx:1.9.1</code></pre><p><strong>V、回滚</strong></p><pre class=" language-bash"><code class="language-bash">kubectl rollout undo deployment/nginx-deployment</code></pre><h2 id="更新-Deployment"><a href="#更新-Deployment" class="headerlink" title="更新 Deployment"></a>更新 Deployment</h2><!--注意：Deployment 的 rollout 当且仅当 Deployment 的pod template（例如： spec.template）中的label更新或者镜像更改时被触发。其它更新，例如扩容Deployment 不会触发--><h2 id="Deployment-更新策略"><a href="#Deployment-更新策略" class="headerlink" title="Deployment 更新策略"></a>Deployment 更新策略</h2><p>Deployment 可以保证在升级时只有一定数量的 Pod 是down的。默认的，它会确保至少有比期望的Pod数量少一个是up状态(最多一个不可用)</p><p>Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的Pod数量多一个的Pod是up的(最多一个surge)</p><p>现在最新的Kubernetes版本中，将从1-1变成25%-25%</p><pre class=" language-bash"><code class="language-bash">$ kubectl describe deployment</code></pre><h2 id="Rollover（多个rollout并行）"><a href="#Rollover（多个rollout并行）" class="headerlink" title="Rollover（多个rollout并行）"></a>Rollover（多个rollout并行）</h2><p><strong>假如您创建了一个有5个 nginx:1.7.9 replica的Deployment，但是当还只有3个nginx:1.7.9的replica创建出来的时候您就开始更新含有5个nginx:1.9.1replica的Deployment。这种情况下，Deployment会立即杀掉已经创建的3个nginx:1.7.9的Pod,并开始创建nginx:1.9.1的Pod。它不会等到所有的5个nginx:1.7.9的Pod都创建完成后才开始改变航道。</strong></p><h2 id="回退Deployment"><a href="#回退Deployment" class="headerlink" title="回退Deployment"></a>回退Deployment</h2><!--只要 Deployment 的rollout 被触发就会创建一个 revision。也就是说当且仅当 Deployment 的 Pod template（如`.spec.template`）被更改，例如更新 template 中的 label 和容器镜像时，就会创建出一个新的 revision。其它的更新，比如扩容 Deployment 不会创建 revision --因此我们可以很方便的手动或者自动扩容。这意味着当您回退到历史revision时，只有 Deployment 中的 Pod template 部分才会回退 --><pre class=" language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/nginx-deployment nginx<span class="token operator">=</span>nginx:1.9.1kubectl rollout status deployments nginx-deploymentkubectl get podskubectl rollout <span class="token function">history</span> deployment/nginx-deploymentkubectl rollout undo deployment/nginx-deploymentkubectl rollout undo deployment/nginx-deployment --to-revison<span class="token operator">=</span>2  <span class="token comment" spellcheck="true">## 可以使用 --revision参数指定某个历史版本</span>kubectl rollout pause deployment/nginx-deployment  <span class="token comment" spellcheck="true">## 暂停 deployment 的更新</span></code></pre><p><strong>您可以用kubectl rollout status 命令查看 Deployment 是否完成。如果rollout 成功完成，kubectl rollout status 将返回一个0值的 Exit Code</strong></p><pre class=" language-bash"><code class="language-bash">$ kubectl rollout status deploy/nginxWaiting <span class="token keyword">for</span> rollout to finish: 2 of 3 updated replicas are available<span class="token punctuation">..</span>.deployment <span class="token string">"nginx"</span> successfully rolled out$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0</code></pre><h2 id="清理-Policy"><a href="#清理-Policy" class="headerlink" title="清理 Policy"></a>清理 Policy</h2><p><strong>您可以通过设置<code>.spec.revisonHistoryLimit</code>项来指定 deployment 最多保留多少revision历史记录。默认会保留所有的 revision；如果将该项设置为0，Deployment就不允许回退了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 控制器 </tag>
            
            <tag> deployment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Pod-控制器</title>
      <link href="/2019/11/25/Kubernetes-Pod-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2019/11/25/Kubernetes-Pod-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是控制器"><a href="#什么是控制器" class="headerlink" title="什么是控制器"></a>什么是控制器</h2><p>Kubernetes 中内建了很多controller(控制器)，这些相当于一个状态机，用来控制 Pod 的具体状态和行为</p><h2 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h2><ul><li><strong>ReplicationController 和 ReplicaSet</strong></li><li><strong>Deployment</strong></li><li><strong>DaemonSet</strong></li><li><strong>StateFulSet</strong></li><li><strong>Job/Cronjob</strong></li><li><strong>Horizontal Pod Autoscaling</strong></li></ul><p><strong>ReplicationController 和 ReplicaSet</strong></p><p><strong>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；</strong></p><p><strong>在新版本的Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController. ReplicaSet跟 ReplicationController 没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector；</strong></p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p><strong>Deployment为 Pod 和 ReplicaSet 提供了一个声明式定义(declarative)方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</strong></p><ul><li><strong>定义 Deployment 来创建 Pod 和 ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容和缩容</strong></li><li><strong>暂停和继续 Deployment</strong></li></ul><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p><strong>DaemonSet 确保全部 (或者一些) Node上运行一个 Pod 的副本，当有 Node 加入集群时，也会为他们新增一个Pod,当有Node从集群移除时，这些 Pod 也会被撤回收，删除 DaemonSet 将会删除它创建的所有Pod</strong></p><ul><li>运行集群存储daemon，例如在每个Node上运行glusterd、ceph</li><li>在每个Node上运行日志收集daemon,例如fluentd、logstash</li><li>在每个Node上运行监控daemon，例如Promethus Node Exporter、collectd、Datadog代理、New Relic代理，或Ganglia gmond</li></ul><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><ul><li>job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</li></ul><h2 id="Cronjob"><a href="#Cronjob" class="headerlink" title="Cronjob"></a>Cronjob</h2><p>cronjob 管理基于时间的job,即：</p><ul><li>在给定时间点只运行一次</li><li>周期地在给定时间点运行</li></ul><p>使用前提条件：<strong>当前使用的kubernetes集群，版本&gt;=1.8(对Cronjob)。对于先前版本的集群，版本&lt;1.8，启动APIServer时，通过传递选项 –runtime-config=batch/v2alpha1=true 可以开启batch/v2alpha1 API</strong></p><p>典型用法如下所示：</p><ul><li>在给定的时间点调度job运行</li><li>创建周期性运行的job，例如：数据库备份、发送邮件</li></ul><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 作为 Controller  为 Pod 提供唯一的标识。它可以保证部署和scale的顺序</p><p>StatefulSet是为了解决有状态服务的问题(对应Deployment和ReplicaSets是为无状态服务而设计)，其应用场景包括：</p><ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后器PodName和HostName不变，基于Headless Service（即没有Cluster IP的 Service）来实现</li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义好的顺序依次进行(即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态)，基于init containers来实现</li><li>有序收缩，有序删除(即从N-1到0)</li></ul><h2 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h2><p>应用的资源使用率通常都有高峰和低估的时候，如果削峰填谷，提高集群的整体资源利用率，让service中的Pod个数自动调整呢？这就有来与Horizontal Pod Autoscaling了，顾名思义，使 Pod 水平缩放</p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> 控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-pod-探测</title>
      <link href="/2019/11/25/Kubernetes-pod-%E6%8E%A2%E6%B5%8B/"/>
      <url>/2019/11/25/Kubernetes-pod-%E6%8E%A2%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="init-模板"><a href="#init-模板" class="headerlink" title="init 模板"></a>init 模板</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: myapp-pod  labels:    app: myappspec:  containers:  - name: myapp-container    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'echo The app is running &amp;&amp; sleep 3600'</span><span class="token punctuation">]</span>  initContainers:  - name: init-myservice    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'until nslookup myservice; do echo waiting for myservice; sleep 2;done;'</span><span class="token punctuation">]</span>  - name: init-mydb    image: busybox    command: <span class="token punctuation">[</span><span class="token string">'sh'</span>,<span class="token string">'-c'</span>,<span class="token string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span><span class="token punctuation">]</span></code></pre><pre class=" language-bash"><code class="language-bash">kind: ServiceapiVersion: v1metadata:  name: myservicespec:  ports:    - protocol: TCP      port: 80      targetPort: 19376--kind: ServiceapiVersion: v1metadata:  name: mydbspec:  ports:    - protocol: TCP      port: 80      targetPort: 19377</code></pre><h2 id="检测探针-就绪检测"><a href="#检测探针-就绪检测" class="headerlink" title="检测探针-就绪检测"></a>检测探针-就绪检测</h2><p><strong>readinessProbe-httpget</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: readiness-httpget-pod  namespace: defaultspec:  containers:  - name: readiness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    readinessProbe:      httpGet:        port: 80        path: /index1.html      initialDelaySeconds: 1      periodSecond: 3</code></pre><h2 id="检测探针-存活检测"><a href="#检测探针-存活检测" class="headerlink" title="检测探针-存活检测"></a>检测探针-存活检测</h2><p><strong>livenessProbe-exec</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-exec-pod  namespace: defaultspec:  containers:  - name: liveness-exec-container    image: harbor.bwingame8.com/library/busybox:v1    imagePullPolicy: IfNotPresent    command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"touch /tmp/live ; sleep 60; rm -rf /tmp/live; sleep 3600"</span><span class="token punctuation">]</span>    livenessProbe:      exec:        command: <span class="token punctuation">[</span><span class="token string">"test"</span>,<span class="token string">"-e"</span>,<span class="token string">"/tmp/live"</span><span class="token punctuation">]</span>      initialDelaySeconds: 1      periodSeconds: 3</code></pre><p><strong>livenessProbe-httpget</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    livenessProbe:      httpGet:        port: http        path: /index.html      initialDelaySeconds: 1      periodSeconds: 3      timeoutSeconds: 10</code></pre><p><strong>livenessProbe-tcp</strong></p><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: probe-tcpspec:  containers:  - name: nginx    image: harbor.bwingame8.com/library/myapp:v1    livenessProbe:      initialDelaySeconds: 5      timeoutSeconds: 1      tcpSocket:        port: 80</code></pre><h2 id="检测探针-就绪-存活检测"><a href="#检测探针-就绪-存活检测" class="headerlink" title="检测探针-就绪+存活检测"></a>检测探针-就绪+存活检测</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: liveness-httpget-pod  namespace: defaultspec:  containers:  - name: liveness-httpget-container    image: harbor.bwingame8.com/library/myapp:v1    imagePullPolicy: IfNotPresent    ports:    - name: http      containerPort: 80    readinessProbe:      httpGet:        port: 80        path: /index1.html      initialDelaySeconds: 1      periodSecond: 3    livenessProbe:      httpGet:        port: http        path: /index.html      initialDelaySeconds: 1      periodSeconds: 3      timeoutSeconds: 10</code></pre><p><strong>用户通过 Liveness 探测可以告诉 kubernetes 什么时候通过重启容器实现自愈；Readiness 探测则是告诉 kubernetes 什么时候可以将容器加入到 Service 负载均衡池中，对外客户端提供服务</strong></p><p><strong>存活检测：如果不是存活状态，那么重启Pod.</strong></p><p><strong>就绪检测： 如果不是就绪状态，那么Pod的状态不是READY</strong></p><h2 id="启动、退出动作"><a href="#启动、退出动作" class="headerlink" title="启动、退出动作"></a>启动、退出动作</h2><pre class=" language-bash"><code class="language-bash">apiVersion: v1kind: Podmetadata:  name: lifecycle-demospec:  containers:  - name: lifecycle-demo-container    image: nginx    lifecycle:      postStart:        exec:          command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"echo hello from the postStart handler > /usr/share/message"</span><span class="token punctuation">]</span>      preStop:        exec:          command: <span class="token punctuation">[</span><span class="token string">"/usr/sbin/nginx"</span>, <span class="token string">"-s"</span>, <span class="token string">"quit"</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pod </tag>
            
            <tag> 探测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中常用字段</title>
      <link href="/2019/11/24/k8s%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5/"/>
      <url>/2019/11/24/k8s%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>必须存在的属性</strong></p><table>     <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>version</td><td>String</td><td>这里是指的是K8S API的版本，目前基本上是v1,可以用kubectl api-version命令查询</td></tr>    <tr><td>king</td><td>String</td><td>这里指的是yaml文件定义的资源类型和角色，比如： Pod</td></tr>    <tr><td>metadata</td><td>Object</td><td>元数据对象，固定值就写metadata</td></tr>    <tr><td>metadata.name</td><td>String</td><td>元数据对象的名字，这里由我们编写，比如命名Pod的名字</td></tr>    <tr><td>metadata.namespace</td><td>String</td><td>元数据对象的命名空间，由我们自身定义</td></tr>    <tr><td>Spec</td><td>Object</td><td>详细定义对象，固定值就写Spec</td></tr>    <tr><td>spec.containers[]</td><td>list</td><td>这里是Spec对象的容器列表定义，是个列表</td> </tr>    <tr><td>spec.containers[].name</td><td>String</td><td>这里定义容器的名字</td></tr>    <tr><td>spec.containers[].image</td><td>String</td><td>这里定义要用到的镜像名称</td></tr></table><p><strong>主要的对象</strong></p><table>    <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>spec.containers[].name</td><td>String</td><td>定义容器的名字</td></tr>    <tr><td>spec.containers[].image</td><td>String</td><td>定义要用到的镜像名称</td></tr>    <tr><td>spec.containers[].imagePullPolicy</td><td>String</td><td>定义镜像拉取策略，有Always、Never、ifNotPrent三个值可选(1) Always:意思是每次都尝试重新拉取镜像（2）Never:表示仅使用本地镜像（3）ifNotPresent:如果本地有镜像就使用本地镜像，没有就拉取在线镜像。上面三个值都没有设置的话，默认是Always</td></tr>    <tr><td>spec.containers[].command[]</td><td>List</td><td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令。</td></tr>    <tr><td>spec.containers[].args[]</td><td>List</td><td>指定容器启动命令参数，因为是数组可以指定多个。</td></tr>    <tr><td>spec.containers[].workingDir</td><td>String</td><td>指定容器的工作目录</td></tr>    <tr><td>spec.containers[].volumeMounts[]</td><td>List</td><td>指定容器内部的存储卷配置</td></tr>    <tr><td>spec.containers[].volumeMounts[].name</td><td>String</td><td>指定可以被容器挂载的存储卷的名称</td></tr>    <tr><td>spec.containers[].volumeMounts[].mountPath</td><td>String</td><td>指定可以被容器挂载的存储卷的路径</td></tr>    <tr><td>spec.containers[].volumeMounts[].readOnly</td><td>String</td><td>设置存储卷路径的读写模式，ture或者false,默认为读写模式</td></tr>    <tr><td>spec.containers[].ports[]</td><td>List</td><td>指定容器需要用到的端口列表</td</tr>    <tr><td>spec.containers[].ports[].name</td><td>String</td><td>指定端口名称</td></tr>    <tr><td>spec.containers[].ports[].containerPort</td><td>String</td><td>指定容器需要监听的端口号</td></tr>    <tr><td>spec.containers[].ports[].hostPort</td><td>String</td><td>指定容器所在主机需要监听的端口号，默认跟上面containerPort相同，注意设置了hostPort同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同，这样会冲突)</td></tr>    <tr><td>spec.containers[].ports[].protocol</td><td>String/td><td>指定端口协议，支持TCP和UDP，默认值为TCP</td></tr>    <tr><td>spec.containers[].env[]</td><td>List</td><td>指定容器运行前需设置的环境变量列表</td></tr>    <tr><td>spec.containers[].env[].name</td><td>String</td><td>指定环境变量名称</td></tr>       <tr><td>spec.containers[].env[].value</td><td>String</td><td>指定环境变量值</td></tr>    <tr><td>spec.containers[].resources</td><td>Object</td><td>指定资源限制和资源请求的值（这里开始就是设置容器的资源上限）</td></tr>    <tr><td>spec.containers[].resources.limits</td><td>Object</td><td>指定设置容器运行时资源的运行上限</td></tr>    <tr><td>spec.containers[].resources.cpu</td><td>String</td><td>指定CPU的限制，单位为core数，将用于docker run --cpu-shares参数(这里前面文章Pod资源限制有讲过)</td></tr>    <tr><td>spec.containers[].resources.limits.memory</td><td>String</td><td>指定MEM内存的限制，单位为MIB、GiB</td></tr>    <tr><td>spec.containers[].resources.requests</td><td>Object</td><td>指定容器启动和调度时的限制设置</td></tr>    <tr><td>spec.containers[].resources.requests.cpu</td><td>String</td><td>CPU请求数，单位为core数，容器启动时初始可用数量</td></tr>    <tr><td>spec.containers[].resources.request.memory</td><td>String</td><td>内存请求，单位MIB、GiB,容器启动的初始化可用数量</td></tr></table><p><strong>额外的参数项</strong></p><table>    <tr><th>参数名</th><th>字段类型</th><th>说明</th></tr>    <tr><td>spec.restartPoliy</td><td>String</td><td>定义Pod的重启策略，可选值为Always、OnFailure，默认值为Always。1 Always： Pod一旦终止运行，则无论容器是如何终止的，kubelet服务都将重启该Pod.2 OnFailure：只有Pod以非零退出码终止时，kubelet才会重启该容器。如果容器正常结束(退出码为0)，则kubelet将不会重启它。3.Never: Pod终止后，kubelet将退出码报告给Master，不会重启该Pod</td></tr>    <tr><td>spec.nodeSelector</td><td>Object</td><td>定义Node的Label过滤标签，以key:value格式指定</td></tr>    <tr><td>spec.imagePullSecrets</td><td>Object</td><td>定义pull镜像时使用secret名称，以name:secretkey格式指定</td></tr>    <tr><td>spec.hostNetwork</td><td>Boolean</td><td>定义是否使用主机网络模式，默认值为false.设置true表示使用宿主机网络，不适用docker网桥，同时设置了true将无法在同一台宿主机上启动第二个副本。</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 字段属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yaml语法</title>
      <link href="/2019/11/24/Yaml%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/11/24/Yaml%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><p><strong>是一个可读性高，用来表达数据序列的格式。YAML 的意思其实是： 仍是一种标记语言，但为了强调这种语言以数据作为中心，而不是以标记语言为重点</strong></p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>缩进时不允许使用Tab键，只允许使用空格</li><li>缩进的空格数据目不重要，只要相同层级的元素左侧对齐即可</li><li># 标识注释，从这个字符一直到行尾，都会被解释器忽略</li></ul><h1 id="YAML支持的数据结构"><a href="#YAML支持的数据结构" class="headerlink" title="YAML支持的数据结构"></a>YAML支持的数据结构</h1><ul><li>对象：键值对的集合，又称为映射(mapping)/哈希(hashes)/字典(dictionary)</li><li>数组：一组按次序排列的值，又称为序列(sequence)/列表(list)</li><li>纯量(scalars)：单个的、不可再分的值</li></ul><h2 id="对象类型：对象的一组键值对，使用冒号结构表示"><a href="#对象类型：对象的一组键值对，使用冒号结构表示" class="headerlink" title="对象类型：对象的一组键值对，使用冒号结构表示"></a>对象类型：对象的一组键值对，使用冒号结构表示</h2><pre class=" language-bash"><code class="language-bash">name: Steveage: 18</code></pre><h2 id="Yaml也允许另一种写法，将所有键值对写成一个行内对象"><a href="#Yaml也允许另一种写法，将所有键值对写成一个行内对象" class="headerlink" title="Yaml也允许另一种写法，将所有键值对写成一个行内对象"></a>Yaml也允许另一种写法，将所有键值对写成一个行内对象</h2><pre class=" language-bash"><code class="language-bash">hash: <span class="token punctuation">{</span> name: Steve, age: 18 <span class="token punctuation">}</span></code></pre><h2 id="数组类型：一组连词线开头的行，构成一个数组"><a href="#数组类型：一组连词线开头的行，构成一个数组" class="headerlink" title="数组类型：一组连词线开头的行，构成一个数组"></a>数组类型：一组连词线开头的行，构成一个数组</h2><pre class=" language-bash"><code class="language-bash">animal- Cat- Dog</code></pre><h2 id="数组也可以采用行内表示法"><a href="#数组也可以采用行内表示法" class="headerlink" title="数组也可以采用行内表示法"></a>数组也可以采用行内表示法</h2><pre class=" language-bash"><code class="language-bash">animal: <span class="token punctuation">[</span>Cat, Dog<span class="token punctuation">]</span></code></pre><h2 id="符合结构：对象和数组可以结合使用，形成符合结构"><a href="#符合结构：对象和数组可以结合使用，形成符合结构" class="headerlink" title="符合结构：对象和数组可以结合使用，形成符合结构"></a>符合结构：对象和数组可以结合使用，形成符合结构</h2><pre class=" language-bash"><code class="language-bash">1 languages:2 - Ruby3 - Perl4 - Python5 websites:6 YAML: yaml.org7 Ruby: ruby-lang.org8 Python: python.org9 Perl: user.perl.org</code></pre><h2 id="纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量"><a href="#纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量" class="headerlink" title="纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量"></a>纯量：纯量是最基本的、不可再分的值。以下数据类型都属于纯量</h2><pre class=" language-bash"><code class="language-bash">1 字符串 布尔值 整数 浮点数 Null2 时间 日期数值直接以字面量的形式表示number: 12.30布尔值用true和false表示isSet: <span class="token boolean">true</span>null用 ~ 表示parent: ~时间采用 ISO8601模式iso8601: 2001-12-14t21:59:43.10-05:00日期采用符合 iso8601 格式的年、月】日表示date: 1976-07-31YAML 允许使用两个感叹号，强制转换数据类型e: <span class="token operator">!</span><span class="token operator">!</span>str 123f: <span class="token operator">!</span><span class="token operator">!</span>str ture</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串默认不适用引号表示</p><pre class=" language-bash"><code class="language-bash">str: 这是一行字符串</code></pre><p>如果字符串之中包含空格或特殊字符，需要放在引号之中</p><pre class=" language-bash"><code class="language-bash">str: <span class="token string">'内容： 字符串'</span></code></pre><p>单引号和双引号都可以使用，双引号不会对特殊字符转义</p><pre class=" language-bash"><code class="language-bash">s1: <span class="token string">'内容\n字符串'</span>s2: <span class="token string">"内容\n字符串"</span></code></pre><p>单引号之中如果还有单引号，必须连续使用两个单引号转义</p><pre class=" language-bash"><code class="language-bash">str: <span class="token string">'labor'</span><span class="token string">'s day'</span></code></pre><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会转为空格</p><pre class=" language-bash"><code class="language-bash">str: 这是一段  多行  字符串</code></pre><p>多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行</p><pre class=" language-bash"><code class="language-bash">this: <span class="token operator">|</span>FooBarthat:<span class="token operator">></span>FooBar</code></pre><p><strong>+</strong> 表示保留文字块末尾的换行， <strong>-</strong> 表示删除字符串末尾的换行</p><pre class=" language-bash"><code class="language-bash">s1: <span class="token operator">|</span>  Foos2: <span class="token operator">|</span>+  Foos3: <span class="token operator">|</span>-  Foo</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> yaml语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm搭建k8s三节点集群</title>
      <link href="/2019/11/24/kubeadm%E6%90%AD%E5%BB%BAk8s%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/"/>
      <url>/2019/11/24/kubeadm%E6%90%AD%E5%BB%BAk8s%E4%B8%89%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubeadm-部署3节点kubernetes-1-15-墙外环境"><a href="#Kubeadm-部署3节点kubernetes-1-15-墙外环境" class="headerlink" title="Kubeadm 部署3节点kubernetes 1.15(墙外环境)"></a>Kubeadm 部署3节点kubernetes 1.15(墙外环境)</h2><p>国内环境请参考：<br>(k8s第一步：)[<a href="https://www.cnblogs.com/fanqisoft/p/11498049.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/11498049.html]</a><br>(k8s第二步：)[<a href="https://www.cnblogs.com/fanqisoft/p/11498217.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fanqisoft/p/11498217.html]</a><br>kubeadm是Kubernetes官方提供的用于快速安装Kubernetes集群的工具，伴随Kubernetes每个版本的发布都会同步更新，kubeadm会对集群配置方面的一些实践做调整，通过实验kubeadm可以学习到Kubernetes官方在集群配置上一些新的最佳实践。<br>已经发布的Kubernetes 1.15中，kubeadm对HA集群的配置已经达到beta可用，说明kubeadm距离生产环境中可用的距离越来越近了。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>三节点分别对应设置系统主机名</p><pre class=" language-bash"><code class="language-bash">hostnamectl set-hostname k8s-masterhostnamectl set-hostname k8s-node1hostnamectl set-hostname k8s-node2</code></pre><p>三节点都添加hosts解析</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">>></span> /etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF192.168.1.85   k8s-master192.168.1.38   k8s-node1192.168.1.119  k8s-node2EOF</span></code></pre><p>三节点都安装依赖包</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token function">wget</span> vim net-tools <span class="token function">git</span></code></pre><p>三节点都设置防火墙为Iptables 并设置空规则</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld <span class="token operator">&amp;&amp;</span> systemctl disable firewalldyum -y <span class="token function">install</span> iptables-services <span class="token operator">&amp;&amp;</span> systemctl start iptables <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> iptables <span class="token operator">&amp;&amp;</span> iptables -F <span class="token operator">&amp;&amp;</span> <span class="token function">service</span> iptalbes save</code></pre><p>三节点都关闭swap虚拟内存和禁用SELINUX</p><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'/ swap / s/^\(.*\)$/#\1/g'</span> /etc/fstabsetenforce 0 <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'s/^SELINUX=.*/SELINUX=disabled/g'</span>  /etc/selinux/config</code></pre><p>三节点都调整内核参数，对于k8s</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/sysctl.d/kubernetes.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOFnet.bridge.bridge-nf-call-iptables=1    # 将桥接的IPv4流量传递到iptables的链中net.bridge.bridge-nf-call-ip6tables=1   # 将桥接的IPv4流量传递到iptables的链中net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它vm.overcommit_memory=1 # 不检查物理内存是否够用vm.panic_on_oom=0 # 开启 OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1   # 禁用ipv6net.netfilter.nf_conntrack_max=2310720EOF</span>执行下面命令让上面的文件生效sysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><p>三节点都设置rsyslogd和systemd journald</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /var/log/journal <span class="token comment" spellcheck="true"># 持久化保存日志的目录</span><span class="token function">mkdir</span> /etc/systemd/journald.conf.d<span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/journald.conf.d/99-prophet.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Journal]# 持久化保存到磁盘Storage=persistent# 压缩历史日志Compress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000# 最大占用空间 10GSystemMaxUse=10G# 单日志文件最大 200MSystemMaxFileSize=200M# 日志保存时间 2 周MaxRetentionSec=2week# 不将日志转发到 syslogForwardToSyslog=noEOF</span>重启 systemd-journald 服务systemctl restart systemd-journald</code></pre><p>我的三节点是远程机房，不宜重启，暂时没有升级内核为4.44.还是3.10内核，由于自己测试环境，自己玩就没有做升级内核的操作，对于在虚拟机上搭建的集群，可以升级内核，按照下面的操作进行，设置后，需要重启。重启后使用uname -r查看内核版本。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>----升级系统内核为4.44Centos7.x系统自带的3.10.x内核存在一些Bugs,导致运行的Docker、Kubernetes不稳定，例如：rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="token comment" spellcheck="true"># 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次</span>yum --enablerepo<span class="token operator">=</span>elrepo-kernel <span class="token function">install</span> -y kernel-lt<span class="token comment" spellcheck="true"># 设置开机从新内核启动</span>grub2-set-default <span class="token string">"CentOS Linux (4.4.202-1.el7.elrepo.x86_64) 7 (Core)"</span>----<span class="token operator">></span></code></pre><p>kube-proxy(主要解决SVC与POD之间的调度关系)开启ipvs(负载均衡能力更强)的前置条件<br>为了使用ipvs，而不是iptables来进行路由规则的创建,需要安装一些ipvs的依赖<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> ipset ipvsadm</code></pre><p>三节点都执行，由于ipvs已经加入到了内核的主干，所以为kube-proxy开启ipvs的前提需要加载以下的内核模块：</p><pre class=" language-bash"><code class="language-bash">modprobe br_netfilter<span class="token function">cat</span> <span class="token operator">></span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&lt;&lt;</span><span class="token string">EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF</span><span class="token function">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> /etc/sysconfig/modules/ipvs.modules <span class="token operator">&amp;&amp;</span> lsmod <span class="token operator">|</span> <span class="token function">grep</span> -e ip_vs -e nf_conntrack_ipv4</code></pre><p>上面脚本创建了的/etc/sysconfig/modules/ipvs.modules文件，保证在节点重启后能自动加载所需模块。 使用lsmod | grep -e ip_vs -e nf_conntrack_ipv4命令查看是否已经正确加载所需的内核模块。<br>要确保各个节点上已经安装了ipset软件包 yum -y install ipset ,为了便于查看ipvs的代理规则，最好还要确认是否安装了管理工具ipvsadm, yum -y install ipvsadm。<br>如果以上前提条件如果不满足，则即使kube-proxy的配置开启了ipvs模式，也会退回到iptables模式。<br>三节点都安装Docker<br>Kubernetes从1.6开始使用CRI(Container Runtime Interface)容器运行时接口。默认的容器运行时仍然是Docker，使用的是kubelet中内置dockershim CRI实现<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo--查看最新的docker版本，以k8s-master节点为例：--<span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum list docker-ce.x86_64  --showduplicates |sort -r</span></code></pre><p>Kubernetes 1.15当前支持的docker版本列表是1.13.1, 17.03, 17.06, 17.09, 18.06, 18.09,这里在各节点安装docker的18.09.7版本。</p><pre class=" language-bash"><code class="language-bash">yum makecache fastyum <span class="token function">install</span> -y --setopt<span class="token operator">=</span>obsoletes<span class="token operator">=</span>0 \  docker-ce-18.09.7-3.el7 systemctl start docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><p>确认一下iptables filter表中FOWARD链的默认策略(pllicy)为ACCEPT。<br>三节点都执行(以k8s-node1为例：)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># iptables -nvL</span>----省略--------Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT 0 packets, 0 bytes<span class="token punctuation">)</span> pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token function">source</span>               destination             0     0 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0               0     0 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED    0     0 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  docker0 <span class="token operator">!</span>docker0  0.0.0.0/0            0.0.0.0/0               0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0    ----省略--------</code></pre><p>三节点都修改docker cgroup driver为systemd<br>根据文档CRI installation中的内容，对于使用systemd作为init system的Linux的发行版，使用systemd作为docker的cgroup driver可以确保服务器节点在资源紧张的情况更加稳定，因此这里修改各个节点上docker的cgroup driver为systemd。<br>创建或修改/etc/docker/daemon.json：    </p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/docker/daemon.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "exec-opts": ["native.cgroupdriver=systemd"]}EOF</span><span class="token function">mkdir</span> -p /etc/systemd/system/docker.service.d/</code></pre><p>三节点都重新加载docker配置文件，启动docker,设置开机自启动:</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reload <span class="token operator">&amp;&amp;</span> systemctl restart docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><p>可以查看docker安装信息,以k8s-node1为例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-node1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker info</span></code></pre><h2 id="第二步kubeadm安装部署K8S"><a href="#第二步kubeadm安装部署K8S" class="headerlink" title="第二步kubeadm安装部署K8S"></a>第二步kubeadm安装部署K8S</h2><p>使用Kubeadm部署Kubernetes<br>安装kubeadm和kubelet<br>三节点上都安装kubeadm 和kubelet,由于墙外环境，不需要修改官方K8S的yum源，就是用GOOGLE k8s.gcr源。墙内环境，需要用阿里云的yum源，或者指定自己搭建的企业级DOCKER Registry仓库harbor(要保证仓库中你已经上传这些组件的镜像哦)，在初始化的时候kubeadm init需要加入–image参数，或者在配置文件kubeadmin-config.yaml指定需要安装组件阿里云镜像的来源地址。</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo<span class="token punctuation">[</span>kubernetes<span class="token punctuation">]</span>name<span class="token operator">=</span>Kubernetesbaseurl<span class="token operator">=</span>https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled<span class="token operator">=</span>1gpgcheck<span class="token operator">=</span>1repo_gpgcheck<span class="token operator">=</span>1gpgkey<span class="token operator">=</span>https://packages.cloud.google.com/yum/doc/yum-key.gpg        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOF</code></pre><p>测试地址<a href="https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64是否可用，如果不可用需要科学上网。" target="_blank" rel="noopener">https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64是否可用，如果不可用需要科学上网。</a><br>由于我们墙外环境，所以就不存在科学上网了，哈哈哈<br>(我们省略这部，测试也没关系，会访问网页内容滴)</p><pre class=" language-bash"><code class="language-bash">curl https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</code></pre><p>三节点都安装kubelet-1.15.1、kubeadm-1.15.1、kubectl-1.15.1</p><pre class=" language-bash"><code class="language-bash">yum makecache fastyum <span class="token function">install</span> -y kubelet-1.15.1 kubeadm-1.15.1 kubectl-1.15.1</code></pre><p>从安装结果可以看出还安装了cri-tools, kubernetes-cni, socat三个依赖：</p><blockquote><ul><li>官方从Kubernetes 1.14开始将cni依赖升级到了0.7.5版本</li><li>socat是kubelet的依赖</li><li>cri-tools是CRI(Container Runtime Interface)容器运行时接口的命令行工具</li></ul></blockquote><p>由于kubelet需要和容器接口交互，启动我们的容器，而我们的k8s通过kubeadm安装出来以后都是以Pod的方式存在，也就是底层以容器的方式运行，所以kubelet一定要开机自启的，否则重启后我们k8s集群可能起不来。<br>三节点都执行</p><pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> kubelet.service</code></pre><p>初始化主节点k8s-master<br>使用 kubeadm config print init-defaults 可以打印集群初始化默认的使用的配置看一下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> <span class="token function">cd</span> /usr/local/install-k8s/core<span class="token punctuation">[</span>root@k8s-master core<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm config print init-defaults</span>apiVersion: kubeadm.k8s.io/v1beta2bootstrapTokens:- groups:  - system:bootstrappers:kubeadm:default-node-token  token: abcdef.0123456789abcdef  ttl: 24h0m0s  usages:  - signing  - authenticationkind: InitConfigurationlocalAPIEndpoint:  advertiseAddress: 1.2.3.4     <span class="token comment" spellcheck="true"># 默认为1.2.3.4修改为本机内网IP  192.168.1.85</span>  bindPort: 6443nodeRegistration:  criSocket: /var/run/dockershim.sock  name: k8s-master               taints:  - effect: NoSchedule    <span class="token comment" spellcheck="true"># master节点不负责pod的调度，也就是master节点不充当work节点的角色</span>    key: node-role.kubernetes.io/master---apiServer:  timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta2certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: <span class="token punctuation">{</span><span class="token punctuation">}</span>dns:  type: CoreDNSetcd:  local:    dataDir: /var/lib/etcdimageRepository: k8s.gcr.io      <span class="token comment" spellcheck="true"># 默认安装镜像组件拉取的镜像源仓库地址</span>kind: ClusterConfigurationkubernetesVersion: v1.16.0    <span class="token comment" spellcheck="true"># 注意：生成配置文件和我们要安装的k8s版本不同，需要为v1.15.1</span>networking:  dnsDomain: cluster.local  podSubnet: <span class="token string">"10.244.0.0/16"</span>      <span class="token comment" spellcheck="true"># 新增pod的网段,默认的配置文件是没有这个pod子网的，我们新增它，如果不新增，需要在初始化指定pod的子网段</span>  serviceSubnet: 10.96.0.0/12               <span class="token comment" spellcheck="true"># SVC的子网</span>scheduler: <span class="token punctuation">{</span><span class="token punctuation">}</span>---                                              <span class="token comment" spellcheck="true">#以下为新增修改为ipvs模式</span>apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: kubeProxyConfigurationfeatureGates:  SupportIPVSProxyMode: <span class="token boolean">true</span>mode: ipvs</code></pre><p>k8s-master1上执行，生成kubeadm初始化配置文件kubeadm-config.yaml</p><pre class=" language-bash"><code class="language-bash">kubeadm config print init-defaults <span class="token operator">></span> kubeadm-config.yaml</code></pre><p>使用上面生成配置文件在master节点上进行初始化，这个kubeadm-init.log日志记录着node节点加入集群中的方式，不过也可以通过命令找到这个加入集群方式的</p><pre class=" language-bash"><code class="language-bash">kubeadm init --config<span class="token operator">=</span>kubeadm-config.yaml --experimental-upload-certs <span class="token operator">|</span> <span class="token function">tee</span> kubeadm-init.log</code></pre><p>使用指定的yaml文件进行初始化安装，自动颁发证书(v1.13后支持)把所有的信息都写入到 kubeadm-init.log中，其中<strong style="color: red">–experimental-upload-certs </strong>这个参数在最新版中已经被弃用了，官方推荐使用 <strong>–upload-certs </strong>替代，<a href="https://v1-15.docs.kubernetes.io/docs/setup/release/notes/" target="_blank" rel="noopener">官方公告：</a>。</p><p>上面记录了完成的初始化输出的内容，根据输出的内容基本上可以看出手动初始化安装一个Kubernetes集群所需要的关键步骤。 其中有以下关键内容：</p><blockquote><ul><li>init：指定版本进行初始化操作</li><li>preflight：初始化前的检查和下载所需要的 Docker 镜像文件</li><li>kubelet-start：生成 kubelet 的配置文件 var/lib/kubelet/config.yaml，没有这个文件 kubelet 无法启动，所以初始化之前的 kubelet 实际上启动不会成功</li><li>certificates：生成 Kubernetes 使用的证书，存放在 /etc/kubernetes/pki 目录中</li><li>kubeconfig：生成 KubeConfig 文件，存放在 /etc/kubernetes 目录中，组件之间通信需要使用对应文件</li><li>control-plane：使用 /etc/kubernetes/manifest 目录下的 YAML 文件，安装 Master 组件</li><li>etcd：使用 /etc/kubernetes/manifest/etcd.yaml 安装 Etcd 服务</li><li>wait-control-plane：等待 control-plan 部署的 Master 组件启动</li><li>apiclient：检查 Master 组件服务状态。</li><li>uploadconfig：更新配置</li><li>kubelet：使用 configMap 配置 kubelet</li><li>patchnode：更新 CNI 信息到 Node 上，通过注释的方式记录</li><li>mark-control-plane：为当前节点打标签，打了角色 Master，和不可调度标签，这样默认就不会使用 Master 节点来运行 Pod</li><li>bootstrap-token：生成 token 记录下来，后边使用 kubeadm join 往集群中添加节点时会用到</li><li>addons：安装附加组件 CoreDNS 和 kube-proxy</li></ul></blockquote><p>初始化完成后需要的工作，还是k8s-master1节点上<br>在当前的用户(我用的root)的Home目录下创建.kube目录(这个目录中保存我们的连接配置，kubectl和kubeApi进行https通讯，所以有一些缓存需要保存以及一些认证文件)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$HOME</span>/.kube  </code></pre><p>拷贝集群管理员的配置文件到这个目录下</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token variable">$HOME</span>/.kube/config  </code></pre><p>授予权限(所有者 所有组授予当前的用户)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token variable">$HOME</span>/.kube/config        </code></pre><p>查看 k8s 节点状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node</span>NAME         STATUS     ROLES    AGE     VERSIONk8s-master   NotReady   master   7m46s   v1.15.1</code></pre><p>此时主节点状态为NotReady，因为我们k8s集群要求一个扁平化的网络存在，由于我们还没构建flanneld网络插件。<br>下载flannel yaml文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master root<span class="token punctuation">]</span> <span class="token function">cd</span> /usr/local/install-k8s/plugin/flannel<span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span> <span class="token function">wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>创建flannel</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl create -f kube-flannel.yml </span><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system # -n 命名空间  </span></code></pre><p>此时查看node状态应该为Ready状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node</span>NAME         STATUS   ROLES    AGE   VERSIONk8s-master   Ready    master   23m   v1.15.1</code></pre><p>查看一下集群状态，确认个组件都处于healthy状态：</p><pre class=" language-bash"><code class="language-bash">kubectl get cs<span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><p>获得 join命令参数方式有两种：<br>​    1 在我们上面kubeadm init初始化的那个kubeadm-init.log日志中也可以找到。</p><p>​    2 k8s-master 节点上执行下面命令。</p><pre class=" language-bash"><code class="language-bash">kubeadm token create --print-join-command</code></pre><p>在k8s-node1和k8s-node2上分别执行加入节点的命令：</p><pre class=" language-bash"><code class="language-bash">kubeadm <span class="token function">join</span> 192.168.1.85:6443 --token abcdef.0123456789abcdef \    --discovery-token-ca-cert-hash sha256:d3a817068b75095f3616f5dd029ee40960ab851a48162fc5e4a0808b8d786ad2 </code></pre><p>在k8s-master节点上查看：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n kube-system -o wide  # 可以在wide加入-w参数</span></code></pre><p>此时查看node节点应该有3个，但子节点状态为notReady，等待子节点的flannel初始化完成即可。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master flannel<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span></code></pre><p>*如果子节点执行加入主节点的命令报错的话，可以尝试执行kubeadm reset命令后重试</p><p>移除node节点以及之后的重新加入：</p><p>k8s-master节点上执行：</p><pre class=" language-bash"><code class="language-bash">kubectl delete node k8s-node2</code></pre><p>在k8s-node2节点上执行：</p><pre class=" language-bash"><code class="language-bash">kubeadm reset <span class="token function">ifconfig</span> cni0 downip <span class="token function">link</span> delete cni0<span class="token function">ifconfig</span> flannel.1 downip <span class="token function">link</span> delete flannel.1<span class="token function">rm</span> -rf /var/lib/cni/</code></pre><p>重新是node节点加入集群<br>如果我们忘记了Master节点的token，可以使用下面的命令来看：</p><pre class=" language-bash"><code class="language-bash">kubeadm token list<span class="token punctuation">[</span>root@k8s-master core<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm token list</span>TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION                                           EXTRA GROUPS5q91af.st35qitumttcwp7e   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-11-23T16:22:16+08:00   <span class="token operator">&lt;</span>none<span class="token operator">></span>                   Proxy <span class="token keyword">for</span> managing TTL <span class="token keyword">for</span> the kubeadm-certs secret   <span class="token operator">&lt;</span>none<span class="token operator">></span>abcdef.0123456789abcdef   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-11-24T14:22:16+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                system:bootstrappers:kubeadm:default-node-tokenuw6dfy.cye0w06s06dms8q8   4h          2019-11-25T17:59:15+08:00   authentication,signing   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                                system:bootstrapp</code></pre><p>默认情况下，token的有效期是24小时，如果token已经过期的话，可以使用以下命令重新生成：</p><pre class=" language-bash"><code class="language-bash">kubeadm token create</code></pre><p>如果你找不到–discovery-token-ca-cert-hash的值，可以使用以下命令生成：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master<span class="token punctuation">]</span> ~$ openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt <span class="token operator">|</span> openssl rsa -pubin -outform der 2<span class="token operator">></span>/dev/null <span class="token operator">|</span> openssl dgst -sha256 -hex <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.* //'</span>7845e6615fcae889eedd6fe55174d904ddd4d3ca5257f04c4438cc67cf06ba58</code></pre><p>除了上面通过两次命令找token和hash，也可以直接一次性执行如下命令来获取:</p><pre class=" language-bash"><code class="language-bash">kubeadm token create --print-join-command </code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> docker </tag>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7-yum安装lnmp环境</title>
      <link href="/2019/11/14/yum%E5%AE%89%E8%A3%85lnmp%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/11/14/yum%E5%AE%89%E8%A3%85lnmp%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="yum安装nginx-php-mysql，搭建lnmp环境"><a href="#yum安装nginx-php-mysql，搭建lnmp环境" class="headerlink" title="yum安装nginx\php\mysql，搭建lnmp环境"></a>yum安装nginx\php\mysql，搭建lnmp环境</h1><p>yum升级</p><pre class=" language-bash"><code class="language-bash">yum update</code></pre><p>yum安装nginx最新源</p><pre class=" language-basj"><code class="language-basj">yum localinstall http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmyum repolist enabled | grep "nginx*" </code></pre><p>安装nginx</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> nginx</code></pre><p>启动nginx</p><pre class=" language-bash"><code class="language-bash">systemctl  start  nginx</code></pre><p>检查开机自动是否设置成功</p><pre class=" language-bash"><code class="language-bash">systemctl list-dependencies <span class="token operator">|</span> <span class="token function">grep</span> nginx</code></pre><p>浏览器中输入公网ip,检测是否安装成功<br><a href="http://xxx.yyy.com" target="_blank" rel="noopener">http://xxx.yyy.com</a></p><h1 id="使用yum安装mysql5-7"><a href="#使用yum安装mysql5-7" class="headerlink" title="使用yum安装mysql5.7"></a>使用yum安装mysql5.7</h1><p>安装mysql源</p><pre class=" language-bash"><code class="language-bash">yum -y localinstall  http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpmyum repolist enabled <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"mysql.*-community.*"</span></code></pre><p>安装mysql</p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> mysql-community-server <span class="token function">install</span> mysql-community-devel</code></pre><p>启动mysql</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld start</code></pre><p>检查mysql启动是否正常</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld status 或者 <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> mysql</code></pre><p>设置mysqld服务开机自启动</p><pre class=" language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> mysqld.service</code></pre><p>检查mysqld开机自启动是否设置成功</p><pre class=" language-bash"><code class="language-bash">systemctl list-dependencies <span class="token operator">|</span> <span class="token function">grep</span> mysqld</code></pre><p>mysql5.7以后的争强了安全机制, 所以使用yum安装,启动会系统会自动生成一个随机的密码,修改mysql密码<br>查看mysql的随机密码</p><pre class=" language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">'temporary password'</span> /var/log/mysqld.log</code></pre><p>使用查询得到的随机密码在终端登录</p><pre class=" language-bash"><code class="language-bash">mysql -u root -p    更改密码<span class="token punctuation">(</span>mysql文档规定,密码必须包括大小写字母数字加特殊符号<span class="token operator">></span>8位<span class="token punctuation">)</span>ALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'Yourpassword'</span><span class="token punctuation">;</span>退出mysql客户端,用刚才修改的密码登录确保密码修改成功<span class="token keyword">exit</span><span class="token punctuation">;</span>mysql -u root -p  </code></pre><h1 id="安装php7-1"><a href="#安装php7-1" class="headerlink" title="安装php7.1"></a>安装php7.1</h1><p>安装php源</p><pre class=" language-bash"><code class="language-bash">rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</code></pre><p>检查源是否安装成功</p><pre class=" language-bash"><code class="language-bash">yum repolist enabled <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"webtatic*"</span></code></pre><p>安装php扩展源 </p><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> php71w php71w-fpmyum -y <span class="token function">install</span> php71w-mbstring php71w-common php71w-gd php71w-mcryptyum -y <span class="token function">install</span> php71w-mysql php71w-xml php71w-cli php71w-develyum -y <span class="token function">install</span> php71w-pecl-memcached php71w-pecl-redis php71w-opcache</code></pre><p>验证php7.1.x和扩展是否安装成功<br>验证php是否安装成功</p><pre class=" language-bash"><code class="language-bash">php -v</code></pre><p>验证对应的扩展是否安装成功</p><pre class=" language-bash"><code class="language-bash">php -m</code></pre><p>设置php-fpm并检测php-fpm的运行状态<br>启动php-fpm</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> php-fpm start</code></pre><p>检查启动是否成功<br>service php-fpm status<br>设置开机自启动<br>systemctl enable php-fpm.service<br>检查开机自启动是否设置成功</p><pre class=" language-bash"><code class="language-bash">systemctl list-dependencies <span class="token operator">|</span> <span class="token function">grep</span> php-fpm<span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> php-fpm</code></pre><p>nginx配置如下：</p><pre class=" language-bash"><code class="language-bash">server<span class="token punctuation">{</span>    listen       80<span class="token punctuation">;</span>    server_name  youserver<span class="token punctuation">;</span>    index index.html index.php<span class="token punctuation">;</span>    root /home/public<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#charset koi8-r;</span>    <span class="token comment" spellcheck="true">#access_log  logs/host.access.log  main;</span>    location / <span class="token punctuation">{</span>        index  index.html index.htm index.php<span class="token punctuation">;</span>        try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.php?<span class="token variable">$query_string</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    error_page  404              /404.html<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># redirect server error pages to the static page /50x.html</span>    <span class="token comment" spellcheck="true">#</span>    error_page   500 502 503 504  /50x.html<span class="token punctuation">;</span>    location <span class="token operator">=</span> /50x.html <span class="token punctuation">{</span>        root   html<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span>    <span class="token comment" spellcheck="true">#</span>    <span class="token comment" spellcheck="true">#location ~ .php$ {</span>    <span class="token comment" spellcheck="true">#    proxy_pass   http://127.0.0.1;</span>    <span class="token comment" spellcheck="true">#}</span>    <span class="token comment" spellcheck="true"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>    <span class="token comment" spellcheck="true">#</span>    location ~ .php$ <span class="token punctuation">{</span>        root           /home/public<span class="token punctuation">;</span>        fastcgi_pass   127.0.0.1:9000<span class="token punctuation">;</span>        fastcgi_index  index.php<span class="token punctuation">;</span>        fastcgi_param  SCRIPT_FILENAME  /home/public<span class="token variable">$fastcgi_script_name</span><span class="token punctuation">;</span>        include        fastcgi_params<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># deny access to .htaccess files, if Apache's document root</span>    <span class="token comment" spellcheck="true"># concurs with nginx's one</span>    <span class="token comment" spellcheck="true">#</span>    location ~ /.ht <span class="token punctuation">{</span>        deny  all<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> lnmp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes之阿里云部署</title>
      <link href="/2019/07/10/kubernetes%E4%B9%8B%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/07/10/kubernetes%E4%B9%8B%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>阿里云K8S高可用部署(我们需要准备六台阿里云的ECS,选择有公网IP的)</p><h1 id="二进制搭建k8s多master集群之第一篇-集群环境和各个组件功能介绍"><a href="#二进制搭建k8s多master集群之第一篇-集群环境和各个组件功能介绍" class="headerlink" title="二进制搭建k8s多master集群之第一篇(集群环境和各个组件功能介绍)"></a>二进制搭建k8s多master集群之第一篇(集群环境和各个组件功能介绍)</h1><p>规划如下：</p><pre class=" language-bash"><code class="language-bash">master01:172.24.150.85<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>  kube-apiserver  kube-conroller-manager etcd        flannel  dockermaster02:172.24.150.86<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>  kube-apiserver  kube-conroller-manager etcd        flannel     docker        master03:172.24.150.87<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>    kube-apiserver  kube-conroller-manager etcd        flannel     dockernode01:172.24.150.88<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>    kube-proxy  kubelet        flannel     dockernode02:172.24.150.89<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>    kube-proxy  kubelet        flannel     dockerhaproxyharbor:172.24.150.90<span class="token punctuation">(</span>内网<span class="token punctuation">)</span>        haproxy harbor</code></pre><h1 id="一-组件版本"><a href="#一-组件版本" class="headerlink" title="一     组件版本"></a>一     组件版本</h1><blockquote><ul><li>kubernetes 1.12.3</li><li>Docker 18.06.1-ce</li><li>Etcd 3.3.10<ul><li>Flanneld 0.10.0</li></ul></li><li>插件<ul><li>CoreDNS</li><li>Dashboard</li><li>Heapster(influxdb,grafana)</li><li>Metrics-Server</li><li>EFK(elasticsearch,fluentd,kibana)<ul><li>镜像仓库</li></ul></li><li>docker registry</li><li>harbor</li></ul></li></ul></blockquote><h1 id="二-主要配置策略"><a href="#二-主要配置策略" class="headerlink" title="二    主要配置策略"></a>二    主要配置策略</h1><p>kube-apiserver:<br>    &gt;    * 使用keepalived和haproxy实现3节点高可用;<br>    &gt;    * 关闭非安全端口8080和匿名访问;<br>    &gt;    * 在安全端口6443接收https请求；<br>    &gt;     * 严格的认证和授权策略(x509,token,RBAC)<br>    &gt;    * 开启bootstrap token认证，支持kubelet TLS bootstrapping;<br>    &gt;    * 使用https访问kubelet,etcd,加密通信；<br>kube-scheduler:<br>    &gt;    * 3节点高可用;<br>    &gt;    * 使用kubeconfig访问apiserver的安全端口;</p><p>kubelet:<br>    &gt;    * 使用kubeadm动态创建bootstrap token，而不是在apiserver中静态配置;<br>    &gt;    * 使用TLS bootstrap机制自动生成client和server证书，过期后自动轮转;<br>    &gt;    * 在KubeletConfiguration类型的JSON文件配置主要参数;<br>    &gt;    * 关闭只读端口，在安全端口10250接收https请求，对请求进行认证和授权，拒绝匿名访问和非授权访问;<br>    &gt;    * 使用kubeconfig访问apiserver的安全端口;<br>kube-proxy:<br>    &gt;    * 使用kubeconfig访问apiserver的安全端口;<br>    &gt;    * 在kubeProxyConfiguration类型的JSON文件配置主要参数;<br>    &gt;    * IPVS代理模式;<br>集群插件:<br>    &gt;    * DNS：使用功能、性能更好的coredns;<br>    &gt;    * Dashboard:支持登录认证<br>    &gt;    * Metric:heapster,metrics-server,使用https访问kubelet安全端口;<br>    &gt;    * Log:Elasticsearch,Fluend,Kibana;<br>    &gt;    * Registry镜像库：docker-registry,harbor;</p><h1 id="三-系统初始化"><a href="#三-系统初始化" class="headerlink" title="三    系统初始化"></a>三    系统初始化</h1><h2 id="1-主机名修改-5个节点都操作"><a href="#1-主机名修改-5个节点都操作" class="headerlink" title="1    主机名修改(5个节点都操作)"></a>1    主机名修改(5个节点都操作)</h2><p>例如：master01<br>hostnamectl set-hostname master01</p><h2 id="2-本地hosts解析-5个节点都操作-至于我为啥多加了etcd01-etcd02-etcd03，为啥etcd三节点集群中的命名而已"><a href="#2-本地hosts解析-5个节点都操作-至于我为啥多加了etcd01-etcd02-etcd03，为啥etcd三节点集群中的命名而已" class="headerlink" title="2    本地hosts解析(5个节点都操作)(至于我为啥多加了etcd01,etcd02,etcd03，为啥etcd三节点集群中的命名而已)"></a>2    本地hosts解析(5个节点都操作)(至于我为啥多加了etcd01,etcd02,etcd03，为啥etcd三节点集群中的命名而已)</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span> <span class="token function">cat</span> <span class="token operator">>></span>/etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF172.24.150.85  master01 etcd01172.24.150.86  master02 etcd02172.24.150.87  master03 etcd03172.24.150.88  node01172.24.150.89  node02172.24.150.90  haproxyhaborEOF</span></code></pre><h2 id="3-master01免密码登录其它节点-由于下面的很多操作都是单独在master01-192-168-1-145-上完成的-即设置master01免密登录其它节点"><a href="#3-master01免密码登录其它节点-由于下面的很多操作都是单独在master01-192-168-1-145-上完成的-即设置master01免密登录其它节点" class="headerlink" title="3    master01免密码登录其它节点(由于下面的很多操作都是单独在master01(192.168.1.145)上完成的,即设置master01免密登录其它节点)"></a>3    master01免密码登录其它节点(由于下面的很多操作都是单独在master01(192.168.1.145)上完成的,即设置master01免密登录其它节点)</h2><p>配置master01可以免密SSH登录其它节点，方便远程分发文件及执行命令</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-keygen -t rsa            #生成公钥和私钥，一路Enter键                        </span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@master01    #分发公钥到master01上，这里需要输入一次master01的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@master02    #分发公钥到master02上，这里需要输入一次master02的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@master03    #分发公钥到master03上，这里需要输入一次master03的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@node01        #分发公钥到node01上，这里需要输入一次node01的密码</span><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ssh-copy-id root@node02        #分发公钥到node02上，这里需要输入一次node02的密码</span></code></pre><h2 id="4-关闭防火墙firewall-5个节点都操作"><a href="#4-关闭防火墙firewall-5个节点都操作" class="headerlink" title="4    关闭防火墙firewall(5个节点都操作)"></a>4    关闭防火墙firewall(5个节点都操作)</h2><pre class=" language-bash"><code class="language-bash">    systemctl stop firewalld          （root权限）    systemctl disable firewalld         <span class="token punctuation">(</span>设置开启未启动模式 <span class="token punctuation">)</span>    iptables -P FORWARD ACCEPT         <span class="token punctuation">(</span>设置FORWARD链为接收模式,要对4表5链有了解哦！<span class="token punctuation">)</span></code></pre><h2 id="5-关闭swap分区"><a href="#5-关闭swap分区" class="headerlink" title="5    关闭swap分区"></a>5    关闭swap分区</h2><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token function">sed</span> -i <span class="token string">'/ swap / s/^\(.*\)$/#\1/g'</span> /etc/fstab <span class="token punctuation">(</span>不太明白哦<span class="token punctuation">)</span></code></pre><h2 id="6-关闭SELinux"><a href="#6-关闭SELinux" class="headerlink" title="6    关闭SELinux"></a>6    关闭SELinux</h2><pre class=" language-bash"><code class="language-bash">setenforce 0<span class="token function">grep</span> SELINUX /etc/selinux/configSELINUX<span class="token operator">=</span>disabled</code></pre><h2 id="7-加载内核模块"><a href="#7-加载内核模块" class="headerlink" title="7    加载内核模块"></a>7    加载内核模块</h2><pre class=" language-bash"><code class="language-bash">modprobe br-netfiltermodprobe ip_vs</code></pre><h2 id="8-设置系统参数"><a href="#8-设置系统参数" class="headerlink" title="8    设置系统参数"></a>8    设置系统参数</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> kubernetes.conf <span class="token operator">&lt;&lt;</span><span class="token string">EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0vm.overcommit_memory=1vm.panic_on_oom=0fs.inotify.max_user_watches=89100fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1net.netfilter.nf_conntrack_max=2310720EOF</span>使上面内容生效：sysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><p>tcp_tw_recycle和Kubernetes的NAT冲突，必须关闭,<br>关闭不适用的IPV6协议栈，防止触发docker BUG;</p><h2 id="9-检查系统内核和模块适不适合运行docker-centos系统"><a href="#9-检查系统内核和模块适不适合运行docker-centos系统" class="headerlink" title="9    检查系统内核和模块适不适合运行docker(centos系统)"></a>9    检查系统内核和模块适不适合运行docker(centos系统)</h2><pre class=" language-bash"><code class="language-bash">curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh <span class="token operator">></span> check-config.sh./check-config.sh</code></pre><h1 id="四-环境介绍"><a href="#四-环境介绍" class="headerlink" title="四    环境介绍"></a>四    环境介绍</h1><p>##############################<br>##############################<br>二进制搭建k8s多master集群之第二篇(使用TLS证书搭建etcd三节点高可用集群)<br>下面本文etcd集群才用三台centos7.5搭建完成。<br>etcd01(master01):     172.24.150.85<br>etcd02(master02):    172.24.150.86<br>etcd03(master03):     172.24.150.87</p><h2 id="一-创建CA证书和密钥"><a href="#一-创建CA证书和密钥" class="headerlink" title="一 创建CA证书和密钥"></a>一 创建CA证书和密钥</h2><p>k8s系统各组件间需要使用TLS证书对通信进行加密，本文档使用CloudFlare的PKI工具集<strong>cfssl</strong>来生成Certificate Authority(CA)证书和密钥文件，CA是自签名证书，用来签名后续创建的其它TLS证书。由于第一篇我们做了master01(etcd01)到master02(etcd02),master03(etcd03)的免密验证，因此下面步骤中我们只需要在master01上操作，然后把证书和工具命令拷贝到其它节点上就可以了，有些需要其它节点必须登录操作的，我会红色标记提醒的</p><h3 id="1-安装CFSSL-master01操作"><a href="#1-安装CFSSL-master01操作" class="headerlink" title="1 安装CFSSL(master01操作)"></a>1 安装CFSSL(master01操作)</h3><pre class=" language-bash"><code class="language-bash">curl -o /usr/local/bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64curl -o /usr/local/bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64<span class="token function">chmod</span> +x /usr/local/bin/cfssl*</code></pre><h3 id="2-创建CA配置文件"><a href="#2-创建CA配置文件" class="headerlink" title="2 创建CA配置文件"></a>2 创建CA配置文件</h3><p>先创建存放证书的目录<br>mkdir -p /etc/kubernetes/cert &amp;&amp; cd /etc/kubernetes/cert   (master01,master02,master03都需要操作一遍)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> ca-config.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "signing": {    "default": {      "expiry": "87600h"    },    "profiles": {      "kubernetes": {        "usages": [            "signing",            "key encipherment",            "server auth",            "client auth"        ],        "expiry": "87600h"      }    }  }}EOF</span>简要介绍：    ca-config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；     signing：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA<span class="token operator">=</span>TRUE；     server auth：表示 client 可以用该 CA 对 server 提供的证书进行验证；     client auth：表示 server 可以用该 CA 对 client 提供的证书进行验证；</code></pre><h3 id="3-创建CA证书签名请求"><a href="#3-创建CA证书签名请求" class="headerlink" title="3 创建CA证书签名请求"></a>3 创建CA证书签名请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> ca-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "kubernetes",  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span>简要介绍:    CN：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 <span class="token punctuation">(</span>User Name<span class="token punctuation">)</span>，浏览器使用该字段验证网站是否合法；    O：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 <span class="token punctuation">(</span>Group<span class="token punctuation">)</span>；    kube-apiserver 将提取的 User、Group 作为 RBAC 授权的用户标识；</code></pre><p>生成CA证书和私钥:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span>2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> generating a new CA key and certificate from CSR2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> generate received request2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> received CSR2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> generating key: rsa-20482019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> encoded CSR2019/07/07 10:53:30 <span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> signed certificate with serial number 605272635170936057386255196971681816888287295153<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</code></pre><h3 id="4-创建etcd证书签名请求文件"><a href="#4-创建etcd证书签名请求文件" class="headerlink" title="4 创建etcd证书签名请求文件"></a>4 创建etcd证书签名请求文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> etcd-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "etcd",  "hosts": [    "127.0.0.1",    "172.24.150.85",    "172.24.150.86",    "172.24.150.87"  ],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span>简要介绍：    hosts 字段指定授权使用该证书的 etcd 节点 IP 或域名列表，这里将 etcd 集群的三个节点 IP 都列在其中<span class="token punctuation">;</span></code></pre><p>生成CA证书和私钥：</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \    -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \    -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \    -profile<span class="token operator">=</span>kubernetes etcd-csr.json <span class="token operator">|</span> cfssljson -bare etcd</code></pre><h3 id="5-将-pem证书分发到其它两台etcd主机节点上即etcd02-master02-、-etcd03-master03"><a href="#5-将-pem证书分发到其它两台etcd主机节点上即etcd02-master02-、-etcd03-master03" class="headerlink" title="5 将*.pem证书分发到其它两台etcd主机节点上即etcd02(master02)、 etcd03(master03)"></a>5 将*.pem证书分发到其它两台etcd主机节点上即etcd02(master02)、 etcd03(master03)</h3><p>另外ca证书也要分发到node01，node02上，因为创建flanneld网络时要用到</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp *.pem master02:/etc/kubernetes/cert</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp *.pem master03:/etc/kubernetes/cert               </span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp ca.pem root@node01:/etc/kubernetes/cert </span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp ca.pem root@node02:/etc/kubernetes/cert </span></code></pre><p>etcd使用证书组件为：<br>    &gt;    * ca.pem<br>    &gt;    * etcd-key.pem<br>    &gt;    * etcd.pem    </p><h2 id="二-部署etcd三节点集群"><a href="#二-部署etcd三节点集群" class="headerlink" title="二 部署etcd三节点集群"></a>二 部署etcd三节点集群</h2><p>三个etcd节点都要安装etcd软件包(即：master01、master02、master03)</p><h3 id="1-三节点下载软件包"><a href="#1-三节点下载软件包" class="headerlink" title="1 三节点下载软件包"></a>1 三节点下载软件包</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/etcd-io/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">tar</span> zxf etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">cp</span>  etcd-v3.3.10-linux-amd64/etcd* /usr/local/bin</code></pre><h3 id="2-三节点都创建etcd数据库工作目录"><a href="#2-三节点都创建etcd数据库工作目录" class="headerlink" title="2 三节点都创建etcd数据库工作目录"></a>2 三节点都创建etcd数据库工作目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/lib/etcd</code></pre><h3 id="3-创建三节点的-systemd-unit-文件"><a href="#3-创建三节点的-systemd-unit-文件" class="headerlink" title="3 创建三节点的 systemd unit 文件"></a>3 创建三节点的 systemd unit 文件</h3><p>master01的systemd unit配置文件如下：<br>###############################  172.24.150.85    ################################</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/etcd.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/ExecStart=/usr/local/bin/etcd \  --name etcd01 \  --cert-file=/etc/kubernetes/cert/etcd.pem \  --key-file=/etc/kubernetes/cert/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/cert/etcd.pem \  --peer-key-file=/etc/kubernetes/cert/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --initial-advertise-peer-urls https://172.24.150.85:2380 \  --listen-peer-urls https://172.24.150.85:2380 \  --listen-client-urls https://172.24.150.85:2379,http://127.0.0.1:2379 \  --advertise-client-urls https://172.24.150.85:2379 \  --initial-cluster-token etcd-cluster-0 \  --initial-cluster etcd01=https://172.24.150.85:2380,etcd02=https://172.24.150.86:2380,etcd03=https://172.24.150.87:2380 \  --initial-cluster-state new \  --data-dir=/var/lib/etcdRestart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>###############################  172.24.150.86    ################################<br>master02的system unit配置文件如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/etcd.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/ExecStart=/usr/local/bin/etcd \  --name etcd02 \  --cert-file=/etc/kubernetes/cert/etcd.pem \  --key-file=/etc/kubernetes/cert/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/cert/etcd.pem \  --peer-key-file=/etc/kubernetes/cert/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --initial-advertise-peer-urls https://172.24.150.86:2380 \  --listen-peer-urls https://172.24.150.86:2380 \  --listen-client-urls https://172.24.150.86:2379,http://127.0.0.1:2379 \  --advertise-client-urls https://172.24.150.86:2379 \  --initial-cluster-token etcd-cluster-0 \  --initial-cluster etcd01=https://172.24.150.85:2380,etcd02=https://172.24.150.86:2380,etcd03=https://172.24.150.87:2380 \  --initial-cluster-state new \  --data-dir=/var/lib/etcdRestart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>###############################  172.24.150.87    ################################<br>master03的system unit配置文件如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/etcd.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.targetDocumentation=https://github.com/coreos[Service]Type=notifyWorkingDirectory=/var/lib/etcd/ExecStart=/usr/local/bin/etcd \  --name etcd03 \  --cert-file=/etc/kubernetes/cert/etcd.pem \  --key-file=/etc/kubernetes/cert/etcd-key.pem \  --peer-cert-file=/etc/kubernetes/cert/etcd.pem \  --peer-key-file=/etc/kubernetes/cert/etcd-key.pem \  --trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \  --initial-advertise-peer-urls https://172.24.150.87:2380 \  --listen-peer-urls https://172.24.150.87:2380 \  --listen-client-urls https://172.24.150.87:2379,http://127.0.0.1:2379 \  --advertise-client-urls https://172.24.150.87:2379 \  --initial-cluster-token etcd-cluster-0 \  --initial-cluster etcd01=https://172.24.150.85:2380,etcd02=https://172.24.150.86:2380,etcd03=https://172.24.150.87:2380 \  --initial-cluster-state new \  --data-dir=/var/lib/etcdRestart=on-failureRestartSec=5LimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>####################################################################################################<br>为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）； </p><p>创建etcd.pem 证书时使用的 etcd-csr.json 文件的 hosts 字段包含所有 etcd 节点的IP，否则证书校验会出错；<br>–initial-cluster-state 值为 new 时，–name 的参数值必须位于 –initial-cluster 列表中.</p><h3 id="4-最好三节点同时启动并且设置开机自启动-xshell工具，一个窗口连接3个主机"><a href="#4-最好三节点同时启动并且设置开机自启动-xshell工具，一个窗口连接3个主机" class="headerlink" title="4 最好三节点同时启动并且设置开机自启动(xshell工具，一个窗口连接3个主机)"></a>4 最好三节点同时启动并且设置开机自启动(xshell工具，一个窗口连接3个主机)</h3><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl start etcd.servicesystemctl <span class="token function">enable</span> etcd.service</code></pre><h3 id="5-查看etcd服务的状态信息"><a href="#5-查看etcd服务的状态信息" class="headerlink" title="5 查看etcd服务的状态信息"></a>5 查看etcd服务的状态信息</h3><pre class=" language-bash"><code class="language-bash">systemctl status etcd.service</code></pre><p>如果不是一起启动的话，最先启动的etcd进程会卡住一段时间，等待其它节点的etcd进程加入集群，为正常现象</p><h3 id="6-验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓"><a href="#6-验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓" class="headerlink" title="6 验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓"></a>6 验证etcd集群状态，以及查看leader，下面命令可以在任何一个etcd节点执行，同时执行也无所谓</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem cluster-health</span>member 2b7694970ad266e9 is healthy: got healthy result from https://172.24.150.86:2379member 2de7ad1771e372b4 is healthy: got healthy result from https://172.24.150.87:2379member cf6dea03cf608ee3 is healthy: got healthy result from https://172.24.150.85:2379cluster is healthy<span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem member list</span>2b7694970ad266e9: name<span class="token operator">=</span>etcd02 peerURLs<span class="token operator">=</span>https://172.24.150.86:2380 clientURLs<span class="token operator">=</span>https://172.24.150.86:2379 isLeader<span class="token operator">=</span>false2de7ad1771e372b4: name<span class="token operator">=</span>etcd03 peerURLs<span class="token operator">=</span>https://172.24.150.87:2380 clientURLs<span class="token operator">=</span>https://172.24.150.87:2379 isLeader<span class="token operator">=</span>falsecf6dea03cf608ee3: name<span class="token operator">=</span>etcd01 peerURLs<span class="token operator">=</span>https://172.24.150.85:2380 clientURLs<span class="token operator">=</span>https://172.24.150.85:2379 isLeader<span class="token operator">=</span>true</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master02 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem cluster-health</span>member 2b7694970ad266e9 is healthy: got healthy result from https://172.24.150.86:2379member 2de7ad1771e372b4 is healthy: got healthy result from https://172.24.150.87:2379member cf6dea03cf608ee3 is healthy: got healthy result from https://172.24.150.85:2379cluster is healthy<span class="token punctuation">[</span>root@master02 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem member list</span>2b7694970ad266e9: name<span class="token operator">=</span>etcd02 peerURLs<span class="token operator">=</span>https://172.24.150.86:2380 clientURLs<span class="token operator">=</span>https://172.24.150.86:2379 isLeader<span class="token operator">=</span>false2de7ad1771e372b4: name<span class="token operator">=</span>etcd03 peerURLs<span class="token operator">=</span>https://172.24.150.87:2380 clientURLs<span class="token operator">=</span>https://172.24.150.87:2379 isLeader<span class="token operator">=</span>falsecf6dea03cf608ee3: name<span class="token operator">=</span>etcd01 peerURLs<span class="token operator">=</span>https://172.24.150.85:2380 clientURLs<span class="token operator">=</span>https://172.24.150.85:2379 isLeader<span class="token operator">=</span>true<span class="token punctuation">[</span>root@master02 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master03 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem cluster-health</span>member 2b7694970ad266e9 is healthy: got healthy result from https://172.24.150.86:2379member 2de7ad1771e372b4 is healthy: got healthy result from https://172.24.150.87:2379member cf6dea03cf608ee3 is healthy: got healthy result from https://172.24.150.85:2379cluster is healthy<span class="token punctuation">[</span>root@master03 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem member list</span>2b7694970ad266e9: name<span class="token operator">=</span>etcd02 peerURLs<span class="token operator">=</span>https://172.24.150.86:2380 clientURLs<span class="token operator">=</span>https://172.24.150.86:2379 isLeader<span class="token operator">=</span>false2de7ad1771e372b4: name<span class="token operator">=</span>etcd03 peerURLs<span class="token operator">=</span>https://172.24.150.87:2380 clientURLs<span class="token operator">=</span>https://172.24.150.87:2379 isLeader<span class="token operator">=</span>falsecf6dea03cf608ee3: name<span class="token operator">=</span>etcd01 peerURLs<span class="token operator">=</span>https://172.24.150.85:2380 clientURLs<span class="token operator">=</span>https://172.24.150.85:2379 isLeader<span class="token operator">=</span>true</code></pre><p>到此ETCD TLS 3节点集群部署完成，下一篇是二进制搭建k8s三节点master高可用集群之第三篇配置flannel网络</p><p>上一篇我们已经搭建etcd高可用集群，这篇我们将搭建Flannel，目的使跨主机的docker能够相互通信，也是保障kubernetes集群的网络基础和保障，下面开始配置。</p><h1 id="生成Flannel网络TLS证书"><a href="#生成Flannel网络TLS证书" class="headerlink" title="生成Flannel网络TLS证书"></a>生成Flannel网络TLS证书</h1><p>在所有集群节点都安装Flannel,下面的操作就只演示master01上，其它节点重复执行即可。(证书就在master01上生成一次就行，然后分发)</p><h2 id="1-创建证书签名请求"><a href="#1-创建证书签名请求" class="headerlink" title="1    创建证书签名请求"></a>1    创建证书签名请求</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> flanneld-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "flanneld",  "hosts": [],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span></code></pre><p>该证书只会被kubectl当做client证书使用，所以hosts字段为空；</p><p>生成证书和私钥:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes flanneld-csr.json <span class="token operator">|</span> cfssljson -bare flanneld</code></pre><h2 id="2-将证书分发到所有集群节点-etc-kubernetes-cert-目录下"><a href="#2-将证书分发到所有集群节点-etc-kubernetes-cert-目录下" class="headerlink" title="2    将证书分发到所有集群节点/etc/kubernetes/cert/目录下"></a>2    将证书分发到所有集群节点/etc/kubernetes/cert/目录下</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@master02:/etc/kubernetes/cert/<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@master03:/etc/kubernetes/cert/<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@node01:/etc/kubernetes/cert/<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> <span class="token function">scp</span>  flanneld*.pem   root@node02:/etc/kubernetes/cert/</code></pre><h1 id="二-部署Flannel"><a href="#二-部署Flannel" class="headerlink" title="二    部署Flannel"></a>二    部署Flannel</h1><h2 id="1-下载Flannel-所有节点"><a href="#1-下载Flannel-所有节点" class="headerlink" title="1    下载Flannel(所有节点)"></a>1    下载Flannel(所有节点)</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/coreos/flannel/releases/download/v0.10.0/flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">tar</span> -xzvf flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">cp</span> <span class="token punctuation">{</span>flanneld,mk-docker-opts.sh<span class="token punctuation">}</span> /usr/local/bin</code></pre><h2 id="2-向etcd写入网段信息"><a href="#2-向etcd写入网段信息" class="headerlink" title="2 向etcd写入网段信息"></a>2 向etcd写入网段信息</h2><p>下面两条命令在etcd集群中任意一台上执行一次就行，也就是创建一个flannel网段供docker分配使用</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem mkdir /kubernetes/network</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem mk /kubernetes/network/config '{"Network":"172.30.0.0/16","SubnetLen":24,"Backend":{"Type":"vxlan"}}'</span></code></pre><p>第二条这么长是一个整命令哦，不要忘记了哦</p><h2 id="3-创建system-unit文件"><a href="#3-创建system-unit文件" class="headerlink" title="3 创建system unit文件"></a>3 创建system unit文件</h2><p>在master01创建好，然后不用做任何修改分发到master02,master03,node01,node02 上。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/systemd/system/flannel.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Flanneld overlay address etcd agentAfter=network.targetAfter=network-online.targetWants=network-online.targetAfter=etcd.serviceBefore=docker.service[Service]Type=notifyExecStart=/usr/local/bin/flanneld \  -etcd-cafile=/etc/kubernetes/cert/ca.pem \  -etcd-certfile=/etc/kubernetes/cert/flanneld.pem \  -etcd-keyfile=/etc/kubernetes/cert/flanneld-key.pem \  -etcd-endpoints=https://172.24.150.85:2379,https://172.24.150.86:2379,https://172.24.150.87:2379 \  -etcd-prefix=/kubernetes/networkExecStartPost=/usr/local/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/dockerRestart=on-failure[Install]WantedBy=multi-user.targetRequiredBy=docker.serviceEOF</span>简要介绍：    mk-docker-opts.sh 脚本将分配给 flanneld 的 Pod 子网网段信息写入到 /run/flannel/docker 文件中，后续 docker 启动时使用这个文件中参数值设置 docker0 网桥。    flanneld 使用系统缺省路由所在的接口和其它节点通信，对于有多个网络接口的机器（如，内网和公网），可以用 -iface<span class="token operator">=</span>enpxx 选项值指定通信接口。</code></pre><h2 id="4-启动所有节点开始启动flannel并且设置开启自启动"><a href="#4-启动所有节点开始启动flannel并且设置开启自启动" class="headerlink" title="4    启动所有节点开始启动flannel并且设置开启自启动"></a>4    启动所有节点开始启动flannel并且设置开启自启动</h2><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> flanneldsystemctl start flanneld</code></pre><h2 id="5-查看flannel分配的子网信息"><a href="#5-查看flannel分配的子网信息" class="headerlink" title="5    查看flannel分配的子网信息"></a>5    查看flannel分配的子网信息</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /run/flannel/docker </span>DOCKER_OPT_BIP<span class="token operator">=</span><span class="token string">"--bip=172.30.60.1/24"</span>DOCKER_OPT_IPMASQ<span class="token operator">=</span><span class="token string">"--ip-masq=true"</span>DOCKER_OPT_MTU<span class="token operator">=</span><span class="token string">"--mtu=1450"</span>DOCKER_NETWORK_OPTIONS<span class="token operator">=</span><span class="token string">" --bip=172.30.60.1/24 --ip-masq=true --mtu=1450"</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /run/flannel/subnet.env </span>FLANNEL_NETWORK<span class="token operator">=</span>172.30.0.0/16FLANNEL_SUBNET<span class="token operator">=</span>172.30.60.1/24FLANNEL_MTU<span class="token operator">=</span>1450FLANNEL_IPMASQ<span class="token operator">=</span>false</code></pre><p>/run/flannel/docker是flannel分配给docker的子网信息，/run/flannel/subnet.env包含了flannel整个大网段以及在此节点上的子网段</p><h2 id="6-查看flannel网络是否生效"><a href="#6-查看flannel网络是否生效" class="headerlink" title="6     查看flannel网络是否生效"></a>6     查看flannel网络是否生效</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:dc:05:69:5c  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.24.150.85  netmask 255.255.240.0  broadcast 172.24.159.255        ether 00:16:3e:01:36:6e  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 698491  bytes 207475857 <span class="token punctuation">(</span>197.8 MiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 631869  bytes 77810204 <span class="token punctuation">(</span>74.2 MiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0flannel.1: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1450        inet 172.30.60.0  netmask 255.255.255.255  broadcast 0.0.0.0        ether 32:1c:4c:05:4a:22  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets 2246  bytes 161117 <span class="token punctuation">(</span>157.3 KiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2246  bytes 161117 <span class="token punctuation">(</span>157.3 KiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>可以明显看到flannel1.1的网络信息，说明flannel网络已经正常。</p><h2 id="三-配置docker支持flannel网络"><a href="#三-配置docker支持flannel网络" class="headerlink" title="三     配置docker支持flannel网络"></a>三     配置docker支持flannel网络</h2><h3 id="1-所有节点-master01-03-node01-02-五个节点都安装docker-安装指定版本的docker就不介绍了"><a href="#1-所有节点-master01-03-node01-02-五个节点都安装docker-安装指定版本的docker就不介绍了" class="headerlink" title="1    所有节点(master01-03,node01-02)五个节点都安装docker,安装指定版本的docker就不介绍了"></a>1    所有节点(master01-03,node01-02)五个节点都安装docker,安装指定版本的docker就不介绍了</h3><h3 id="2-配置daocker支持flannel网络"><a href="#2-配置daocker支持flannel网络" class="headerlink" title="2    配置daocker支持flannel网络"></a>2    配置daocker支持flannel网络</h3><p>所有docker节点都操作,对5个节点默认的docker system unit配置文件进行修改</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span>     /usr/lib/systemd/system/docker.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Docker Application Container EngineDocumentation<span class="token operator">=</span>https://docs.docker.comAfter<span class="token operator">=</span>network-online.target firewalld.serviceWants<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notify<span class="token comment" spellcheck="true"># the default is not to use systemd for cgroups because the delegate issues still</span><span class="token comment" spellcheck="true"># exists and systemd currently does not support the cgroup feature set required</span><span class="token comment" spellcheck="true"># for containers run by docker</span>EnvironmentFile<span class="token operator">=</span>/run/flannel/dockerExecStart<span class="token operator">=</span>/usr/bin/dockerd <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>ExecReload<span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span><span class="token comment" spellcheck="true"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><span class="token comment" spellcheck="true"># in the kernel. We recommend using cgroups to do container-local accounting.</span>LimitNOFILE<span class="token operator">=</span>infinityLimitNPROC<span class="token operator">=</span>infinityLimitCORE<span class="token operator">=</span>infinity<span class="token comment" spellcheck="true"># Uncomment TasksMax if your systemd version supports it.</span><span class="token comment" spellcheck="true"># Only systemd 226 and above support this version.</span><span class="token comment" spellcheck="true">#TasksMax=infinity</span>TimeoutStartSec<span class="token operator">=</span>0<span class="token comment" spellcheck="true"># set delegate yes so that systemd does not reset the cgroups of docker containers</span>Delegate<span class="token operator">=</span>yes<span class="token comment" spellcheck="true"># kill only the docker process, not all processes in the cgroup</span>KillMode<span class="token operator">=</span>process<span class="token comment" spellcheck="true"># restart the docker process if it exits prematurely</span>Restart<span class="token operator">=</span>on-failureStartLimitBurst<span class="token operator">=</span>3StartLimitInterval<span class="token operator">=</span>60s<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target<span class="token comment" spellcheck="true">##主要修改配置文件以下两行:</span>EnvironmentFile<span class="token operator">=</span>/run/flannel/dockerExecStart<span class="token operator">=</span>/usr/bin/dockerd <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>这里两行不同而已</code></pre><h2 id="3-重启docker，是配置生效"><a href="#3-重启docker，是配置生效" class="headerlink" title="3    重启docker，是配置生效"></a>3    重启docker，是配置生效</h2><p>先看一下没有修改docker的system unit文件，重启前</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:dc:05:69:5c  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.24.150.85  netmask 255.255.240.0  broadcast 172.24.159.255        ether 00:16:3e:01:36:6e  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 806758  bytes 292970377 <span class="token punctuation">(</span>279.3 MiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 729328  bytes 88585438 <span class="token punctuation">(</span>84.4 MiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0flannel.1: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1450        inet 172.30.60.0  netmask 255.255.255.255  broadcast 0.0.0.0        ether 32:1c:4c:05:4a:22  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets 2914  bytes 195853 <span class="token punctuation">(</span>191.2 KiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2914  bytes 195853 <span class="token punctuation">(</span>191.2 KiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>#添加docker的system unit配置文件后，然后重启docker服务,ifconfig命令查看</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart docker</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ifconfig</span>docker0: flags<span class="token operator">=</span>4099<span class="token operator">&lt;</span>UP,BROADCAST,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.30.60.1  netmask 255.255.255.0  broadcast 172.30.60.255        ether 02:42:dc:05:69:5c  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 172.24.150.85  netmask 255.255.240.0  broadcast 172.24.159.255        ether 00:16:3e:01:36:6e  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 814217  bytes 293897650 <span class="token punctuation">(</span>280.2 MiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 736551  bytes 89555535 <span class="token punctuation">(</span>85.4 MiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0flannel.1: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1450        inet 172.30.60.0  netmask 255.255.255.255  broadcast 0.0.0.0        ether 32:1c:4c:05:4a:22  txqueuelen 0  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags<span class="token operator">=</span>73<span class="token operator">&lt;</span>UP,LOOPBACK,RUNNING<span class="token operator">></span>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  <span class="token punctuation">(</span>Local Loopback<span class="token punctuation">)</span>        RX packets 2993  bytes 200086 <span class="token punctuation">(</span>195.3 KiB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2993  bytes 200086 <span class="token punctuation">(</span>195.3 KiB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h2 id="4-查看dockers网络是否生效"><a href="#4-查看dockers网络是否生效" class="headerlink" title="4    查看dockers网络是否生效"></a>4    查看dockers网络是否生效</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动一个容器，查看容器分配的ip是否在flannel网络分配的网段内</span><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -itd --name ceshi centos</span>Unable to <span class="token function">find</span> image <span class="token string">'centos:latest'</span> locallylatest: Pulling from library/centos8ba884070f61: Pull complete Digest: sha256:a799dd8a2ded4a83484bbae769d97655392b3f86533ceb7dd96bbac929809f3cStatus: Downloaded newer image <span class="token keyword">for</span> centos:latestefbb88d013137b8014f3ca4c6a1f55b706fed2d4575c838b1a4b307c1d1e2508<span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' efbb88</span>172.30.60.2</code></pre><h2 id="5-查看所有集群主机的网络情况"><a href="#5-查看所有集群主机的网络情况" class="headerlink" title="5    查看所有集群主机的网络情况"></a>5    查看所有集群主机的网络情况</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 system<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># etcdctl --ca-file=/etc/kubernetes/cert/ca.pem --cert-file=/etc/kubernetes/cert/etcd.pem --key-file=/etc/kubernetes/cert/etcd-key.pem ls /kubernetes/network/subnets</span>/kubernetes/network/subnets/172.30.21.0-24/kubernetes/network/subnets/172.30.60.0-24/kubernetes/network/subnets/172.30.81.0-24/kubernetes/network/subnets/172.30.80.0-24/kubernetes/network/subnets/172.30.14.0-24</code></pre><p>从输出可以看出容器使用了172.30.0.0/24网络，属于flannel分配的网络段，到此集群网络配置完成</p><p>下一篇将部署二进制搭建k8s三节点master高可用集群之配置k8s master及高可用</p><p>二进制搭建k8s三节点master高可用集群之配置k8s master及高可用<br>k8s master集群部署如下：<br>master01:172.24.150.85<br>master02:172.24.150.86<br>master03:172.24.150.87<br>haproxyharbor:172.24.150.90 (kube-apiserver的前端SLB)</p><h1 id="一-配置kubernetes-master集群-3master节点"><a href="#一-配置kubernetes-master集群-3master节点" class="headerlink" title="一  配置kubernetes master集群(3master节点)"></a>一  配置kubernetes master集群(3master节点)</h1><p>kubernetes master 节点包含的组件：</p><blockquote><ul><li>kube-apiserver</li><li>kube-scheduler</li><li>kbue-controller-manager<br>目前这三个组件需要部署在同一台机器上(这句话不理解，难道是这三节点要么同时部署在master01,要么同时部署在master02,或master03上吗？难道不能kube-apiserver部署在master01,scheduler部署在master02,controller-manager部署在master03上吗？在或者两个组件部署在一个节点，另一个组件部署在其它两个节点任意节点上不可以吗？三个组件必须捆绑在一起吗？) </li><li>kube-scheduler,kube-controller-manager和kube-apiserver三者的功能紧密相关:</li><li>同时只能有一个kube-sheduler、kube-controller-manager进程处于工作状态，如果运行多个，则需要通过选举产生一个leader;</li></ul></blockquote><h2 id="部署kubectl命令工具"><a href="#部署kubectl命令工具" class="headerlink" title="部署kubectl命令工具"></a>部署kubectl命令工具</h2><p>kubectl 是 kubernetes 集群的命令行管理工具，本文档介绍安装和配置它的步骤。<br>kubectl 默认从 ~/.kube/config 文件读取 kube-apiserver 地址、证书、用户名等信息，如果没有配置，执行 kubectl 命令时可能会出错。<br> ~/.kube/config只需要部署一次，然后拷贝到其他的master。</p><h3 id="1-下载kubectl"><a href="#1-下载kubectl" class="headerlink" title="1    下载kubectl"></a>1    下载kubectl</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://dl.k8s.io/v1.12.3/kubernetes-server-linux-amd64.tar.gz<span class="token function">tar</span> -xzvf kubernetes-server-linux-amd64.tar.gz<span class="token function">cd</span> kubernetes/server/bin/<span class="token function">cp</span> kube-apiserver kubeadm kube-controller-manager kubectl kube-scheduler /usr/local/bin</code></pre><h3 id="2-创建请求证书"><a href="#2-创建请求证书" class="headerlink" title="2     创建请求证书"></a>2     创建请求证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> admin-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "admin",  "hosts": [],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "system:masters",      "OU": "yunwei"    }  ]}EOF</span>O 为 system:masters，kube-apiserver 收到该证书后将请求的 Group 设置为 system:masters；预定义的 ClusterRoleBinding cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予所有 API的权限；该证书只会被 kubectl 当做 client 证书使用，所以 hosts 字段为空；</code></pre><p>生成证书和私钥</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes admin-csr.json <span class="token operator">|</span> cfssljson -bare admin</code></pre><h3 id="3-创建-kube-config文件"><a href="#3-创建-kube-config文件" class="headerlink" title="3    创建~/.kube/config文件"></a>3    创建~/.kube/config文件</h3><pre class=" language-bash"><code class="language-bash">kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials admin \  --client-certificate<span class="token operator">=</span>admin.pem \  --client-key<span class="token operator">=</span>admin-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context kubernetes \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>admin \  --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context kubernetes --kubeconfig<span class="token operator">=</span>kubectl.kubeconfig</code></pre><h3 id="4-分发-kube-config文件"><a href="#4-分发-kube-config文件" class="headerlink" title="4    分发~/.kube/config文件"></a>4    分发~/.kube/config文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp kubectl.kubeconfig   ~/.kube/config</span><span class="token punctuation">[</span>root@k8s-master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp kubectl.kubeconfig   root@master02:~/.kube/config</span><span class="token punctuation">[</span>root@k8s-master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp kubectl.kubeconfig   root@master03:~/.kube/config</span></code></pre><h2 id="部署api-server"><a href="#部署api-server" class="headerlink" title="部署api-server"></a>部署api-server</h2><h3 id="1-创建kube-apiserver的证书签名请求"><a href="#1-创建kube-apiserver的证书签名请求" class="headerlink" title="1    创建kube-apiserver的证书签名请求"></a>1    创建kube-apiserver的证书签名请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master01<span class="token punctuation">]</span>cat <span class="token operator">></span> kubernetes-csr.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "CN": "kubernetes",  "hosts": [    "127.0.0.1",    "172.24.150.85",    "172.24.150.86",    "172.24.150.87",    "172.24.150.90",    "47.108.21.49",    "kubernetes",    "kubernetes.default",    "kubernetes.default.svc",    "kubernetes.default.svc.cluster",    "kubernetes.default.svc.cluster.local"  ],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "ST": "BeiJing",      "L": "BeiJing",      "O": "k8s",      "OU": "yunwei"    }  ]}EOF</span>hosts 字段指定授权使用该证书的 IP 或域名列表，这里列出了 VIP 、apiserver 节点 IP、kubernetes 服务 IP 和域名；域名最后字符不能是 .<span class="token punctuation">(</span>如不能为 kubernetes.default.svc.cluster.local.<span class="token punctuation">)</span>，否则解析时失败，提示： x509: cannot parse dnsName <span class="token string">"kubernetes.default.svc.cluster.local."</span>；如果使用非 cluster.local 域名，如 bqding.com，则需要修改域名列表中的最后两个域名为：kubernetes.default.svc.bqding、kubernetes.default.svc.bqding.com</code></pre><p>生成证书和私钥:</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes kubernetes-csr.json <span class="token operator">|</span> cfssljson -bare kubernetes</code></pre><h3 id="2-将生成的证书和私钥文件拷贝到master节点："><a href="#2-将生成的证书和私钥文件拷贝到master节点：" class="headerlink" title="2     将生成的证书和私钥文件拷贝到master节点："></a>2     将生成的证书和私钥文件拷贝到master节点：</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubernetes*.pem root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@k8s-master1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubernetes*.pem root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建加密配置文件"><a href="#3-创建加密配置文件" class="headerlink" title="3    创建加密配置文件"></a>3    创建加密配置文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat > encryption-config.yaml &lt;&lt;EOF</span>kind: EncryptionConfigapiVersion: v1resources:  - resources:      - secrets    providers:      - aescbc:          keys:            - name: key1              secret: <span class="token variable"><span class="token variable">$(</span><span class="token function">head</span> -c 32 /dev/urandom <span class="token operator">|</span> base64<span class="token variable">)</span></span>      - identity: <span class="token punctuation">{</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="4-分发加密配置文件到master节点"><a href="#4-分发加密配置文件到master节点" class="headerlink" title="4    分发加密配置文件到master节点"></a>4    分发加密配置文件到master节点</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp encryption-config.yaml  root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp encryption-config.yaml  root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="5-创建kube-apiserver-systemd-unit文件"><a href="#5-创建kube-apiserver-systemd-unit文件" class="headerlink" title="5    创建kube-apiserver systemd unit文件"></a>5    创建kube-apiserver systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/kube-apiserver.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-apiserver \  --enable-admission-plugins=Initializers,NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \  --anonymous-auth=false \  --experimental-encryption-provider-config=/etc/kubernetes/cert/encryption-config.yaml \  --advertise-address=172.24.150.85 \  --bind-address=172.24.150.85 \  --insecure-port=0 \  --authorization-mode=Node,RBAC \  --runtime-config=api/all \  --enable-bootstrap-token-auth \  --service-cluster-ip-range=10.254.0.0/16 \  --service-node-port-range=30000-38700 \  --tls-cert-file=/etc/kubernetes/cert/kubernetes.pem \  --tls-private-key-file=/etc/kubernetes/cert/kubernetes-key.pem \  --client-ca-file=/etc/kubernetes/cert/ca.pem \  --kubelet-client-certificate=/etc/kubernetes/cert/kubernetes.pem \  --kubelet-client-key=/etc/kubernetes/cert/kubernetes-key.pem \  --service-account-key-file=/etc/kubernetes/cert/ca-key.pem \  --etcd-cafile=/etc/kubernetes/cert/ca.pem \  --etcd-certfile=/etc/kubernetes/cert/kubernetes.pem \  --etcd-keyfile=/etc/kubernetes/cert/kubernetes-key.pem \  --etcd-servers=https://172.24.150.85:2379,https://172.24.150.86:2379,https://172.24.150.87:2379 \  --enable-swagger-ui=true \  --allow-privileged=true \  --apiserver-count=3 \  --audit-log-maxage=30 \  --audit-log-maxbackup=3 \  --audit-log-maxsize=100 \  --audit-log-path=/var/log/kube-apiserver-audit.log \  --event-ttl=1h \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5Type=notifyLimitNOFILE=65536[Install]WantedBy=multi-user.targeEOF</span>--experimental-encryption-provider-config：启用加密特性；--authorization-mode<span class="token operator">=</span>Node,RBAC： 开启 Node 和 RBAC 授权模式，拒绝未授权的请求；--enable-admission-plugins：启用 ServiceAccount 和 NodeRestriction；--service-account-key-file：签名 ServiceAccount Token 的公钥文件，kube-controller-manager 的 --service-account-private-key-file 指定私钥文件，两者配对使用；--tls-*-file：指定 apiserver 使用的证书、私钥和 CA 文件。--client-ca-file 用于验证 client <span class="token punctuation">(</span>kue-controller-manager、kube-scheduler、kubelet、kube-proxy 等<span class="token punctuation">)</span>请求所带的证书；--kubelet-client-certificate、--kubelet-client-key：如果指定，则使用 https 访问 kubelet APIs；需要为证书对应的用户<span class="token punctuation">(</span>上面 kubernetes*.pem 证书的用户为 kubernetes<span class="token punctuation">)</span> 用户定义 RBAC 规则，否则访问 kubelet API 时提示未授权；--bind-address： 不能为 127.0.0.1，否则外界不能访问它的安全端口 6443；--insecure-port<span class="token operator">=</span>0：关闭监听非安全端口<span class="token punctuation">(</span>8080<span class="token punctuation">)</span>；--service-cluster-ip-range： 指定 Service Cluster IP 地址段；--service-node-port-range： 指定 NodePort 的端口范围；--runtime-config<span class="token operator">=</span>api/all<span class="token operator">=</span>true： 启用所有版本的 APIs，如 autoscaling/v2alpha1；--enable-bootstrap-token-auth：启用 kubelet bootstrap 的 token 认证；--apiserver-count<span class="token operator">=</span>3：指定集群运行模式，多台 kube-apiserver 会通过 leader 选举产生一个工作节点，其它节点处于阻塞状态；</code></pre><h3 id="6-分发kube-apiserver-service文件到其它master"><a href="#6-分发kube-apiserver-service文件到其它master" class="headerlink" title="6 分发kube-apiserver.service文件到其它master"></a>6 分发kube-apiserver.service文件到其它master</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-apiserver.service root@master02:/etc/systemd/system/kube-apiserver.service</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-apiserver.service root@master03:/etc/systemd/system/kube-apiserver.service</span></code></pre><h3 id="7-创建日志目录"><a href="#7-创建日志目录" class="headerlink" title="7 创建日志目录"></a>7 创建日志目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/log/kubernetes/</code></pre><h3 id="8-启动api-server服务"><a href="#8-启动api-server服务" class="headerlink" title="8 启动api-server服务"></a>8 启动api-server服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl daemon-reload<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl <span class="token function">enable</span> kube-apiserver<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl start kube-apiserver</code></pre><h3 id="9-检查api-server和集群状态"><a href="#9-检查api-server和集群状态" class="headerlink" title="9    检查api-server和集群状态"></a>9    检查api-server和集群状态</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -ptln | grep kube-apiserve</span>tcp        0      0 192.168.80.9:6443       0.0.0.0:*               LISTEN      22348/kube-apiserve<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl cluster-info</span>Kubernetes master is running at https://172.24.150.90:6443To further debug and diagnose cluster problems, use <span class="token string">'kubectl cluster-info dump'</span><span class="token keyword">.</span></code></pre><h3 id="10-授予kubernetes证书访问kubelet-api权限"><a href="#10-授予kubernetes证书访问kubelet-api权限" class="headerlink" title="10    授予kubernetes证书访问kubelet api权限"></a>10    授予kubernetes证书访问kubelet api权限</h3><pre class=" language-bash"><code class="language-bash">kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole<span class="token operator">=</span>system:kubelet-api-admin --user kubernetes</code></pre><h2 id="三-部署kube-controller-manager"><a href="#三-部署kube-controller-manager" class="headerlink" title="三  部署kube-controller-manager"></a>三  部署kube-controller-manager</h2><p>该集群包含 3 个节点，启动后将通过竞争选举机制产生一个 leader 节点，其它节点为阻塞状态。当 leader 节点不可用后，剩余节点将再次进行选举产生新的 leader 节点，从而保证服务的可用性。<br>为保证通信安全，本文档先生成 x509 证书和私钥，kube-controller-manager 在如下两种情况下使用该证书：<br>与 kube-apiserver 的安全端口通信时;<br>在安全端口(https，10252) 输出 prometheus 格式的 metrics；</p><h3 id="1-创建kube-controller-manager证书请求"><a href="#1-创建kube-controller-manager证书请求" class="headerlink" title="1    创建kube-controller-manager证书请求"></a>1    创建kube-controller-manager证书请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>cat <span class="token operator">></span> kube-controller-manager-csr.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF{    "CN": "system:kube-controller-manager",    "key": {        "algo": "rsa",        "size": 2048    },    "hosts": [      "127.0.0.1",      "172.24.150.85",      "172.24.150.86",      "172.24.150.87"    ],    "names": [      {        "C": "CN",        "ST": "BeiJing",        "L": "BeiJing",        "O": "system:kube-controller-manager",        "OU": "yunwei"      }    ]}EOF</span>hosts 列表包含所有 kube-controller-manager 节点 IP；CN 为 system:kube-controller-manager、O 为 system:kube-controller-manager，kubernetes 内置的 ClusterRoleBindings system:kube-controller-manager 赋予 kube-controller-manager 工作所需的权限。</code></pre><p>生成证书和私钥：</p><pre class=" language-bash"><code class="language-bash">cfssl gencert -ca<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  -ca-key<span class="token operator">=</span>/etc/kubernetes/cert/ca-key.pem \  -config<span class="token operator">=</span>/etc/kubernetes/cert/ca-config.json \  -profile<span class="token operator">=</span>kubernetes kube-controller-manager-csr.json <span class="token operator">|</span> cfssljson -bare kube-controller-manager</code></pre><h3 id="2-将生成的证书和私钥分发到所有master节点"><a href="#2-将生成的证书和私钥分发到所有master节点" class="headerlink" title="2 将生成的证书和私钥分发到所有master节点"></a>2 将生成的证书和私钥分发到所有master节点</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager*.pem root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager*.pem root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建和分发kubeconfig文件"><a href="#3-创建和分发kubeconfig文件" class="headerlink" title="3 创建和分发kubeconfig文件"></a>3 创建和分发kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash">kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfigkubectl config set-credentials system:kube-controller-manager \  --client-certificate<span class="token operator">=</span>kube-controller-manager.pem \  --client-key<span class="token operator">=</span>kube-controller-manager-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfigkubectl config set-context system:kube-controller-manager \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>system:kube-controller-manager \  --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfigkubectl config use-context system:kube-controller-manager --kubeconfig<span class="token operator">=</span>kube-controller-manager.kubeconfig</code></pre><p>分发kube-controller-manager.kubeconfig到master02、master03节点</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager.kubeconfig root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-controller-manager.kubeconfig root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="4-创建和分发kube-controller-manager-systemd-unit文件"><a href="#4-创建和分发kube-controller-manager-systemd-unit文件" class="headerlink" title="4    创建和分发kube-controller-manager systemd unit文件"></a>4    创建和分发kube-controller-manager systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span>cat <span class="token operator">></span> /etc/systemd/system/kube-controller-manager.service  <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-controller-manager \  --address=127.0.0.1 \  --kubeconfig=/etc/kubernetes/cert/kube-controller-manager.kubeconfig \  --authentication-kubeconfig=/etc/kubernetes/cert/kube-controller-manager.kubeconfig \  --service-cluster-ip-range=10.254.0.0/16 \  --cluster-name=kubernetes \  --cluster-signing-cert-file=/etc/kubernetes/cert/ca.pem \  --cluster-signing-key-file=/etc/kubernetes/cert/ca-key.pem \  --experimental-cluster-signing-duration=8760h \  --root-ca-file=/etc/kubernetes/cert/ca.pem \  --service-account-private-key-file=/etc/kubernetes/cert/ca-key.pem \  --leader-elect=true \  --feature-gates=RotateKubeletServerCertificate=true \  --controllers=*,bootstrapsigner,tokencleaner \  --horizontal-pod-autoscaler-use-rest-clients=true \  --horizontal-pod-autoscaler-sync-period=10s \  --tls-cert-file=/etc/kubernetes/cert/kube-controller-manager.pem \  --tls-private-key-file=/etc/kubernetes/cert/kube-controller-manager-key.pem \  --use-service-account-credentials=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=onRestart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span>--address：指定监听的地址为127.0.0.1--kubeconfig：指定 kubeconfig 文件路径，kube-controller-manager 使用它连接和验证 kube-apiserver；--cluster-signing-*-file：签名 TLS Bootstrap 创建的证书；--experimental-cluster-signing-duration：指定 TLS Bootstrap 证书的有效期；--root-ca-file：放置到容器 ServiceAccount 中的 CA 证书，用来对 kube-apiserver 的证书进行校验；--service-account-private-key-file：签名 ServiceAccount 中 Token 的私钥文件，必须和 kube-apiserver 的 --service-account-key-file 指定的公钥文件配对使用；--service-cluster-ip-range ：指定 Service Cluster IP 网段，必须和 kube-apiserver 中的同名参数一致；--leader-elect<span class="token operator">=</span>true：集群运行模式，启用选举功能；被选为 leader 的节点负责处理工作，其它节点为阻塞状态；--feature-gates<span class="token operator">=</span>RotateKubeletServerCertificate<span class="token operator">=</span>true：开启 kublet server 证书的自动更新特性；--controllers<span class="token operator">=</span>*,bootstrapsigner,tokencleaner：启用的控制器列表，tokencleaner 用于自动清理过期的 Bootstrap token；--horizontal-pod-autoscaler-*：custom metrics 相关参数，支持 autoscaling/v2alpha1；--tls-cert-file、--tls-private-key-file：使用 https 输出 metrics 时使用的 Server 证书和秘钥；--use-service-account-credentials<span class="token operator">=</span>true:</code></pre><p>分发kube-controller-manager systemd unit文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-controller-manager.service root@master02:/etc/systemd/system/kube-controller-manager.service</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-controller-manager.service root@master03:/etc/systemd/system/kube-controller-manager.service</span></code></pre><h3 id="5-启动kube-controller-manager服务"><a href="#5-启动kube-controller-manager服务" class="headerlink" title="5    启动kube-controller-manager服务"></a>5    启动kube-controller-manager服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable kube-controller-manager &amp;&amp; systemctl start kube-controller-manager</span></code></pre><h3 id="6-检查kube-controller-manager服务"><a href="#6-检查kube-controller-manager服务" class="headerlink" title="6    检查kube-controller-manager服务"></a>6    检查kube-controller-manager服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lnpt|grep kube-controll</span>tcp        0      0 127.0.0.1:10252         0.0.0.0:*               LISTEN      17906/kube-controll tcp6       0      0 :::10257                :::*                    LISTEN      17906/kube-controll</code></pre><h3 id="7-查看当前kube-controller-manager的leader"><a href="#7-查看当前kube-controller-manager的leader" class="headerlink" title="7 查看当前kube-controller-manager的leader"></a>7 查看当前kube-controller-manager的leader</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  kubectl get endpoints kube-controller-manager --namespace=kube-system  -o yaml</span>apiVersion: v1kind: Endpointsmetadata:  annotations:    control-plane.alpha.kubernetes.io/leader: <span class="token string">'{"holderIdentity":"master03_318c0152-a096-11e9-a701-00163e0134cf","leaseDurationSeconds":15,"acquireTime":"2019-07-08T02:25:14Z","renewTime":"2019-07-09T14:40:23Z","leaderTransitions":1}'</span>  creationTimestamp: 2019-07-07T09:04:06Z  name: kube-controller-manager  namespace: kube-system  resourceVersion: <span class="token string">"248855"</span>  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-controller-manager  uid: 2caad7f6-a096-11e9-9fca-00163e0132fb</code></pre><p>当前leader为master03节点</p><h2 id="四-部署kube-scheduler"><a href="#四-部署kube-scheduler" class="headerlink" title="四    部署kube-scheduler"></a>四    部署kube-scheduler</h2><p>该集群包含 3 个节点，启动后将通过竞争选举机制产生一个 leader 节点，其它节点为阻塞状态。当 leader 节点不可用后，剩余节点将再次进行选举产生新的 leader 节点，从而保证服务的可用性。<br>为保证通信安全，本文档先生成 x509 证书和私钥，kube-scheduler 在如下两种情况下使用该证书：<br>1 与 kube-apiserver 的安全端口通信;<br>2 在安全端口(https，10251) 输出 prometheus 格式的 metrics；</p><h3 id="1-创建kube-scheduler证书请求"><a href="#1-创建kube-scheduler证书请求" class="headerlink" title="1 创建kube-scheduler证书请求"></a>1 创建kube-scheduler证书请求</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span>cat <span class="token operator">></span> kube-scheduler-csr.json <span class="token operator">&lt;&lt;</span> <span class="token string">EOF{    "CN": "system:kube-scheduler",    "hosts": [      "127.0.0.1",      "172.24.150.85",      "172.24.150.86",      "172.24.150.87"    ],    "key": {        "algo": "rsa",        "size": 2048    },    "names": [      {        "C": "CN",        "ST": "BeiJing",        "L": "BeiJing",        "O": "system:kube-scheduler",        "OU": "yunwei"      }    ]}EOF</span>hosts 列表包含所有 kube-scheduler 节点 IP；CN 为 system:kube-scheduler、O 为 system:kube-scheduler，kubernetes 内置的 ClusterRoleBindings system:kube-scheduler 将赋予 kube-scheduler 工作所需的权限。</code></pre><p>生成证书和私钥：<br>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem <br>  -ca-key=/etc/kubernetes/cert/ca-key.pem <br>  -config=/etc/kubernetes/cert/ca-config.json <br>  -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler</p><h3 id="2-创建和分发kube-scheduler-kubeconfig文件"><a href="#2-创建和分发kube-scheduler-kubeconfig文件" class="headerlink" title="2    创建和分发kube-scheduler.kubeconfig文件"></a>2    创建和分发kube-scheduler.kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config set-cluster kubernetes \      --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \      --embed-certs<span class="token operator">=</span>true \      --server<span class="token operator">=</span>https://172.24.150.90:6443 \      --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig<span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config set-credentials system:kube-scheduler \  --client-certificate<span class="token operator">=</span>kube-scheduler.pem \  --client-key<span class="token operator">=</span>kube-scheduler-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig<span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config set-context system:kube-scheduler \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>system:kube-scheduler \  --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig<span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span> kubectl config use-context system:kube-scheduler --kubeconfig<span class="token operator">=</span>kube-scheduler.kubeconfig上一步创建的证书、私钥以及 kube-apiserver 地址被写入到 kubeconfig 文件中；</code></pre><p>分发kubeconfig到master02、master03节点</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-scheduler.kubeconfig root@master02:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-scheduler.kubeconfig root@master03:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建和分发kube-scheduler-systemd-unit文件"><a href="#3-创建和分发kube-scheduler-systemd-unit文件" class="headerlink" title="3    创建和分发kube-scheduler systemd unit文件"></a>3    创建和分发kube-scheduler systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/kube-scheduler.service <span class="token operator">&lt;&lt;</span> <span class="token string">EOF[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/GoogleCloudPlatform/kubernetes[Service]ExecStart=/usr/local/bin/kube-scheduler \  --address=127.0.0.1 \  --kubeconfig=/etc/kubernetes/cert/kube-scheduler.kubeconfig \  --leader-elect=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span>--address：在 127.0.0.1:10251 端口接收 http /metrics 请求；kube-scheduler 目前还不支持接收 https 请求；--kubeconfig：指定 kubeconfig 文件路径，kube-scheduler 使用它连接和验证 kube-apiserver；--leader-elect<span class="token operator">=</span>true：集群运行模式，启用选举功能；被选为 leader 的节点负责处理工作，其它节点为阻塞状态；</code></pre><p>分发 systemd unit 文件到所有 master 节点：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-scheduler.service master02:/etc/systemd/system/kube-scheduler.service</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp /etc/systemd/system/kube-scheduler.service master03:/etc/systemd/system/kube-scheduler.service</span></code></pre><h3 id="4-启动kube-scheduler服务"><a href="#4-启动kube-scheduler服务" class="headerlink" title="4    启动kube-scheduler服务"></a>4    启动kube-scheduler服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl daemon-reload <span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span> systemctl <span class="token function">enable</span> kube-scheduler <span class="token operator">&amp;&amp;</span> systemctl start kube-scheduler</code></pre><h3 id="5-查看kube-scheduler运行监听端口"><a href="#5-查看kube-scheduler运行监听端口" class="headerlink" title="5    查看kube-scheduler运行监听端口"></a>5    查看kube-scheduler运行监听端口</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lnpt|grep kube-scheduler</span>tcp        0      0 127.0.0.1:10251         0.0.0.0:*               LISTEN      17921/kube-schedule</code></pre><h3 id="6-查看当前kube-scheduler的leader"><a href="#6-查看当前kube-scheduler的leader" class="headerlink" title="6    查看当前kube-scheduler的leader"></a>6    查看当前kube-scheduler的leader</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get endpoints kube-scheduler --namespace=kube-system  -o yaml</span>apiVersion: v1kind: Endpointsmetadata:  annotations:    control-plane.alpha.kubernetes.io/leader: <span class="token string">'{"holderIdentity":"master03_3e7bc3fc-a097-11e9-ba09-00163e0134cf","leaseDurationSeconds":15,"acquireTime":"2019-07-08T02:24:52Z","renewTime":"2019-07-09T14:51:37Z","leaderTransitions":1}'</span>  creationTimestamp: 2019-07-07T09:11:31Z  name: kube-scheduler  namespace: kube-system  resourceVersion: <span class="token string">"249869"</span>  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-scheduler  uid: 35b657c6-a097-11e9-8e39-00163e01366e</code></pre><p>可见当前的leader为master03节点</p><h2 id="七-在master01、master02、master03节点上验证功能是否正常"><a href="#七-在master01、master02、master03节点上验证功能是否正常" class="headerlink" title="七    在master01、master02、master03节点上验证功能是否正常"></a>七    在master01、master02、master03节点上验证功能是否正常</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   <span class="token punctuation">[</span>root@master02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get componentstatuses</span>NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   ok                  scheduler            Healthy   ok                  etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   <span class="token punctuation">[</span>root@master03 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs</span>NAME                 STATUS    MESSAGE             ERRORscheduler            Healthy   ok                  controller-manager   Healthy   ok                  etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><h2 id="八-haproxy做3master节点的高可用-未做keepalived的心跳检测"><a href="#八-haproxy做3master节点的高可用-未做keepalived的心跳检测" class="headerlink" title="八 haproxy做3master节点的高可用(未做keepalived的心跳检测)"></a>八 haproxy做3master节点的高可用(未做keepalived的心跳检测)</h2><p>haproxy 监听 haproxyharbor主机的6443端口，后端连接所有 kube-apiserver 实例，提供健康检查和负载均衡功能</p><h3 id="1-haproxyharbor主机安装haproxy"><a href="#1-haproxyharbor主机安装haproxy" class="headerlink" title="1     haproxyharbor主机安装haproxy"></a>1     haproxyharbor主机安装haproxy</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@haproxyharbor ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /etc/haproxy/ &amp;&amp; mv haproxy.cfg haproxy.cfg.bak &amp;&amp; cat >/etc/haproxy/haproxy.cfg &lt;&lt;EOF</span>global    log /dev/log    local0    log /dev/log    local1 notice    <span class="token function">chroot</span> /var/lib/haproxy    stats socket /var/run/haproxy-admin.sock mode 660 level admin    stats <span class="token function">timeout</span> 30s    user haproxy    group haproxy    daemon    nbproc 1defaults    log     global    <span class="token function">timeout</span> connect 5000    <span class="token function">timeout</span> client  10m    <span class="token function">timeout</span> server  10mlisten  admin_stats    bind 0.0.0.0:10080    mode http    log 127.0.0.1 local0 err    stats refresh 30s    stats uri /status    stats realm welcome login\ Haproxy    stats auth admin:123456    stats hide-version    stats admin <span class="token keyword">if</span> TRUElisten kube-master    bind 0.0.0.0:6443    mode tcp    option tcplog    balance roundrobin    server master01 172.24.150.85:6443 check inter 2000 fall 2 rise 2 weight 1    server master02 172.24.150.86:6443 check inter 2000 fall 2 rise 2 weight 1    server master03 172.24.150.87:6443 check inter 2000 fall 2 rise 2 weight 1EOFhaproxy 在 10080 端口输出 status 信息；haproxy 监听该主机上所有接口的 6443 端口，该端口与环境变量 <span class="token variable">${KUBE_APISERVER}</span> 指定的端口必须一致；server 字段列出所有 kube-apiserver 监听的 IP 和端口；</code></pre><h3 id="2-启动haproxy服务"><a href="#2-启动haproxy服务" class="headerlink" title="2    启动haproxy服务"></a>2    启动haproxy服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@haproxyharbor ~<span class="token punctuation">]</span> systemctl <span class="token function">enable</span> haproxy <span class="token operator">&amp;&amp;</span> systemctl start haproxy</code></pre><h3 id="3-查看haproxy的服务状态："><a href="#3-查看haproxy的服务状态：" class="headerlink" title="3    查看haproxy的服务状态："></a>3    查看haproxy的服务状态：</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@haproxyharbor ~<span class="token punctuation">]</span> systemctl status haproxy<span class="token operator">|</span><span class="token function">grep</span> Active</code></pre><p>###################################################################</p><h1 id="对node01、node02节点部署k8s-node服务"><a href="#对node01、node02节点部署k8s-node服务" class="headerlink" title="对node01、node02节点部署k8s node服务"></a>对node01、node02节点部署k8s node服务</h1><p>kubernetes work节点运行如下组件：docker、kubelet、kube-proxy、flannel</p><h2 id="一-安装依赖包-node01和node02都安装"><a href="#一-安装依赖包-node01和node02都安装" class="headerlink" title="一    安装依赖包(node01和node02都安装)"></a>一    安装依赖包(node01和node02都安装)</h2><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span>yum <span class="token function">install</span> -y epel-release <span class="token function">wget</span> conntrack ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token operator">&amp;&amp;</span> /usr/sbin/modprobe ip_vs<span class="token punctuation">[</span>root@node02 ~<span class="token punctuation">]</span>yum <span class="token function">install</span> -y epel-release <span class="token function">wget</span> conntrack ipvsadm ipset jq iptables curl sysstat libseccomp <span class="token operator">&amp;&amp;</span> /usr/sbin/modprobe ip_vs</code></pre><h2 id="二-部署kubelet组件"><a href="#二-部署kubelet组件" class="headerlink" title="二     部署kubelet组件"></a>二     部署kubelet组件</h2><p>kublet 运行在每个 worker 节点上，接收 kube-apiserver 发送的请求，管理 Pod 容器，执行交互式命令，如 exec、run、logs 等。<br>kublet 启动时自动向 kube-apiserver 注册节点信息，内置的 cadvisor 统计和监控节点的资源使用情况。<br>为确保安全，本文档只开启接收 https 请求的安全端口，对请求进行认证和授权，拒绝未授权的访问(如 apiserver、heapster)。</p><h3 id="1-下载和分发kubelet二进制文件"><a href="#1-下载和分发kubelet二进制文件" class="headerlink" title="1    下载和分发kubelet二进制文件"></a>1    下载和分发kubelet二进制文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">wget</span> https://dl.k8s.io/v1.12.3/kubernetes-server-linux-amd64.tar.gz<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">tar</span> -xzvf kubernetes-server-linux-amd64.tar.gz<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">cp</span> kubernetes/server/bin/<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">cp</span> kubelet kube-proxy /usr/local/bin<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">scp</span>  kubelet kube-proxy root@node01:/usr/local/bin<span class="token punctuation">[</span>root@master01 src<span class="token punctuation">]</span> <span class="token function">scp</span>  kubelet kube-proxy root@node02:/usr/local/bin</code></pre><h3 id="2-创建kubelet-bootstrap-kubeconfig文件-master01执行"><a href="#2-创建kubelet-bootstrap-kubeconfig文件-master01执行" class="headerlink" title="2    创建kubelet bootstrap kubeconfig文件(master01执行)"></a>2    创建kubelet bootstrap kubeconfig文件(master01执行)</h3><p>###################由于我是两个node(node01,node02)节点只需创建两个token就可以了##################################</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#创建 token</span><span class="token function">export</span> BOOTSTRAP_TOKEN<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>kubeadm token create \  --description kubelet-bootstrap-token \  --groups system:bootstrappers:master01 \  --kubeconfig ~/.kube/config<span class="token variable">)</span></span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># export BOOTSTRAP_TOKEN=$(kubeadm token create \</span><span class="token operator">></span>   --description kubelet-bootstrap-token \<span class="token operator">></span>   --groups system:bootstrappers:master01 \<span class="token operator">></span>   --kubeconfig ~/.kube/config<span class="token punctuation">)</span>I0709 20:02:07.166974   29695 version.go:93<span class="token punctuation">]</span> could not fetch a Kubernetes version from the internet: unable to get URL <span class="token string">"https://dl.k8s.io/release/stable-1.txt"</span><span class="token keyword">:</span> Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled <span class="token keyword">while</span> waiting <span class="token keyword">for</span> connection <span class="token punctuation">(</span>Client.Timeout exceeded <span class="token keyword">while</span> awaiting headers<span class="token punctuation">)</span>I0709 20:02:07.167046   29695 version.go:94<span class="token punctuation">]</span> falling back to the local client version: v1.12.3<span class="token comment" spellcheck="true">##暂时不用理会这继续往下执行  </span><span class="token comment" spellcheck="true"># 设置集群参数</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials kubelet-bootstrap \  --token<span class="token operator">=</span><span class="token variable">${BOOTSTRAP_TOKEN}</span> \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kubelet-bootstrap \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master01.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true">##########################################################################</span><span class="token comment" spellcheck="true">#创建 token</span><span class="token function">export</span> BOOTSTRAP_TOKEN<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>kubeadm token create \  --description kubelet-bootstrap-token \  --groups system:bootstrappers:master02 \  --kubeconfig ~/.kube/config<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 设置集群参数</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials kubelet-bootstrap \  --token<span class="token operator">=</span><span class="token variable">${BOOTSTRAP_TOKEN}</span> \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kubelet-bootstrap \  --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>kubelet-bootstrap-master02.kubeconfigkubelet-bootstrap-master0x.kubeconfig文件创建两次，分别为改成kubelet-bootstrap-master01.kubeconfig,kubelet-bootstrap-master02.kubeconfig证书中写入 Token 而非证书，证书后续由 controller-manager 创建。</code></pre><p>##########################################################################################<br>#创建 token</p><p>注意补充：</p><pre class=" language-bash"><code class="language-bash">使用kubeadm安装需要下载相关的镜像，可以使用以下命令查看<span class="token punctuation">[</span>root@master01 bin<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm config images list</span>I0707 19:23:47.877237   13023 version.go:93<span class="token punctuation">]</span> could not fetch a Kubernetes version from the internet: unable to get URL <span class="token string">"https://dl.k8s.io/release/stable-1.txt"</span><span class="token keyword">:</span> Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled <span class="token keyword">while</span> waiting <span class="token keyword">for</span> connection <span class="token punctuation">(</span>Client.Timeout exceeded <span class="token keyword">while</span> awaiting headers<span class="token punctuation">)</span>I0707 19:23:47.877324   13023 version.go:94<span class="token punctuation">]</span> falling back to the local client version: v1.12.3k8s.gcr.io/kube-apiserver:v1.12.3k8s.gcr.io/kube-controller-manager:v1.12.3k8s.gcr.io/kube-scheduler:v1.12.3k8s.gcr.io/kube-proxy:v1.12.3k8s.gcr.io/pause:3.1k8s.gcr.io/etcd:3.2.24k8s.gcr.io/coredns:1.2.2<span class="token comment" spellcheck="true"># 先在墙外的一台服务器上下载好需要的镜像，然后打tag标签，上传到自己的dockerhub上，再在墙内机器上下载，然后在反打回标签就可以了</span><span class="token punctuation">[</span>root@li1891-184 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker images</span>REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZEcntsp/kube-proxy                     v1.12.3             ab97fa69b926        7 months ago        96.5MBk8s.gcr.io/kube-proxy                v1.12.3             ab97fa69b926        7 months ago        96.5MBcntsp/kube-apiserver                 v1.12.3             6b54f7bebd72        7 months ago        194MBk8s.gcr.io/kube-apiserver            v1.12.3             6b54f7bebd72        7 months ago        194MBcntsp/kube-controller-manager        v1.12.3             c79022eb8bc9        7 months ago        164MBk8s.gcr.io/kube-controller-manager   v1.12.3             c79022eb8bc9        7 months ago        164MBcntsp/kube-scheduler                 v1.12.3             5e75513787b1        7 months ago        58.3MBk8s.gcr.io/kube-scheduler            v1.12.3             5e75513787b1        7 months ago        58.3MBcntsp/etcd                           3.2.24              3cab8e1b9802        9 months ago        220MBk8s.gcr.io/etcd                      3.2.24              3cab8e1b9802        9 months ago        220MBcntsp/coredns                        1.2.2               367cdc8433a4        10 months ago       39.2MBk8s.gcr.io/coredns                   1.2.2               367cdc8433a4        10 months ago       39.2MBcntsp/pause                          3.1                 da86e6ba6ca1        18 months ago       742kBk8s.gcr.io/pause                     3.1                 da86e6ba6ca1        18 months ago       742kBdocker tag cntsp/kube-proxy:v1.12.3  k8s.gcr.io/kube-proxy:v1.12.3docker tag cntsp/kube-apiserver:v1.12.3 k8s.gcr.io/kube-apiserver:v1.12.3docker tag cntsp/kube-controller-manager:v1.12.3 k8s.gcr.io/kube-controller-manager:v1.12.3docker tag cntsp/kube-scheduler:v1.12.3  k8s.gcr.io/kube-scheduler:v1.12.3docker tag cntsp/etcd:3.2.24  k8s.gcr.io/etcd:3.2.24docker tag cntsp/coredns:1.2.2  k8s.gcr.io/coredns:1.2.3docker tag cntsp/pause:3.1  k8s.gcr.io/pause:3.1</code></pre><h3 id="3-查看kubeadm为各个节点创建的token"><a href="#3-查看kubeadm为各个节点创建的token" class="headerlink" title="3    查看kubeadm为各个节点创建的token:"></a>3    查看kubeadm为各个节点创建的token:</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubeadm token list --kubeconfig ~/.kube/config</span>TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION               EXTRA GROUPS5hdpcv.oov1vb6p2pdsk9cj   19h         2019-07-10T20:02:07+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01    5la9kt.rg86oqup9lmh8mc3   20h         2019-07-10T20:54:04+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master03        <span class="token comment" spellcheck="true">##</span>7pmf04.7exbjzt4e0mqb1k6   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-07-08T19:14:17+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master018thsbu.kczv9cg4p18qc1uh   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-07-08T23:53:33+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01a2480e.fcpm6md4y3auhlbj   <span class="token operator">&lt;</span>invalid<span class="token operator">></span>   2019-07-08T18:01:24+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01broru2.ntzhoupwbokulsgy   20h         2019-07-10T20:50:56+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master01        <span class="token comment" spellcheck="true">##</span>ovf435.wx9o306i9sof1ztm   20h         2019-07-10T20:53:12+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:master02        <span class="token comment" spellcheck="true">##</span>创建的 token 有效期为 1 天，超期后将不能再被使用，且会被 kube-controller-manager 的 tokencleaner 清理<span class="token punctuation">(</span>如果启用该 controller 的话<span class="token punctuation">)</span>；kube-apiserver 接收 kubelet 的 bootstrap token 后，将请求的 user 设置为 system:bootstrap:，group 设置为 system:bootstrappers</code></pre><p>查看各token关联的Secret</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get secrets  -n kube-system</span>NAME                                             TYPE                                  DATA   AGEattachdetach-controller-token-pmwks              kubernetes.io/service-account-token   3      2d7hbootstrap-signer-token-fz6jp                     kubernetes.io/service-account-token   3      2d7hbootstrap-token-0a7w0g                           bootstrap.kubernetes.io/token         7      2d4hbootstrap-token-2w1i45                           bootstrap.kubernetes.io/token         7      2d6hbootstrap-token-2xbl5i                           bootstrap.kubernetes.io/token         7      6h28mbootstrap-token-5hdpcv                           bootstrap.kubernetes.io/token         7      4h36mbootstrap-token-5la9kt                           bootstrap.kubernetes.io/token         7      3h44mbootstrap-token-7pmf04                           bootstrap.kubernetes.io/token         7      2d5hbootstrap-token-8thsbu                           bootstrap.kubernetes.io/token         7      2dbootstrap-token-a2480e                           bootstrap.kubernetes.io/token         7      2d6hbootstrap-token-broru2                           bootstrap.kubernetes.io/token         7      3h47mbootstrap-token-bz7en0                           bootstrap.kubernetes.io/token         7      2d4hbootstrap-token-cssc84                           bootstrap.kubernetes.io/token         7      2d7hbootstrap-token-iau28s                           bootstrap.kubernetes.io/token         7      2d7hbootstrap-token-iufp5a                           bootstrap.kubernetes.io/token         7      2d4hbootstrap-token-ovf435                           bootstrap.kubernetes.io/token         7      3h45mbootstrap-token-tv8p15                           bootstrap.kubernetes.io/token         7      37hbootstrap-token-wj6vmg                           bootstrap.kubernetes.io/token         7      2d4hcertificate-controller-token-gh8qq               kubernetes.io/service-account-token   3      2d7hclusterrole-aggregation-controller-token-4nsb7   kubernetes.io/service-account-token   3      2d7hcronjob-controller-token-l95gw                   kubernetes.io/service-account-token   3      2d7hdaemon-set-controller-token-4d5wk                kubernetes.io/service-account-token   3      2d7hdefault-token-p5gvt                              kubernetes.io/service-account-token   3      2d7hdeployment-controller-token-jlnhh                kubernetes.io/service-account-token   3      2d7hdisruption-controller-token-xgt7n                kubernetes.io/service-account-token   3      2d7hendpoint-controller-token-jgr6r                  kubernetes.io/service-account-token   3      2d7hexpand-controller-token-lhbpc                    kubernetes.io/service-account-token   3      2d7hgeneric-garbage-collector-token-6t9mt            kubernetes.io/service-account-token   3      2d7hhorizontal-pod-autoscaler-token-f7zvp            kubernetes.io/service-account-token   3      2d7hjob-controller-token-5bq5b                       kubernetes.io/service-account-token   3      2d7hnamespace-controller-token-vcp7v                 kubernetes.io/service-account-token   3      2d7hnode-controller-token-kzjgc                      kubernetes.io/service-account-token   3      2d7hpersistent-volume-binder-token-2sz49             kubernetes.io/service-account-token   3      2d7hpod-garbage-collector-token-nw6ck                kubernetes.io/service-account-token   3      2d7hpv-protection-controller-token-jg9rq             kubernetes.io/service-account-token   3      2d7hpvc-protection-controller-token-bj5c7            kubernetes.io/service-account-token   3      2d7hreplicaset-controller-token-jv5r5                kubernetes.io/service-account-token   3      2d7hreplication-controller-token-5nfzh               kubernetes.io/service-account-token   3      2d7hresourcequota-controller-token-dpzk9             kubernetes.io/service-account-token   3      2d7hservice-account-controller-token-qxflv           kubernetes.io/service-account-token   3      2d7hservice-controller-token-8bhkb                   kubernetes.io/service-account-token   3      2d7hstatefulset-controller-token-sms2q               kubernetes.io/service-account-token   3      2d7htoken-cleaner-token-85hbw                        kubernetes.io/service-account-token   3      2d7httl-controller-token-zdwb4                       kubernetes.io/service-account-token   3      2d7h</code></pre><h3 id="4-分发bootstrap-kubeconfig文件"><a href="#4-分发bootstrap-kubeconfig文件" class="headerlink" title="4    分发bootstrap kubeconfig文件"></a>4    分发bootstrap kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubelet-bootstrap-master01.kubeconfig root@node01:/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig</span><span class="token punctuation">[</span>root@master1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kubelet-bootstrap-master02.kubeconfig root@node02:/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig</span></code></pre><h3 id="5-创建和分发kubelet参数配置文件"><a href="#5-创建和分发kubelet参数配置文件" class="headerlink" title="5    创建和分发kubelet参数配置文件"></a>5    创建和分发kubelet参数配置文件</h3><p>创建 kubelet 参数配置模板文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>cat <span class="token operator">></span> kubelet.config.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "kind": "KubeletConfiguration",  "apiVersion": "kubelet.config.k8s.io/v1beta1",  "authentication": {    "x509": {      "clientCAFile": "/etc/kubernetes/cert/ca.pem"    },    "webhook": {      "enabled": true,      "cacheTTL": "2m0s"    },    "anonymous": {      "enabled": false    }  },  "authorization": {    "mode": "Webhook",    "webhook": {      "cacheAuthorizedTTL": "5m0s",      "cacheUnauthorizedTTL": "30s"    }  },  "address": "172.24.150.88",  "port": 10250,  "readOnlyPort": 0,  "cgroupDriver": "cgroupfs",  "hairpinMode": "promiscuous-bridge",  "serializeImagePulls": false,  "featureGates": {    "RotateKubeletClientCertificate": true,    "RotateKubeletServerCertificate": true  },  "clusterDomain": "cluster.local.",  "clusterDNS": ["10.254.0.2"]}EOF</span>address：API 监听地址，不能为 127.0.0.1，否则 kube-apiserver、heapster 等不能调用 kubelet 的 API；readOnlyPort<span class="token operator">=</span>0：关闭只读端口<span class="token punctuation">(</span>默认 10255<span class="token punctuation">)</span>，等效为未指定；authentication.anonymous.enabled：设置为 false，不允许匿名?访问 10250 端口；authentication.x509.clientCAFile：指定签名客户端证书的 CA 证书，开启 HTTP 证书认证；authentication.webhook.enabled<span class="token operator">=</span>true：开启 HTTPs bearer token 认证；对于未通过 x509 证书和 webhook 认证的请求<span class="token punctuation">(</span>kube-apiserver 或其他客户端<span class="token punctuation">)</span>，将被拒绝，提示 Unauthorized；authroization.mode<span class="token operator">=</span>Webhook：kubelet 使用 SubjectAccessReview API 查询 kube-apiserver 某 user、group 是否具有操作资源的权限<span class="token punctuation">(</span>RBAC<span class="token punctuation">)</span>；featureGates.RotateKubeletClientCertificate、featureGates.RotateKubeletServerCertificate：自动 rotate 证书，证书的有效期取决于 kube-controller-manager 的 --experimental-cluster-signing-duration 参数；需要 root 账户运行；</code></pre><p>为node01、node02分发kubelet配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>scp kubelet.config.json root@node01:/etc/kubernetes/cert/kubelet.config.json<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span>scp kubelet.config.json root@node02:/etc/kubernetes/cert/kubelet.config.json</code></pre><h3 id="6-创建和分发kubelet-systemd-unit文件"><a href="#6-创建和分发kubelet-systemd-unit文件" class="headerlink" title="6     创建和分发kubelet systemd unit文件"></a>6     创建和分发kubelet systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/systemd/system/kubelet.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Kubernetes KubeletDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletExecStart=/usr/local/bin/kubelet \  --bootstrap-kubeconfig=/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig \  --cert-dir=/etc/kubernetes/cert \  --kubeconfig=/etc/kubernetes/cert/kubelet.kubeconfig \  --config=/etc/kubernetes/cert/kubelet.config.json \  --hostname-override=172.24.150.89 \  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1 \  --allow-privileged=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span>如果设置了 --hostname-override 选项，则 kube-proxy 也需要设置该选项，否则会出现找不到 Node 的情况；--bootstrap-kubeconfig：指向 bootstrap kubeconfig 文件，kubelet 使用该文件中的用户名和 token 向 kube-apiserver 发送 TLS Bootstrapping 请求；K8S approve kubelet 的 csr 请求后，在 --cert-dir 目录创建证书和私钥文件，然后写入 --kubeconfig 文件；</code></pre><h3 id="7-Bootstrap-Token-Auth和授予权限"><a href="#7-Bootstrap-Token-Auth和授予权限" class="headerlink" title="7    Bootstrap Token Auth和授予权限"></a>7    Bootstrap Token Auth和授予权限</h3><p>kublet 启动时查找配置的 –kubeletconfig 文件是否存在，如果不存在则使用 –bootstrap-kubeconfig 向 kube-apiserver 发送证书签名请求 (CSR)。<br>kube-apiserver 收到 CSR 请求后，对其中的 Token 进行认证（事先使用 kubeadm 创建的 token），认证通过后将请求的 user 设置为 system:bootstrap:，group 设置为 system:bootstrappers，这一过程称为 Bootstrap Token Auth。<br>默认情况下，这个 user 和 group 没有创建 CSR 的权限，kubelet 启动失败，错误日志如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> journalctl -u kubelet -a <span class="token operator">|</span><span class="token function">grep</span> -A 2 <span class="token string">'certificatesigningrequests'</span>july 06 06:42:36 kube-node1 kubelet<span class="token punctuation">[</span>26986<span class="token punctuation">]</span>: F0506 06:42:36.314378   26986 server.go:233<span class="token punctuation">]</span> failed to run Kubelet: cannot create certificate signing request: certificatesigningrequests.certificates.k8s.io is forbidden: User <span class="token string">"system:bootstrap:lemy40"</span> cannot create certificatesigningrequests.certificates.k8s.io at the cluster scopejuly 06 06:42:36 node01 systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: kubelet.service: Main process exited, code<span class="token operator">=</span>exited, status<span class="token operator">=</span>255/n/ajuly 06 06:42:36 node01 systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: kubelet.service: Failed with result <span class="token string">'exit-code'</span><span class="token keyword">.</span></code></pre><p>解决办法是：创建一个 clusterrolebinding，将 group system:bootstrappers 和 clusterrole system:node-bootstrapper 绑定：</p><pre class=" language-bash"><code class="language-bash">root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --group=system:bootstrappers</span></code></pre><h3 id="8-启动kubelet服务"><a href="#8-启动kubelet服务" class="headerlink" title="8    启动kubelet服务"></a>8    启动kubelet服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /var/log/kubernetes <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> -p /var/lib/kubeletsystemctl daemon-reload systemctl <span class="token function">enable</span> kubelet systemctl restart kubelet</code></pre><p>关闭 swap 分区，否则 kubelet 会启动失败；<br>必须先创建工作和日志目录；<br>kubelet 启动后使用 –bootstrap-kubeconfig 向 kube-apiserver 发送 CSR 请求，当这个 CSR 被 approve 后，kube-controller-manager 为 kubelet 创建 TLS 客户端证书、私钥和 –kubeletconfig 文件。<br>注意：kube-controller-manager 需要配置 –cluster-signing-cert-file 和 –cluster-signing-key-file 参数，才会为 TLS Bootstrap 创建证书和私钥。<br>两个 node 节点的 csr 均处于 pending 状态；<br>** 此时kubelet的进程有，但是监听端口还未启动，需要进行下面步骤！**</p><h3 id="9-approve-kubelet-csr请求"><a href="#9-approve-kubelet-csr请求" class="headerlink" title="9    approve kubelet csr请求"></a>9    approve kubelet csr请求</h3><p>可以手动或自动 approve CSR 请求,** 推荐使用自动的方式**，因为从 v1.8 版本开始，可以自动轮转approve csr 后生成的证书。<br>i、手动approve csr请求<br>查看 CSR 列表:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE   REQUESTOR                 CONDITIONnode-csr-P7XcQAc2yNlXn1pUmQFxXNCdGyyt8ccVuW3bmoUZiK4   30m   system:bootstrap:e7n0o5   Pendingnode-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM   79m   system:bootstrap:ydbwyk   Pendingnode-csr-u2sVzVkFYnMxPIYWjXHbqRJROtTZBYzA1s2vATPLzyo   30m   system:bootstrap:8w6j3n   Pendingapprove CSR <span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl certificate approve node-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM</span>certificatesigningrequest.certificates.k8s.io <span class="token string">"node-csr gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM"</span> approved</code></pre><p>查看 Approve 结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl describe csr node-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM</span>Name:               node-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAMLabels:             <span class="token operator">&lt;</span>none<span class="token operator">></span>Annotations:        <span class="token operator">&lt;</span>none<span class="token operator">></span>CreationTimestamp:  Thu, 20 Dec 2018 19:55:39 +0800Requesting User:    system:bootstrap:ydbwykStatus:             Approved,IssuedSubject:         Common Name:    system:node: 172.24.150.88         Serial Number:           Organization:   system:nodesEvents:  <span class="token operator">&lt;</span>none<span class="token operator">></span>Requesting User：请求 CSR 的用户，kube-apiserver 对它进行认证和授权；Subject：请求签名的证书信息；证书的 CN 是 system:node:192.168.80.10， Organization 是 system:nodes，kube-apiserver 的 Node 授权模式会授予该证书的相关权限；</code></pre><p>ii、自动approve csr请求<br>创建三个 ClusterRoleBinding，分别用于自动 approve client、renew client、renew server 证书：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat > csr-crb.yaml &lt;&lt;EOF</span> <span class="token comment" spellcheck="true"># Approve all CSRs for the group "system:bootstrappers"</span> kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: auto-approve-csrs-for-group subjects: - kind: Group   name: system:bootstrappers   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: system:certificates.k8s.io:certificatesigningrequests:nodeclient   apiGroup: rbac.authorization.k8s.io--- <span class="token comment" spellcheck="true"># To let a node of the group "system:nodes" renew its own credentials</span> kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: node-client-cert-renewal subjects: - kind: Group   name: system:nodes   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   apiGroup: rbac.authorization.k8s.io---<span class="token comment" spellcheck="true"># A ClusterRole which instructs the CSR approver to approve a node requesting a</span><span class="token comment" spellcheck="true"># serving cert matching its client cert.</span>kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  name: approve-node-server-renewal-csrrules:- apiGroups: <span class="token punctuation">[</span><span class="token string">"certificates.k8s.io"</span><span class="token punctuation">]</span>  resources: <span class="token punctuation">[</span><span class="token string">"certificatesigningrequests/selfnodeserver"</span><span class="token punctuation">]</span>  verbs: <span class="token punctuation">[</span><span class="token string">"create"</span><span class="token punctuation">]</span>--- <span class="token comment" spellcheck="true"># To let a node of the group "system:nodes" renew its own server credentials</span> kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata:   name: node-server-cert-renewal subjects: - kind: Group   name: system:nodes   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: approve-node-server-renewal-csr   apiGroup: rbac.authorization.k8s.ioEOFauto-approve-csrs-for-group：自动 approve node 的第一次 CSR； 注意第一次 CSR 时，请求的 Group 为 system:bootstrappers；node-client-cert-renewal：自动 approve node 后续过期的 client 证书，自动生成的证书 Group 为 system:nodes<span class="token punctuation">;</span>node-server-cert-renewal：自动 approve node 后续过期的 server 证书，自动生成的证书 Group 为 system:nodes<span class="token punctuation">;</span></code></pre><p>生效配置：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01<span class="token punctuation">]</span>kubectl apply -f csr-crb.yaml</code></pre><h3 id="10-查看kubelet情况"><a href="#10-查看kubelet情况" class="headerlink" title="10    查看kubelet情况"></a>10    查看kubelet情况</h3><p>等待一段时间(1-10 分钟)，两个节点的 CSR 都被自动 approve</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE   REQUESTOR                 CONDITIONnode-csr-P7XcQAc2yNlXn1pUmQFxXNCdGyyt8ccVuW3bmoUZiK4   35m   system:bootstrap:e7n0o5   Approved,Issuednode-csr-gD18nmcyPUNWNyDQvCo2BMYiiA4K59BNkclFRWv1SAM   84m   system:bootstrap:ydbwyk   Approved,Issued</code></pre><p>节点ready:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span>NAME            STATUS   ROLES    AGE     VERSION172.24.150.88   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   3h40m   v1.12.3172.24.150.89   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   3h39m   v1.12.3</code></pre><p>kube-controller-manager 为各 node 生成了 kubeconfig 文件和公私钥：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ll</span>total 52-rw------- 1 root root 1679 Jul  7 14:18 ca-key.pem-rw-r--r-- 1 root root 1359 Jul  7 14:18 ca.pem-rw------- 1 root root 1675 Jul  7 13:30 flanneld-key.pem-rw-r--r-- 1 root root 1391 Jul  7 13:30 flanneld.pem-rw------- 1 root root 2158 Jul  9 20:57 kubelet-bootstrap.kubeconfig-rw------- 1 root root 1273 Jul  9 21:17 kubelet-client-2019-07-09-21-17-43.pemlrwxrwxrwx 1 root root   59 Jul  9 21:17 kubelet-client-current.pem -<span class="token operator">></span> /etc/kubernetes/cert/kubelet-client-2019-07-09-21-17-43.pem-rw-r--r-- 1 root root  800 Jul  9 21:01 kubelet.config.json-rw-r--r-- 1 root root 2185 Jul  9 21:07 kubelet.crt-rw------- 1 root root 1679 Jul  9 21:07 kubelet.key-rw------- 1 root root 2298 Jul  9 21:17 kubelet.kubeconfig-rw-r--r-- 1 root root  321 Jul  9 21:36 kube-proxy.config.yaml-rw------- 1 root root 6273 Jul  9 21:28 kube-proxy.kubeconfigkubelet-server 证书会周期轮转；</code></pre><h2 id="三-部署kube-proxy组件"><a href="#三-部署kube-proxy组件" class="headerlink" title="三    部署kube-proxy组件"></a>三    部署kube-proxy组件</h2><p>kube-proxy 运行在所有 worker 节点上，，它监听 apiserver 中 service 和 Endpoint 的变化情况，创建路由规则来进行服务负载均衡。<br>本文档讲解部署 kube-proxy 的部署，使用 ipvs 模式。</p><h3 id="1-创建证书"><a href="#1-创建证书" class="headerlink" title="1    创建证书"></a>1    创建证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat > kube-proxy-csr.json &lt;&lt;EOF</span><span class="token punctuation">{</span>  <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"system:kube-proxy"</span>,  <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,    <span class="token string">"size"</span><span class="token keyword">:</span> 2048  <span class="token punctuation">}</span>,  <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,      <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"BeiJing"</span>,      <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"BeiJing"</span>,      <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,      <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"yunwei"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFCN：指定该证书的 User 为 system:kube-proxy；预定义的 RoleBinding system:node-proxier 将User system:kube-proxy 与 Role system:node-proxier 绑定，该 Role 授予了调用 kube-apiserver Proxy 相关 API 的权限；该证书只会被 kube-proxy 当做 client 证书使用，所以 hosts 字段为空；</code></pre><h3 id="2-创建和分发kubeconfig文件"><a href="#2-创建和分发kubeconfig文件" class="headerlink" title="2    创建和分发kubeconfig文件"></a>2    创建和分发kubeconfig文件</h3><pre class=" language-bash"><code class="language-bash">root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config set-cluster kubernetes \</span>  --certificate-authority<span class="token operator">=</span>/etc/kubernetes/cert/ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span>https://172.24.150.90:6443 \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config set-credentials kube-proxy \</span>  --client-certificate<span class="token operator">=</span>kube-proxy.pem \  --client-key<span class="token operator">=</span>kube-proxy-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config set-context default \</span>  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kube-proxy \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig<span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span>--embed-certs<span class="token operator">=</span>true：将 ca.pem 和 admin.pem 证书内容嵌入到生成的 kubectl-proxy.kubeconfig 文件中<span class="token punctuation">(</span>不加时，写入的是证书文件路径<span class="token punctuation">)</span>；</code></pre><p>分发kubeconfig文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-proxy.kubeconfig root@node01:/etc/kubernetes/cert/</span><span class="token punctuation">[</span>root@master01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># scp kube-proxy.kubeconfig root@node02:/etc/kubernetes/cert/</span></code></pre><h3 id="3-创建kube-proxy配置文件"><a href="#3-创建kube-proxy配置文件" class="headerlink" title="3    创建kube-proxy配置文件"></a>3    创建kube-proxy配置文件</h3><p>从 v1.10 开始，kube-proxy 部分参数可以配置文件中配置。可以使用 –write-config-to 选项生成该配置文件，或者参考 kubeproxyconfig 的类型定义源文件 ：<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/apis/kubeproxyconfig/types.go" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/apis/kubeproxyconfig/types.go</a><br>创建 kube-proxy config 文件模板：</p><p>[root@master01 cert]# cat &gt;kube-proxy.config.yaml &lt;&lt;EOF<br>apiVersion: kubeproxy.config.k8s.io/v1alpha1<br>bindAddress: 172.24.150.88<br>clientConnection:<br>  kubeconfig: /etc/kubernetes/cert/kube-proxy.kubeconfig<br>clusterCIDR: 172.30.0.0/16<br>healthzBindAddress: 172.24.150.88:10256<br>hostnameOverride: k8s-node1<br>kind: KubeProxyConfiguration<br>metricsBindAddress: 172.24.150.88:10249<br>mode: “ipvs”<br>EOF<br>bindAddress: 监听地址；<br>clientConnection.kubeconfig: 连接 apiserver 的 kubeconfig 文件；<br>clusterCIDR: kube-proxy 根据 –cluster-cidr 判断集群内部和外部流量，指定 –cluster-cidr 或 –masquerade-all选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT；<br>hostnameOverride: 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 ipvs 规则；<br>mode: 使用 ipvs 模式；<br>其中clusterc idr为flannel网络地址。</p><p>文件格式问题，注意参考格式见下<br>[root@kmaster01 kubernetes]# cat /etc/kubernetes/kube-proxy.config.yaml<br>apiVersion: kubeproxy.config.k8s.io/v1alpha1<br>bindAddress: 172.24.150.88<br>clientConnection:<br>  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig<br>clusterCIDR: 172.30.0.0/16<br>healthzBindAddress: 172.24.150.88:10256<br>hostnameOverride: k8s-master1<br>kind: KubeProxyConfiguration<br>metricsBindAddress: 172.24.150.88:10249<br>mode: “ipvs”<br>[root@k8s-master1 kubernetes]#<br>kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig     ## 注意这个前面的空格，没有就会报下面的错误：</p><p>Jul 06 00:35:13 node01 kube-proxy[25540]: I0706 00:35:13.307740   25540 server.go:412] Neither kubeconfig file nor master URL was specified. Falling back to in-cluster config.<br>Jul 06 00:35:13 node01 kube-proxy[25540]: F0706 00:35:13.307780   25540 server.go:360] unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined</p><pre><code>为各节点创建和分发 kube-proxy 配置文件：```bash[root@master01 cert]# scp kube-proxy.config.yaml root@node01:/etc/kubernetes/cert/[root@master01 cert]# scp kube-proxy.config.yaml root@node02:/etc/kubernetes/cert/</code></pre><h3 id="4-在node01和node02上分别创建-kube-proxy-systemd-unit文件"><a href="#4-在node01和node02上分别创建-kube-proxy-systemd-unit文件" class="headerlink" title="4    在node01和node02上分别创建 kube-proxy systemd unit文件"></a>4    在node01和node02上分别创建 kube-proxy systemd unit文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat >/etc/systemd/system/kube-proxy.service &lt;&lt;EOF</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes Kube-Proxy ServerDocumentation<span class="token operator">=</span>https://github.com/GoogleCloudPlatform/kubernetesAfter<span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>WorkingDirectory<span class="token operator">=</span>/var/lib/kube-proxyExecStart<span class="token operator">=</span>/usr/local/bin/kube-proxy \  --config<span class="token operator">=</span>/etc/kubernetes/cert/kube-proxy.config.yaml \  --alsologtostderr<span class="token operator">=</span>true \  --logtostderr<span class="token operator">=</span>false \  --log-dir<span class="token operator">=</span>/var/lib/kube-proxy/log \  --v<span class="token operator">=</span>2Restart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>5LimitNOFILE<span class="token operator">=</span>65536<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF<span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat >/etc/systemd/system/kube-proxy.service &lt;&lt;EOF</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes Kube-Proxy ServerDocumentation<span class="token operator">=</span>https://github.com/GoogleCloudPlatform/kubernetesAfter<span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>WorkingDirectory<span class="token operator">=</span>/var/lib/kube-proxyExecStart<span class="token operator">=</span>/usr/local/bin/kube-proxy \  --config<span class="token operator">=</span>/etc/kubernetes/cert/kube-proxy.config.yaml \  --alsologtostderr<span class="token operator">=</span>true \  --logtostderr<span class="token operator">=</span>false \  --log-dir<span class="token operator">=</span>/var/lib/kube-proxy/log \  --v<span class="token operator">=</span>2Restart<span class="token operator">=</span>on-failureRestartSec<span class="token operator">=</span>5LimitNOFILE<span class="token operator">=</span>65536<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.targetEOF</code></pre><h3 id="5-启动kube-proxy服务"><a href="#5-启动kube-proxy服务" class="headerlink" title="5    启动kube-proxy服务"></a>5    启动kube-proxy服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p /var/lib/kube-proxy/log</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable kube-proxy</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart kube-proxy</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p /var/lib/kube-proxy/log</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl daemon-reload</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable kube-proxy</span><span class="token punctuation">[</span>root@node02 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart kube-proxy</span></code></pre><p>必须先创建工作和日志目录；</p><h3 id="6-检查启动结果-node01和node02上"><a href="#6-检查启动结果-node01和node02上" class="headerlink" title="6    检查启动结果(node01和node02上)"></a>6    检查启动结果(node01和node02上)</h3><pre class=" language-bash"><code class="language-bash">systemctl status kube-proxy<span class="token operator">|</span><span class="token function">grep</span> Active确保状态为 active <span class="token punctuation">(</span>running<span class="token punctuation">)</span>，否则查看日志，确认原因：journalctl -u kube-proxy</code></pre><p>查看监听端口状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node1 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lnpt|grep kube-proxy</span>tcp        0      0  172.24.150.88:10256     0.0.0.0:*               LISTEN      9617/kube-proxy     tcp        0      0  172.24.150.88:10249     0.0.0.0:*               LISTEN      9617/kube-proxy10249：http prometheus metrics port<span class="token punctuation">;</span>10256：http healthz port<span class="token punctuation">;</span></code></pre><h3 id="7-查看ipvs路由规则"><a href="#7-查看ipvs路由规则" class="headerlink" title="7 查看ipvs路由规则"></a>7 查看ipvs路由规则</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install ipvsadm</span><span class="token punctuation">[</span>root@node01 cert<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#ipvsadm -ln</span>IP Virtual Server version 1.2.1 <span class="token punctuation">(</span>size<span class="token operator">=</span>4096<span class="token punctuation">)</span>Prot LocalAddress:Port Scheduler Flags  -<span class="token operator">></span> RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.254.0.1:443 rr  -<span class="token operator">></span>  172.24.150.85:6443            Masq    1      0          0           -<span class="token operator">></span>  172.24.150.86:6443            Masq    1      0          0           -<span class="token operator">></span>  172.24.150.87:6443            Masq    1      0          0 可见将所有到 kubernetes cluster ip 443 端口的请求都转发到 kube-apiserver 的 6443 端口。至此node节点部署完成。</code></pre><h2 id="四-验证集群功能"><a href="#四-验证集群功能" class="headerlink" title="四 验证集群功能"></a>四 验证集群功能</h2><h3 id="1-查看节点状况"><a href="#1-查看节点状况" class="headerlink" title="1    查看节点状况"></a>1    查看节点状况</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span>NAME            STATUS   ROLES    AGE   VERSION172.24.150.88   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   13h   v1.12.3172.24.150.89   Ready    <span class="token operator">&lt;</span>none<span class="token operator">></span>   13h   v1.12.3</code></pre><h3 id="2-创建nginx-web测试文件"><a href="#2-创建nginx-web测试文件" class="headerlink" title="2    创建nginx web测试文件"></a>2    创建nginx web测试文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat >nginx-web.yml&lt;&lt;EOF </span>apiVersion: v1kind: Servicemetadata:  name: nginx-web  labels:    tier: frontendspec:  type: NodePort  selector:    tier: frontend  ports:  - name: http    port: 80    targetPort: 80---apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: nginx-con  labels:    tier: frontendspec:  replicas: 3  template:    metadata:      labels:        tier: frontend    spec:      containers:      - name: nginx-pod        image: nginx        ports:        - containerPort: 80EOF</code></pre><p>执行nginx-web.yaml文件:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl create -f nginx-web.yml</span></code></pre><h3 id="3-查看各个Node上Pod-IP的连通性"><a href="#3-查看各个Node上Pod-IP的连通性" class="headerlink" title="3    查看各个Node上Pod IP的连通性"></a>3    查看各个Node上Pod IP的连通性</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  kubectl get pod -o wide</span>NAME                         READY   STATUS    RESTARTS   AGE   IP            NODE            NOMINATED NODEnginx-con-594b8d6b48-46gf7   1/1     Running   0          12h   172.30.21.2   172.24.150.88   <span class="token operator">&lt;</span>none<span class="token operator">></span>nginx-con-594b8d6b48-9t2xt   1/1     Running   0          12h   172.30.14.2   172.24.150.89   <span class="token operator">&lt;</span>none<span class="token operator">></span>nginx-con-594b8d6b48-vt589   1/1     Running   1          12h   172.30.21.3   172.24.150.88   <span class="token operator">&lt;</span>none<span class="token operator">></span>可见，nginx 的 Pod IP 分别是 172.30.21.2、172.30.14.2、172.30.21.2，在node01、node02 上分别 <span class="token function">ping</span> 这三个 IP，看是否连通：<span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ping  172.30.21.3</span>PING 172.30.21.3 <span class="token punctuation">(</span>172.30.21.3<span class="token punctuation">)</span> 56<span class="token punctuation">(</span>84<span class="token punctuation">)</span> bytes of data.64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.074 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.034 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.026 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>4 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.022 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>5 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.022 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>6 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.024 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>7 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.021 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>8 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.020 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>9 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.022 ms^C--- 172.30.21.3 <span class="token function">ping</span> statistics ---9 packets transmitted, 9 received, 0% packet loss, <span class="token function">time</span> 7999msrtt min/avg/max/mdev <span class="token operator">=</span> 0.020/0.029/0.074/0.017 ms<span class="token punctuation">[</span>root@node02 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ping  172.30.21.3</span>PING 172.30.21.3 <span class="token punctuation">(</span>172.30.21.3<span class="token punctuation">)</span> 56<span class="token punctuation">(</span>84<span class="token punctuation">)</span> bytes of data.64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.415 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.268 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.215 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>4 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.205 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>5 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.208 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>6 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.211 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>7 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>8 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>9 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.203 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>10 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>11 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.216 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>12 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.224 ms64 bytes from 172.30.21.3: icmp_seq<span class="token operator">=</span>13 ttl<span class="token operator">=</span>63 time<span class="token operator">=</span>0.217 ms</code></pre><h3 id="4-查看server的集群ip"><a href="#4-查看server的集群ip" class="headerlink" title="4    查看server的集群ip"></a>4    查看server的集群ip</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@master01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        AGEkubernetes   ClusterIP   10.254.0.1       <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP        2d17hnginx-web    NodePort    10.254.189.106   <span class="token operator">&lt;</span>none<span class="token operator">></span>        80:36545/TCP   12h10.254.189.106为nginx service的集群ip，代理的是前面的三个pod容器应用。PORT 80是集群IP的端口，36545是node节点上的端口，可以用nodeip:nodeport方式访问服务node01对应的公网IP为：47.108.67.44 ，在一台和这个k8s集群好不相干的主机上访问<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  curl http://47.108.67.44:36545/</span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span>    body <span class="token punctuation">{</span>        width: 35em<span class="token punctuation">;</span>        margin: 0 auto<span class="token punctuation">;</span>        font-family: Tahoma, Verdana, Arial, sans-serif<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span>/style<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>h1<span class="token operator">></span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>For online documentation and support please refer to<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://nginx.org/"</span><span class="token operator">></span>nginx.org<span class="token operator">&lt;</span>/a<span class="token operator">></span>.<span class="token operator">&lt;</span>br/<span class="token operator">></span>Commercial support is available at<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://nginx.com/"</span><span class="token operator">></span>nginx.com<span class="token operator">&lt;</span>/a<span class="token operator">></span>.<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>em<span class="token operator">></span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes集群中的pause容器</title>
      <link href="/2019/07/10/kubernetes%E4%B9%8Bpause/"/>
      <url>/2019/07/10/kubernetes%E4%B9%8Bpause/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上搭建好了k8s多主集群，启动了一个nginx的pod，然而每启动一个pod就伴随这一个pause容器，考虑到之前在做kubelet的systemd unit文件时有见到：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@node01 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps</span>CONTAINER ID    IMAGE                                                                 COMMAND                  CREATED             STATUS        PORTS    NAMES43884d79fe6f    nginx                                                                 <span class="token string">"nginx -g 'daemon of…"</span>   11 hours ago        Up 11 hours            k8s_nginx-pod_nginx-con-594b8d6b48-46gf7_default_25b0048f-a24f-11e9-8149-00163e0134cf_0eff67394c9c8    nginx                                                                 <span class="token string">"nginx -g 'daemon of…"</span>   11 hours ago        Up 11 hours            k8s_nginx-pod_nginx-con-594b8d6b48-vt589_default_25aefc99-a24f-11e9-8149-00163e0134cf_1261226f6b92a    registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1   <span class="token string">"/pause"</span>                 11 hours ago        Up 11 hours            k8s_POD_nginx-con-594b8d6b48-vt589_default_25aefc99-a24f-11e9-8149-00163e0134cf_1fc94013b93dd    registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1   <span class="token string">"/pause"</span>                 11 hours ago        Up 11 hours            k8s_POD_nginx-con-594b8d6b48-46gf7_default_25b0048f-a24f-11e9-8149-00163e0134cf_1</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">### 6     创建和分发kubelet systemd unit文件</span>```bash<span class="token function">cat</span> <span class="token operator">></span>/etc/systemd/system/kubelet.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Kubernetes KubeletDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletExecStart=/usr/local/bin/kubelet \  --bootstrap-kubeconfig=/etc/kubernetes/cert/kubelet-bootstrap.kubeconfig \  --cert-dir=/etc/kubernetes/cert \  --kubeconfig=/etc/kubernetes/cert/kubelet.kubeconfig \  --config=/etc/kubernetes/cert/kubelet.config.json \  --hostname-override=172.24.150.89 \  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1 \  --allow-privileged=true \  --alsologtostderr=true \  --logtostderr=false \  --log-dir=/var/log/kubernetes \  --v=2Restart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOF</span></code></pre><p>首先找一下源码看一下：<br><a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause" target="_blank" rel="noopener">pause源码</a>C语言编写的主要有四个文件：<br>orphan.c文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include &lt;unistd.h></span>int main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  pid_t pid<span class="token punctuation">;</span>  pid <span class="token operator">=</span> fork<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span>      <span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"Child exiting: pid=%d ppid=%d\n"</span>, getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>, getppid<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    printf<span class="token punctuation">(</span><span class="token string">"Parent exiting: pid=%d ppid=%d\n"</span>, getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>, getppid<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  perror<span class="token punctuation">(</span><span class="token string">"Could not create child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>pause.c文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;signal.h></span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include &lt;stdlib.h></span><span class="token comment" spellcheck="true">#include &lt;string.h></span><span class="token comment" spellcheck="true">#include &lt;sys/types.h></span><span class="token comment" spellcheck="true">#include &lt;sys/wait.h></span><span class="token comment" spellcheck="true">#include &lt;unistd.h></span><span class="token comment" spellcheck="true">#define STRINGIFY(x) #x</span><span class="token comment" spellcheck="true">#define VERSION_STRING(x) STRINGIFY(x)</span><span class="token comment" spellcheck="true">#ifndef VERSION</span><span class="token comment" spellcheck="true">#define VERSION HEAD</span><span class="token comment" spellcheck="true">#endif</span>static void sigdown<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>  psignal<span class="token punctuation">(</span>signo, <span class="token string">"Shutting down, got signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>static void sigreap<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>waitpid<span class="token punctuation">(</span>-1, NULL, WNOHANG<span class="token punctuation">)</span> <span class="token operator">></span> 0<span class="token punctuation">)</span>    <span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>int argc, char **argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>  int i<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> 1<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> ++i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>strcasecmp<span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span>, <span class="token string">"-v"</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>      printf<span class="token punctuation">(</span><span class="token string">"pause.c %s\n"</span>, VERSION_STRING<span class="token punctuation">(</span>VERSION<span class="token punctuation">))</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> 0<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> 1<span class="token punctuation">)</span>    /* Not an error because pause sees use outside of infra containers. */    fprintf<span class="token punctuation">(</span>stderr, <span class="token string">"Warning: pause should be the first process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGINT, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigdown<span class="token punctuation">}</span>, NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>    <span class="token keyword">return</span> 1<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGTERM, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigdown<span class="token punctuation">}</span>, NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>    <span class="token keyword">return</span> 2<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sigaction<span class="token punctuation">(</span>SIGCHLD, <span class="token operator">&amp;</span><span class="token punctuation">(</span>struct sigaction<span class="token punctuation">)</span><span class="token punctuation">{</span>.sa_handler <span class="token operator">=</span> sigreap,                                             .sa_flags <span class="token operator">=</span> SA_NOCLDSTOP<span class="token punctuation">}</span>,                NULL<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>    <span class="token keyword">return</span> 3<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  fprintf<span class="token punctuation">(</span>stderr, <span class="token string">"Error: infinite loop terminated\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> 42<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至于里面写的啥，我也看不懂，pose出来让你们看看哈！<br><strong>Makefile</strong>文件用于制作pause镜像，制作镜像的模板是Dockerfile，首先看这个Dockerfile(去除注释)文件：</p><pre class=" language-bash"><code class="language-bash">FROM scratchARG ARCHADD bin/pause-<span class="token variable">${ARCH}</span> /pauseENTRYPOINT <span class="token punctuation">[</span><span class="token string">"/pause"</span><span class="token punctuation">]</span></code></pre><p>FROM scratch:    基础镜像是一个空镜像(an explicity empty image)<br>ARG ARCH:    等待在docker-build -build-arg时提供的ARCH参数<br>ADD bin/pause-$(ARCH)/pause:    添加外部文件到内部<br>ENTRYPOINT[“/pause”]:    开启容器，运行命令<br>中间两部非常重要，至于如何实现的不懂哦？</p><p>pause的Makefile</p><pre class=" language-bash"><code class="language-bash">.PHONY: all push container clean orphan all-push push-manifestinclude <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/hack/make-rules/Makefile.manifestREGISTRY ?<span class="token operator">=</span> staging-k8s.gcr.ioIMAGE <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>REGISTRY<span class="token variable">)</span></span>/pauseIMAGE_WITH_ARCH <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>TAG <span class="token operator">=</span> 3.1REV <span class="token operator">=</span> <span class="token punctuation">$(</span>shell <span class="token function">git</span> describe --contains --always --match<span class="token operator">=</span><span class="token string">'v*'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Architectures supported: amd64, arm, arm64, ppc64le and s390x</span>ARCH ?<span class="token operator">=</span> amd64ALL_ARCH <span class="token operator">=</span> amd64 arm arm64 ppc64le s390xCFLAGS <span class="token operator">=</span> -Os -Wall -Werror -static -DVERSION<span class="token operator">=</span>v<span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>REV<span class="token variable">)</span></span>KUBE_CROSS_IMAGE ?<span class="token operator">=</span> k8s.gcr.io/kube-crossKUBE_CROSS_VERSION ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token function">cat</span> <span class="token punctuation">..</span>/build-image/cross/VERSION<span class="token variable">)</span></span>BIN <span class="token operator">=</span> pauseSRCS <span class="token operator">=</span> pause.cifeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,amd64<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> x86_64-linux-gnuendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,arm<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> arm-linux-gnueabihfendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,arm64<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> aarch64-linux-gnuendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,ppc64le<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> powerpc64le-linux-gnuendififeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,s390x<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> s390x-linux-gnuendif<span class="token comment" spellcheck="true"># If you want to build AND push all containers, see the 'all-push' rule.</span>all: all-containerall-push: all-push-images push-manifestpush-manifest: manifest-tool    manifest-tool push from-args --platforms <span class="token variable"><span class="token variable">$(</span>call join_platforms,<span class="token punctuation">$(</span>ALL_ARCH<span class="token variable">)</span></span><span class="token punctuation">)</span> --template <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span>-ARCH:<span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span> --target <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>sub-container-%:    <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> ARCH<span class="token operator">=</span><span class="token variable">$*</span> containersub-push-%:    <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> ARCH<span class="token operator">=</span><span class="token variable">$*</span> pushall-container: <span class="token variable"><span class="token variable">$(</span>addprefix sub-container-,<span class="token punctuation">$(</span>ALL_ARCH<span class="token variable">)</span></span><span class="token punctuation">)</span>all-push-images: <span class="token variable"><span class="token variable">$(</span>addprefix sub-push-,<span class="token punctuation">$(</span>ALL_ARCH<span class="token variable">)</span></span><span class="token punctuation">)</span>build: bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 先启动一个容器</span>```bashbin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>SRCS<span class="token variable">)</span></span>    <span class="token function">mkdir</span> -p bin    docker run --rm -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        <span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_VERSION<span class="token variable">)</span></span> \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-gcc <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-strip <span class="token variable">$@</span>"</span></code></pre><h1 id="根据上面的启动容器，来build一个pause镜像"><a href="#根据上面的启动容器，来build一个pause镜像" class="headerlink" title="根据上面的启动容器，来build一个pause镜像"></a>根据上面的启动容器，来build一个pause镜像</h1><pre class=" language-bash"><code class="language-bash">container: .container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>.container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>    docker build --pull -t <span class="token variable"><span class="token variable">$(</span>IMAGE_WITH_ARCH<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span> --build-arg ARCH<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span> <span class="token keyword">.</span>    <span class="token function">touch</span> <span class="token variable">$@</span>push: .push-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>.push-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> .container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>    docker push <span class="token variable"><span class="token variable">$(</span>IMAGE_WITH_ARCH<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>    <span class="token function">touch</span> <span class="token variable">$@</span><span class="token comment" spellcheck="true"># Useful for testing, not automatically included in container image</span>orphan: bin/orphan-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>bin/orphan-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> orphan.c    <span class="token function">mkdir</span> -p bin    docker run -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        <span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_VERSION<span class="token variable">)</span></span> \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-gcc <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-strip <span class="token variable">$@</span>"</span>clean:    <span class="token function">rm</span> -rf .container-* .push-* bin/</code></pre><p>ARCH值：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Architectures supported: amd64, arm, arm64, ppc64le and s390x</span>ARCH ?<span class="token operator">=</span> amd64ALL_ARCH <span class="token operator">=</span> amd64 arm arm64 ppc64le s390x</code></pre><p>可以看出支持很多架构类型，默认为amd64</p><p>制作pause镜像的过程如下：</p><pre class=" language-bash"><code class="language-bash">REGISTRY ?<span class="token operator">=</span> staging-k8s.gcr.ioIMAGE <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>REGISTRY<span class="token variable">)</span></span>/pauseIMAGE_WITH_ARCH <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>IMAGE<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>TAG <span class="token operator">=</span> 3.1ARCH ?<span class="token operator">=</span> amd64BIN <span class="token operator">=</span> pauseSRCS <span class="token operator">=</span> pause.cREV <span class="token operator">=</span> <span class="token punctuation">$(</span>shell <span class="token function">git</span> describe --contains --always --match<span class="token operator">=</span><span class="token string">'v*'</span><span class="token punctuation">)</span>CFLAGS <span class="token operator">=</span> -Os -Wall -Werror -static -DVERSION<span class="token operator">=</span>v<span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>REV<span class="token variable">)</span></span>KUBE_CROSS_IMAGE ?<span class="token operator">=</span> k8s.gcr.io/kube-crossKUBE_CROSS_VERSION ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token function">cat</span> <span class="token punctuation">..</span>/build-image/cross/VERSION<span class="token variable">)</span></span>ifeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>,amd64<span class="token punctuation">)</span>    TRIPLE ?<span class="token operator">=</span> x86_64-linux-gnubuild: bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 启动一个容器</span>bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>SRCS<span class="token variable">)</span></span>    <span class="token function">mkdir</span> -p bin    docker run --rm -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        <span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_IMAGE<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>KUBE_CROSS_VERSION<span class="token variable">)</span></span> \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-gcc <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            <span class="token variable"><span class="token variable">$(</span>TRIPLE<span class="token variable">)</span></span>-strip <span class="token variable">$@</span>"</span><span class="token comment" spellcheck="true"># build一个pause镜像</span>container: .container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>.container-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span><span class="token keyword">:</span> bin/<span class="token variable"><span class="token variable">$(</span>BIN<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span>    docker build --pull -t <span class="token variable"><span class="token variable">$(</span>IMAGE_WITH_ARCH<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span>TAG<span class="token variable">)</span></span> --build-arg ARCH<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>ARCH<span class="token variable">)</span></span> <span class="token keyword">.</span>    <span class="token function">touch</span> <span class="token variable">$@</span></code></pre><p>$(KUBE_CROSS_IMAGE):$(KUBE_CROSS_VERSION)=k8s.gcr.io/kube-cross:v1.12.6-1</p><h1 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h1><pre class=" language-bash"><code class="language-bash">bin/pause-amd64:pause.c    <span class="token function">mkdir</span> -p bin    docker run --rm -u $<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>:$<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> -v $<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/build \        k8s.gcr.io/kube-cross:v1.12.6-1 \        /bin/bash -c <span class="token string">"\            cd /build &amp;&amp; \            x86_64-linux-gnu-gcc v3.1-<span class="token variable"><span class="token variable">$(</span>REV<span class="token variable">)</span></span> -o <span class="token variable">$@</span> $^ &amp;&amp; \            x86_64-linux-gnu-strip <span class="token variable">$@</span>"</span><span class="token comment" spellcheck="true"># build一个pause镜像</span>container: .container-amd64.container-amd64: bin/pause-amd64    docker build --pull -t staging-k8s.gcr.io/pause-amd64:3.1 --build-arg ARCH<span class="token operator">=</span>amd64 <span class="token keyword">.</span></code></pre><p>至于详细的构建过程，我就不写了， 我看不懂呀！    </p><p>pause容器的工作<br>可知kubernetes的pod抽象基于Linux的namespace和cgroups，为容器提供了良好的隔离环境。在同一个pod中，不同容器犹如在localhost中。</p><p>在Unix系统中，PID为1的进程为init进程，即所有进程的父进程。它很特殊，维护一张进程表，不断地检查进程状态。例如，一旦某个子进程由于父进程的错误而变成了“孤儿进程”，其便会被init进程进行收养并最终回收资源，从而结束进程。</p><p>或者，某子进程已经停止但进程表中仍然存在该进程，因为其父进程未进行wait syscall进行索引，从而该进程变成“僵尸进程”，这种僵尸进程存在时间较短。不过如果父进程只wait，而未syscall的话，僵尸进程便会存在较长时间。</p><p>同时，init进程不能处理某个信号逻辑，拥有“信号屏蔽”功能，从而防止init进程被误杀。</p><p>容器中使用pid namespace来对pid进行隔离，从而每个容器中均有其独立的init进程。例如对于寄主机上可以用个发送SIGKILL或者SIGSTOP(也就是docker kill 或者docker stop)来强制终止容器的运行，即终止容器内的init进程。一旦init进程被销毁， 同一pid namespace下的进程也随之被销毁，并容器进程被回收相应资源。</p><p>kubernetes中的pause容器便被设计成为每个业务容器提供以下功能：<br>在pod中担任Linux命名空间共享的基础；<br>启用pid命名空间，开启init进程。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -idt --name pause-ceshi cntsp/pause:3.1 </span>ce2a4ffccf1d2b190b9f8cc45f6e4912f278aa7a55280ce8a69433e5345e5816<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -idt --name busybox11 --net=container:pause11 --pid=container:pause11 --ipc=container:pause11 busybox</span>docker: Error response from daemon: No such container: pause11.See <span class="token string">'docker run --help'</span><span class="token keyword">.</span><span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -idt --name busybox11 --net=container:pause-ceshi --pid=container:pause-ceshi --ipc=container:pause-ceshi busybox</span>Unable to <span class="token function">find</span> image <span class="token string">'busybox:latest'</span> locallylatest: Pulling from library/busybox8e674ad76dce: Pull complete Digest: sha256:c94cf1b87ccb80f2e6414ef913c748b105060debda482058d2b8d0fce39f11b9Status: Downloaded newer image <span class="token keyword">for</span> busybox:latest6bec8c69198eaa444580ccaa0a50afbc16a51eea489fa7e81729d535cb691ea6<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps -a </span>CONTAINER ID        IMAGE                                          COMMAND             CREATED             STATUS                PORTS                          NAMES6bec8c69198e        busybox                                        <span class="token string">"sh"</span>                bout a minute ago   Up About a minute                                    busybox11ce2a4ffccf1d        cntsp/pause:3.1                                <span class="token string">"/pause"</span>            2 minutes ago       Up 2 minutes                                         pause-ceshi<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it busybox11 /bin/bash</span>OCI runtime <span class="token function">exec</span> failed: <span class="token function">exec</span> failed: container_linux.go:348: starting container process caused <span class="token string">"exec: \"/bin/bash\": stat /bin/bash: no such file or directory"</span><span class="token keyword">:</span> unknown<span class="token punctuation">[</span>root@harbor1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it busybox11 /bin/sh</span>/ <span class="token comment" spellcheck="true"># ps aux</span>PID   USER     TIME  COMMAND    1 root      0:00 /pause    6 root      0:00 sh   16 root      0:00 /bin/sh   21 root      0:00 <span class="token function">ps</span> aux/ <span class="token comment" spellcheck="true"># </span>这里补充一点：Docker网络模式：其中有一种是Container:            <span class="token operator">></span> * 复用其它容器的网络Container模式：    <span class="token operator">></span>    * 重用另一个容器的Network Namespace,新创建的容器不会创建网卡，配置IP    <span class="token operator">></span>    * 和一个指定的容器共享IP、端口范围    <span class="token operator">></span>    * 两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的，两个容器的进程可以通过lo网卡设备通信。    <span class="token operator">></span>    * Pod里的Pause容器和Pod里的其它容器就是此种网络</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> pause </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql整型长度</title>
      <link href="/2019/06/26/mysql%E6%95%B4%E5%9E%8B%E9%95%BF%E5%BA%A6/"/>
      <url>/2019/06/26/mysql%E6%95%B4%E5%9E%8B%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>数据库中很多整型数据限定了长度，int(3):有些人会错误认为3代表的是允许存储的最大宽度，比如：误以为int(3)能存储的最大数是999，不能存储大于999的数值。</p><pre class=" language-bash"><code class="language-bash">MySQL的int和tinyint的默认长度是int<span class="token punctuation">(</span>11<span class="token punctuation">)</span>和tinyint<span class="token punctuation">(</span>4<span class="token punctuation">)</span>，而boolean型实际存储的是tinyint<span class="token punctuation">(</span>1<span class="token punctuation">)</span>.浮点型的长度使用来限制数字存储范围的。比如float<span class="token punctuation">(</span>3,2<span class="token punctuation">)</span>,只能够写入0.00-999.99整型的长度并不会限制存储的数字范围。比如 int和int<span class="token punctuation">(</span>3<span class="token punctuation">)</span>的存储范围都是-2147483648 ~ 2147483647, int unsigned 和 int<span class="token punctuation">(</span>3<span class="token punctuation">)</span> unsigned 的存储范围都是0 ~ 4294967295.整型的长度实际上可以理解为”显示长度“，如果该字段有开启<span class="token string">"zerofill/补零"</span>就能很明显的知道它的作用。</code></pre><p>1    验证整型长度是否会限制存储范围和整型长度的补零作用</p><pre class=" language-bash"><code class="language-bash">创建数据表:    CREATE TABLE test01<span class="token punctuation">(</span>        with_int_length int<span class="token punctuation">(</span>3<span class="token punctuation">)</span>,        without_int_length int    <span class="token punctuation">)</span>    insert into test01<span class="token punctuation">(</span>with_int_length,without_int_length<span class="token punctuation">)</span> values<span class="token punctuation">(</span>1111,1111<span class="token punctuation">)</span><span class="token punctuation">;</span>    insert into test01<span class="token punctuation">(</span>with_int_length,without_int_length<span class="token punctuation">)</span> values<span class="token punctuation">(</span>11111,11111<span class="token punctuation">)</span><span class="token punctuation">;</span>    commit<span class="token punctuation">;</span>    mysql<span class="token operator">></span> <span class="token keyword">select</span> * from test01<span class="token punctuation">;</span>    +-----------------+--------------------+    <span class="token operator">|</span> with_int_length <span class="token operator">|</span> without_int_length <span class="token operator">|</span>    +-----------------+--------------------+    <span class="token operator">|</span>            1111 <span class="token operator">|</span>               1111 <span class="token operator">|</span>    <span class="token operator">|</span>           11111 <span class="token operator">|</span>              11111 <span class="token operator">|</span>    +-----------------+--------------------+    2 rows <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.00 sec<span class="token punctuation">)</span>    CREATE TABLE test02 <span class="token punctuation">(</span>      with_length int<span class="token punctuation">(</span>3<span class="token punctuation">)</span> ZEROFILL,      without_length int    <span class="token punctuation">)</span> ENGINE<span class="token operator">=</span>innodb, CHARSET<span class="token operator">=</span>utf8    insert into test02 <span class="token punctuation">(</span>with_length, without_length<span class="token punctuation">)</span> VALUE <span class="token punctuation">(</span>11, 11<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">select</span> * from test02<span class="token punctuation">;</span>    mysql<span class="token operator">></span> <span class="token keyword">select</span> * from test02<span class="token punctuation">;</span>    +-------------+----------------+    <span class="token operator">|</span> with_length <span class="token operator">|</span> without_length <span class="token operator">|</span>    +-------------+----------------+    <span class="token operator">|</span>         011 <span class="token operator">|</span>             11 <span class="token operator">|</span>    +-------------+----------------+    1 row <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.01 sec<span class="token punctuation">)</span></code></pre><p>高性能MySQL一书中说明：<br>“高性能MySQL” 书中在”4.1 选择优化的数据类型”中提到:<br>MySQL 可以为整数类型指定宽度, 例如 INT(11), 对大多数应用这是没有意义的: 它不会限制值的合法范围, 只是规定了 MySQL 的一些交互工具(例如 MySQL 命令行客户端)用来显示字符的个数. 对于存储和计算来说, INT(1) 和 INT(20) 是相同的</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> int </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务</title>
      <link href="/2019/06/25/mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/06/25/mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="深入学习MySQL事务：ACID特性的实现原理"><a href="#深入学习MySQL事务：ACID特性的实现原理" class="headerlink" title="深入学习MySQL事务：ACID特性的实现原理"></a>深入学习MySQL事务：ACID特性的实现原理</h1><p>事务是MySQL等关系型数据库区别与NoSQL的中重要方面，是保证数据一致性的重要手段，<strong>本文将首先介绍MySQL事务相关的基础概念，然后介绍事务的ACID特性，并分析其实现原理</strong></p><h1 id="一-基础概念"><a href="#一-基础概念" class="headerlink" title="一    基础概念"></a><table><tr><td bgcolor=#7FFFD4;><p style="color:red;font-size:24px">一    基础概念</p></td></tr></table></h1><p>事务(Transaction)是访问和更新数据库的程序执行单元;事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQ支持事务，本文介绍基于MySQL5.6.<br>首先回顾一下MySQL事务的基础知识。</p><ol><li>逻辑架构和存储引擎</li></ol><p>如上图所示，MySQL服务器逻辑架构从上往下可以分为三层：<br>(1)第一层：处理客户端连接，授权认证等。<br>(2)第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。<br>(3)第三层：存储引擎，负责MySQL中数据的存储和提取。MySQL中服务器层部管理事务，事务是由存储引擎实现的。MySQL支持事务的存储引擎有InnoDB、NDB Cluster等，其中InnoDB使用最为广泛；其它存储引擎不支持事务如MyISAM、Memory等。<br>如无特殊说明，后文中描述的内容都是基于InnoDB.</p><h1 id="提交和回滚"><a href="#提交和回滚" class="headerlink" title="提交和回滚"></a>提交和回滚</h1><p>典型的MySQL事务是如下操作的：</p><pre class=" language-bash"><code class="language-bash">start transaction<span class="token punctuation">;</span>---DML语句--------DML语句--------DML语句-----commit<span class="token punctuation">;</span></code></pre><p>其中start transaction标识事务开始，commit提交事务，将执行结果写入到数据库,如果sql语句执行出现问题，会调用rollback，回滚所有已经执行成功的sql语句，当然，也可以在事务中直接使用rollback语句进行回滚。<br>自动提交：<br>MySQL中默认采用的是自动提交(autocommit)模式，如下所示：<br>mysql&gt; SHOW VARIABLES LIKE ‘AUTOCOMMIT’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| autocommit    | ON    |<br>+—————+——-+<br>1 row in set, 1 warning (0.06 sec)<br>在自动提交模式，如果没有start transaction显式地开始一个事务，那么每个sql语句都会被当作一个事务执行提交操作<br>通过如下方式，可以关闭autocommit;需要注意的是，autocommit参数是针对连接的，在一个连接中修改了参数，不会对其它连接产生影响。<br>mysql&gt; SET AUTOCOMMIT = 0;<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; SHOW VARIABLES LIKE ‘AUTOCOMMIT’;<br>+—————+——-+<br>| Variable_name | Value |<br>+—————+——-+<br>| autocommit    | OFF   |<br>+—————+——-+<br>1 row in set, 1 warning (0.00 sec)</p><p>如果关闭了autocommit，则所有的sql语句都在一个事务中，直到执行了commit(rollback),该事务成功结束(事务失败结束),同时开始了另外一个事务。<br><strong>特殊操作</strong><br>在MySQL中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行commit提交事务；如DDL语句(create table/drop table/alter table)、lock tables语句等等<br>不过，成勇的select、insert、update和delect命令，都不会强制提交事务的。<br><strong>ACID特性</strong><br>ACID是衡量事务的四个特性：</p><blockquote><ul><li>原子性(Atomicity,或称不可分割性)</li><li>一致性(Consistency)</li><li>隔离性(isolation)</li><li>持久性(Durability)<br>按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；InnoDB默认事务隔离级别是可重复读，不满足隔离性；Oracle默认的事务隔离级别为READ COMMITED,不满足隔离性…因此与其说ACID是事务必须满足的条件，不如说他们是衡量事务的四个维度。<br>下面将详细介绍ACID特性及其实现原理；为了便于理解，介绍的顺序不是严格按照A-C-I-D。</li></ul></blockquote><h1 id="二-原子性"><a href="#二-原子性" class="headerlink" title="二    原子性"></a><table><tr><td bgcolor=#7FFFD4;><p style="color:red;font-size:24px">二    原子性</p></td></tr></table></h1><p>1    定义<br>    原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。<br>2    实现原理：undo log<br>    在说明原子性原理之前，首先介绍一个MySQL事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p><pre><code>下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。</code></pre><h1 id="三-持久性"><a href="#三-持久性" class="headerlink" title="三    持久性"></a><table><tr><td bgcolor=#7FFFD4;><p style="color:red;font-size:24px">三    持久性</p></td></tr></table></h1><p>1    定义<br>    持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其它操作或故障不应该对其有任何影响。<br>2    实现原理：redo     log<br>    redo log和undo log都属于InnoDB的事务日志，下面先聊一下(redo log)存在的背景。<br>    InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低，为此，InnoDB提供了缓存(Buffer Pool),Buffer Pool中包含了磁盘中部分数据页映射，作为访问数据库的缓冲;当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool;当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中(这一过程为刷脏)。</p><pre><code>于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。**redo log与binlog**我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。# &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4;&gt;&lt;p style=&quot;color:red;font-size:24px&quot;&gt;三    隔离性&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;1    定义    **与原子性、持久性侧重与研究事务本身不同，隔离性研究的是不同事务之间的相互影响**隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。    隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)，那么隔离性的探讨，主要可以分为两个方面：    &gt; * (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性    &gt; * (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性    **2.锁机制**    首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。    锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。    行锁与表锁        按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。    如何查看锁信息    有多种方法可以查看InnoDB中锁的情况，例如：    ```bash    SELECT * FROM information_schema.innodb_locks;#锁的概况    show engine innodb status;#InnoDB整体状态，其中包括锁的情况    ```    其中lock_type为RECORD，代表锁为行锁(记录锁)；lock_mode为X，代表排它锁(写锁)。    除了排它锁(写锁)之外，MySQL中还有共享锁(读锁)的概念。由于本文重点是MySQL事务的实现原理，因此对锁的介绍到此为止，后续会专门写文章分析MySQL中不同锁的区别、使用场景等，欢迎关注。    **3 脏读、不可重复读和幻读**    首先来看并发情况下，读操作可能存在的三类问题：    (1)    脏读：当前事务(A)中可以读到其它事务(B)未提交的数据(脏数据),这种现象是脏读，举例如下(以账户余额表为例)：        ------------------------------------------------------------------        时间        事务A                    事务B        ------------------------------------------------------------------        T1            开始事务                开始事务        ------------------------------------------------------------------        T2                                    修改zhangsan的余额                                            将余额由100改为200        ------------------------------------------------------------------        T3            查询zhangsan的余额                    结果为200[脏读]        ------------------------------------------------------------------        T4                                    提交事务        ------------------------------------------------------------------    (2)不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。    脏读与不可重复读的区别在于：前者读到的是其他事务为提交的数据，后者读到的是其它事务已提交的数据。        -------------------------------------------------------------------------------        时间        事务A                                            事务B        -------------------------------------------------------------------------------        T1            开始事务                                        开始事务        -------------------------------------------------------------------------------        T2            查询zhangsan的余额,结果为100        -------------------------------------------------------------------------------        T3                                                            修改zhangsan的余额                                                                    将余额由100改为200        -------------------------------------------------------------------------------        T4                                                            提交事务        -------------------------------------------------------------------------------        T5            查询zhangsan的余额，结果为                    200[不可重复读]        -------------------------------------------------------------------------------        (3)幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。举例如下：        ---------------------------------------------------------------------------------        时间            事务A                                事务B        ---------------------------------------------------------------------------------        T1                开始事务                            开始事务        ---------------------------------------------------------------------------------        T2                查询0&lt;id&lt;5的所有用户的余额:                        zhangsan:100(id=1)        ---------------------------------------------------------------------------------        T3                                                    账户余额表中插入新用户                                                            lisi:200(id=2)        ---------------------------------------------------------------------------------        T4                                                    提交事务        ---------------------------------------------------------------------------------        T5                查询0&lt;id&lt;5的所有用户的余额：                        zhangsan:100(id=1)                        lisi:200(id=2)【幻读】        ------------------------------------------------------------------------------------------        4 事务隔离级别        ------------------------------------------------------------------------------------------        SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，        隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：        ------------------------------------------------------------------------------------------        隔离级别                  脏读            不可重复读            幻读        ------------------------------------------------------------------------------------------        Read Uncommitted        可能            可能                可能            读未提交        ------------------------------------------------------------------------------------------        Read committed            不可能            可能                可能            读已提交        ------------------------------------------------------------------------------------------        Repeatable Read            不可能            不可能                可能        可重复读        ------------------------------------------------------------------------------------------        Serializable            不可能            不可能                不可能        可串行化        ------------------------------------------------------------------------------------------        在实际应用中，读未提交在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。可串行化强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是读已提交(如Oracle)或可重复读（如：mysql,后文简称RR）        mysql&gt; select @@global.tx_isolation;        +-----------------------+                   | @@global.tx_isolation |                   +-----------------------+                   | REPEATABLE-READ       |                   +-----------------------+                   1 row in set, 1 warning (0.00 sec)          mysql&gt; select @@tx_isolation;                                    +-----------------+                         | @@tx_isolation  |                         +-----------------+                         | REPEATABLE-READ |                         +-----------------+                         1 row in set, 1 warning (0.00 sec)          MYSQL中InnoDB默认的隔离级别是RR，后文会重点介绍RR。需要注意的是，在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。    5    MVCC        RR解决脏读，不可重复读、幻读等问题，使用的是MVCC：MVCC全称：Multi-Version Concurrency Control,即多版本的并发控制协议，下面的例子很好的体现了MVCC的特点：在同一时刻，不同事务读取到的数据可能是不同的(即多版本)-在T5时刻，事务A和事务C可以读取到不同版本的数据。        ---------------------------------------------------------------------        时间    事务A                   事务B                    事务C        -------------------------------------------------------------------------        T1        开始事务               开始事务                    开始事务        --------------------------------------------------------------------------        T2        查询zhangsan的                余额结果为100        --------------------------------------------------------------------------        T3                                修改zhangsan的余额                                        将余额由100改为200        --------------------------------------------------------------------------        T4                                提交事务        --------------------------------------------------------------------------        T5        查询zhangsan的余额                结果为100                                        查询zhangsan的余额                                                                结果为200        --------------------------------------------------------------------------        MVCC最大的有点是读不加锁，因此读写不冲突，并发性能好，InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(可以称之为标记位)和undo log。其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo log的指针等等，当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log,从而实现MVCC；隐藏列的详细格式不再展开。        下面结合前文提到的几个问题分别说明：        (1)脏读        -------------------------------------------------------------        时间        事务A                        事务B        -------------------------------------------------------------        T1            开始事务                    开始事务        -------------------------------------------------------------        T2                                        修改zhangsan的余额,                                                将余额由100改为200        -------------------------------------------------------------        T3            查询zhangsan的余额                    结果为100(避免了脏读)        -------------------------------------------------------------        T4                                        提交事务        -------------------------------------------------------------        当事务A在T3时间节点读取zhangsan的余额时，会发现数据已被其他事务修改，且状态为未提交。此时事务A读取最新数据后，根据数据的undo log执行回滚操作，得到事务B修改前的数据，从而避免了脏读。        (2)不可重复读        -------------------------------------------------------------        时间        事务A                        事务B        -------------------------------------------------------------        T1            开始事务                    开始事务        -------------------------------------------------------------        T2            查询zhangsan的余额                    结果为100        -------------------------------------------------------------        T3                                        修改zhangsan的余额                                                将余额由100改为200        -------------------------------------------------------------        T4                                        提交事务        -------------------------------------------------------------                查询zhangsan的余额        T5        结果为100(避免了不可重复读)        -------------------------------------------------------------        当事务A在T2节点第一次读取数据时，会记录该数据的版本号（数据的版本号是以row为单位记录的），假设版本号为1；当事务B提交时，该行记录的版本号增加，假设版本号为2；当事务A在T5再一次读取数据时，发现数据的版本号（2）大于第一次读取时记录的版本号（1），因此会根据undo log执行回滚操作，得到版本号为1时的数据，从而实现了可重复读。        (3)幻读        InnoDB实现的RR通过next-key lock机制避免了幻读现象。        **next-key lock是行锁的一种，实现相当于record lock(记录锁) + gap lock(间隙锁)；其特点是不仅会锁住记录本身(record lock的功能)，还会锁定一个范围(gap lock的功能)。**当然，这里我们讨论的是不加锁读：此时的next-key lock并不是真的加锁，只是为读取的数据增加了标记（标记内容包括数据的版本号等）；准确起见姑且称之为类next-key lock机制。还是以前面的例子来说明：        -------------------------------------------------------------------        时间            事务A                                 事务B        --------------------------------------------------------------------------        T1                开始事务                            开始事务        --------------------------------------------------------------------------        T2                查询0&lt;id&lt;5的所有用户的余额：                        zhangsan:100(id=1)        --------------------------------------------------------------------------        T3                                                    账户余额表中插入新用户                                                            lisi:200(id=2)        --------------------------------------------------------------------------        T4                                                    提交事务        --------------------------------------------------------------------------        T5                查询0&lt;id&lt;5的所有用户的余额：                        zhangsan:100(id=1)                        (避免了幻读)        --------------------------------------------------------------------------        当事务A在T2节点第一次读取0&lt;id&lt;5数据时，标记的不只是id=1的数据，而是将范围(0,5)进行了标记，这样当T5时刻再次读取0&lt;id&lt;5数据时，便可以发现id=4的数据比之前标记的版本号更高，此时再结合undo log执行回滚操作，避免了幻读。    6 总结        概括来说，InnoDB实现的RR，通过锁机制、数据的隐藏列、undo log和类next-key lock,实现了一定程度的隔离性，可以满足大多数场景的需要，不过需要说明的是，RR虽然避免了幻读问题，但是毕竟不是Serializable,不能保证完全的隔离，下面是一个例子，大家可以自己验证一下。        -------------------------------------------------------------------------        时间            事务A                            事务B        -------------------------------------------------------------------------        T1                开始事务                        开始事务        -------------------------------------------------------------------------        T2            查询0&lt;id&lt;5的所有用户的余额：                    zhangsan:100(id=1)                    -------------------------------------------------------------------------        T3                                                账户余额表中插入新用户                                                        lisi:200(id=2)        -------------------------------------------------------------------------        T4                                                提交事务        -------------------------------------------------------------------------        T5            修改0&lt;id&lt;5的所有用户的余额为300        -------------------------------------------------------------------------        T6            提交事务(事务A提交后，zhangsan和lisi的余额都是300)        -------------------------------------------------------------------------# &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4;&gt;&lt;p style=&quot;color:red;font-size:24px&quot;&gt;五    一致性&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    1    **基本概念**        一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。    2    **实现**                         可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。        实现一致性的措施包括：    &gt; *    保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证    &gt; * 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等    &gt; *应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致# &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4;&gt;&lt;p style=&quot;color:red;font-size:24px&quot;&gt;六    总结&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;    **下面总结一下ACID特性及其实现原理：**        原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log        持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log        隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制、数据的隐藏列、undo log和类next-key lock机制        一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障</code></pre><p><a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">转载自：</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> transcation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql入门</title>
      <link href="/2019/06/21/mysql%E5%85%A5%E9%97%A8/"/>
      <url>/2019/06/21/mysql%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>SQL概述<br>SQL，一般发音为sequel，SQL的全称Structured Query Language),SQL用来和数据库打交道，完成和数据库的通信，SQL是一套标准。但是每一个数据库都有自己的特性别的数据库没有，当使用这个数据库特性相关的功能，这时SQL语句可能就不是标准了(90%以上的SQL都是通用的)</p><p>什么是数据库<br>数据库，通常是一个或一组文件，保存了一些符合特定规格的数据，数据库对应的英语单词是DataBase,简称DB，数据库软件称为数据库管理系统(DBMS)，全称为DataBase Management System,如：Oracle、SQL Server、MySQL、Sybase、Informix、 DB2、interbase 、PostgreSql</p><p>MySql概述<br>MySQL最初是由”MySQL AB”公司开发的一套关系型数据库管理系统(RDBMS-Relation Database Management System).MySQL不仅是最流行的开源数据库，而且是业界成长最快的数据库，每天有超过7万次的下载量，其应用范围从大型企业到专有的嵌入应用系统。<br>MySQL</p><p>查询建表语句：<br>show create table 表名;<br>show create table draw_company_result; </p><blockquote><p>CREATE TABLE <code>draw_company_result</code> (<br>  <code>draw_id</code> varchar(30) NOT NULL,<br>  <code>game_code</code> varchar(10) NOT NULL DEFAULT ‘’,<br>  <code>company</code> varchar(30) NOT NULL,<br>  <code>result</code> varchar(255) DEFAULT ‘’,<br>  <code>operator</code> varchar(255) DEFAULT NULL,<br>  <code>operatortime</code> datetime DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (<code>draw_id</code>,<code>game_code</code>,<code>company</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8</p></blockquote><p>查询表的单个字段<br>user openfire;<br>select username from ofUser;<br>select username, name, email from ofUser;</p><p>查询重命名表名，并不能修改真正的修改表名</p><p>mysql&gt; select username, encryptedPassword from ofUser;<br>+———-+————————————————–+<br>| username | encryptedPassword                                |<br>+———-+————————————————–+<br>| admin    | 61a46ea4fb839834cc6e88519e28a5e353a96d402957e094 |<br>| gang     | 269d01e7a82a1cd51642e1e574357bf30e4ad174f3f26bde |<br>| jia      | 248be0a8c9a505221bf7a0a7523521119cfaa2bfa288a106 |<br>| jian     | 65b416288a78bac5732531ff33565860e71a203d9974de4c |<br>| pei      | 4242b7cb67849778199f189d97010b24291c03d8cab70a41 |<br>+———-+————————————————–+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select username,encryptedPassword as passwd from ofUser;<br>+———-+————————————————–+<br>| username | passwd                                           |<br>+———-+————————————————–+<br>| admin    | 61a46ea4fb839834cc6e88519e28a5e353a96d402957e094 |<br>| gang     | 269d01e7a82a1cd51642e1e574357bf30e4ad174f3f26bde |<br>| jia      | 248be0a8c9a505221bf7a0a7523521119cfaa2bfa288a106 |<br>| jian     | 65b416288a78bac5732531ff33565860e71a203d9974de4c |<br>| pei      | 4242b7cb67849778199f189d97010b24291c03d8cab70a41 |<br>+———-+————————————————–+<br>5 rows in set (0.00 sec)<br>注意：可以写成 select username,encryptedPassword  passwd from ofUser;<br>省去as关键字也是可以的<br>注意：字符串用单引号</p><p>条件查询:<br>条件查询需要用到where语句，where必须放到from语句表的后面<br>支持如下运算符<br>运算符                      说明<br>=                          等于<br>&lt;&gt;或!=                    不等于<br>&lt;                          小于<br>&lt;=                          小于等于</p><blockquote><pre><code>                    大于</code></pre><p>=                        大于等于<br>between … and …       两个值之间,等同于&gt;= and &lt;=<br>is null                   为null(is not null 不为空)<br>and                          并且<br>or                          或者<br>in                        包含，相当于多个or(not in不在这个范围中)<br>not                       not可以取非，主要用在is 或者in中<br>like                      like 称为模糊查询，支持%或下划线匹配<br>str_to_date                将字符串转换日期<br>date_format                  格式化日期<br>format                      设置千分位<br>round                      四舍五入<br>rand()                      生成随机数<br>Ifnull                      可以将null转换成一个具体值</p></blockquote><p>mysql&gt; select username,name,creationDate as crtDate from ofUser where email=’123@qq.com’;<br>+———-+——+—————–+<br>| username | name | crtDate         |<br>+———-+——+—————–+<br>| gang     | gang | 001560644570688 |<br>+———-+——+—————–+<br>1 row in set (0.00 sec)</p><p>找出工资大于1800的员工，要求部门编号是20或者30的。</p><p>select<br>    empno,enmae,sal,deptno<br>from<br>    emp<br>where<br>    sal &gt; 1800 and (deptno = 20 or deptno =30);<br>    mysql&gt; SELECT EMPNO,ENAME,SAL,DEPTNO FROM EMP WHERE SAL&gt;1800 AND (DEPTNO =20 OR DEPTNO = 30);<br>    +——-+——-+———+——–+<br>    | EMPNO | ENAME | SAL     | DEPTNO |<br>    +——-+——-+———+——–+<br>    |  7566 | JONES | 2975.00 |     20 |<br>    |  7698 | BLAKE | 2850.00 |     30 |<br>    |  7782 | CLARK | 2450.00 |     20 |<br>    |  7788 | SCOTT | 3000.00 |     20 |<br>    |  7902 | FORD  | 3000.00 |     20 |<br>    +——-+——-+———+——–+<br>    5 rows in set (0.00 sec)</p><p>查找出某个字段对应的数据中T字母结尾的：<br>mysql&gt; select ENAME FROM EMP WHERE ENAME LIKE ‘%T’;<br>+——-+<br>| ENAME |<br>+——-+<br>| SCOTT |<br>+——-+<br>1 row in set (0.00 sec)</p><p>查找出某个字段对应的数据中第二个字母是A的：<br>mysql&gt; select ENAME FROM EMP WHERE ENAME LIKE ‘_A%’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| WARD   |<br>| MARTIN |<br>| JAMES  |<br>+——–+<br>3 rows in set (0.00 sec)</p><p>查找出某个字段对应的数据中里面含有A的：<br>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME LIKE ‘%A%’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| ALLEN  |<br>| WARD   |<br>| MARTIN |<br>| BLAKE  |<br>| CLARK  |<br>| ADAMS  |<br>| JAMES  |<br>+——–+<br>7 rows in set (0.00 sec)</p><p>注意：%代表任意多个字符，_代表任意单个字符</p><p>注意：Null为空，但不是空串</p><p>排序 order by<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>默认升序排序<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL asc;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| KING   | 5000.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| SMITH  |  800.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)<br>DESC:     降序排序</p><p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC,ENAME ASC;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| KING   | 5000.00 |<br>| FORD   | 3000.00 |<br>| SCOTT  | 3000.00 |<br>| JONES  | 2975.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| ALLEN  | 1600.00 |<br>| TURNER | 1500.00 |<br>| MILLER | 1300.00 |<br>| MARTIN | 1250.00 |<br>| WARD   | 1250.00 |<br>| ADAMS  | 1100.00 |<br>| JAMES  |  950.00 |<br>| SMITH  |  800.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>单一字段排序<br>排序采用order by子句，order by后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序，如果存在where子句，那么order by<br>必须放到where语句的后面</p><ul><li>按照薪水由小到大排序(系统默认由小到大)<br>mysql&gt; SELECT * FROM EMP ORDER BY SAL;</li></ul><p>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+<br>14 rows in set (0.00 sec)</p><p>使用字段的位置来排序<br>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY 2;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| SMITH  |  800.00 |<br>| JAMES  |  950.00 |<br>| ADAMS  | 1100.00 |<br>| WARD   | 1250.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| TURNER | 1500.00 |<br>| ALLEN  | 1600.00 |<br>| CLARK  | 2450.00 |<br>| BLAKE  | 2850.00 |<br>| JONES  | 2975.00 |<br>| SCOTT  | 3000.00 |<br>| FORD   | 3000.00 |<br>| KING   | 5000.00 |<br>+——–+———+</p><p>mysql&gt; SELECT ENAME,SAL FROM EMP ORDER BY 1;<br>+——–+———+<br>| ENAME  | SAL     |<br>+——–+———+<br>| ADAMS  | 1100.00 |<br>| ALLEN  | 1600.00 |<br>| BLAKE  | 2850.00 |<br>| CLARK  | 2450.00 |<br>| FORD   | 3000.00 |<br>| JAMES  |  950.00 |<br>| JONES  | 2975.00 |<br>| KING   | 5000.00 |<br>| MARTIN | 1250.00 |<br>| MILLER | 1300.00 |<br>| SCOTT  | 3000.00 |<br>| SMITH  |  800.00 |<br>| TURNER | 1500.00 |<br>| WARD   | 1250.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>数据处理函数/单行处理函数</p><p>Lower        转换小写<br>upper        转换大写<br>substr        取字串(substr(被截取的字符串，起始下标，截取的长度))<br>length        取长度<br>trim        去空格</p><p>将查询结果显示小写</p><p>mysql&gt; SELECT lower(ENAME) as ename from EMP;<br>+——–+<br>| ename  |<br>+——–+<br>| smith  |<br>| allen  |<br>| ward   |<br>| jones  |<br>| martin |<br>| blake  |<br>| clark  |<br>| scott  |<br>| king   |<br>| turner |<br>| adams  |<br>| james  |<br>| ford   |<br>| miller |<br>+——–+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; SELECT upper(ENAME) as ename from EMP;<br>+——–+<br>| ename  |<br>+——–+<br>| SMITH  |<br>| ALLEN  |<br>| WARD   |<br>| JONES  |<br>| MARTIN |<br>| BLAKE  |<br>| CLARK  |<br>| SCOTT  |<br>| KING   |<br>| TURNER |<br>| ADAMS  |<br>| JAMES  |<br>| FORD   |<br>| MILLER |<br>+——–+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; select username from ofUser;<br>+———-+<br>| username |<br>+———-+<br>| admin    |<br>| pei      |<br>| gang     |<br>| jian     |<br>| jia      |<br>+———-+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select upper(username) from ofUser;<br>+—————–+<br>| upper(username) |<br>+—————–+<br>| ADMIN           |<br>| PEI             |<br>| GANG            |<br>| JIAN            |<br>| JIA             |<br>+—————–+<br>5 rows in set (0.00 sec)</p><p>mysql&gt; select upper(username) as username from ofUser;<br>+———-+<br>| username |<br>+———-+<br>| ADMIN    |<br>| PEI      |<br>| GANG     |<br>| JIAN     |<br>| JIA      |<br>+———-+<br>5 rows in set (0.00 sec)</p><p>substr(args1,args2,args3)<br>args1参数为字段名，<br>args2参数为起始下标，<br>args3参数为截取的长度</p><p>查找表emp中字段ename中第二个字母为A的：<br>之前的方法：<br>    mysql&gt; SELECT ENAME FROM EMP WHERE ENAME LIKE ‘_A%’;<br>    +——–+<br>    | ENAME  |<br>    +——–+<br>    | WARD   |<br>    | MARTIN |<br>    | JAMES  |<br>    +——–+<br>    3 rows in set (0.00 sec)</p><p>substr()函数的方法：<br>    mysql&gt; SELECT ENAME FROM EMP WHERE substr(ENAME,2,1) = ‘A’;<br>    +——–+<br>    | ENAME  |<br>    +——–+<br>    | WARD   |<br>    | MARTIN |<br>    | JAMES  |<br>    +——–+<br>    3 rows in set (0.00 sec)</p><p>length(args1)</p><p>select length(ename) from emp;</p><p>trim  去除查询中输入的空格<br>mysql&gt; SELECT ENAME FROM EMP WHERE substr(ENAME,2,1) = ‘A’;<br>+——–+<br>| ENAME  |<br>+——–+<br>| WARD   |<br>| MARTIN |<br>| JAMES  |<br>+——–+<br>3 rows in set (0.00 sec)</p><p>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME=’ SMITH ‘;<br>Empty set (0.00 sec)</p><p>mysql&gt; SELECT ENAME FROM EMP WHERE ENAME = trim(‘ SMITH ‘);<br>+——-+<br>| ENAME |<br>+——-+<br>| SMITH |<br>+——-+<br>1 row in set (0.00 sec)</p><p>补助为空的显示为0<br>mysql&gt; SELECT ENAME,ifnull(comm,0) as comm from EMP;<br>+——–+———+<br>| ENAME  | comm    |<br>+——–+———+<br>| SMITH  |    0.00 |<br>| ALLEN  |  300.00 |<br>| WARD   |  500.00 |<br>| JONES  |    0.00 |<br>| MARTIN | 1400.00 |<br>| BLAKE  |    0.00 |<br>| CLARK  |    0.00 |<br>| SCOTT  |    0.00 |<br>| KING   |    0.00 |<br>| TURNER |    0.00 |<br>| ADAMS  |    0.00 |<br>| JAMES  |    0.00 |<br>| FORD   |    0.00 |<br>| MILLER |    0.00 |<br>+——–+———+<br>14 rows in set (0.00 sec)</p><p>mysql&gt; SELECT ENAME,(SAL+ifnull(comm,0))*12 as yearsal from EMP;<br>+——–+———-+<br>| ENAME  | yearsal  |<br>+——–+———-+<br>| SMITH  |  9600.00 |<br>| ALLEN  | 22800.00 |<br>| WARD   | 21000.00 |<br>| JONES  | 35700.00 |<br>| MARTIN | 31800.00 |<br>| BLAKE  | 34200.00 |<br>| CLARK  | 29400.00 |<br>| SCOTT  | 36000.00 |<br>| KING   | 60000.00 |<br>| TURNER | 18000.00 |<br>| ADAMS  | 13200.00 |<br>| JAMES  | 11400.00 |<br>| FORD   | 36000.00 |<br>| MILLER | 15600.00 |<br>+——–+———-+<br>14 rows in set (0.00 sec)</p><p>0     先了解一下数据库中的数据类型：<br>    int            整数型<br>    varchar        可变长度字符串<br>    char        定长字符串<br>    date        日期类型<br>    double        浮点类型</p><ol><li><p>关于MYSQL中的日期处理<br> 1.1  每一个数据库处理日期的时候，采用的机制都是不同的，日期处理都有自己的一套机制。<br> 所有在实际的开发中，表中的字段定义为DATE类型，这种情况很少。因为一旦使用日期类型，那么java程序将不能够通用。在实际开发中，一般使用日期字符串来表示日期<br> 1.2  日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以还是需要掌握。</p><pre><code>     -     str_to_date     -    date_format str_to_date:     该函数的作用是：将“日期字符串”转换成“日期类型”的数据 【varchar  ----&gt; date】                 该函数的执行结果是DATE类型                 该函数的使用格式：                     str_to_date(&#39;日期字符串&#39;,&#39;日期格式&#39;)                 关于MYSQL中的日期格式：                         回顾java中的日期格式：                             yyyy    年                             MM        月                             dd        日                             HH        时                             mm        分                             ss        秒                             SSS        毫秒                 java中将字符串转换成日期类型：                     SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);                     Date date = sdf.parse(&quot;1970-10-10&quot;);                 MySQL的日期格式：                     %Y          年                     %m            月                     %d            日                     %H            时                     %i            分                     %s            秒</code></pre></li></ol><p>MYSQL默认的日期格式： %Y-%m-%d              </p><pre><code>        案例： 查询出1980-12-17入职的员工                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE = &#39;1980-12-17&#39;;                +-------+------------+                | ENAME | HIREDATE   |                +-------+------------+                | SMITH | 1980-12-17 |                +-------+------------+                1 row in set (0.01 sec)                等同如下SQL命令:                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE = str_to_date(&#39;1980-12-17&#39;,&#39;%Y-%m-%d&#39;);                +-------+------------+                | ENAME | HIREDATE   |                +-------+------------+                | SMITH | 1980-12-17 |                +-------+------------+                1 row in set (0.00 sec)                MYSQL默认的日期格式： %Y-%m-%d，以上的日期字符串&#39;1980-12-17&#39;正好和默认的日期格式一样，存在了自动类型转换，自动将日期字符串转换成了日期类型，所以以上查询可以查询出结果。                mysql&gt; SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE=&#39;12-17-1980&#39;;                Empty set, 1 warning (0.00 sec)                &#39;12-17-1980&#39;日期字符串和mysql默认的日期格式不同                hiredate是date类型，&#39;12-17-1980&#39;是一个字符串varchar类型，类型不匹配.                所以无法查询结果，并且有警告方法。                纠正以上SQL语句的错误：                select ENAME, HIREDATE from EMP where HIREDATE = str_to_date(&#39;12-17-1980&#39;,%d-%m-%Y);                mysql&gt; select version();                +-----------+                | version() |                +-----------+                | 5.7.26    |                +-----------+                1 row in set (0.00 sec)                mysql&gt; select ENAME, HIREDATE from EMP where HIREDATE = str_to_date(&#39;12-17-1980&#39;,%d-%m-%Y);                ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;%d-%m-%Y)&#39; at line 1                在5.7.26中没有测试通过        3.6  案例：            创建学生表: 【create 语句，以后详细讲】            create table t_student(                id int(10),                name varchar(32),                birth date            );            插入数据：【insert语句，以后详细讲】            insert into t_student(id,name,birth) values(1,&#39;jack&#39;,&#39;1980-10-11&#39;);            以上可以执行，因为&#39;1980-10-11&#39;虽然是一个varchar类型，但是由于格式和MYSQL数据库默认的日期格式相同，所以存在自动类型转换.            mysql&gt;insert into t_student(id,name,birth) values(2,&#39;zhangsan&#39;,&#39;10-11-1970&#39;);            ERROR 1292(22007):Incorrect date value:&#39;10-11-1970&#39; for column &#39;birth&#39; at row 1 以上发生错误：                    第一：&#39;10-11-1970&#39;日期字符串的格式和mysql默认的格式不同                    第二：&#39;10-11-1970&#39;是varchar类型，birth字段需要date类型，类型不匹配.                    纠正以上错误：                    insert into t_student(id,name,birth) values(2,&#39;zhangsan&#39;,str_to_date(&#39;10-11-1970&#39;,&#39;%m-%d-%Y&#39;));    str_to_date函数通常使用在插入操作中，字段是date类型，不接收字符串varchar类型。    需要通过该函数将varchar变成date再插入数据，才能成功。date_format:    该函数的作用是：将&quot;日期类型date&quot;转换成具有特定格式的日期字符串varchar【date---&gt;varchar】    该函数的运算结果是:varchar类型【具备特定格式的】    该函数的语法格式：    date_format(日期类型数据,&#39;日期格式&#39;)    回顾java中的日期格式化：            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            Date nowTime = new Date();            String strTime = sdf.format(newTime);        案例：查询员工的入职日期，以&#39;10-12-1980&#39;的格式显示到窗口中。            mysql&gt; SELECT ENAME, date_format(hiredate,&#39;%m-%d-%Y&#39;) as HIREDATE  from EMP;            +--------+------------+            | ENAME  | HIREDATE   |            +--------+------------+            | SMITH  | 12-17-1980 |            | ALLEN  | 02-20-1981 |            | WARD   | 02-22-1981 |            | JONES  | 04-02-1981 |            | MARTIN | 09-28-1981 |            | BLAKE  | 05-01-1981 |            | CLARK  | 06-09-1981 |            | SCOTT  | 04-19-1987 |            | KING   | 11-17-1981 |            | TURNER | 09-08-1981 |            | ADAMS  | 05-23-1987 |            | JAMES  | 12-03-1981 |            | FORD   | 12-03-1981 |            | MILLER | 01-23-1982 |            +--------+------------+            14 rows in set (0.00 sec)        以下两个DQL语句的执行结果相同：        select ename,hiredate from emp; 【hiredate自动转换成varchar类型，并且采用 %Y-%m-%d 格式】            mysql&gt; SELECT ENAME, HIREDATE FROM EMP;            +--------+------------+            | ENAME  | HIREDATE   |            +--------+------------+            | SMITH  | 1980-12-17 |            | ALLEN  | 1981-02-20 |            | WARD   | 1981-02-22 |            | JONES  | 1981-04-02 |            | MARTIN | 1981-09-28 |            | BLAKE  | 1981-05-01 |            | CLARK  | 1981-06-09 |            | SCOTT  | 1987-04-19 |            | KING   | 1981-11-17 |            | TURNER | 1981-09-08 |            | ADAMS  | 1987-05-23 |            | JAMES  | 1981-12-03 |            | FORD   | 1981-12-03 |            | MILLER | 1982-01-23 |            +--------+------------+            14 rows in set (0.00 sec)        select ename,date_format(hiredate,&#39;%Y-%m-%d&#39;) as hiredate from emp;        mysql&gt; SELECT ENAME,date_format(HIREDATE,&#39;%Y-%m-%d&#39;) as HIREDATE FROM EMP;        +--------+------------+        | ENAME  | HIREDATE   |        +--------+------------+        | SMITH  | 1980-12-17 |        | ALLEN  | 1981-02-20 |        | WARD   | 1981-02-22 |        | JONES  | 1981-04-02 |        | MARTIN | 1981-09-28 |        | BLAKE  | 1981-05-01 |        | CLARK  | 1981-06-09 |        | SCOTT  | 1987-04-19 |        | KING   | 1981-11-17 |        | TURNER | 1981-09-08 |        | ADAMS  | 1987-05-23 |        | JAMES  | 1981-12-03 |        | FORD   | 1981-12-03 |        | MILLER | 1982-01-23 |        +--------+------------+        14 rows in set (0.00 sec)        结论：date_format函数主要使用在查询操作中，客户需要日期以特定格式展示的时候，需要用到该函数。</code></pre><p>分组函数/聚合函数/多行处理函数<br>注意：分组函数不能直接使用在where子句中<br>count         取得记录数<br>sum            求和<br>avg            取平均<br>max            取最大的数<br>min            取最小的数<br>注意：分组函数自动忽略空值，不需要手动的加where条件排除控制<br>select count(*) from emp where xxx;符合条件的所有记录总数<br>select count(comm) from emp; comm这个字段中不为空的元素总数<br>注意：分组函数不能直接使用在where关键字后面</p><p>distinct关键字  去除重复记录<br>注意：distinct只能放到所有字段最前面<br>    mysql&gt; SELECT JOB FROM EMP;<br>    +———–+<br>    | JOB       |<br>    +———–+<br>    | CLERK     |<br>    | SALESMAN  |<br>    | SALESMAN  |<br>    | MANAGER   |<br>    | SALESMAN  |<br>    | MANAGER   |<br>    | MANAGER   |<br>    | ANALYST   |<br>    | PRESIDENT |<br>    | SALESMAN  |<br>    | CLERK     |<br>    | CLERK     |<br>    | ANALYST   |<br>    | CLERK     |<br>    +———–+<br>    14 rows in set (0.00 sec)</p><pre><code>mysql&gt; SELECT distinct JOB FROM EMP;+-----------+| JOB       |+-----------+| CLERK     || SALESMAN  || MANAGER   || ANALYST   || PRESIDENT |+-----------+5 rows in set (0.00 sec)mysql&gt; SELECT DEPTNO,JOB FROM EMP;+--------+-----------+| DEPTNO | JOB       |+--------+-----------+|     20 | CLERK     ||     30 | SALESMAN  ||     30 | SALESMAN  ||     20 | MANAGER   ||     30 | SALESMAN  ||     30 | MANAGER   ||     20 | MANAGER   ||     20 | ANALYST   ||     10 | PRESIDENT ||     30 | SALESMAN  ||     20 | CLERK     ||     30 | CLERK     ||     20 | ANALYST   ||     10 | CLERK     |+--------+-----------+14 rows in set (0.00 sec)mysql&gt; SELECT distinct DEPTNO,JOB FROM EMP;+--------+-----------+| DEPTNO | JOB       |+--------+-----------+|     20 | CLERK     ||     30 | SALESMAN  ||     20 | MANAGER   ||     30 | MANAGER   ||     20 | ANALYST   ||     10 | PRESIDENT ||     30 | CLERK     ||     10 | CLERK     |+--------+-----------+8 rows in set (0.00 sec)</code></pre><p>select count(distinct job) from emp;<br>    mysql&gt; SELECT count(distinct JOB) from EMP;<br>    +———————+<br>    | count(distinct JOB) |<br>    +———————+<br>    |                   5 |<br>    +———————+<br>    1 row in set (0.00 sec)</p><p>分组查询：<br>    分组查询主要涉及两个子句，分别是：group by和 having<br>    group by 分组查询<br>            order by 【表示通过哪个或者哪些字段进行排序】<br>            group by 【表示通过哪个或者哪些字段进行分组】<br>    2.2    案例：找出每个工作岗位的最高薪水 【先按照工作岗位分组，使用max求每一组的最高薪水】<br>        select<br>                max(sal)<br>        from<br>                emp<br>        group by<br>                job;<br>        mysql&gt; SELECT max(SAL) FROM EMP GROUP BY JOB;<br>        +———-+<br>        | max(SAL) |<br>        +———-+<br>        |  3000.00 |<br>        |  1300.00 |<br>        |  2975.00 |<br>        |  5000.00 |<br>        |  1600.00 |<br>        +———-+<br>        5 rows in set (0.00 sec)</p><pre><code>    以上的SQL语句表示，先按照job分组，然后对每一组使用max(sal)求最高薪水。    以上查询结果是5条记录。        工作岗位可以写到select后面吗？        可以，因为正好工作岗位job也是5个不同的值。        select                 job,max(sal)        from                 emp        group by                job;        mysql&gt; SELECT JOB,max(SAL) FROM EMP GROUP BY JOB;        +-----------+----------+        | JOB       | max(SAL) |        +-----------+----------+        | ANALYST   |  3000.00 |        | CLERK     |  1300.00 |        | MANAGER   |  2975.00 |        | PRESIDENT |  5000.00 |        | SALESMAN  |  1600.00 |        +-----------+----------+        5 rows in set (0.00 sec)    ename可以编写到select后面吗？            - mysql中，可以，语法在这方面比较松散，不严格，但是查询结果没有意义            - oracle中，不可以，执行的时候报错。                select                 ename,job,max(sal)        from                emp        group by                job;        mysql&gt; select ENAME,JOB,MAX(SAL) FROM EMP GROUP BY JOB;            ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;bjpowernode.EMP.ENAME&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by            mysql&gt; SELECT ENAME,JOB,max(SAL) from EMP group by JOB;            ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;bjpowernode.EMP.ENAME&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by    *重点：若一条SQL语句当中有group by子句，那么select关键子后面只能跟参与分组的字段和分组的函数。*2.3 案例：计算每个部门的平均薪水【按照部门编号分组，对每一组求平均薪水】    mysql&gt; select deptno,avg(sal) as avgsal from emp group by deptno;    mysql&gt; SELECT DEPTNO,avg(SAL) as avgsal FROM EMP GROUP BY DEPTNO;    +--------+-------------+    | DEPTNO | avgsal      |    +--------+-------------+    |     10 | 3150.000000 |    |     20 | 2220.833333 |    |     30 | 1566.666667 |    +--------+-------------+    3 rows in set (0.00 sec)    mysql&gt; SELECT * FROM DEPT;    +--------+------------+-----------+    | DEPTNO | DNAME      | LOC       |    +--------+------------+-----------+    |     10 | ACCOUNTING | NEW YOURK |    |     20 | RESEARCH   | DALLAS    |    |     30 | SALES      | CHICAGO   |    |     40 | OPERATIONS | BOSTON    |    +--------+------------+-----------+    4 rows in set (0.00 sec)    mysql&gt; SELECT * FROM EMP;    +-------+--------+-----------+------+------------+---------+---------+--------+    | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |    +-------+--------+-----------+------+------------+---------+---------+--------+    |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |    |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |    |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |    |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |    |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |    |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |    |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |    |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |    |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |    |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |    |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |    |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |    |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |    |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |    +-------+--------+-----------+------+------------+---------+---------+--------+2.4 案例：计算不同部门中的不同岗位的最高薪水    select deptno,job,max(sal) from emp group by deptno,job;   //deptno,job两个字段联合起来分组。    mysql&gt; SELECT DEPTNO, JOB,max(SAL) from EMP group by DEPTNO,JOB;    +--------+-----------+----------+    | DEPTNO | JOB       | max(SAL) |    +--------+-----------+----------+    |     10 | CLERK     |  1300.00 |    |     10 | PRESIDENT |  5000.00 |    |     20 | ANALYST   |  3000.00 |    |     20 | CLERK     |  1100.00 |    |     20 | MANAGER   |  2975.00 |    |     30 | CLERK     |   950.00 |    |     30 | MANAGER   |  2850.00 |    |     30 | SALESMAN  |  1600.00 |    +--------+-----------+----------+    8 rows in set (0.00 sec)2.5 找出每个工作岗位的最高薪水，除MANAGER之外    mysql&gt; select job,max(sal) from emp group by job;        mysql&gt; SELECT JOB,max(SAL) from EMP group by JOB;        +-----------+----------+        | JOB       | max(SAL) |        +-----------+----------+        | ANALYST   |  3000.00 |        | CLERK     |  1300.00 |        | MANAGER   |  2975.00 |        | PRESIDENT |  5000.00 |        | SALESMAN  |  1600.00 |        +-----------+----------+        5 rows in set (0.00 sec)    mysql&gt; select job,max(sal) from emp where job&lt;&gt;&#39;MANAGER&#39; group by job;    mysql&gt;     mysql&gt; SELECT JOB,max(SAL) from EMP where JOB&lt;&gt;&#39;MANAGER&#39; GROUP BY JOB;    +-----------+----------+    | JOB       | max(SAL) |    +-----------+----------+    | ANALYST   |  3000.00 |    | CLERK     |  1300.00 |    | PRESIDENT |  5000.00 |    | SALESMAN  |  1600.00 |    +-----------+----------+    4 rows in set (0.00 sec)2.6 找出每个工作岗位的平均薪水，要求显示平均薪水大于1500.    select job,avg(sal)  from emp group by job;    select job,avg(sal) from emp where avg(sal)&gt;1500 group by job;    ERROR 1111(HY00):Invalid user of group function    where关键字后面不能使用分组函数.    分组函数必须在分组完成后执行，而分组需要group by,而group by在where后面执行。注意：下面这个SQL语句执行会报错误：Group function is not allowed here    找出公司中哪些部门的平均薪水大于6000的列出来：        select                 department_id, avg(salary)        from                    employees        where                 avg(salary)&gt;6000        group by department_id        #having avg(salary) &gt;6000        ;    原因：        sql语句的执行顺序为：            from         子句            where        子句            group by     子句            having         子句            order by     子句            select         子句        首先得知道分组/聚合函数是对结果集运算的，当在where子句使用聚合函数时，此时根据group by分割结果集的子句还没有执行，此时只有from后的结果集。        所以无法在where子句中使用聚合函数。</code></pre><ol start="3"><li><p>having</p><pre><code>  having 和 where功能都是为了完成数据的过滤  where和having后面都是添加条件  *where  在group by之前完成过滤*  *having 在group by之后完成过滤*  案例：找出每个工作岗位的平均薪水，要求显示平均薪水大于1500  select           job,avg(sal)  from          emp  group by          job  having          avg(sal)&gt;1500;  mysql&gt; SELECT JOB,avg(SAL) FROM EMP group by JOB having avg(SAL) &gt;1500;  +-----------+-------------+  | JOB       | avg(SAL)    |  +-----------+-------------+  | ANALYST   | 3000.000000 |  | MANAGER   | 2758.333333 |  | PRESIDENT | 5000.000000 |  +-----------+-------------+  3 rows in set (0.00 sec)</code></pre></li></ol><pre><code>    原则：            尽量在where中过滤，无法过滤的数据，通常都是需要先分组之后再过滤的，这个时候可以选择使用having。            效率的问题</code></pre><ol start="4"><li><p>一个完整的DQL语句的总结<br>  select</p><pre><code>      ...</code></pre><p>  from</p><pre><code>      ...</code></pre><p>  where</p><pre><code>      ...</code></pre><p>  group by</p><pre><code>      ...</code></pre><p>  having </p><pre><code>      ...</code></pre><p>  order by</p><pre><code>      ...</code></pre><p>  第一：以上的关键字顺序不能变，严格遵守<br>  第二：执行顺序</p><pre><code>      1.from       从某张表中检索数据      2.where      经过某条件进行过滤      3.group by      然后分组      4.having     分组之后不满意再过滤      5.select     查询出来      6.order by   排序输出</code></pre></li></ol><p>连接查询<br>    1 什么是连接查询？<br>            - 查询的时候只从一张表检索数据，被称为单表查询<br>            - 在实际的开发中，数据并不是存储在一张表中的，是同时存储在多张表中<br>                这些表和表之间存在关系，我们在检索的时候通常是需要将多张表联合起来取得有效数据，<br>                这种多表查询被称为连接查询或者叫做跨表查询。<br>    2 连接查询根据出现年代分类：<br>            - SQL92【1992】<br>            - SQL99【1999：更新的语法，主要掌握这种语法】<br>            DBA: DataBase Administrator【数据库管理员，薪水很高】<br>            老的DBA可能还在编写SQL92语法，所以SQL92语法也要会，起码能看懂。<br>    3 连接查询根据连接方式可以分为：<br>            - 内连接<br>                * 等值连接<br>                * 非等值连接<br>                * 自连接<br>            - 外链接<br>                * 左外连接（左连接）<br>                * 右外连接(右连接)<br>            - 全连接【不讲，使用很少】</p><pre><code>4 当多张表进行连接查询，若没有任何条件进行限制，会发生什么现象？    案例：查询每一个员工所在的部门名称，要求最终显示员工名和对应的部门名。    SELECT ENAME,DEPTNO FROM EMP;&lt;emp是员工表&gt;    mysql&gt; SELECT ENAME,DEPTNO FROM EMP;    +--------+--------+    | ENAME  | DEPTNO |    +--------+--------+    | SMITH  |     20 |    | ALLEN  |     30 |    | WARD   |     30 |    | JONES  |     20 |    | MARTIN |     30 |    | BLAKE  |     30 |    | CLARK  |     20 |    | SCOTT  |     20 |    | KING   |     10 |    | TURNER |     30 |    | ADAMS  |     20 |    | JAMES  |     30 |    | FORD   |     20 |    | MILLER |     10 |    +--------+--------+    14 rows in set (0.00 sec)    SELECT DEPTNO,DNAME FROM DEPT;&lt;dept是部门表&gt;    mysql&gt; SELECT DEPTNO,DNAME FROM DEPT;    +--------+------------+    | DEPTNO | DNAME      |    +--------+------------+    |     10 | ACCOUNTING |    |     20 | RESEARCH   |    |     30 | SALES      |    |     40 | OPERATIONS |    +--------+------------+    4 rows in set (0.00 sec)    主要分析：多张表连接查询，若没有任何条件限制，会发生什么？    小知识点：在进行多表连接查询的时候，尽量给表起别名，这样效率高，可读性高。    mysql&gt; select e.ENAME,d.DNAME from EMP e,DEPT d;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | ACCOUNTING |    | SMITH  | RESEARCH   |    | SMITH  | SALES      |    | SMITH  | OPERATIONS |    | ALLEN  | ACCOUNTING |    | ALLEN  | RESEARCH   |    | ALLEN  | SALES      |    | ALLEN  | OPERATIONS |    | WARD   | ACCOUNTING |    | WARD   | RESEARCH   |    | WARD   | SALES      |    | WARD   | OPERATIONS |    | JONES  | ACCOUNTING |    | JONES  | RESEARCH   |    | JONES  | SALES      |    | JONES  | OPERATIONS |    | MARTIN | ACCOUNTING |    | MARTIN | RESEARCH   |    | MARTIN | SALES      |    | MARTIN | OPERATIONS |    | BLAKE  | ACCOUNTING |    | BLAKE  | RESEARCH   |    | BLAKE  | SALES      |    | BLAKE  | OPERATIONS |    | CLARK  | ACCOUNTING |    | CLARK  | RESEARCH   |    | CLARK  | SALES      |    | CLARK  | OPERATIONS |    | SCOTT  | ACCOUNTING |    | SCOTT  | RESEARCH   |    | SCOTT  | SALES      |    | SCOTT  | OPERATIONS |    | KING   | ACCOUNTING |    | KING   | RESEARCH   |    | KING   | SALES      |    | KING   | OPERATIONS |    | TURNER | ACCOUNTING |    | TURNER | RESEARCH   |    | TURNER | SALES      |    | TURNER | OPERATIONS |    | ADAMS  | ACCOUNTING |    | ADAMS  | RESEARCH   |    | ADAMS  | SALES      |    | ADAMS  | OPERATIONS |    | JAMES  | ACCOUNTING |    | JAMES  | RESEARCH   |    | JAMES  | SALES      |    | JAMES  | OPERATIONS |    | FORD   | ACCOUNTING |    | FORD   | RESEARCH   |    | FORD   | SALES      |    | FORD   | OPERATIONS |    | MILLER | ACCOUNTING |    | MILLER | RESEARCH   |    | MILLER | SALES      |    | MILLER | OPERATIONS |    +--------+------------+    56 rows in set (0.00 sec)结论：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录条数乘积，这种现象被称为笛卡尔积现象。为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件。5    案例：查询每一个员工所在的部门名称，要求最终显示员工名和对应的部门名。    mysql&gt; SELECT ENAME,DEPTNO FROM EMP;   &lt;EMP是员工表&gt;    +--------+--------+    | ENAME  | DEPTNO |    +--------+--------+    | SMITH  |     20 |    | ALLEN  |     30 |    | WARD   |     30 |    | JONES  |     20 |    | MARTIN |     30 |    | BLAKE  |     30 |    | CLARK  |     20 |    | SCOTT  |     20 |    | KING   |     10 |    | TURNER |     30 |    | ADAMS  |     20 |    | JAMES  |     30 |    | FORD   |     20 |    | MILLER |     10 |    +--------+--------+    14 rows in set (0.00 sec)mysql&gt; SELECT DEPTNO,DNAME FROM DEPT;&lt;DEPT是部门表&gt;    +--------+------------+    | DEPTNO | DNAME      |    +--------+------------+    |     10 | ACCOUNTING |    |     20 | RESEARCH   |    |     30 | SALES      |    |     40 | OPERATIONS |    +--------+------------+    4 rows in set (0.00 sec)注意：在连接查询的时候虽然使用了限制条件，但是匹配的次数没有减少，还是56次，只不过这一次的结果都是有效记录。SQL92语法：内连接中的等值连接mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e, DEPT d where e.DEPTNO = d.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)SQL99语法：内连接中的等值连接SQL99语法的优点：表连接独立出来了，结构更清晰，对表连接不满意的话，可以再追加where进行过滤。mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e join DEPT d on e.DEPTNO = d.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e inner join DEPT d on e.DEPTNO = d.DEPTNO; //inner可以省略mysql&gt; SELECT e.ENAME,d.DNAME FROM EMP e inner join DEPT d on e.DEPTNO = d.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)6. 案例：找出每一个员工对应的工资等级，要求显示员工名、工资等级。mysql&gt; SELECT * FROM SALGRADE;+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+5 rows in set (0.00 sec)mysql&gt; SELECT * FROM EMP;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+14 rows in set (0.00 sec)mysql&gt; SELECT * from EMP E, SALGRADE S WHERE E.SAL between S.LOSAL AND S.HISAL;+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | GRADE | LOSAL | HISAL |+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |     1 |   700 |  1200 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     3 |  1401 |  2000 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     2 |  1201 |  1400 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     2 |  1201 |  1400 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |     4 |  2001 |  3000 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |     5 |  3001 |  9999 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     3 |  1401 |  2000 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |     1 |   700 |  1200 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |     1 |   700 |  1200 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |     4 |  2001 |  3000 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |     2 |  1201 |  1400 |+-------+--------+-----------+------+------------+---------+---------+--------+-------+-------+-------+14 rows in set (0.00 sec)mysql&gt; SELECT E.ENAME,E.SAL,S.GRADE from EMP E, SALGRADE S WHERE E.SAL between S.LOSAL AND S.HISAL;+--------+---------+-------+| ENAME  | SAL     | GRADE |+--------+---------+-------+| SMITH  |  800.00 |     1 || ALLEN  | 1600.00 |     3 || WARD   | 1250.00 |     2 || JONES  | 2975.00 |     4 || MARTIN | 1250.00 |     2 || BLAKE  | 2850.00 |     4 || CLARK  | 2450.00 |     4 || SCOTT  | 3000.00 |     4 || KING   | 5000.00 |     5 || TURNER | 1500.00 |     3 || ADAMS  | 1100.00 |     1 || JAMES  |  950.00 |     1 || FORD   | 3000.00 |     4 || MILLER | 1300.00 |     2 |+--------+---------+-------+14 rows in set (0.00 sec)SQL99语法：内连接中的非等值连接    SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e inner join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;//inner可以省略    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e inner join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;    +--------+---------+-------+    | ENAME  | SAL     | GRADE |    +--------+---------+-------+    | SMITH  |  800.00 |     1 |    | ALLEN  | 1600.00 |     3 |    | WARD   | 1250.00 |     2 |    | JONES  | 2975.00 |     4 |    | MARTIN | 1250.00 |     2 |    | BLAKE  | 2850.00 |     4 |    | CLARK  | 2450.00 |     4 |    | SCOTT  | 3000.00 |     4 |    | KING   | 5000.00 |     5 |    | TURNER | 1500.00 |     3 |    | ADAMS  | 1100.00 |     1 |    | JAMES  |  950.00 |     1 |    | FORD   | 3000.00 |     4 |    | MILLER | 1300.00 |     2 |    +--------+---------+-------+    14 rows in set (0.00 sec)    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e join SALGRADE s on e.SAL between s.LOSAL and s.HISAL;    +--------+---------+-------+    | ENAME  | SAL     | GRADE |    +--------+---------+-------+    | SMITH  |  800.00 |     1 |    | ALLEN  | 1600.00 |     3 |    | WARD   | 1250.00 |     2 |    | JONES  | 2975.00 |     4 |    | MARTIN | 1250.00 |     2 |    | BLAKE  | 2850.00 |     4 |    | CLARK  | 2450.00 |     4 |    | SCOTT  | 3000.00 |     4 |    | KING   | 5000.00 |     5 |    | TURNER | 1500.00 |     3 |    | ADAMS  | 1100.00 |     1 |    | JAMES  |  950.00 |     1 |    | FORD   | 3000.00 |     4 |    | MILLER | 1300.00 |     2 |    +--------+---------+-------+    14 rows in set (0.00 sec)SQL92语法：内连接中的非等值连接    mysql&gt; SELECT e.ENAME,e.SAL,s.GRADE FROM EMP e, SALGRADE s where e.SAL between s.LOSAL and s.HISAL;    +--------+---------+-------+    | ENAME  | SAL     | GRADE |    +--------+---------+-------+    | SMITH  |  800.00 |     1 |    | ALLEN  | 1600.00 |     3 |    | WARD   | 1250.00 |     2 |    | JONES  | 2975.00 |     4 |    | MARTIN | 1250.00 |     2 |    | BLAKE  | 2850.00 |     4 |    | CLARK  | 2450.00 |     4 |    | SCOTT  | 3000.00 |     4 |    | KING   | 5000.00 |     5 |    | TURNER | 1500.00 |     3 |    | ADAMS  | 1100.00 |     1 |    | JAMES  |  950.00 |     1 |    | FORD   | 3000.00 |     4 |    | MILLER | 1300.00 |     2 |    +--------+---------+-------+    14 rows in set (0.00 sec)7.     案例：找出每一个员工的上级领导，要求显示员工名以及对应的领导名    SQL92语法：内连接中的自连接    select a.ename empname,b.ename leadername from emp a, emp b where a.mgr = b.empno;    mysql&gt; SELECT * FROM EMP;    +-------+--------+-----------+------+------------+---------+---------+--------+    | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |    +-------+--------+-----------+------+------------+---------+---------+--------+    |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |    |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |    |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |    |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |    |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |    |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |    |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |    |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |    |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |    |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |    |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |    |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |    |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |    |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |    +-------+--------+-----------+------+------------+---------+---------+--------+    14 rows in set (0.00 sec)    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A,EMP B WHERE A.MGR = B.EMPNO;    +---------+------------+    | EMPNAME | LEADERNAME |    +---------+------------+    | SMITH   | FORD       |    | ALLEN   | BLAKE      |    | WARD    | BLAKE      |    | JONES   | KING       |    | MARTIN  | BLAKE      |    | BLAKE   | KING       |    | CLARK   | KING       |    | SCOTT   | JONES      |    | TURNER  | BLAKE      |    | ADAMS   | SCOTT      |    | JAMES   | BLAKE      |    | FORD    | JONES      |    | MILLER  | CLARK      |    +---------+------------+    13 rows in set (0.00 sec)    SQL99语法：内连接中的自连接    select a.ename empname,b.ename leadername from emp a inner *join* emp b *on* a.mgr=b.empno;//inner可以省略    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A INNER JOIN EMP B ON A.MGR = B.EMPNO;    +---------+------------+    | EMPNAME | LEADERNAME |    +---------+------------+    | SMITH   | FORD       |    | ALLEN   | BLAKE      |    | WARD    | BLAKE      |    | JONES   | KING       |    | MARTIN  | BLAKE      |    | BLAKE   | KING       |    | CLARK   | KING       |    | SCOTT   | JONES      |    | TURNER  | BLAKE      |    | ADAMS   | SCOTT      |    | JAMES   | BLAKE      |    | FORD    | JONES      |    | MILLER  | CLARK      |    +---------+------------+    13 rows in set (0.00 sec)    select a.ename empname,b.ename leadername from emp a join emp b on a.mgr=b.empno;    mysql&gt; SELECT A.ENAME EMPNAME,B.ENAME LEADERNAME FROM EMP A JOIN EMP B ON A.MGR=B.EMPNO;    +---------+------------+    | EMPNAME | LEADERNAME |    +---------+------------+    | SMITH   | FORD       |    | ALLEN   | BLAKE      |    | WARD    | BLAKE      |    | JONES   | KING       |    | MARTIN  | BLAKE      |    | BLAKE   | KING       |    | CLARK   | KING       |    | SCOTT   | JONES      |    | TURNER  | BLAKE      |    | ADAMS   | SCOTT      |    | JAMES   | BLAKE      |    | FORD    | JONES      |    | MILLER  | CLARK      |    +---------+------------+    13 rows in set (0.00 sec)8、案例：找出每一个员工对应的部门名称,要求显示所有部门    内连接：        A表和B表能够完全匹配的记录查询出来，被称为内连接    外连接：        A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录，会自动模拟出NULL与之匹配，这种查询被称为外连接。        外连接的查询结果条数 &gt;= 内连接的查询结果条数    select e.ename, d.dname from emp e join dept d on e.deptno=d.deptno;    mysql&gt; SELECT * FROM DEPT;    +--------+------------+-----------+    | DEPTNO | DNAME      | LOC       |    +--------+------------+-----------+    |     10 | ACCOUNTING | NEW YOURK |    |     20 | RESEARCH   | DALLAS    |    |     30 | SALES      | CHICAGO   |    |     40 | OPERATIONS | BOSTON    |    +--------+------------+-----------+    4 rows in set (0.00 sec)    有四个部门    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    +--------+------------+    14 rows in set (0.00 sec)    14条记录只显示了三个部门    SQL99语法：外连接中的右外连接[右外连接]    select e.ename, d.dname from emp e right join dept d on e.deptno=d.deptno;    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E RIGHT JOIN DEPT D ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    15条记录显示了，所有4个部门    select e.ename,d.dname from emp e right outer join dept d on e.deptno=d.deptno; //outer可以省略    mysql&gt; SELECT E.ENAME,D.DNAME FROM EMP E RIGHT OUTER JOIN DEPT D ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    SQL99语法：外连接中的左外连接[左外连接]    select e.ename, d.dname from dept d left join emp e on e.deptno=d.deptno;    mysql&gt; SELECT E.ENAME,D.DNAME FROM DEPT D LEFT JOIN EMP E ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    select e.ename,d.dname from dept d left outer join emp e on e.deptno=d.deptno; //outer可以省略    mysql&gt; SELECT E.ENAME,D.DNAME FROM DEPT D LEFT OUTER JOIN EMP E ON E.DEPTNO=D.DEPTNO;    +--------+------------+    | ENAME  | DNAME      |    +--------+------------+    | SMITH  | RESEARCH   |    | ALLEN  | SALES      |    | WARD   | SALES      |    | JONES  | RESEARCH   |    | MARTIN | SALES      |    | BLAKE  | SALES      |    | CLARK  | RESEARCH   |    | SCOTT  | RESEARCH   |    | KING   | ACCOUNTING |    | TURNER | SALES      |    | ADAMS  | RESEARCH   |    | JAMES  | SALES      |    | FORD   | RESEARCH   |    | MILLER | ACCOUNTING |    | NULL   | OPERATIONS |    +--------+------------+    15 rows in set (0.00 sec)    注意：任何一个右外连接都可以写成左外连接，任何一个左外连接也同样可以写成右外连接为什么inner和outter可以省略，加上去有什么好处？        -    可以省略，因为区分内连接和外连接依靠的不是这些关键字，而是看SQL语句中是否存在left/right            若存在，表示一定是一个外连接，其它都是内连接。        -    加上去的好处是增强可读性。9.    案例：找出每一个员工对应的领导名，要求显示所有的员工        select A.ENAME EMPNAME,B.ENAME LEADERNAME from EMP A left join EMP B on A.mgr=B.empno;        SELECT B.ENAME LEADERNAME, A.ENAME EMPNAME FROM EMP B RIGHT OUTER JOIN EMP A ON A.MGR=B.EMPNO;    mysql&gt; SELECT B.ENAME LEADERNAME, A.ENAME EMPNAME FROM EMP B RIGHT OUTER JOIN EMP A ON A.MGR=B.EMPNO;        +------------+---------+        | LEADERNAME | EMPNAME |        +------------+---------+        | FORD       | SMITH   |        | BLAKE      | ALLEN   |        | BLAKE      | WARD    |        | KING       | JONES   |        | BLAKE      | MARTIN  |        | KING       | BLAKE   |        | KING       | CLARK   |        | JONES      | SCOTT   |        | NULL       | KING    |        | BLAKE      | TURNER  |        | SCOTT      | ADAMS   |        | BLAKE      | JAMES   |        | JONES      | FORD    |        | CLARK      | MILLER  |        +------------+---------+        14 rows in set (0.00 sec)        mysql&gt; select A.ENAME EMPNAME,B.ENAME LEADERNAME from EMP A left OUTER join EMP B on A.mgr=B.empno;        +---------+------------+        | EMPNAME | LEADERNAME |        +---------+------------+        | SMITH   | FORD       |        | ALLEN   | BLAKE      |        | WARD    | BLAKE      |        | JONES   | KING       |        | MARTIN  | BLAKE      |        | BLAKE   | KING       |        | CLARK   | KING       |        | SCOTT   | JONES      |        | KING    | NULL       |        | TURNER  | BLAKE      |        | ADAMS   | SCOTT      |        | JAMES   | BLAKE      |        | FORD    | JONES      |        | MILLER  | CLARK      |        +---------+------------+        14 rows in set (0.01 sec)</code></pre><p>10    案例：找出每一个员工对应的部门名称，以及该员工对应的工资等级。要求显示员工名、部门名、工资等级</p><pre><code>*多张表进行表连接的语法格式*select         xxxfrom        ajoin        bon        条件join        con        条件原理：a和b表进行表连接1    先找出每一个员工对应的部门名称，显示员工名、部门名        mysql&gt; SELECT A.ENAME EMPNAME ,B.DNAME DEPTNAME FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO ;        +---------+------------+        | EMPNAME | DEPTNAME   |        +---------+------------+        | SMITH   | RESEARCH   |        | ALLEN   | SALES      |        | WARD    | SALES      |        | JONES   | RESEARCH   |        | MARTIN  | SALES      |        | BLAKE   | SALES      |        | CLARK   | RESEARCH   |        | SCOTT   | RESEARCH   |        | KING    | ACCOUNTING |        | TURNER  | SALES      |        | ADAMS   | RESEARCH   |        | JAMES   | SALES      |        | FORD    | RESEARCH   |        | MILLER  | ACCOUNTING |        +---------+------------+        14 rows in set (0.00 sec)mysql&gt; SELECT * FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO ;+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO | DEPTNO | DNAME      | LOC       |+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+|  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |     30 | SALES      | CHICAGO   ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |     30 | SALES      | CHICAGO   ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |     30 | SALES      | CHICAGO   ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |     30 | SALES      | CHICAGO   ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |     10 | ACCOUNTING | NEW YOURK ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |     30 | SALES      | CHICAGO   ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |     30 | SALES      | CHICAGO   ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |     20 | RESEARCH   | DALLAS    ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |     10 | ACCOUNTING | NEW YOURK |+-------+--------+-----------+------+------------+---------+---------+--------+--------+------------+-----------+14 rows in set (0.00 sec)    mysql&gt; SELECT A.ENAME EMPNAME ,A.SAL EMPSAL ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL&gt;C.LOSAL AND A.SAL&lt;C.HISAL ;    +---------+------------+-------+    | EMPNAME | DEPTNAME   | GRADE |    +---------+------------+-------+    | SMITH   | RESEARCH   |     1 |    | ALLEN   | SALES      |     3 |    | WARD    | SALES      |     2 |    | JONES   | RESEARCH   |     4 |    | MARTIN  | SALES      |     2 |    | BLAKE   | SALES      |     4 |    | CLARK   | RESEARCH   |     4 |    | KING    | ACCOUNTING |     5 |    | TURNER  | SALES      |     3 |    | ADAMS   | RESEARCH   |     1 |    | JAMES   | SALES      |     1 |    | MILLER  | ACCOUNTING |     2 |    +---------+------------+-------+    12 rows in set (0.00 sec    mysql&gt; SELECT A.ENAME EMPNAME ,A.SAL EMPSAL ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL&gt;C.LOSAL AND A.SAL&lt;C.HISAL ;        +---------+---------+------------+-------+        | EMPNAME | EMPSAL  | DEPTNAME   | GRADE |        +---------+---------+------------+-------+        | SMITH   |  800.00 | RESEARCH   |     1 |        | ALLEN   | 1600.00 | SALES      |     3 |        | WARD    | 1250.00 | SALES      |     2 |        | JONES   | 2975.00 | RESEARCH   |     4 |        | MARTIN  | 1250.00 | SALES      |     2 |        | BLAKE   | 2850.00 | SALES      |     4 |        | CLARK   | 2450.00 | RESEARCH   |     4 |        | KING    | 5000.00 | ACCOUNTING |     5 |        | TURNER  | 1500.00 | SALES      |     3 |        | ADAMS   | 1100.00 | RESEARCH   |     1 |        | JAMES   |  950.00 | SALES      |     1 |        | MILLER  | 1300.00 | ACCOUNTING |     2 |        +---------+---------+------------+-------+        12 rows in set (0.00 sec)        mysql&gt; SELECT * FROM SALGRADE;        +-------+-------+-------+        | GRADE | LOSAL | HISAL |        +-------+-------+-------+        |     1 |   700 |  1200 |        |     2 |  1201 |  1400 |        |     3 |  1401 |  2000 |        |     4 |  2001 |  3000 |        |     5 |  3001 |  9999 |        +-------+-------+-------+        5 rows in set (0.00 sec)    mysql&gt; SELECT A.ENAME EMPNAME ,B.DNAME DEPTNAME,C.GRADE GRADE FROM EMP A JOIN DEPT B ON A.DEPTNO = B.DEPTNO JOIN SALGRADE C ON A.SAL BETWEEN C.LOSAL AND HISAL ;    +---------+------------+-------+    | EMPNAME | DEPTNAME   | GRADE |    +---------+------------+-------+    | SMITH   | RESEARCH   |     1 |    | ALLEN   | SALES      |     3 |    | WARD    | SALES      |     2 |    | JONES   | RESEARCH   |     4 |    | MARTIN  | SALES      |     2 |    | BLAKE   | SALES      |     4 |    | CLARK   | RESEARCH   |     4 |    | SCOTT   | RESEARCH   |     4 |    | KING    | ACCOUNTING |     5 |    | TURNER  | SALES      |     3 |    | ADAMS   | RESEARCH   |     1 |    | JAMES   | SALES      |     1 |    | FORD    | RESEARCH   |     4 |    | MILLER  | ACCOUNTING |     2 |    +---------+------------+-------+    14 rows in set (0.00 sec)</code></pre><p>子查询<br>子查询就是嵌套的select语句，可以理解为子查询是一张表<br>    在where语句中使用子查询，也就是在where语句中加入select语句<br>    1、什么是子查询？<br>        - select 语句嵌套select语句<br>    2、子查询可以出现在哪？<br>        select …(select)<br>        from…(select)<br>        where…(select)<br>    WHERE后面使用子查询<br>    3、案例：找出薪水比公司平均薪水高的员工，显示员工名和薪水</p><pre><code>select ENAME,SAL from EMP where SAL &gt;avg(SAL);以上语句执行报错，分组函数不能直接使用在where后面第一步： 找出公司的平均薪水mysql&gt; select avg(SAL) from EMP;+-------------+| avg(SAL)    |+-------------+| 2073.214286 |+-------------+1 row in set (0.00 sec)第二步：找出薪水大于平均薪水的员工信息：mysql&gt; SELECT ENAME,SAL FROM EMP WHERE SAL &gt; (select avg(SAL) from EMP);+-------+---------+| ENAME | SAL     |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING  | 5000.00 || FORD  | 3000.00 |+-------+---------+6 rows in set (0.00 sec)</code></pre><p>4.from后面使用子查询【小窍门：将查询语句当作临时表】<br>    案例：  找出每一个部门的平均薪水，并且要求显示平均薪水的薪水等级。<br>    第一步：找出每个部门的平均薪水<br>    select DEPTNO,avg(SAL) from EMP group by DEPTNO;<br>    mysql&gt; select DEPTNO,avg(SAL) avgsal from EMP group by DEPTNO;<br>    +——–+————-+<br>    | DEPTNO | avgsal      |<br>    +——–+————-+<br>    |     10 | 3150.000000 |<br>    |     20 | 2220.833333 |<br>    |     30 | 1566.666667 |<br>    +——–+————-+<br>    3 rows in set (0.00 sec)</p><pre><code>第二步：将上面查询结果当作临时表t,t表和salgrade s表进行连接，条件：t.avgsal between s.losal and s.hisal;mysql&gt; select a.avgsal , b.GRADE from (select DEPTNO,avg(SAL) avgsal from EMP group by DEPTNO) a join SALGRADE b on a.avgsal between b.LOSAL and b.HISAL ;+-------------+-------+| avgsal      | GRADE |+-------------+-------+| 3150.000000 |     5 || 2220.833333 |     4 || 1566.666667 |     3 |+-------------+-------+3 rows in set (0.00 sec)</code></pre><p>5     在select后面使用子查询【了解】<br>    mysql&gt; SELECT E.ENAME,(SELECT D.DNAME FROM DEPT D WHERE E.DEPTNO=D.DEPTNO) AS DNAME FROM EMP E;<br>    +——–+————+<br>    | ENAME  | DNAME      |<br>    +——–+————+<br>    | SMITH  | RESEARCH   |<br>    | ALLEN  | SALES      |<br>    | WARD   | SALES      |<br>    | JONES  | RESEARCH   |<br>    | MARTIN | SALES      |<br>    | BLAKE  | SALES      |<br>    | CLARK  | RESEARCH   |<br>    | SCOTT  | RESEARCH   |<br>    | KING   | ACCOUNTING |<br>    | TURNER | SALES      |<br>    | ADAMS  | RESEARCH   |<br>    | JAMES  | SALES      |<br>    | FORD   | RESEARCH   |<br>    | MILLER | ACCOUNTING |<br>    +——–+————+<br>    14 rows in set (0.00 sec)</p><p>union</p><pre><code>mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB = &#39;MANAGER&#39; OR JOB=&#39;SALESMAN&#39;;+--------+----------+| ENAME  | JOB      |+--------+----------+| ALLEN  | SALESMAN || WARD   | SALESMAN || JONES  | MANAGER  || MARTIN | SALESMAN || BLAKE  | MANAGER  || CLARK  | MANAGER  || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec)mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;MANAGER&#39;;+-------+---------+| ENAME | JOB     |+-------+---------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER |+-------+---------+3 rows in set (0.01 sec)mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;SALESMAN&#39;;+--------+----------+| ENAME  | JOB      |+--------+----------+| ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+4 rows in set (0.00 sec)mysql&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;MANAGER&#39;     -&gt; UNION    -&gt; SELECT ENAME,JOB FROM EMP WHERE JOB=&#39;SALESMAN&#39;;+--------+----------+| ENAME  | JOB      |+--------+----------+| JONES  | MANAGER  || BLAKE  | MANAGER  || CLARK  | MANAGER  || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+7 rows in set (0.00 sec)</code></pre><p>LIMIT<br>    1     limit用来获取一张表中的某部分数据<br>    2    limit只有在MYSQL数据库中存在，不通用，是MYSQL数据库管理系统的特色。</p><pre><code>3     案例：找出员工表前5条记录    mysql&gt; SELECT ENAME FROM EMP limit 5;    +--------+    | ENAME  |    +--------+    | SMITH  |    | ALLEN  |    | WARD   |    | JONES  |    | MARTIN |    +--------+    5 rows in set (0.00 sec)    以上SQL语句的&quot;limit 5&quot;中的5表示从表中记录下表0开始，取5条等同于下面的SQL语句：    mysql&gt; select ENAME FROM EMP LIMIT 0,5;    +--------+    | ENAME  |    +--------+    | SMITH  |    | ALLEN  |    | WARD   |    | JONES  |    | MARTIN |    +--------+    5 rows in set (0.00 sec)    LIMIT的使用语法格式：        limit起始下标，长度        起始下标没有指定，默认从0开始，0表示表中第一条记录。4    案例：找出公司中工资排名在前5名的员工    思路：按照工资降序排列取前5个    mysql&gt;     mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC;    +--------+---------+    | ENAME  | SAL     |    +--------+---------+    | KING   | 5000.00 |    | SCOTT  | 3000.00 |    | FORD   | 3000.00 |    | JONES  | 2975.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | ALLEN  | 1600.00 |    | TURNER | 1500.00 |    | MILLER | 1300.00 |    | WARD   | 1250.00 |    | MARTIN | 1250.00 |    | ADAMS  | 1100.00 |    | JAMES  |  950.00 |    | SMITH  |  800.00 |    +--------+---------+    14 rows in set (0.01 sec)    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 5;    +-------+---------+    | ENAME | SAL     |    +-------+---------+    | KING  | 5000.00 |    | FORD  | 3000.00 |    | SCOTT | 3000.00 |    | JONES | 2975.00 |    | BLAKE | 2850.00 |    +-------+---------+    5 rows in set (0.00 sec)5     案例：找出工资排名【3-9】名的员工    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 3,9;    +--------+---------+    | ENAME  | SAL     |    +--------+---------+    | JONES  | 2975.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | ALLEN  | 1600.00 |    | TURNER | 1500.00 |    | MILLER | 1300.00 |    | WARD   | 1250.00 |    | MARTIN | 1250.00 |    | ADAMS  | 1100.00 |    +--------+---------+    9 rows in set (0.00 sec)    mysql&gt; select ENAME,SAL FROM EMP ORDER BY SAL DESC LIMIT 2,8;    +--------+---------+    | ENAME  | SAL     |    +--------+---------+    | SCOTT  | 3000.00 |    | JONES  | 2975.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | ALLEN  | 1600.00 |    | TURNER | 1500.00 |    | MILLER | 1300.00 |    | WARD   | 1250.00 |    +--------+---------+    8 rows in set (0.00 sec)6     MYSQL中通用的分页SQL语句：    每页显示3条记录    第一页：0,3    第二页：3,3    第三页：6,3    第四页：9,3    每页显示pageSize条记录    第pageNo页：( pageNo - 1 ) * pageSize , pageSize    SELECT         t.*    FROM        t    ORDER BY        t.x DESC/ASC    LIMIT ( pageNo - 1 ) * pageSize , pageSize</code></pre><p>创建表 DDL()</p><ul><li><p>语法格式：<br>create table tableName(<br>   columnName dataType(length),<br>   columnName dataType(length),<br>);<br>set character_set_results=’utf-8’;</p><p>表：<br>   1    表格(table),用来存储数据，表格是一种结构化文件。<br>   2    表格行被称为记录(表中的数据)，表格列被称为字段。<br>   3    表格的字段属性包括：字段名称、字段数据类型、字段长度、字段约束</p><p>   4    创建表的语法：</p><pre><code>   CREATE TABLE tablename(       columnname1 dataType(length),       columnname2 dataType(length),   );</code></pre><p>   5    关于MYSQL数据库中的数据类型？</p><pre><code>   -    VARCHAR           * 可变长度字符串           * VARCHAR(3) 表示存储的数据不能超过3个字符长度   -    CHAR           * 定长字符串           * VARCHAR和CHAR对比：               - 都是字符串类型               - VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间，                 但是在分配的时候需要执行相关的判断程序，效率较低               - CHAR不需要动态分配空间，所以执行效率很高，但是可能会导致空间浪费。               - 若字段中的数据布局配伸缩性，建议采用CHAR类型存储               - 若字段中的数据具备很强伸缩性，建议采用VARCHAR类型存储。               * CHAR(3)：表示存储的数据不能超过3个字符长度   -    INT           * 整数型           * INT(3) 表示最大可以存储999(老师课堂讲解有误)           INT(3) 3表示的是可以显示的有效长度(添加补零功能后，比较明显)               CREATE TABLE test01(                   with_int_length int(3),                   without_int_length int               )               insert into test01(with_int_length,without_int_length) values(1111,1111);               insert into test01(with_int_length,without_int_length) values(11111,11111);               commit;               mysql&gt; select * from test01;               +-----------------+--------------------+               | with_int_length | without_int_length |               +-----------------+--------------------+               |            1111 |               1111 |               |           11111 |              11111 |               +-----------------+--------------------+               2 rows in set (0.00 sec)               CREATE TABLE test02 (                 with_length int(3) ZEROFILL,                 without_length int               ) ENGINE=innodb, CHARSET=utf8               insert into test02 (with_length, without_length) VALUE (11, 11);               select * from test02;               mysql&gt; select * from test02;               +-------------+----------------+               | with_length | without_length |               +-------------+----------------+               |         011 |             11 |               +-------------+----------------+               1 row in set (0.01 sec)   -    BIGINT           * 长整型           * 对应Java程序中的long类型   -     FLOAT           * 浮点型单精度   -    DOUBLE           * 浮点型双精度           * DOUBLE(7,2)   表示7个有效数字，2个小数位   -    DATE           * 日期类型           * 在实际开发中为了通用，所以日期类型一般不使用，采用字符串代替日期比较多。   -    BLOB           *  Binary Large OBject 二进制大对象           * 专门存储图片声音视频等数据           *  数据库表中存储一个图片是很常见的，但是存储一个比较大的视频是很少见的。           一般都是提供一个视频的链接地址   -    CLOB           * Character Large OBject 二进制大对象           * 可以存储比较打的文本，4G+   -    其它</code></pre></li></ul><p>6    创建表格[学生表]<br>        设计：建立学生信息表，字段包括：<br>                学号 【INT】<br>                姓名 【VARCHAR】<br>                性别 【CHAR】<br>                出生日期【DATA】<br>                邮箱地址【VARCHAR】</p><pre><code>        建表语句：            CREATE TABLE t_student(            NO  INT(10),            NAME VARCHAR(32),            SEX  CHAR(1),            BIRTH DATE,            EMAIL VARCHAR(128)        );        注意：            * 表格的名字最好以t_ 或者 tb1_开始，增强可读性            * VARCHAR长度最好是2的倍数，方便存储中文        删除表格：            drop table t_student;【这种删除格式，若数据库没有这个表格，会报错】            drop table if exists t_student;【最好采用这种方式删除，mysql数据库管理系统的特色语法】        mysql&gt; desc t_student;        +-------+--------------+------+-----+---------+-------+        | Field | Type         | Null | Key | Default | Extra |        +-------+--------------+------+-----+---------+-------+        | NO    | int(10)      | YES  |     | NULL    |       |        | NAME  | varchar(32)  | YES  |     | NULL    |       |        | SEX   | char(1)      | YES  |     | NULL    |       |        | BIRTH | date         | YES  |     | NULL    |       |        | EMAIL | varchar(128) | YES  |     | NULL    |       |        +-------+--------------+------+-----+---------+-------+        5 rows in set (0.00 sec)7.     向t_student表格中插入数据    7.1 向表格插入数据必须使用insert语句，这属于DML语句    7.2 DML语句包括：insert,update,delete【增删改表中的数据，和表结构无关】    7.3    insert语句的语法格式：        INSERT INTO tablename(columnname1,columnname2,columnname3,...) values(value1,value2,value3,...)字段和值必须一一对应，个数必须相同，数据类型必须一致    7.4    向t_student表格中插入数据        INSERT INTO t_student(NO,NAME,SEX,BIRTH,EMAIL) values(1,&#39;cntsp&#39;,&#39;m&#39;,&#39;1948-11-51&#39;,&#39;cntsp@beijingpowernode.com&#39;);        INSERT INTO t_student(NO,NAME,SEX,BIRTH,EMAIL) values(2,&#39;zhongjie&#39;,&#39;m&#39;,&#39;1958-11-21&#39;,&#39;zhongjie@beijingpowernode.com&#39;);                mysql&gt; select * from t_student;        +------+----------+------+------------+-------------------------------+        | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |        +------+----------+------+------------+-------------------------------+        |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |        |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |        +------+----------+------+------------+-------------------------------+    7.5    可以这样执行insert语句吗？        INSERT INTO t_student(name,email) VALUES(&#39;wangwu&#39;,&#39;wangwu@bjpowernode.com&#39;);        mysql&gt; INSERT INTO t_student(name,email) VALUES(&#39;wangwu&#39;,&#39;wangwu@bjpowernode.com&#39;);        Query OK, 1 row affected (0.01 sec)        mysql&gt; select * from t_student;        +------+----------+------+------------+-------------------------------+        | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |        +------+----------+------+------------+-------------------------------+        |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |        |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |        | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |        +------+----------+------+------------+-------------------------------+        3 rows in set (0.00 sec)        默认情况下：当一张表被创建之后，没有指定约束的话，可以为NULL，并且没有指定任何默认值的话，默认值为NULL，这里的默认值NLL表示：若插入数据的时候没有给该字段指定任何数据，默认插入NULL值。            我们可以再向NO,SEX,BIRTH字段中插入值吗？            INSERT INTO t_student(NO,SEX,BIRTH) VALUES(3,&#39;m&#39;,&#39;1990-11-12&#39;);            mysql&gt; INSERT INTO t_student(NO,SEX,BIRTH) VALUES(3,&#39;m&#39;,&#39;1990-11-12&#39;);            Query OK, 1 row affected (0.01 sec)            mysql&gt; select * from t_student;            +------+----------+------+------------+-------------------------------+            | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |            +------+----------+------+------------+-------------------------------+            |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |            |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |            | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |            |    3 | NULL     | m    | 1990-11-12 | NULL                          |            +------+----------+------+------------+-------------------------------+            4 rows in set (0.00 sec)            以上执行insert语句只能导致底层数据库表中新增一条记录。            若希望NULL变成其它数据，需要使用UPDAT语句进行更新操作。    7.6    INSERT语句中字段的名字可以省略吗？            mysql&gt; INSERT INTO t_student VALUES(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1960-12-16&#39;,&#39;zhaoliu@163.com&#39;);            Query OK, 1 row affected (0.01 sec)            mysql&gt; select * from t_student;            +------+----------+------+------------+-------------------------------+            | NO   | NAME     | SEX  | BIRTH      | EMAIL                         |            +------+----------+------+------------+-------------------------------+            |    2 | zhongjie | m    | 1958-11-21 | zhongjie@beijingpowernode.com |            |    1 | cntsp    | m    | 1948-11-01 | cntsp@beijingpowernode.com    |            | NULL | wangwu   | NULL | NULL       | wangwu@bjpowernode.com        |            |    3 | NULL     | m    | 1990-11-12 | NULL                          |            |    4 | zhaoliu  | m    | 1960-12-16 | zhaoliu@163.com               |            +------+----------+------+------------+-------------------------------+            5 rows in set (0.00 sec)            INSERT INTO t_student VALUES(5,&#39;LTIANLI&#39;,&#39;m&#39;,&#39;1990-05-18&#39;);            mysql&gt; INSERT INTO t_student VALUES(5,&#39;LTIANLI&#39;,&#39;m&#39;,&#39;1990-05-18&#39;);            ERROR 1136 (21S01): Column count doesn&#39;t match value count at row 1            结论：建立不要将前面的字段省略，如省略就表示将表中所有字段全部加上。省略之后程序不健壮，无法修改表结构，修改表结构，可能导致insert语句执行失败。    7.7  插入中文试试？【在DOS窗口中】            mysql&gt; show create table t_student;</code></pre><p>+———–+——————————————————————————————————————————————————————————————————————————–+<br>| Table     | Create Table                                                                                                                                                                                                                   |<br>+———–+——————————————————————————————————————————————————————————————————————————–+<br>| t_student | CREATE TABLE <code>t_student</code> (<br>  <code>NO</code> int(10) DEFAULT NULL,<br>  <code>NAME</code> varchar(32) DEFAULT NULL,<br>  <code>SEX</code> char(1) DEFAULT NULL,<br>  <code>BIRTH</code> date DEFAULT NULL,<br>  <code>EMAIL</code> varchar(128) DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 |<br>+———–+——————————————————————————————————————————————————————————————————————————–+<br>1 row in set (0.00 sec)<br>            编码方式为：utf8<br>            DOS窗口操作数据库<br>            set character_set_result = ‘GBK’;<br>            插入失败，原因是DOS窗口是GBK的编码方式，但是数据库表只能接受UTF8<br>            怎么解决？<br>                使用MYSQL Front工具插入数据【MYSQL的客户端软件，在实际开发中使用较多】<br>                使用mysql front 工具插入数据成功，在DOS窗口中使用select语句查询的时候出现乱码，怎么解决？<br>                    修改查询结果集的显示编码方式，这里修改的不是DOS窗口的编码：<br>                    mysql&gt; set character_set_results = ‘GBK’;【临时有效，当前窗口有效】</p><pre><code>                查看MYSQL的相关字符编码方式：show variables like &#39;%char%&#39;;8     关于创建表格的时候给字段添加默认值：    drop table if exists t_student;    create table t_student(        no int(10),        name varchar(32),        sex char(1) default &#39;m&#39;    );    insert into t_student(no,name) values(1,&#39;jack&#39;);    insert into t_student(no,name) values(2,&#39;lucy&#39;);    commit;    mysql&gt; select * from t_student;    +------+------+------+    | no   | name | sex  |    +------+------+------+    |    1 | jack | m    |    |    2 | lucy | m    |    +------+------+------+    2 rows in set (0.00 sec)    mysql&gt; desc t_student;    +-------+-------------+------+-----+---------+-------+    | Field | Type        | Null | Key | Default | Extra |    +-------+-------------+------+-----+---------+-------+    | no    | int(10)     | YES  |     | NULL    |       |    | name  | varchar(32) | YES  |     | NULL    |       |    | sex   | char(1)     | YES  |     | m       |       |    +-------+-------------+------+-----+---------+-------+    3 rows in set (0.00 sec)    关于SQL脚本：        你是怎么看SQL脚本的？            - 该文件是一个普通的文本文件，后缀名.sql，被称为SQL脚本            - 在SQL脚本中有大量的SQL语句，想批量的执行SQL语句，可以将这些SQL语句写入SQL脚本文件中，            直接使用source执行这个脚本，可以执行大量的SQL语句。            - 若项目中期就职，可能数据库表，以及表中的记录都已经准备好了，可能Team leader就给你一个SQL脚本，直接执行这个SQL脚本将底层数据库中的数据完成初始化，就可以开发了    9     获取系统当前时间        mysql&gt; select now()            -&gt; ;        +---------------------+        | now()               |        +---------------------+        | 2019-06-22 15:55:37 |        +---------------------+        1 row in set (0.00 sec)    创建表：机构表        create table t_organization(            code char(20),            name varchar(32),            createTime date        );        insert into t_organization(code,name,createTime) values(&#39;11111&#39;,&#39;国家外汇局&#39;,now());                insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;河北省外汇局&#39;,now());        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;河南省外汇局&#39;,now());        insert into t_organization(code,name,createTime) values(&#39;11112&#39;,&#39;山东省外汇局&#39;,now());10    表的复制【快速复制】        mysql&gt;create table EMP1 as select * from EMP;         mysql&gt; create table EMP1 as select * from EMP;         Query OK, 14 rows affected (0.01 sec)        Records: 14  Duplicates: 0  Warnings: 0        mysql&gt; show tables;        +-----------------------+        | Tables_in_bjpowernode |        +-----------------------+        | DEPT                  |        | EMP                   |        | EMP1                  |        | SALGRADE              |        | t_student             |        +-----------------------+        5 rows in set (0.00 sec)        mysql&gt; select * from EMP1;        +-------+--------+-----------+------+------------+---------+---------+--------+        | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |        +-------+--------+-----------+------+------------+---------+---------+--------+        |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |        |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |        |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |        |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |        |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |        |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |        |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     20 |        |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |        |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |        |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |        |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |        |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |        |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |        |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |        +-------+--------+-----------+------+------------+---------+---------+--------+        14 rows in set (0.00 sec)        mysql&gt; create table  EMP2 as select EMPNO,ENAME,SAL FROM EMP;        Query OK, 14 rows affected (0.00 sec)        Records: 14  Duplicates: 0  Warnings: 0        mysql&gt;         mysql&gt; select * from EMP2;        +-------+--------+---------+        | EMPNO | ENAME  | SAL     |        +-------+--------+---------+        |  7396 | SMITH  |  800.00 |        |  7499 | ALLEN  | 1600.00 |        |  7521 | WARD   | 1250.00 |        |  7566 | JONES  | 2975.00 |        |  7654 | MARTIN | 1250.00 |        |  7698 | BLAKE  | 2850.00 |        |  7782 | CLARK  | 2450.00 |        |  7788 | SCOTT  | 3000.00 |        |  7839 | KING   | 5000.00 |        |  7844 | TURNER | 1500.00 |        |  7876 | ADAMS  | 1100.00 |        |  7900 | JAMES  |  950.00 |        |  7902 | FORD   | 3000.00 |        |  7934 | MILLER | 1300.00 |        +-------+--------+---------+        14 rows in set (0.01 sec)语法结构：        CREATE TABLE tablename AS SELECT COLUMNNAME,... FROM tablename;11    将查询结果插入到某张表中    insert into EMP2 select * from EMP2 where sal=3000;    mysql&gt; insert into EMP2 select * from EMP2 where sal=3000;    Query OK, 2 rows affected (0.00 sec)    Records: 2  Duplicates: 0  Warnings: 0    mysql&gt; SELECT * FROM EMP2;    +-------+--------+---------+    | EMPNO | ENAME  | SAL     |    +-------+--------+---------+    |  7396 | SMITH  |  800.00 |    |  7499 | ALLEN  | 1600.00 |    |  7521 | WARD   | 1250.00 |    |  7566 | JONES  | 2975.00 |    |  7654 | MARTIN | 1250.00 |    |  7698 | BLAKE  | 2850.00 |    |  7782 | CLARK  | 2450.00 |    |  7788 | SCOTT  | 3000.00 |    |  7839 | KING   | 5000.00 |    |  7844 | TURNER | 1500.00 |    |  7876 | ADAMS  | 1100.00 |    |  7900 | JAMES  |  950.00 |    |  7902 | FORD   | 3000.00 |    |  7934 | MILLER | 1300.00 |    |  7788 | SCOTT  | 3000.00 |    |  7902 | FORD   | 3000.00 |    +-------+--------+---------+    16 rows in set (0.00 sec)12  增/删/改 表结构【DDL语句】    drop table if exists t_student;    create table t_student{        NAME VARCHAR(10),        SEX CHAR(1)    };    INSERT INTO t_student(NAME,SEX) values(&#39;JACK&#39;,&#39;M&#39;);    INSERT INTO t_student(NAME,SEX) VALUES(&#39;MARY&#39;,&#39;F&#39;);    commit;    DROP TABLE IF EXISTS runoob_tb1;    CREATE TABLE IF NOT EXISTS `runoob_tbl`(       `runoob_id` INT UNSIGNED AUTO_INCREMENT,       `runoob_title` VARCHAR(100) NOT NULL,       `submission_date` DATE,        PRIMARY KEY ( `runoob_id` )        )ENGINE=InnoDB DEFAULT CHARSET=utf8;    添加字段        如：需求发生改变，需要向runoob_tbl中加入联系作者字段，字段名称为：author类型为varchar(100)        alter table runoob_tbl add author varchar(100) not null default &#39;&#39;,ALGORITHM=INPLACE;        给runoob_tbl表格添加一个作者字段        alter table runoob_tbl add author varchar(100) not null default &#39;&#39;,ALGORITHM=INPLACE;        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(100)     | NO   |     |         |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        将ru表格中的tel字段长度扩展到120个长度【改】        ALTER TABLE runoob_tbl MODIFY author VARCHAR(120);        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(100)     | NO   |     |         |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        mysql&gt; ALTER TABLE runoob_tbl MODIFY author VARCHAR(120);        Query OK, 0 rows affected (0.04 sec)        Records: 0  Duplicates: 0  Warnings: 0        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(120)     | YES  |     | NULL    |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        将runoob_tbl 表格中的author字段删除【删】        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        | author          | varchar(120)     | YES  |     | NULL    |                |        +-----------------+------------------+------+-----+---------+----------------+        4 rows in set (0.00 sec)        mysql&gt; ALTER TABLE runoob_tbl DROP author;        Query OK, 0 rows affected (0.01 sec)        Records: 0  Duplicates: 0  Warnings: 0        mysql&gt; desc runoob_tbl;        +-----------------+------------------+------+-----+---------+----------------+        | Field           | Type             | Null | Key | Default | Extra          |        +-----------------+------------------+------+-----+---------+----------------+        | runoob_id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |        | runoob_title    | varchar(100)     | NO   |     | NULL    |                |        | submission_date | date             | YES  |     | NULL    |                |        +-----------------+------------------+------+-----+---------+----------------+        3 rows in set (0.01 sec)13    增/删/改 表中的数据【insert, update,delete 属于DML语句】    update        update 语句的语法格式                UPDATE tablename SET 字段名=字段值 ,字段名=字段值 where 条件;                注意： update语句没有条件，会将一张表所有的数据都更新        delete 语法格式：                DELETE FROM tablename where 条件;                注意： 若没有条件限制，会将这张表的数据全部删除约束和非空约束    1    什么是约束，为什么使用约束？            -    约束对应的英语单词：constraint            -    约束实际上就是表中数据的限制条件            -    表的设计的时候加入约束的目的就是为了保证表中的记录完整和有效    2    约束包括哪些呢？            -    非空约束        (not null)            -    唯一性约束        (unique)            -    主键约束        (primary key)  简称 PK            -    外键约束        (foreign key)     简称 FK            -    检查约束        (MYSQL不支持，oracle支持)    3    非空约束            -    not null约束的字段，不能为NULL值，必须给定具体的数据            -    创建表，给字段添加非空约束【创建用户表，用户名不能为空】    4    唯一性约束            - unique约束的字段具有唯一性，不可重复            - 创建用户，保证邮箱地址唯一            drop table if exists t_user;            //列级约束            create table t_user(                id int(10),                name varchar(32) not null,                email varchar(128) unique            );            insert into t_user(id,name,email) values(1,&#39;jack&#39;,&#39;jack@bjpowernode.com&#39;);//成功            insert into t_user(id,name,email) values(2,&#39;abc&#39;&#39;jack@bjpowernode.com&#39;);//失败            EEROR 1062 (23000): Duplicate entry &#39;jack@bjpowernode.com&#39; for key &#39;emial&#39;            insert into t_user(id,name) value(2,&#39;abc&#39;);//成功            insert into t_user(id,name) values(3,&#39;def&#39;);//成功            unique约束的字段不能重复，但是可以为NULL             drop table if exists t_user;            //表级约束            create table t_user{                id int(10),                name varchar(32) not null,                email varcher(128),                unique(email)            };            //表级约束给多个字段联合添加约束【一下程序表示name和email连个字段联合唯一】            drop table if exists t_user;            create table t_user(                    id int(10),                    name varchar(32) not null,                    email varchar(128),                    unique(name,email)            );            //表级约束还可以给约束起名字            //为什么要起名字？因为以后要通过这个名字来删除这个约束            drop table if exists t_user;            create table t_user(                id int(10),                name varchar(32) not null,                email varchar(128),                constraint t_user_email_unique unique(email)            );            //查询约束的名字            mysql&gt; use information_schema;            Reading table information for completion of table and column names            You can turn off this feature to get a quicker startup with -A            Database changed            mysql&gt; show tables;            +---------------------------------------+            | Tables_in_information_schema          |            +---------------------------------------+            | CHARACTER_SETS                        |            | COLLATIONS                            |            | COLLATION_CHARACTER_SET_APPLICABILITY |            | COLUMNS                               |            | COLUMN_PRIVILEGES                     |            | ENGINES                               |            | EVENTS                                |            | FILES                                 |            | GLOBAL_STATUS                         |            | GLOBAL_VARIABLES                      |            | KEY_COLUMN_USAGE                      |            | OPTIMIZER_TRACE                       |            | PARAMETERS                            |            | PARTITIONS                            |            | PLUGINS                               |            | PROCESSLIST                           |            | PROFILING                             |            | REFERENTIAL_CONSTRAINTS               |            | ROUTINES                              |            | SCHEMATA                              |            | SCHEMA_PRIVILEGES                     |            | SESSION_STATUS                        |            | SESSION_VARIABLES                     |            | STATISTICS                            |            | TABLES                                |            | TABLESPACES                           |            | TABLE_CONSTRAINTS                     |            | TABLE_PRIVILEGES                      |            | TRIGGERS                              |            | USER_PRIVILEGES                       |            | VIEWS                                 |            | INNODB_LOCKS                          |            | INNODB_TRX                            |            | INNODB_SYS_DATAFILES                  |            | INNODB_FT_CONFIG                      |            | INNODB_SYS_VIRTUAL                    |            | INNODB_CMP                            |            | INNODB_FT_BEING_DELETED               |            | INNODB_CMP_RESET                      |            | INNODB_CMP_PER_INDEX                  |            | INNODB_CMPMEM_RESET                   |            | INNODB_FT_DELETED                     |            | INNODB_BUFFER_PAGE_LRU                |            | INNODB_LOCK_WAITS                     |            | INNODB_TEMP_TABLE_INFO                |            | INNODB_SYS_INDEXES                    |            | INNODB_SYS_TABLES                     |            | INNODB_SYS_FIELDS                     |            | INNODB_CMP_PER_INDEX_RESET            |            | INNODB_BUFFER_PAGE                    |            | INNODB_FT_DEFAULT_STOPWORD            |            | INNODB_FT_INDEX_TABLE                 |            | INNODB_FT_INDEX_CACHE                 |            | INNODB_SYS_TABLESPACES                |            | INNODB_METRICS                        |            | INNODB_SYS_FOREIGN_COLS               |            | INNODB_CMPMEM                         |            | INNODB_BUFFER_POOL_STATS              |            | INNODB_SYS_COLUMNS                    |            | INNODB_SYS_FOREIGN                    |            | INNODB_SYS_TABLESTATS                 |            +---------------------------------------+            61 rows in set (0.00 sec)            mysql&gt; desc COLLATIONs;            +--------------------+-------------+------+-----+---------+-------+            | Field              | Type        | Null | Key | Default | Extra |            +--------------------+-------------+------+-----+---------+-------+            | COLLATION_NAME     | varchar(32) | NO   |     |         |       |            | CHARACTER_SET_NAME | varchar(32) | NO   |     |         |       |            | ID                 | bigint(11)  | NO   |     | 0       |       |            | IS_DEFAULT         | varchar(3)  | NO   |     |         |       |            | IS_COMPILED        | varchar(3)  | NO   |     |         |       |            | SORTLEN            | bigint(3)   | NO   |     | 0       |       |            +--------------------+-------------+------+-----+---------+-------+            6 rows in set (0.00 sec)            mysql&gt; DESC TABLE_CONSTRAINTS;【该表格专门存储约束信息的】            +--------------------+--------------+------+-----+---------+-------+            | Field              | Type         | Null | Key | Default | Extra |            +--------------------+--------------+------+-----+---------+-------+            | CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |            | CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |            | CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |            | TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |            | TABLE_NAME         | varchar(64)  | NO   |     |         |       |            | CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |            +--------------------+--------------+------+-----+---------+-------+            6 rows in set (0.00 sec)            mysql&gt; select CONSTRAINT_NAME from TABLE_CONSTRAINTS where TABLE_NAME=&#39;t_user&#39;;5    not null和unique可以联合使用吗？        -    可以联合使用        -    被not null unique 约束的字段，既不能为空，也不能重复        -    例子：6    主键约束-primary key  简称:PK        6.1        主键涉及到的术语:                    -    主键约束                    -    主键字段                    -    主键值        6.2        以上的主键约束、主键字段、主键值的关系？                - 表中某个字段添加主键约束之后                该字段被称为主键字段，主键字段中                出现的每一个数据能被称为主键值        6.3        给某个字段添加主键约束之后，该字段不能重复，并且也不能为空                效果和 not null unique  约束相同，但是本质不同，主键约束除了可以做到&quot;not null unique&quot;之外，主键字段还会默认添加&quot;索引-index&quot;        6.4        一张表应该有主键字段，若没有，表示这张表是无效的。                &quot;主键值&quot;是当前行数据的唯一标识。&quot;主键值&quot;是当前行数据的身份证号。                即使表中的两行记录相关的数据是相同的，但是由于主键值不同，我们认为这是两行完全不同的数据。        6.5        给一个字段添加主键约束，被称为单一主键。                    //单一主键                    //列级约束                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(5) UNSIGNED PRIMARY KEY,                        name VARCHAR(20)                    );                    //单一主键                    //表级约束                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(5) UNSIGNED,                        name VARCHAR(20),                        PRIMARY KEY(id)                    );                     //单一主键                    //表级约束                    //起名                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(3) UNSIGNED,                        name VARCHAR(32),                        email VARCHAR(40),                        CONSTRAINT t_user_id_pk PRIMARY KEY(id)                    );        6.6        给多个字段联合添加一个主键约束，被称为复合主键。                    //复合主键                    //表级约束                    //起名                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(2) UNSIGNED,                        name VARCHAR(10),                        CONSTRAINT t_user_id_pk PRIMARY KEY(id,name)                    );                    INSERT INTO t_user(id,name) values(10000,&#39;jack&#39;);                    INSERT INTO t_user(id,name) values(10000,&#39;cntsp&#39;);                    INSERT INTO t_user(id,name) values(5456,&#39;cntsp&#39;);                    COMMIT;                    SELECT * FROM t_user;        6.7        无论是单一主键还是复合主键，一张表主键约束只能有一个。        6.8        主键根据性质分类：                -    自然主键                    *     主键值若是一个自然数，这个自然数和当前表的业务没有任何关系，这种主键叫做自然主键                -    业务主键                    *    主键值若和当前表中业务紧密相关的，那么这种主键值被称为业务主键，当业务数据发生改变的时候，主键值通常受到影响。                    所以业务主键使用较少。大部分都是使用自然主键            6.9        在MYSQL数据库管理系统中提供了一个自增的数字，专们用来自动生成主键值。                    主键值不需要用户维护，也不需要用户提供了，自动生成的，这个自增的数字默认从1开始，以1递增：                    1,2,3,4,5,6,7,8.....                    DROP TABLE IF EXISTS t_user;                    CREATE TABLE t_user(                        id INT(10) UNSIGNED PRIMARY KEY auto_increment,                        name VARCHAR(32),                        email VARCHAR(40)                    );                    INSERT INTO t_user(name,email) values(&#39;jack&#39;,&#39;123@qq.com&#39;);                    INSERT INTO t_user(name,email) values(&#39;jack&#39;,&#39;123@qq.com&#39;);                    COMMIT;    7    外键约束foreign  key-简称FK        7.1    外键涉及到的术语：                -    外键约束                -    外键字段                -    外键值        7.2    外键约束、外键字段、外键值之间的的关系？                某个字段添加外键约束之后，该字段称为外键字段                外键字段中的每一个数据都是外键值        7.3    外键也分为：单一外键【给一个字段添加外键约束】和复合外键【给多个字段联合添加一个外键约束】        7.4    一张表中可以有多个外键字段        7.5    分析场景：            请设计数据库表用来存储学生和班级信息，给出两种解决方案            学生信息和班级信息之间的关系，一个班级对应多个学生，这是典型的一对多的关系            第一种涉及方案：将学生信息和班级信息存储到一张表中。            学生信息表t_student            sno(pk)     sname        classno        cname            ---------------------------------------------------------            1            jack        100            北京海定区...高三1班            2            lucy        100            北京海定区...高三1班            3            zhangsan     100            北京海定区...高三1班            4            ford        200            北京海定区...高三2班            5            king        200            北京海定区...高三2班            6            allen        300            北京海定区...高三3班            7            lisi        300            北京海定区...高三3班            以上设计的缺点：数据臃肿            第二种解决方案：将学生信息和班级信息分开两张表存储，学生表 + 班级表            学生表t_student            sno(pk)        sname       classno(fk)            -----------------------------------            1            jack        100            2            lucy        100            3            zhangsan    100            4            ford        200            5            king        200            6            allen        300            7            lisi        300            班级表t_class            cno(pk)         cname            ------------------------------------------------            100                北京海淀区....高三1班            200                北京海淀区....高三2班            300                北京海淀区....高三3班            结论：为了保证t_student表中的class字段中的数据必须来自于t_class表中cno字段中的数据，有必要给t_studnet            表中的classno字段添加外键约束，classno字段被称为外键字段，该字段中的100 200 300被称为外键值。classno这里是一个单一外键字段            注：    外键值可以为NULL            注：    外键字段去引用一张表的某个字段的时候，被引用的字段必须具有unique约束。            注：    有了外键引用之后，表分为父表和子表，以上父表是：班级表，子表是：学生表            创建表先创建父表，再创建子表，删除数据的时候先删除子表中的数据，再删除父表中的数据，插入父表中的数据，再插入子表中的数据。            -------------------------------------SQL文----------------------------------------------------------------            DROP TABLE IF EXISTS t_student;            DROP TABLE IF EXISTS t_class;            CREATE TABLE t_class(                    cno int(3) unsigned primary key,                    cname varchar(120) not null unique            );            CREATE TABLE t_student(                sno int(3) unsigned primary key,                sname varchar(32) not null,                classno int(3) unsigned,                constraint t_student_classno_fk foreign key(classno) references t_class(cno)            );            insert into t_class(cno,cname) values(100,&#39;高三1班&#39;);            insert into t_class(cno,cname) values(200,&#39;高三2班&#39;);            insert into t_class(cno,cname) values(300,&#39;高三3班&#39;);            insert into t_student(sno,sname,classno) values(1,&#39;jack&#39;,100);            insert into t_student(sno,sname,classno) values(2,&#39;lucy&#39;,100);            insert into t_student(sno,sname,classno) values(3,&#39;zhangsan&#39;,100);            insert into t_student(sno,sname,classno) values(4,&#39;ford&#39;,200);            insert into t_student(sno,sname,classno) values(5,&#39;king&#39;,200);            insert into t_student(sno,sname,classno) values(6,&#39;allen&#39;,300);            insert into t_student(sno,sname,classno) values(7,&#39;lisi&#39;,300);            select * from t_student;            select * from t_class;            commit;            insert into t_student(sno,sname,classno) values(8,&#39;lisi&#39;,500);            -------------------------------------SQL文-------------------------------------------------------------------            找出每个学生的班级名称            mysql&gt; SELECT s.sname,c.cname from t_student s join t_class c on s.classno = c.cno;            +----------+------------+            | sname    | cname      |            +----------+------------+            | jack     | 高三1班    |            | lucy     | 高三1班    |            | zhangsan | 高三1班    |            | ford     | 高三2班    |            | king     | 高三2班    |            | allen    | 高三3班    |            | lisi     | 高三3班    |            +----------+------------+            7 rows in set (0.00 sec)            重点：典型的一对多，在多的一方加外键8    级联更新和级联删除        -    添加级联更新和级联删除的时候要在外键约束后面添加        -     在删除父表中数据的时候，级联删除子表中的数据                * 删除外键约束                    alter table t_student drop foreign key t_student_classno_fk;                * 添加外键的约束                    alert table t_student add                     constraint t_student_classno_fk                    foreign key(classno) t_class(cno) on delete cascade;        -    在更新父表中数据的时候，级联更新子表中的数据                * 删除外键约束                    alter table t_student drop foreign key t_student_classno_fk;                * 添加外键的约束                    alert table t_student add                     constraint t_student_classno_fk                    foreign key(classno) t_class(cno) on update cascade ;        -    以上的级联更新和级联删除谨慎使用，因为级联操作会将数据改变或者删除【数据无价】15    存储引擎    存储引擎的使用        数据库中的各表均被(在创建表时)指定的存储引擎来处理。        服务器可用的引擎依赖于以下因素：            &gt; * MySQL的版本            &gt; * 服务器在开发时如何被配置            &gt; * 启动选项为了了解当前服务器中有哪些存储引擎可用，可使用SHOW ENGINES语句：mysql&gt; SHOW ENGINES\G;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        || MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         || MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         || BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         || MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         || CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         || ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         || PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         || FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)15.2.1     MyISAM存储引擎        &gt; * MyISAM    存储引擎是MySQL最常用的引擎        &gt; * 它管理的表具有以下特征：            -     使用三个文件表示每个表:                    &gt; * 使用三个文件表示每个表：                        * 格式文件 -存储表结构的定义(mytable.frm)                        * 数据文件 -存储表行的内容(mytable.MYD)                        * 索引文件 -存储表上索引(mytable.MYI)                    -    灵活的AUTO_INCREMENT字段处理                    -    可被转换为压缩、只读表来节省空间15.2.2        InnoDB存储引擎            &gt;    *     InnoDB存储引擎是MySQL的缺省引擎。            &gt;    *     它管理的表具有以下主要特征：                    -    每个InooDB表在数据库目录中以.frm格式文件表示                    -    InnoDB表空间tablespace被用于存储表的内容                    -    提供一组用来记录事务性活动的日志文件                    -    用COMMIT(提交)、SAVEPOINT及ROLLBACK(回滚)支持事务处理                    -    提供全ACID兼容                    -    在MySQL服务器崩溃后提供自动恢复                    -    多版本(MVCC)和行级锁定                    -    支持外键及引用的完整性，包括级联删除和更新            MEMORY存储引擎                    *    使用MEMORY存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得MEMORY存储引擎非常快                    *    MEMORY存储引擎管理的表具有一下特征：                        -    在数据库目录内，每个表均以.frm格式的文件表示                        -    表数据及索引被存储在内存中                        -    表级锁机制                        -    不能包含TEXT或BLOB字段                    *    MEMORY存储引擎以前被称为HEAP引擎。        15.3        选择合适的存储引擎                    *    MyISAM 表最适合于大量的数据读而少量数据更新的混合操作，MyISAM表的另一种使用情形是使用压缩的只读表。                    *    如果查询中包含较多的数据更新操作，应使用InnoDB,其行级锁机制和多版本的支持为数据读取和更新的混合操作提供了良好的并发机制。                    *    可使用MEMORY存储引擎来存储非永久需要的数据，或者是能够从基于磁盘的表中重新生成的数据。    事务：            1    什么是事务？                    -    事务对应的英语但是：Transaction                    -    事务：一个最小的不可再分的工作单元。                    -    通常一个事务对应一个完整的业务。 【例如：银行账户转账业务，该业务就是一个最小的工作单元】                    -    而一个完整的业务需要批量的DML语句(insert,update,delete)共同联合完成。                    -    事务只和DML语句有关系，或者说DML语句才有事务                    -    以上所描述的&quot;批量的DML语句&quot;共有多少条DML语句，这个和业务逻辑有关系                    业务逻辑不同DML语句的个数不同。            2.    关于银行账户转账操作，账户转账是一个完整的业务，最小的单元，不可再分。也就是说银行账户转账是一个事务。                    t_act 账户表                    actno        balance                    -----------------------------------------                    act-001        50000.0                    act-002        10000.0                    执行转账操作(10000):                        update     t_act set balance=40000.0    where actno=&#39;act-001&#39;;                        update  t_act set balance=20000.0    where actno=&#39;act-002&#39;;                        以上的两条DML语句要求必须同时成功或者同时失败，最小单元，不可再分。当第一条DML语句执行成功之后，并不能将底层数据库中第一个账户的数据修改。只是将操作记录一下，这个记录是在内存中完成的，当第二条DML语句执行失败，情况所有的历史操作记录。要完成以上的功能，必须借助事务。        3    事务的四个特性：                -    原子性(A)【Atomicity,或称不可分割性】                        * 事务是最小的工作单元，不可再分                -    一致性(C)【Consistency】                        *  事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败                -    隔离性(I)【isolation】                        *    事务A和事务B之间具有隔离                -    持久性(D)【Durablity】                        *    是事务的保证，事务终结的标志【内存中的数据持久到硬盘文件中】        4    关于一些术语：                -    开启事务: Start Transaction                -    事务结束：End Transaction                -    提交事务: Commit Transacton                -    回滚事务: Rollback Transaction        5    和事务有关的两条重要的SQL语句【TCL】                commit:      提交     成功的结束，将所有的DML语句操作历史记录和底层硬盘文件中的数据来一次同步。                rollback:    回滚    失败的结束，将所有的DML语句操作历史记录全部清空        6    事务开启的标志是什么？事务结束的标志是什么？                -    开启的标志                -    结束的标志        7    重点：                在事务进行过程中，未结束之前，DML语句是不会更改底层数据库文件中的数据。只是将历史操作记录一下，在内存中完成记录。                只有在事务结束的时候，而且是成功的结束的时候才会修改底层硬盘文件中的数据。    8    在MYSQL数据库管理系统中，事务的提交和回滚的演示        -    在MYSQL数据库管理系统中，默认情况下，事务是自动提交的，也就是说，只要执行一条DML语句，开启了事务，并且提交了事务。        -    这种自动提交机制是可以关闭的: 【关闭的第一种方式】            start transaction;     手动开启事务            DML语句...            DML语句...            DML语句...            commit;             手动提交事务【事务成功的结束】            start transaction;    手动开启事务            DML语句...            DML语句...            DML语句...            DML语句...            DML语句...            rollback;    手动回滚事务【事务失败的结束】            -    如果禁用自动提交，事务可以跨越多条语句。            -    在这种情况下，事务可以用COMMIT和ROLLBACK语句来显式地提交或回滚。    *    自动提交模式下可以通过服务器变量AUTOCOMMIT来控制    例如：        关闭自动提交模式        mysql&gt;SET AUTOCOMMIT = OFF;        或        mysql&gt;SET SESSION AUTOCOMMIT = OFF;        打开自动提交模式        mysql&gt;SET AUTOCOMMIT = ON;        或        mysql&gt;SET SESSION AUTOCOMMIT = ON;        只对当前事务有效        mysql&gt;show variables like &#39;%auto%&#39;;查看变量状态9    事务四个特性之一：隔离性(isolation)            9.1    事务A和事务B之间具有一定的隔离性        9.2    隔离性有隔离级别(4个)：                -    read uncommitted 读未提交                -    read committed   读已提交                -   repeatable read  可重复性                -    serializable     串行化        9.3    read uncommitted 读未提交            -    事务A和事务B，事务A未提交的数据，事务B可以读取到            -    这里读取到的数据可以叫做&quot;脏数据&quot;或者叫做“Dirty Read”            -    这种隔离级别是最低级别，这种级别一般都是在理论上存在，数据库默认的隔离级别一般都是高于该隔离界别的。        9.4    read committed 读已提交            -    事务A和事务B，事务A提交的数据，事务B才能读取到。            -    这种隔离级别高于上面的读未提交            -    换句话说：对方事务提交之后的数据，我当前事务才能过读取到。            -    这种隔离级别可以避免脏数据。            -    这种隔离界别会导致：“不可重复读取”            -    Oracle数据库管理系统默认的隔离级别就是：读已提交        9.5    repeatable read 可重复读            -    事务A和事务B，事务A提交之后的数据，事务B读取不到。            -    事务B是可重复读取数据的            -    这种隔离级别高于读取数据的。            -    换句话说：对方提交之后的数据我还是读取不到.            -    这种隔离级别可以避免“不可重复读取”，达到可重复读取            -    MYSQL数据库管理系统默认的隔离级别就是：可重复读            -    虽然可以达到“可重复读”的效果，但是会导致：“幻象读”        9.6    serializable  串行化            -    事务A和事务B，事务A在操作数据库表中数据的时候，事务B只能排队等待。            -    这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好。            -    这种隔离级别可以避免“幻象读”，每一次读取的都是数据库表中真实记录。            -    事务A和事务B不再并发。10.        隔离级别与一致性问题的关系        隔离级别        脏读取        不可重复读取            设置事务的隔离级别：            第一种方式：修改my.ini配置文件            可选值：                -    READ-UNCOMMITTED                -    READ-COMMITTED                -    REPEATABLE-READ                -    SERIALIZABLE                ----------------my.ini----------------                [mysqld]                transaction-ioslation = READ-COMMITTED            第二种方式：使用命令动态设置事务的隔离级别            &gt;    *     隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句            &gt;    *    语法模式为： SET|GLOBAL|SESSION|TRANSACTION|ISOLATIONLEVEL &lt;isolation-level&gt;            其中的&lt;isolation-level&gt;可以是：                -    READ-UNCOMMITTED                -    READ-COMMITTED                -    REPEATABLE-READ                -    SERIALIZABLE            例如：SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;    隔离级别的作用范围：            事务隔离级别的作用范围分为两种：                -    全局及：对所有的会话有效                -    会话级：只对当前的会话有效            &gt;*    例如：设置会话级隔离级别为READ COMMITTED；                SET TRANACTION ISOLATION LEVEL READCOMMITTED;                或者：                SET SESSION TRANACTION ISOLATION LEVEL READ COMMITTED;                设置全局级隔离级别为READ COMMITTED                SET GLOBAL TRANACTION ISOLATION LEVEL READ COMMITTED;        16.4.6  查看隔离级别                服务器变量tx_isolation(包含会话级和全局级两个变量)中保存着当前的会话隔离级别。                为了查看当前隔离级别，可访问tx_isolation变量；                    -    查看会话级的当前隔离级别；                    mysql&gt; SELECT @@tx_isolation;                    或：                    mysql&gt; SELECT @@session.tx_isolation;                    查看全局级的当前隔离级别；                    mysql&gt;SELECT @@global.tx_isolation        12    并发事务与隔离级别示例            12.1    读未提交     read uncommitted</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level read uncommitted;<br>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;<br>start transaction;                                                                            start transacton;<br>insert into t_user(name) values(‘wangwu’);                                                    select * from t_user;</p><pre><code>                                                                                select * from t_us    12.2    可重复读     read committed</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level read committed;<br>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;</p><p>start transaction;                                                                            start transacton;</p><p>insert into t_user(name) values(‘ford’);                                                    select * from t_user;</p><p>commit;                                                                                        select * from t_user;</p><pre><code>        12.3    可重复读     repeatable read</code></pre><p>——-会话1———————————————————————————–会话2——————-<br>set global transacton isolation level repeatable read;<br>select @@tx_isolation;</p><hr><p>|@@tx_isolation |<br>+—————+<br>|READ-COMMITTED |</p><p>退出DOS窗口<br>user bjpowernode;                                                                            user bjpowernode;</p><p>start transaction;                                                                            start transacton;</p><p>select * from t_user;                                                                       select * from t_user;</p><p>insert into t_user(name) values(‘cntsp’);                                                    select * from t_user;</p><p>commit;                                                                                        select * from t_user;</p><pre><code>索引：    1    什么是索引？            -    索引对应的英语单词是：index            -    索引相当于一本字典的目录，索引的作用是提高程序的检索【查询】效率。    2    主键自动添加索引，所以能够通过主键查询尽量通过主键查询，效率较高。    3    索引和表相同，都是一个对象，表是存储在硬盘文件中的，那么索引是表的一部分，索引也是存储在硬盘文件中。    4    在MYSQL数据库管理系统中，对表中记录进行检索的时候，通常包括几种检索方式：        第一种方式：全表扫描【效率较低】                假设有一张表：emp员工表                select * from emp where ename=&#39;KING&#39;;                若ename字段上没有添加索引，那么在通过ename字段过滤数据的时候                ename字段会被全表扫描                假设有一张表：dept部门表                select * from dept where dname=&#39;ACCOUNTING&#39;;                若dname字段上没有索引，那么在通过dname字段过滤数据的时候，dname字段会被全部扫描        第二种方式：通过索引进行检索【提高查询效率】5.    一张表中有多个字段，每一个字段都是可以添加索引的。6.    什么情况下适合给表中的某个字段添加索引呢？        -    该字段数据量庞大        -    该字段很少的DML操作【DML操作很多的话，索引也是需要不断的维护，效率反而降低】        -    该字段经常出现在where子句中        索引原理            索引被用来快速找出在一个列某一特定值的行，没有索引，MySQL不得不首先以第一条记录开始，然后读完整个表知道它找出相关的行。表越大，花费时间越多，对于一个有序字段，可以运用二分查找(BinarySearch)，这就是为什么性能能得到本质上的提高。MYISAM和INNODB都是B+Tree作为索引结构。            (主键：unique都会默认的添加索引)    7    怎么创建索引?        create index dept_dname index on dept(dname);        create unique index dept_dname_index on dept(dname);//添加unique表示dept表中的dname字段添加一个唯一性约束    8    删除索引        drop     index dept_dname_index on dept;19    DBA命令    19.1    新建命令            CREATE USER username IDENTIFIED BY &#39;password&#39;;            说明username --你将创建的用户名，password --该用户的登录密码：密码可以为空，如果为空则该用户可以不需要密码登录服务器    192.    授权            命令详解            mysql&gt;grant all privileges on dbname.tbname to username@&#39;loginip&#39; identified by &#39;passwd&#39; with grant option;            dbname=*  表示所有数据库            taname=*  表示所有表    19    导出            导出整个数据库            在windows 的DOS命令窗口中执行：mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123            导出指定库下的指定表            在window的dos命令窗口中执行：mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p123    19.4.2    导入            mysql&gt;source D:\bjpowernode.sql</code></pre><p>数据库设计三范式：<br>        1、 数据库设计三范式：<br>            设计数据库表的时候所依据的规范，共三个规范</p><pre><code>        第一范式：            要求有主键，并且要求每一个字段原子性不可再分            数据库表中不能出现重复记录，每个字段是原子性的不能再分            不符合第一范式的示例            ------------------------------------------------------------            学生编号        学生姓名            联系方式            ------------------------------------------------------------            1001            张三                zs@gamil.com.13599999999            ------------------------------------------------------------            1002            李四                ls@gmail.com.13699999999            ------------------------------------------------------------            1001            王五                ww@163.com.134888888888            ------------------------------------------------------------            存在的问题：                ** 最后一条记录和第一条重复(不唯一，没有主键) **                ** 联系方式字段可以再分，不是原子性的 **            修改后为：            --------------------------------------------------------------------            学生编号        学生姓名            邮箱地址            电话号码            --------------------------------------------------------------------            1001            张三                zs@gamil.com        13599999999            --------------------------------------------------------------------            1002            李四                ls@gmail.com        13699999999            --------------------------------------------------------------------            1003            王五                ww@163.com          134888888888            --------------------------------------------------------------------            **关于第一范式,每一行必须唯一，也就是每个表必须有主键，这是我们数据库涉及的最基本要求，主要通常采用数值型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定，如联系方式，为了开发上的便利可能就采用一个字段了**        第二范式：            要求所有非主键字段完全依赖主键，不能产生部分依赖            第二范式是建立在第一范式基础上的，另外要求所有非主键字段完全依赖主键，不能产生部分依赖            示例：            --------------------------------------------------------------------            学生编号        学生姓名            教师编号            电话号码            --------------------------------------------------------------------            1001            张三                001                    王老师            --------------------------------------------------------------------            1002            李四                002                    赵老师            --------------------------------------------------------------------            1003            王五                001                  王老师            --------------------------------------------------------------------            1001            张三                002                    赵老师            --------------------------------------------------------------------            确定主键：            --------------------------------------------------------------------            学生编号(PK)        教师编号(PK)        学生姓名        教师姓名            --------------------------------------------------------------------            1001                001                    张三            王老师            --------------------------------------------------------------------            1002                002                    李四            赵老师            --------------------------------------------------------------------            1003                001                    王五            王老师            --------------------------------------------------------------------            1001                002                    张三            赵老师            --------------------------------------------------------------------            以上虽然确定了主键，但此表会出现大量的沉余，主要涉及到的沉余字段为“学生姓名”和“教师姓名”，出现沉余的            原因在于，学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部门依赖了主键的一个字段教师编号，这就是第二范式部分依赖。            解决方案如下：            学生信息表：            ------------------------------------------------            学生编号(PK)            学生姓名            ------------------------------------------------            1001                    张三            ------------------------------------------------            1002                    李四            ------------------------------------------------            1003                    王五            ------------------------------------------------            教师信息表            ------------------------------------------------            教师编号(PK)            教师姓名            ------------------------------------------------            001                        王老师            ------------------------------------------------            002                        赵老师            ------------------------------------------------            教师和学生的关系表            -------------------------------------------------------------------------            学生编号(PK) fk-&gt;学生表的学生编号        教师编号(PK)fk-&gt;教师表的教师编号            -------------------------------------------------------------------------            1001                                        001            -------------------------------------------------------------------------            1002                                        002            -------------------------------------------------------------------------            1003                                        001            -------------------------------------------------------------------------            1001                                        002            -------------------------------------------------------------------------            如果一个表是单一主键，那么它就是复合第二范式，部分依赖和主键有关系            以上是一种典型的“多对多”的涉及        第三范式：            所有非主键字段和主键字段之间不能产生传递依赖            建立在第二范式基础上的，非主键字段不能传递依赖与主键字段(不要产生传递依赖)            --------------------------------------------------------------------------            学生编号(PK)         学生姓名        班级编号            班级名称            --------------------------------------------------------------------------            1001                张三            01                    一年一班            --------------------------------------------------------------------------            1002                李四            02                    一年二班            --------------------------------------------------------------------------            1003                王五            03                    一年三班            --------------------------------------------------------------------------            1004                赵六            03                    一年三班            --------------------------------------------------------------------------            从上表可以看出，班级名称字段存在沉余，因为班级名称字段没有直接依赖于主键，班级名称字段依赖与班级编号，            班级编号依赖于学生编号，那么这就是传递依赖，解决的办法是将沉余字段单独拿出来建立表，如：            学生信息表：            -----------------------------------------------------            学生编号(PK)            学生姓名        班级编号(FK)            -----------------------------------------------------            1001                    张三            01            -----------------------------------------------------            1002                    李四            02            -----------------------------------------------------            1003                    王五            03            -----------------------------------------------------            1004                    赵六            03            -----------------------------------------------------            班级信息表            -----------------------------------------------------            班级编号(PK)                班级名称            -----------------------------------------------------            01                            一年一班            02                            一年二班            -----------------------------------------------------            03                            一年三班            -----------------------------------------------------            以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一对一    2、 几个比较经典的范式：        一对一：                第一种方案：    分两张表存储，共享主键                                t_husband                                hno(pk)    hname                                --------------------                                1            张三                                2            王五                                3            赵六                                --------------------                                t_wife                                wno(pk) wname 【wno同时也是fk，引用t_husband中的hno】                                -----------------------------------                                3        a                                2        b                                1        c                                ----------------------------------                第二种方案：    分两张表存储，外键唯一                                t_husband                                hno(pk)    hname    wifeno                                ----------------------------------                                1            张三    100                                2            王五    300                                3            赵六    200                                ----------------------------------                                t_wife                                wno(pk) wname 【wno同时也是fk，引用t_husband中的hno】                                -----------------------------------                                100        a                                300     b                                200        c                                ----------------------------------        一对多：分两张表存储，在多的一方添加外键，这个外键字段引用一对一放中的主键字段        多对多：分三张表存储，在学生表中存储学生信息，在课程表中存储学生和课程信息6    在实际开发中是怎样的？        数据库设计尽量遵循三范式，        但是还是根据实际情况进行取舍        有时可能会拿沉余换速度        最终目的要满足客户需求</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制部署k8s</title>
      <link href="/2019/04/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s/"/>
      <url>/2019/04/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2k8s/</url>
      
        <content type="html"><![CDATA[<p>Centos7系统使用二进制包部署kubernetes1.13集群</p><p>一 简述<br>Kubernetes1.13 的核心特性包括：利用kubeadm简化集群管理、容器存储接口(CSI)以及将CoreDNS作为默认DNS。<br>利用kubeadm简化集群管理功能<br>Kubeadm是管理集群生命周期的重要工具，能够帮助从我们从创建到配置再到升级的整个过程，随着1.13版本的发布，kubeadm功能进入GA版本，正式普遍可用。kubeadm处理现有硬件上的生产集群的引导，并以最佳实践方式配置kubernetes核心组件，以便为新节点提供安全而简单的连接流程并支持轻松升级。<br>该GA版本中最值得注意的是已经毕业的高级功能，尤其是可插拔性和可配置性。kubeadm旨在为管理员与高级自动化系统提供一套工具箱，如今已迈出重要一步。<br>容器存储接口(CSI)<br>容器存储接口最初于1.9版本中作为alpha测试功能引入，在1.10版本中进入beta测试，如今终于进入GA阶段正式普遍可用。在CSI的帮助下，kubernetes卷层将真正实现可扩展性。通过CSI，第三方存储供应商将可以直接编写可与kubernetes互操作的代码，而无需触及任何kubernetes核心代码。事实上，相关规范也已经同步进入1.0阶段。随着CSI的稳定，插件作者将能够按照自己的节奏开发核心存储插件，详见CSI文档。<br>CoreDNS称为Kubernetes的默认DNS服务器<br>在1.11版本中，开发团队宣布CoreDNS已实现基于DNS服务发现的普遍可用性。在最新的1.13版本中，CoreDNS正式去掉kuber-dns成为Kubernetes中的默认DNS服务器。CoreDNS是一种通用的、权威的DNS服务器，能够提供与Kubernetes向下兼容且具备可扩展性的集成能力。由于CoreDNS自身单一可执行文件与单一进程的特性，因此CoreDNS的活动部件数量会少于之前的DNS服务器，且能够通过创建自定义DNS条目来支持各类灵活的用例。此外，由于CoreDNS采用Go语言编写，它具有强大的内存安全性。</p><p>CoreDNS现在是kubernetes1.13急后续版本推荐的DNS解决方案，Kubernetes已将常用测试基础设施架构切换为默认使用CoreDNS,因此，开发团队建议用户也尽快完成切换。KubeDNS仍将至少支持一个版本，但现在是时候开始规划迁移了。</p><p>centos7系统的内网服务器三台：master:192.168.1.119;node1:192.168.1.118;node2:192.168.1.163</p><p>一 初始化系统环境和安装指定版本的docker(三台机器同时进行如下部署)(墙外环境)<br>1 关闭防火墙和SELINUX</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld.service <span class="token operator">&amp;&amp;</span> systemctl disable firewalld.service<span class="token comment" spellcheck="true"># 禁用SELINUX,临时生效</span>setenforce 0<span class="token comment" spellcheck="true"># 修改配置文件，重启后生效</span><span class="token function">sed</span> -i <span class="token string">'s#SELINUX=enforcing#SELINUX=disabled#g'</span> /etc/selinux/config或者打开配置文件修改<span class="token function">vi</span> /etc/selinux/configSELINUX<span class="token operator">=</span>disabled  </code></pre><p>2 关闭swap</p><pre class=" language-bash"><code class="language-bash">swapoff -a <span class="token operator">&amp;&amp;</span> sysctl -w vm.swappiness<span class="token operator">=</span>0<span class="token function">vi</span> /etc/fstab<span class="token comment" spellcheck="true">#UUID=7bff6243-324c-4587-b550-55dc34018ebf swap   swap defaults   0 0</span></code></pre><p>3 设置Docker所需参数</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> /etc/sysctl.d/k8s.confnet.ipv4.ip_forward <span class="token operator">=</span> 1net.bridge.bridge-nf-call-ip6tables <span class="token operator">=</span> 1net.bridge.bridge-nf-call-iptables <span class="token operator">=</span> 1EOFsysctl -p /etc/sysctl.d/k8s.conf</code></pre><p>4 安装Docker</p><pre class=" language-bash"><code class="language-bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<span class="token comment" spellcheck="true"># 如果没有yum-config-manager命令的话，请安装，步骤如下</span>--------------------------------------------------- start -----------------------------------------------------------<span class="token punctuation">[</span>root@rancherserver ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum search yum-config-manager</span>已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: centos.uhost.hk * epel: mirror.pregi.net * extras: centos.uhost.hk * updates: centos.uhost.hk<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>匹配：yum-config-manager <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>yum-utils.noarch <span class="token keyword">:</span> Utilities based around the yum package manageryum -y <span class="token function">install</span> yum-utils <span class="token comment" spellcheck="true"># 安装yum-config-manager的依赖包就可以了</span>---------------------------------------------------- end --------------------------------------------------------------yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -ryum <span class="token function">install</span> docker-ce-18.06.0.ce-3.el7 -ysystemctl start docker <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> docker</code></pre><h1 id="二-下面只需在192-168-1-119-master主机上部署"><a href="#二-下面只需在192-168-1-119-master主机上部署" class="headerlink" title="二 下面只需在192.168.1.119  master主机上部署"></a>二 下面只需在192.168.1.119  master主机上部署</h1><h2 id="2-1-创建k8s目录和下载自制证书的工具"><a href="#2-1-创建k8s目录和下载自制证书的工具" class="headerlink" title="2.1 创建k8s目录和下载自制证书的工具"></a>2.1 创建k8s目录和下载自制证书的工具</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">###  2.1.1 创建安装目录</span><span class="token function">mkdir</span> -p  /home/k8s/etcd/<span class="token punctuation">{</span>bin,cfg,ssl<span class="token punctuation">}</span><span class="token function">mkdir</span> -p  /home/k8s/kubernetes/<span class="token punctuation">{</span>bin,cfg,ssl<span class="token punctuation">}</span><span class="token function">mkdir</span> -p  /home/k8s/cfssl/<span class="token punctuation">{</span>etcd,kubernetes<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">#(这两个目录用来存放相关证书文件)</span><span class="token comment" spellcheck="true">### 2.1.2 安装配置CFSSL(CFSSL是自己创建证书的工具)</span><span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssl_linux-amd64<span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64<span class="token function">wget</span> https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64<span class="token function">chmod</span> +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64<span class="token function">mv</span> cfssl_linux-amd64 /usr/local/bin/cfssl<span class="token function">mv</span> cfssljson_linux-amd64 /usr/local/bin/cfssljson<span class="token function">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre><h2 id="2-2-开始创建证书"><a href="#2-2-开始创建证书" class="headerlink" title="2.2 开始创建证书"></a>2.2 开始创建证书</h2><h3 id="2-2-1创建ETCD证书-目录为-home-k8s-cfssl-etcd"><a href="#2-2-1创建ETCD证书-目录为-home-k8s-cfssl-etcd" class="headerlink" title="2.2.1创建ETCD证书(目录为/home/k8s/cfssl/etcd/)"></a>2.2.1创建ETCD证书(目录为/home/k8s/cfssl/etcd/)</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-config.json<span class="token punctuation">{</span>  <span class="token string">"signing"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"default"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>    <span class="token punctuation">}</span>,    <span class="token string">"profiles"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"www"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>,         <span class="token string">"usages"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token string">"signing"</span>,            <span class="token string">"key encipherment"</span>,            <span class="token string">"server auth"</span>,            <span class="token string">"client auth"</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="2-2-2-创建ETCD-CA配置文件"><a href="#2-2-2-创建ETCD-CA配置文件" class="headerlink" title="2.2.2 创建ETCD CA配置文件"></a>2.2.2 创建ETCD CA配置文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"etcd CA"</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="2-2-3创建ETCD-Server证书"><a href="#2-2-3创建ETCD-Server证书" class="headerlink" title="2.2.3创建ETCD Server证书"></a>2.2.3创建ETCD Server证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> server-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"etcd"</span>,    <span class="token string">"hosts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token string">"192.168.1.119"</span>,    <span class="token string">"192.168.1.118"</span>,    <span class="token string">"192.168.1.63"</span>    <span class="token punctuation">]</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="2-2-4生成ETCD-CA证书和私钥"><a href="#2-2-4生成ETCD-CA证书和私钥" class="headerlink" title="2.2.4生成ETCD CA证书和私钥"></a>2.2.4生成ETCD CA证书和私钥</h3><pre class=" language-bash"><code class="language-bash">cfssl gencert -initca ca-csr.json <span class="token operator">|</span> cfssljson -bare ca -cfssl gencert -ca<span class="token operator">=</span>ca.pem -ca-key<span class="token operator">=</span>ca-key.pem -config<span class="token operator">=</span>ca-config.json -profile<span class="token operator">=</span>www server-csr.json <span class="token operator">|</span> cfssljson -bare server</code></pre><h3 id="2-2-5创建Kubernetes-CA证书"><a href="#2-2-5创建Kubernetes-CA证书" class="headerlink" title="2.2.5创建Kubernetes CA证书"></a>2.2.5创建Kubernetes CA证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-config.json<span class="token punctuation">{</span>  <span class="token string">"signing"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"default"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>    <span class="token punctuation">}</span>,    <span class="token string">"profiles"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>      <span class="token string">"kubernetes"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"expiry"</span><span class="token keyword">:</span> <span class="token string">"87600h"</span>,         <span class="token string">"usages"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token string">"signing"</span>,            <span class="token string">"key encipherment"</span>,            <span class="token string">"server auth"</span>,            <span class="token string">"client auth"</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>EOF<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> ca-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"kubernetes"</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,            <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"System"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFcfssl gencert -initca ca-csr.json <span class="token operator">|</span> cfssljson -bare ca -</code></pre><h3 id="2-2-6-生成API-SERVER证书"><a href="#2-2-6-生成API-SERVER证书" class="headerlink" title="2.2.6 生成API_SERVER证书"></a>2.2.6 生成API_SERVER证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> server-csr.json<span class="token punctuation">{</span>    <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"kubernetes"</span>,    <span class="token string">"hosts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>      <span class="token string">"10.0.0.1"</span>,      <span class="token string">"127.0.0.1"</span>,      <span class="token string">"192.168.1.119"</span>,      <span class="token string">"kubernetes"</span>,      <span class="token string">"kubernetes.default"</span>,      <span class="token string">"kubernetes.default.svc"</span>,      <span class="token string">"kubernetes.default.svc.cluster"</span>,      <span class="token string">"kubernetes.default.svc.cluster.local"</span>    <span class="token punctuation">]</span>,    <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,        <span class="token string">"size"</span><span class="token keyword">:</span> 2048    <span class="token punctuation">}</span>,    <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,            <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,            <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,            <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"System"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFcfssl gencert -ca<span class="token operator">=</span>ca.pem -ca-key<span class="token operator">=</span>ca-key.pem -config<span class="token operator">=</span>ca-config.json -profile<span class="token operator">=</span>kubernetes server-csr.json <span class="token operator">|</span> cfssljson -bare server</code></pre><h3 id="2-2-7-创建Kubernetes-Proxy证书"><a href="#2-2-7-创建Kubernetes-Proxy证书" class="headerlink" title="2.2.7 创建Kubernetes Proxy证书"></a>2.2.7 创建Kubernetes Proxy证书</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> EOF <span class="token operator">|</span> <span class="token function">tee</span> kube-proxy-csr.json<span class="token punctuation">{</span>  <span class="token string">"CN"</span><span class="token keyword">:</span> <span class="token string">"system:kube-proxy"</span>,  <span class="token string">"hosts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,  <span class="token string">"key"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"algo"</span><span class="token keyword">:</span> <span class="token string">"rsa"</span>,    <span class="token string">"size"</span><span class="token keyword">:</span> 2048  <span class="token punctuation">}</span>,  <span class="token string">"names"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token string">"C"</span><span class="token keyword">:</span> <span class="token string">"CN"</span>,      <span class="token string">"L"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,      <span class="token string">"ST"</span><span class="token keyword">:</span> <span class="token string">"Guangzhou"</span>,      <span class="token string">"O"</span><span class="token keyword">:</span> <span class="token string">"k8s"</span>,      <span class="token string">"OU"</span><span class="token keyword">:</span> <span class="token string">"System"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span>EOFcfssl gencert -ca<span class="token operator">=</span>ca.pem -ca-key<span class="token operator">=</span>ca-key.pem -config<span class="token operator">=</span>ca-config.json -profile<span class="token operator">=</span>kubernetes kube-proxy-csr.json <span class="token operator">|</span> cfssljson -bare kube-proxy</code></pre><h2 id="2-3-Master主机到其它两个node节点做ssh-key认证"><a href="#2-3-Master主机到其它两个node节点做ssh-key认证" class="headerlink" title="2.3  Master主机到其它两个node节点做ssh-key认证"></a>2.3  Master主机到其它两个node节点做ssh-key认证</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ssh-keygen </span>Generating public/private rsa key pair.Enter <span class="token function">file</span> <span class="token keyword">in</span> <span class="token function">which</span> to save the key <span class="token punctuation">(</span>/root/.ssh/id_rsa<span class="token punctuation">)</span>: Created directory <span class="token string">'/root/.ssh'</span><span class="token keyword">.</span>Enter passphrase <span class="token punctuation">(</span>empty <span class="token keyword">for</span> no passphrase<span class="token punctuation">)</span>: Enter same passphrase again: Your identification has been saved <span class="token keyword">in</span> /root/.ssh/id_rsa.Your public key has been saved <span class="token keyword">in</span> /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:FQjjiRDp8IKGT+UDM+GbQLBzF3DqDJ+pKnMIcHGyO/o root@qas-k8s-master01The key's randomart image is:+---<span class="token punctuation">[</span>RSA 2048<span class="token punctuation">]</span>----+<span class="token operator">|</span>o.<span class="token operator">==</span>o o. <span class="token punctuation">..</span>      <span class="token operator">|</span><span class="token operator">|</span>ooB+o+ o.  <span class="token keyword">.</span>     <span class="token operator">|</span><span class="token operator">|</span>B++@o o   <span class="token keyword">.</span>      <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">=</span>X**o    <span class="token keyword">.</span>       <span class="token operator">|</span><span class="token operator">|</span>o<span class="token operator">=</span>O. <span class="token keyword">.</span>  S        <span class="token operator">|</span><span class="token operator">|</span><span class="token punctuation">..</span>+              <span class="token operator">|</span><span class="token operator">|</span>oo <span class="token keyword">.</span>             <span class="token operator">|</span><span class="token operator">|</span>* <span class="token keyword">.</span>              <span class="token operator">|</span><span class="token operator">|</span>o+E              <span class="token operator">|</span>+----<span class="token punctuation">[</span>SHA256<span class="token punctuation">]</span>-----+<span class="token comment" spellcheck="true"># ssh-copy-id 192.168.1.119</span><span class="token comment" spellcheck="true"># ssh-copy-id 192.168.1.63</span><span class="token comment" spellcheck="true"># 上面一步要输入这两台机器的密码</span></code></pre><h1 id="三-部署ETCD服务集群-三台机器同时都需要部署"><a href="#三-部署ETCD服务集群-三台机器同时都需要部署" class="headerlink" title="三 部署ETCD服务集群(三台机器同时都需要部署)"></a>三 部署ETCD服务集群(三台机器同时都需要部署)</h1><h2 id="三个节点都要下载etcd源码包，三台机器通过xshell同时连接"><a href="#三个节点都要下载etcd源码包，三台机器通过xshell同时连接" class="headerlink" title="三个节点都要下载etcd源码包，三台机器通过xshell同时连接"></a>三个节点都要下载etcd源码包，三台机器通过xshell同时连接</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src/<span class="token function">wget</span> http://down.cdn1688.net/k8s1.13/etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">tar</span> -xvf etcd-v3.3.10-linux-amd64.tar.gz<span class="token function">cd</span> etcd-v3.3.10-linux-amd64/ <span class="token operator">&amp;&amp;</span> <span class="token function">cp</span> etcd etcdctl /home/k8s/etcd/bin/</code></pre><h2 id="192-168-1-119-Master节点部署如下"><a href="#192-168-1-119-Master节点部署如下" class="headerlink" title="192.168.1.119 Master节点部署如下"></a>192.168.1.119 Master节点部署如下</h2><pre class=" language-bash"><code class="language-bash">vim /home/k8s/etcd/cfg/etcd<span class="token comment" spellcheck="true">#[Member]</span>ETCD_NAME<span class="token operator">=</span><span class="token string">"etcd1"</span>ETCD_DATA_DIR<span class="token operator">=</span><span class="token string">"/var/lib/etcd/default.etcd"</span>ETCD_LISTEN_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2380"</span>ETCD_LISTEN_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379"</span><span class="token comment" spellcheck="true">#[Clustering]</span>ETCD_INITIAL_ADVERTISE_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2380"</span>ETCD_ADVERTISE_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379"</span>ETCD_INITIAL_CLUSTER<span class="token operator">=</span><span class="token string">"etcd1=https://192.168.1.119:2380,etcd2=https://192.168.1.118:2380,etcd3=https://192.168.1.63:2380"</span>ETCD_INITIAL_CLUSTER_TOKEN<span class="token operator">=</span><span class="token string">"etcd-cluster"</span>ETCD_INITIAL_CLUSTER_STATE<span class="token operator">=</span><span class="token string">"new"</span></code></pre><h2 id="创建etcd的systemd-unit文件"><a href="#创建etcd的systemd-unit文件" class="headerlink" title="创建etcd的systemd unit文件"></a>创建etcd的systemd unit文件</h2><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/etcd.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Etcd ServerAfter<span class="token operator">=</span>network.targetAfter<span class="token operator">=</span>network-online.targetWants<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notifyEnvironmentFile<span class="token operator">=</span>/home/k8s/etcd/cfg/etcdExecStart<span class="token operator">=</span>/home/k8s/etcd/bin/etcd \--name<span class="token operator">=</span><span class="token variable">${ETCD_NAME}</span> \--data-dir<span class="token operator">=</span><span class="token variable">${ETCD_DATA_DIR}</span> \--listen-peer-urls<span class="token operator">=</span><span class="token variable">${ETCD_LISTEN_PEER_URLS}</span> \--listen-client-urls<span class="token operator">=</span><span class="token variable">${ETCD_LISTEN_CLIENT_URLS}</span>,http://127.0.0.1:2379 \--advertise-client-urls<span class="token operator">=</span><span class="token variable">${ETCD_ADVERTISE_CLIENT_URLS}</span> \--initial-advertise-peer-urls<span class="token operator">=</span><span class="token variable">${ETCD_INITIAL_ADVERTISE_PEER_URLS}</span> \--initial-cluster<span class="token operator">=</span><span class="token variable">${ETCD_INITIAL_CLUSTER}</span> \--initial-cluster-token<span class="token operator">=</span><span class="token variable">${ETCD_INITIAL_CLUSTER_TOKEN}</span> \--initial-cluster-state<span class="token operator">=</span>new \--cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--key-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pem \--peer-cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--peer-key-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pem \--trusted-ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem \--peer-trusted-ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pemRestart<span class="token operator">=</span>on-failureLimitNOFILE<span class="token operator">=</span>65536<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><h3 id="把目录-home-k8s-cfssl-etcd-下制作的证书文件拷贝到-home-k8s-etcd-ssl目录下用于启动etcd服务"><a href="#把目录-home-k8s-cfssl-etcd-下制作的证书文件拷贝到-home-k8s-etcd-ssl目录下用于启动etcd服务" class="headerlink" title="把目录/home/k8s/cfssl/etcd/下制作的证书文件拷贝到/home/k8s/etcd/ssl目录下用于启动etcd服务"></a>把目录/home/k8s/cfssl/etcd/下制作的证书文件拷贝到/home/k8s/etcd/ssl目录下用于启动etcd服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> /home/k8s/cfssl/etcd/  /home/k8s/etcd/ssl/</code></pre><h2 id="192-168-1-118-node1节点部署如下"><a href="#192-168-1-118-node1节点部署如下" class="headerlink" title="192.168.1.118  node1节点部署如下"></a>192.168.1.118  node1节点部署如下</h2><pre class=" language-bash"><code class="language-bash">把master的etcd的配置文件和启动文件拷贝到node1上<span class="token comment" spellcheck="true"># 进入192.168.1.119(master)的/home/k8s/目录</span><span class="token function">scp</span> -r /home/k8s/etcd    192.168.1.118:/home/k8s/<span class="token function">scp</span> -r /usr/lib/systemd/system/etcd.service 192.168.1.118:/usr/lib/systemd/system/etcd.service<span class="token comment" spellcheck="true"># 进入192.168.1.118(node1)需要对/home/k8s/etcd/cfg/etcd配置文件进行修改</span>vim /home/k8s/etcd/cfg/etcd<span class="token comment" spellcheck="true">#[Member]</span>ETCD_NAME<span class="token operator">=</span><span class="token string">"etcd2"</span>ETCD_DATA_DIR<span class="token operator">=</span><span class="token string">"/var/lib/etcd/default.etcd"</span>ETCD_LISTEN_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2380"</span>ETCD_LISTEN_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2379"</span><span class="token comment" spellcheck="true">#[Clustering]</span>ETCD_INITIAL_ADVERTISE_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2380"</span>ETCD_ADVERTISE_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.118:2379"</span>ETCD_INITIAL_CLUSTER<span class="token operator">=</span><span class="token string">"etcd1=https://192.168.1.119:2380,etcd2=https://192.168.1.118:2380,etcd3=https://192.168.1.63:2380"</span>ETCD_INITIAL_CLUSTER_TOKEN<span class="token operator">=</span><span class="token string">"etcd-cluster"</span>ETCD_INITIAL_CLUSTER_STATE<span class="token operator">=</span><span class="token string">"new"</span>node1节点的 etcd的 systemd unit 文件<span class="token punctuation">(</span>启动文件<span class="token punctuation">)</span>不需要修改</code></pre><h2 id="192-168-1-163-node2节点部署如下"><a href="#192-168-1-163-node2节点部署如下" class="headerlink" title="192.168.1.163  node2节点部署如下"></a>192.168.1.163  node2节点部署如下</h2><pre class=" language-bash"><code class="language-bash">把master的etcd的配置文件和启动文件拷贝到node1上<span class="token comment" spellcheck="true"># 进入192.168.1.119(master)的/home/k8s/目录</span><span class="token function">scp</span> -r /home/k8s/etcd    192.168.1.163:/home/k8s/<span class="token function">scp</span> -r /usr/lib/systemd/system/etcd.service 192.168.1.63:/usr/lib/systemd/system/etcd.service<span class="token comment" spellcheck="true"># 进入192.168.1.63(node2)需要对/home/k8s/etcd/cfg/etcd配置文件进行修改</span>vim /home/k8s/etcd/cfg/etcd<span class="token comment" spellcheck="true">#[Member]</span>ETCD_NAME<span class="token operator">=</span><span class="token string">"etcd3"</span>ETCD_DATA_DIR<span class="token operator">=</span><span class="token string">"/var/lib/etcd/default.etcd"</span>ETCD_LISTEN_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2380"</span>ETCD_LISTEN_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2379"</span><span class="token comment" spellcheck="true">#[Clustering]</span>ETCD_INITIAL_ADVERTISE_PEER_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2380"</span>ETCD_ADVERTISE_CLIENT_URLS<span class="token operator">=</span><span class="token string">"https://192.168.1.63:2379"</span>ETCD_INITIAL_CLUSTER<span class="token operator">=</span><span class="token string">"etcd1=https://192.168.1.119:2380,etcd2=https://192.168.1.118:2380,etcd3=https://192.168.1.63:2380"</span>ETCD_INITIAL_CLUSTER_TOKEN<span class="token operator">=</span><span class="token string">"etcd-cluster"</span>ETCD_INITIAL_CLUSTER_STATE<span class="token operator">=</span><span class="token string">"new"</span>node2节点的 etcd的 systemd unit 文件<span class="token punctuation">(</span>启动文件<span class="token punctuation">)</span>也不需要修改</code></pre><h3 id="三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）"><a href="#三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）" class="headerlink" title="三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）"></a>三节点同时启动etcd服务（注意事项：ETCD集群启动时，必须两个或者三个节点同时启动，启动一个节点集群是无法正常启动的）</h3><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> etcdsystemctl start etcd</code></pre><p>###<br>验证集群是否正常运行</p><pre class=" language-bash"><code class="language-bash">/home/k8s/etcd/bin/etcdctl \--ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem \--cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--key-file<span class="token operator">=</span>/homek8s/etcd/ssl/server-key.pem \--endpoints<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379,\https://192.168.1.118:2379,\https://192.168.1.63:2379"</span> cluster-health</code></pre><h2 id="四-三节点部署Flannel网络"><a href="#四-三节点部署Flannel网络" class="headerlink" title="四 三节点部署Flannel网络"></a>四 三节点部署Flannel网络</h2><h3 id="先在master上部署Flannel网络，登录master机器"><a href="#先在master上部署Flannel网络，登录master机器" class="headerlink" title="先在master上部署Flannel网络，登录master机器"></a>先在master上部署Flannel网络，登录master机器</h3><p>向etcd写入集群Pod网段信息</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/k8s/etcd/ssl//home/k8s/etcd/bin/etcdctl \--ca-file<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem  \--cert-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem \--key-file<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pem \--endpoints<span class="token operator">=</span><span class="token string">"https://192.168.1.119:2379,\https://192.168.1.118:2379,https://192.168.1.63:2379"</span> \<span class="token keyword">set</span> /coreos.com/network/config  <span class="token string">'{ "Network": "172.18.0.0/16", "Backend": {"Type": "vxlan"}}'</span></code></pre><p>下面这两句话部署的过程中我不懂啥意思，尤其是第一句简直就是懵逼了</p><blockquote><ul><li>flanneld当前版本(v0.10.0)不支持etcdv3,故使用etcd v2 API写入配置key和网段数据</li><li>写入Pod网段 ${CLUSTER_CIDR}必须是/16段地址，必须与kube-controller-的-cluster-cidr参数值一致;</li></ul></blockquote><p>下载安装flannel软件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src/ <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> http://down.cdn1688.net/k8s1.13/flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">tar</span> -xvf flannel-v0.10.0-linux-amd64.tar.gz<span class="token function">mv</span> flannel mk-docker-opts.sh /home/k8s/kubernetes/bin/创建Flannel配置文件vim /home/k8s/kubernetes/cfg/flanneldFLANNEL_OPTIONS<span class="token operator">=</span><span class="token string">"--etcd-endpoints=https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile=/home/k8s/etcd/ssl/ca.pem -etcd-certfile=/home/k8s/etcd/ssl/server.pem -etcd-keyfile=/home/k8s/etcd/ssl/server-key.pem"</span></code></pre><p>创建flanneld的systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/flanneld.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Flanneld overlay address etcd agentAfter<span class="token operator">=</span>network-online.target network.targetBefore<span class="token operator">=</span>docker.service<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notifyEnvironmentFile<span class="token operator">=</span>/home/k8s/kubernetes/cfg/flanneldExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/flanneld --ip-masq <span class="token variable">$FLANNEL_OPTIONS</span>ExecStartPost<span class="token operator">=</span>/home/k8s/kubernetes/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/subnet.envRestart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><blockquote><ul><li>mk-docker-opts.sh脚本分配给flanneld的Pod子网网段信息写入/run/flannel/docker文件，后续docker启动时使用这个文件中的环境变量配置docker0网桥;</li><li>flanneld使用系统缺省路由所在的接口与其它节点通信，对于有多个网络接口(如内网和公网)的节点，可以用-iface参数指定通信接口，如上面的eth0接口;</li><li>flanneld运行时需要root权限<br>配置Docker启动指定子网段</li></ul></blockquote><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/docker.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Docker Application Container EngineDocumentation<span class="token operator">=</span>https://docs.docker.comAfter<span class="token operator">=</span>network-online.target firewalld.serviceWants<span class="token operator">=</span>network-online.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>Type<span class="token operator">=</span>notifyEnvironmentFile<span class="token operator">=</span>/run/flannel/subnet.envExecStart<span class="token operator">=</span>/usr/bin/dockerd <span class="token variable">$DOCKER_NETWORK_OPTIONS</span>ExecReload<span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span>LimitNOFILE<span class="token operator">=</span>infinityLimitNPROC<span class="token operator">=</span>infinityLimitCORE<span class="token operator">=</span>infinityTimeoutStartSec<span class="token operator">=</span>0Delegate<span class="token operator">=</span>yesKillMode<span class="token operator">=</span>processRestart<span class="token operator">=</span>on-failureStartLimitBurst<span class="token operator">=</span>3StartLimitInterval<span class="token operator">=</span>60s<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>注意：对上面的文件内容做一下解析：</p><blockquote><ul><li>FLannel网络必须在宿主机网络能对外(其它node节点)正常通信的情况下启动才有意义，所以这里定义After=network.target</li><li>只有当Flannel网络启动之后，才能创建一个与其它节点不会冲突的网络，而docker的网络需要和fannel网络相同才能保证跨主机通信，所以docker必须要在flannel网络创建后才能启动，这里定义before=docker.service<br>将flanneld systemd unit文件拷贝到所有节点(在master上操作)</li></ul></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#把对应的配置文件拷贝到node1和node2上</span><span class="token function">scp</span> -r /home/k8s/kubernetes    192.168.1.118:/home/k8s/<span class="token function">scp</span> -r /home/k8s/kubernetes    192.168.1.63:/home/k8s/<span class="token function">scp</span> /home/k8s/kubernetes/cfg/flanneld   192.168.1.118:/home/k8s/kubernetes/cfg/flanneld<span class="token function">scp</span> /home/k8s/kubernetes/cfg/flanneld   192.168.1.63:/home/k8s/kubernetes/cfg/flanneld<span class="token function">scp</span> /usr/lib/systemd/system/docker.server 192.168.1.118:/usr/lib/systemd/system/docker.servier<span class="token function">scp</span> /usr/lib/systemd/system/docker.server   192.168.1.63:/usr/lib/systemd/system/docker.servier<span class="token function">scp</span> /usr/lib/systemd/system/flanneld.service  192.168.1.118:/usr/lib/systemd/system/flanneld.servier<span class="token function">scp</span> /usr/lib/systemd/system/flanneld.service  192.168.1.63:/usr/lib/systemd/system/flanneld.servier</code></pre><p>三节点都执行下面命令：启动服务和重启docker</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl start flanneld <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> flanneldsystemctl restart docker</code></pre><p>可以在各个节点上查看是否生效(下面是在master、node1、node2上的操作结果)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ip addr</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: em1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc mq state UP qlen 1000    link/ether 80:18:44:e3:61:e4 brd ff:ff:ff:ff:ff:ff    inet 192.168.1.119/24 brd 192.168.1.255 scope global em1       valid_lft forever preferred_lft forever    inet6 fe80::4e7f:7ff9:fbc0:d131/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever3: em2: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:61:e5 brd ff:ff:ff:ff:ff:ff4: em3: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:61:e6 brd ff:ff:ff:ff:ff:ff5: em4: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:61:e7 brd ff:ff:ff:ff:ff:ff6: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UP     link/ether 02:42:24:16:72:04 brd ff:ff:ff:ff:ff:ff    inet 172.18.89.1/24 brd 172.18.89.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:24ff:fe16:7204/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever7: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN     link/ether 4a:a6:d0:d3:f2:ce brd ff:ff:ff:ff:ff:ff    inet 172.18.89.0/32 scope global flannel.1       valid_lft forever preferred_lft forever11: vethea3f23b@if10: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether be:59:a5:d3:cd:41 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::bc59:a5ff:fed3:cd41/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever<span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ip addr</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: em1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc mq state UP qlen 1000    link/ether 80:18:44:e3:56:c0 brd ff:ff:ff:ff:ff:ff    inet 192.168.1.118/24 brd 192.168.1.255 scope global em1       valid_lft forever preferred_lft forever    inet6 fe80::4585:be92:8558:dbf6/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever3: em2: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:56:c1 brd ff:ff:ff:ff:ff:ff4: em3: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:56:c2 brd ff:ff:ff:ff:ff:ff5: em4: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 80:18:44:e3:56:c3 brd ff:ff:ff:ff:ff:ff6: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UP     link/ether 02:42:e2:a7:53:8f brd ff:ff:ff:ff:ff:ff    inet 172.18.99.1/24 brd 172.18.99.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:e2ff:fea7:538f/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever7: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN     link/ether ba:7d:4e:4b:6a:ef brd ff:ff:ff:ff:ff:ff    inet 172.18.99.0/32 scope global flannel.1       valid_lft forever preferred_lft forever9: vethd9144bb@if8: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether c2:39:12:a7:be:cd brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::c039:12ff:fea7:becd/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever11: vethec20706@if10: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether de:d4:47:90:8d:a5 brd ff:ff:ff:ff:ff:ff link-netnsid 1    inet6 fe80::dcd4:47ff:fe90:8da5/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever<span class="token comment" spellcheck="true">#######################################################################################</span><span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ip addr</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: em1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc mq state UP qlen 1000    link/ether 20:47:47:8d:f4:9c brd ff:ff:ff:ff:ff:ff    inet 192.168.1.63/24 brd 192.168.1.255 scope global em1       valid_lft forever preferred_lft forever    inet6 fe80::976b:ad75:61c6:8c2d/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever3: em2: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 20:47:47:8d:f4:9d brd ff:ff:ff:ff:ff:ff4: em3: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 20:47:47:8d:f4:9e brd ff:ff:ff:ff:ff:ff5: em4: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">></span> mtu 1500 qdisc mq state DOWN qlen 1000    link/ether 20:47:47:8d:f4:9f brd ff:ff:ff:ff:ff:ff6: docker0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UP     link/ether 02:42:79:c7:6b:62 brd ff:ff:ff:ff:ff:ff    inet 172.18.72.1/24 brd 172.18.72.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:79ff:fec7:6b62/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever7: flannel.1: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue state UNKNOWN     link/ether 4e:cd:29:4b:df:1b brd ff:ff:ff:ff:ff:ff    inet 172.18.72.0/32 scope global flannel.1       valid_lft forever preferred_lft forever13: veth1e4d6e8@if12: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether fe:6c:77:28:be:eb brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::fc6c:77ff:fe28:beeb/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever17: veth7a9dd40@if16: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1450 qdisc noqueue master docker0 state UP     link/ether 7a:05:16:52:c1:4a brd ff:ff:ff:ff:ff:ff link-netnsid 1    inet6 fe80::7805:16ff:fe52:c14a/64 scope <span class="token function">link</span>        valid_lft forever preferred_lft forever</code></pre><p>这时三个节点都部署了etcd、flannled、docker服务了,下面是master、node1、node2上的显示</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lntp |grep etcd</span>tcp        0      0 192.168.1.119:2379      0.0.0.0:*               LISTEN      12651/etcd          tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      12651/etcd          tcp        0      0 192.168.1.119:2380      0.0.0.0:*               LISTEN      12651/etcd   <span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep flannel</span>root      12903      1  0 4月29 ?       00:08:32 /home/k8s/kubernetes/bin/flanneld --ip-masq --etcd-endpoints<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem -etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem -etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot      64750  64185  0 15:46 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto flannel<span class="token punctuation">[</span>root@docker-1 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep docker</span>root      13017      1  0 4月29 ?       01:25:11 /usr/bin/dockerd --bip<span class="token operator">=</span>172.18.89.1/24 --ip-masq<span class="token operator">=</span>false --mtu<span class="token operator">=</span>1450root      13031  13017  0 4月29 ?       00:55:16 docker-containerd --config /var/run/docker/containerd/containerd.tomlroot      65318  64185  0 15:51 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto docker<span class="token comment" spellcheck="true">#######################################################################################</span><span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lntp |grep etcd</span>tcp        0      0 192.168.1.118:2379      0.0.0.0:*               LISTEN      11976/etcd          tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      11976/etcd          tcp        0      0 192.168.1.118:2380      0.0.0.0:*               LISTEN      11976/etcd   <span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep flanneld</span>root      12131      1  0 4月29 ?       00:08:42 /home/k8s/kubernetes/bin/flanneld --ip-masq --etcd-endpoints<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem -etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem -etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot     114125 114001  0 15:47 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto flanneld<span class="token punctuation">[</span>root@docker-2 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep docker</span>root      12243      1  0 4月29 ?       01:40:32 /usr/bin/dockerd --bip<span class="token operator">=</span>172.18.99.1/24 --ip-masq<span class="token operator">=</span>false --mtu<span class="token operator">=</span>1450root      12258  12243  1 4月29 ?       02:13:34 docker-containerd --config /var/run/docker/containerd/containerd.toml<span class="token comment" spellcheck="true">#######################################################################################</span><span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># netstat -lntp |grep etcd</span>tcp        0      0 192.168.1.63:2379       0.0.0.0:*               LISTEN      11645/etcd          tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      11645/etcd          tcp        0      0 192.168.1.63:2380       0.0.0.0:*               LISTEN      11645/etcd   <span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep flanneld</span>root      11781      1  0 4月29 ?       00:08:47 /home/k8s/kubernetes/bin/flanneld --ip-masq --etcd-endpoints<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 -etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem -etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem -etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot      35948  35741  0 15:45 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto flanneld<span class="token punctuation">[</span>root@docker-3 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep docker</span>root      11892      1  0 4月29 ?       01:42:50 /usr/bin/dockerd --bip<span class="token operator">=</span>172.18.72.1/24 --ip-masq<span class="token operator">=</span>false --mtu<span class="token operator">=</span>1450root      11906  11892  1 4月29 ?       02:25:14 docker-containerd --config /var/run/docker/containerd/containerd.toml</code></pre><h2 id="五-部署master节点"><a href="#五-部署master节点" class="headerlink" title="五    部署master节点"></a>五    部署master节点</h2><p>kubernetes master节点运行如下组件：</p><blockquote><ul><li>kuber-apiserver</li><li>kube-scheduler</li><li>kube-controller-manager  </li><li>注意：kuber-scheduler和kube-controlller-manager可以以集群模式运行，通过leader选举产生一个工作进程，其它进程处于阻塞模式。</li></ul></blockquote><p>将kubernetes-server二进制文件解压拷贝到master节点</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src <span class="token operator">&amp;&amp;</span> <span class="token function">wget</span> http://down.cdn1688.net/k8s1.13/kubernetes-server-linux-amd64.tar.gz<span class="token comment" spellcheck="true"># 特别注意下面这目录</span><span class="token function">cd</span> /usr/local/src/kubernetes/server/bin <span class="token function">cp</span> kube-scheduler kube-apiserver kube-controller-manager kubectl /home/k8s/kubernetes/bin/<span class="token comment" spellcheck="true">## 拷贝证书</span><span class="token function">cp</span> /home/k8s/cfssl/kubernetes/*pem  /home/k8s/kubernetes/ssl/</code></pre><p>部署kube-apiserver组件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建TLS Bootstrapping Token</span><span class="token operator">></span> <span class="token function">head</span> -c 16 /dev/urandom <span class="token operator">|</span> od -An -t x <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">' '</span>b2d81324fb83862f435f66498b90e5bdvim /home/k8s/kubernetes/cfg/token.csvb2d81324fb83862f435f66498b90e5bd,kubelet-bootstrap,10001,<span class="token string">"system:kubelet-bootstrap"</span></code></pre><p>创建apiserver配置文件</p><pre class=" language-bash"><code class="language-bash">vim /home/k8s/kubernetes/cfg/kube-apiserverKUBE_APISERVER_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--etcd-servers=https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 \--bind-address=192.168.1.119 \--secure-port=6443 \--advertise-address=192.168.1.119 \--allow-privileged=true \--service-cluster-ip-range=10.0.0.0/24 \--enable-admission-plugins=NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota,NodeRestriction \--authorization-mode=RBAC,Node \--enable-bootstrap-token-auth \--token-auth-file=/home/k8s/kubernetes/cfg/token.csv \--service-node-port-range=30000-50000 \--tls-cert-file=/home/k8s/kubernetes/ssl/server.pem  \--tls-private-key-file=/home/k8s/kubernetes/ssl/server-key.pem \--client-ca-file=/home/k8s/kubernetes/ssl/ca.pem \--service-account-key-file=/home/k8s/kubernetes/ssl/ca-key.pem \--etcd-cafile=/home/k8s/etcd/ssl/ca.pem \--etcd-certfile=/home/k8s/etcd/ssl/server.pem \--etcd-keyfile=/home/k8s/etcd/ssl/server-key.pem"</span></code></pre><p>创建kube-apiserver systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/kube-apiserver.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes API ServerDocumentation<span class="token operator">=</span>https://github.com/kubernetes/kubernetes<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-apiserverExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-apiserver <span class="token variable">$KUBE_APISERVER_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>启动kube-apiserver服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-apiserversystemctl restart kube-apiserver<span class="token comment" spellcheck="true"># 查看apiserver是否运行</span><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps  -ef | grep kube-apiserver </span>root      16331      1  3 4月29 ?       06:43:45 /home/k8s/kubernetes/bin/kube-apiserver --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --etcd-servers<span class="token operator">=</span>https://192.168.1.119:2379,https://192.168.1.118:2379,https://192.168.1.63:2379 --bind-address<span class="token operator">=</span>192.168.1.119 --secure-port<span class="token operator">=</span>6443 --advertise-address<span class="token operator">=</span>192.168.1.119 --allow-privileged<span class="token operator">=</span>true --service-cluster-ip-range<span class="token operator">=</span>10.0.0.0/24 --enable-admission-plugins<span class="token operator">=</span>NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota,NodeRestriction --authorization-mode<span class="token operator">=</span>RBAC,Node --enable-bootstrap-token-auth --token-auth-file<span class="token operator">=</span>/home/k8s/kubernetes/cfg/token.csv --service-node-port-range<span class="token operator">=</span>30000-50000 --tls-cert-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/server.pem --tls-private-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/server-key.pem --client-ca-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca.pem --service-account-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca-key.pem --etcd-cafile<span class="token operator">=</span>/home/k8s/etcd/ssl/ca.pem --etcd-certfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server.pem --etcd-keyfile<span class="token operator">=</span>/home/k8s/etcd/ssl/server-key.pemroot     109163 104117  0 21:41 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto kube-apiserver</code></pre><p>部署kube-scheduler</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建kube-scheduler配置文件</span>vim /home/k8s/kubernetes/cfg/kube-schedulerKUBE_SCHEDULER_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true --v=4 --master=127.0.0.1:8080 --leader-elect"</span></code></pre><blockquote><ul><li>-address:在127.0.0.1:10251 端口接收http/metrics请求；kube-scheduler目前还不支持接收https请求；</li><li>-kubeconfig:指定kubeconfig文件路径，kube-scheduler使用它连接和验证kube-apiserver;</li><li>-leader-elect=true:集群运行模式，启用选举功能；被选为leader的节点负责处理工作，其它节点为阻塞状态；</li></ul></blockquote><p>创建kube-scheduler systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/kube-scheduler.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes SchedulerDocumentation<span class="token operator">=</span>https://github.com/kubernetes/kubernetes<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-schedulerExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-scheduler <span class="token variable">$KUBE_SCHEDULER_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>启动服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-scheduler.servicesystemctl .restart kube-scheduler.service<span class="token comment" spellcheck="true">## 查看kube-scheduler是否运行和状态</span><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  ps -ef |grep kube-scheduler </span>root      32101      1  1 4月29 ?       02:01:04 /home/k8s/kubernetes/bin/kube-scheduler --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-electroot     110330 104117  0 21:50 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto kube-scheduler<span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kube-scheduler.service</span>● kube-scheduler.service - Kubernetes Scheduler   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/kube-scheduler.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since 一 2019-04-29 21:21:08 CST<span class="token punctuation">;</span> 1 weeks 1 days ago     Docs: https://github.com/kubernetes/kubernetes Main PID: 32101 <span class="token punctuation">(</span>kube-scheduler<span class="token punctuation">)</span>   Memory: 26.1M   CGroup: /system.slice/kube-scheduler.service           └─32101 /home/k8s/kubernetes/bin/kube-scheduler --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-elect5月 07 21:44:19 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:44:19.379442   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/kubernetes/cmd/kube-scheduler/app/server.go:232: Watch close - *v1.Pod total 3 items received5月 07 21:44:44 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:44:44.318917   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.Service total 0 items received5月 07 21:45:09 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:45:09.308219   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.PersistentVolumeClaim total 0 items received5月 07 21:48:08 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:48:08.319573   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.Node total 105 items received5月 07 21:48:26 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:48:26.301859   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.ReplicaSet total 4 items received5月 07 21:48:34 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:48:34.319324   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.ReplicationController total 0 items received5月 07 21:49:20 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:49:20.328175   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.PersistentVolume total 0 items received5月 07 21:49:22 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:49:22.380500   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/kubernetes/cmd/kube-scheduler/app/server.go:232: Watch close - *v1.Pod total 3 items received5月 07 21:49:33 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:49:33.290127   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1beta1.PodDisruptionBudget total 0 items received5月 07 21:50:15 docker-1 kube-scheduler<span class="token punctuation">[</span>32101<span class="token punctuation">]</span>: I0507 21:50:15.277980   32101 reflector.go:357<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: Watch close - *v1.StorageClass total 0 items received</code></pre><p>部署kube-controller-manager</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建kube-controller-manager配置文件</span>vim /home/k8s/kubernetes/cfg/kube-controller-manager KUBE_CONTROLLER_MANAGER_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--master=127.0.0.1:8080 \--leader-elect=true \--address=127.0.0.1 \--service-cluster-ip-range=10.0.0.0/24 \--cluster-name=kubernetes \--cluster-signing-cert-file=/home/k8s/kubernetes/ssl/ca.pem \--cluster-signing-key-file=/home/k8s/kubernetes/ssl/ca-key.pem  \--root-ca-file=/home/k8s/kubernetes/ssl/ca.pem \--service-account-private-key-file=/home/k8s/kubernetes/ssl/ca-key.pem"</span></code></pre><p>创建kube-controller-manager systemd unit文件</p><pre class=" language-bash"><code class="language-bash">vim /usr/lib/systemd/system/kube-controller-manager.service <span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes Controller ManagerDocumentation<span class="token operator">=</span>https://github.com/kubernetes/kubernetes<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-controller-managerExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-controller-manager <span class="token variable">$KUBE_CONTROLLER_MANAGER_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>启动kube-controller-manager服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-controller-managersystemctl restart kube-controller-manager</code></pre><p>查看kube-controller-manager是否运行</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kube-controller-manager</span>● kube-controller-manager.service - Kubernetes Controller Manager   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/kube-controller-manager.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since 一 2019-04-29 21:25:58 CST<span class="token punctuation">;</span> 1 weeks 1 days ago     Docs: https://github.com/kubernetes/kubernetes Main PID: 32544 <span class="token punctuation">(</span>kube-controller<span class="token punctuation">)</span>   Memory: 76.2M   CGroup: /system.slice/kube-controller-manager.service           └─32544 /home/k8s/kubernetes/bin/kube-controller-manager --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-elect<span class="token operator">=</span>true --address<span class="token operator">=</span>127.0.0.1 --service-cluster-ip-range<span class="token operator">=</span>10.0.0.0/24 --cluster-name<span class="token operator">=</span>kubernetes --cluster-signing-cert-file<span class="token operator">=</span>/home/k8s/kuberne<span class="token punctuation">..</span>.5月 07 21:56:02 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:02.328943   32544 attach_detach_controller.go:634<span class="token punctuation">]</span> processVolumesInUse <span class="token keyword">for</span> node <span class="token string">"192.168.1.118"</span>5月 07 21:56:03 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:03.184628   32544 node_lifecycle_controller.go:929<span class="token punctuation">]</span> Node 192.168.1.119 ReadyCondition updated. Updating timestamp.5月 07 21:56:03 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:03.184673   32544 node_lifecycle_controller.go:929<span class="token punctuation">]</span> Node 192.168.1.118 ReadyCondition updated. Updating timestamp.5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.193087   32544 attach_detach_controller.go:634<span class="token punctuation">]</span> processVolumesInUse <span class="token keyword">for</span> node <span class="token string">"192.168.1.63"</span>5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.614869   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.614875   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:04 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:04.712730   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:08 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:08.184898   32544 node_lifecycle_controller.go:929<span class="token punctuation">]</span> Node 192.168.1.63 ReadyCondition updated. Updating timestamp.5月 07 21:56:08 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:08.782878   32544 reflector.go:215<span class="token punctuation">]</span> k8s.io/client-go/informers/factory.go:132: forcing resync5月 07 21:56:08 docker-1 kube-controller-manager<span class="token punctuation">[</span>32544<span class="token punctuation">]</span>: I0507 21:56:08.793132   32544 pv_controller_base.go:408<span class="token punctuation">]</span> resyncing PV controller<span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps -ef |grep kube-controller-manager</span>root      32544      1  4 4月29 ?       09:30:31 /home/k8s/kubernetes/bin/kube-controller-manager --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --master<span class="token operator">=</span>127.0.0.1:8080 --leader-elect<span class="token operator">=</span>true --address<span class="token operator">=</span>127.0.0.1 --service-cluster-ip-range<span class="token operator">=</span>10.0.0.0/24 --cluster-name<span class="token operator">=</span>kubernetes --cluster-signing-cert-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca.pem --cluster-signing-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca-key.pem --root-ca-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca.pem --service-account-private-key-file<span class="token operator">=</span>/home/k8s/kubernetes/ssl/ca-key.pemroot     111998 104117  0 22:03 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto kube-controller-manager</code></pre><p>将可执行文件路径/home/k8s/kubernetes/bin/添加到环境变量PATH中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/profile.d/vim k8s.sh<span class="token function">export</span> PATH<span class="token operator">=</span>/home/k8s/kubernetes/bin:<span class="token variable">$PATH</span><span class="token function">source</span> k8s.sh</code></pre><p>查看集群master状态</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 cfg<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get cs,nodes</span>NAME                                 STATUS    MESSAGE             ERRORcomponentstatus/controller-manager   Healthy   ok                  componentstatus/scheduler            Healthy   ok                  componentstatus/etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre><h1 id="六-部署node1和node2节点"><a href="#六-部署node1和node2节点" class="headerlink" title="六 部署node1和node2节点"></a>六 部署node1和node2节点</h1><p>kubernetes work节点运行如下组件：</p><blockquote><ul><li>docker   ：开头我们已经部署了</li><li>kubelet</li><li>kube-proxy</li></ul></blockquote><p>部署kubelet组件</p><blockquote><ul><li>kubelet运行在每个work节点上，接收kube-apiserver发送的请求，管理Pod容器，执行交互式命令，如exec、run、logs等</li><li>kubelet启动时自动向kube-apiserver注册节点信息，内置的cadvisor统计和监控节点的资源使用情况</li><li>为确保安全，本文档只开启接收https请求的安全端口，对请求进行认证和授权，拒绝未授权的访问(如apierver、heapster)。</li></ul></blockquote><p>将master节点上kubelet二进制文件拷贝到node1和node2节点上</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 bin<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/k8s/kubernetes/bin<span class="token punctuation">[</span>root@docker-1 bin<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /usr/local/src/kubernetes/server/bin </span><span class="token comment" spellcheck="true">#master也作为一个节点使用</span><span class="token punctuation">[</span>root@docker-1 /usr/local/src/kubernetes/server/bin<span class="token punctuation">]</span> <span class="token function">cp</span> kubelet kube-proxy  /home/k8s/kubernetes/bin<span class="token function">scp</span> kubelet kube-proxy 192.168.1.118:/home/k8s/kubernetes/bin/<span class="token function">scp</span> kubelet kube-proxy 192.168.1.63:/home/k8s/kubernetes/bin</code></pre><p>创建kubelet bootstrap kubeconfig文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/k8s/cfssl/kubernetes<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#vim environment.sh </span><span class="token comment" spellcheck="true"># 创建kubelet bootstrapping kubeconfig </span>BOOTSTRAP_TOKEN<span class="token operator">=</span>b2d81324fb83862f435f66498b90e5bdKUBE_APISERVER<span class="token operator">=</span><span class="token string">"https://192.168.1.119:6443"</span><span class="token comment" spellcheck="true"># 设置集群参数</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>./ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span><span class="token variable">${KUBE_APISERVER}</span> \  --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true"># 设置客户端认证参数</span>kubectl config set-credentials kubelet-bootstrap \  --token<span class="token operator">=</span><span class="token variable">${BOOTSTRAP_TOKEN}</span> \  --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true"># 设置上下文参数</span>kubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kubelet-bootstrap \  --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true"># 设置默认上下文</span>kubectl config use-context default --kubeconfig<span class="token operator">=</span>bootstrap.kubeconfig<span class="token comment" spellcheck="true">#----------------------</span><span class="token comment" spellcheck="true"># 创建kube-proxy kubeconfig文件</span>kubectl config set-cluster kubernetes \  --certificate-authority<span class="token operator">=</span>./ca.pem \  --embed-certs<span class="token operator">=</span>true \  --server<span class="token operator">=</span><span class="token variable">${KUBE_APISERVER}</span> \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfigkubectl config set-credentials kube-proxy \  --client-certificate<span class="token operator">=</span>./kube-proxy.pem \  --client-key<span class="token operator">=</span>./kube-proxy-key.pem \  --embed-certs<span class="token operator">=</span>true \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfigkubectl config set-context default \  --cluster<span class="token operator">=</span>kubernetes \  --user<span class="token operator">=</span>kube-proxy \  --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfigkubectl config use-context default --kubeconfig<span class="token operator">=</span>kube-proxy.kubeconfig</code></pre><p>将生成的bootstrap.kubeconfig 、kube-proxy.kubeconfig两个文件拷贝到所有nodes节点 </p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">pwd</span>/home/k8s/cfssl/kubernetes<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">cp</span> /home/k8s/cfssl/kubernetes/bootstrap.kubeconfig kube-proxy.kubeconfig /home/k8s/kubernetes/cfg/<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">cp</span> /home/k8s/cfssl/kubernetes/bootstrap.kubeconfig kube-proxy.kubeconfig   192.168.1.118:/home/k8s/kubernetes/cfg/<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span> <span class="token function">cp</span> /home/k8s/cfssl/kubernetes/bootstrap.kubeconfig kube-proxy.kubeconfig   192.168.1.63:/home/k8s/kubernetes/cfg/</code></pre><p>继续在master主机上创建kubelet参数配置文件拷贝到所有nodes节点</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建kubelet参数配置模板文件</span>vim /home/k8s/kubernetes/cfg/kubelet.configapiVersion: kubelet.config.k8s.io/v1beta1address: 192.168.1.119port: 10250readOnlyPort: 10255cgroupDriver: cgroupfsclusterDNS: <span class="token punctuation">[</span><span class="token string">"10.0.0.2"</span><span class="token punctuation">]</span>clusterDomain: cluster.local.failSwapOn: <span class="token boolean">false</span>authentication:  anonymous:    enabled: <span class="token boolean">true</span><span class="token comment" spellcheck="true"># 创建kubelet配置文件</span>vim /home/k8s/kubernetes/cfg/kubeletKUBELET_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--hostname-override=192.168.1.119 \--kubeconfig=/home/k8s/kubernetes/cfg/kubelet.kubeconfig \--bootstrap-kubeconfig=/home/k8s/kubernetes/cfg/bootstrap.kubeconfig \--config=/home/k8s/kubernetes/cfg/kubelet.config \--cert-dir=/home/k8s/kubernetes/ssl \--pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0"</span><span class="token comment" spellcheck="true"># 创建kubelet systemd unit文件</span>vim /usr/lib/systemd/system/kubelet.service<span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes KubeletAfter<span class="token operator">=</span>docker.serviceRequires<span class="token operator">=</span>docker.service<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>/home/k8s/kubernetes/cfg/kubeletExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kubelet <span class="token variable">$KUBELET_OPTS</span>Restart<span class="token operator">=</span>on-failureKillMode<span class="token operator">=</span>process<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>在master操作将kubelet-bootstrap用户绑定到系统集群角色</p><pre class=" language-bash"><code class="language-bash">kubectl create clusterrolebinding kubelet-bootstrap \  --clusterrole<span class="token operator">=</span>system:node-bootstrapper \  --user<span class="token operator">=</span>kubelet-bootstrap</code></pre><p>将master上的<b>/home/k8s/kubernetes/cfg/kubelet</b>文件和<strong>/usr/lib/systemd/system/kubelet.service</strong>拷贝到node1和node2上</p><p>[root@docker-1]scp /home/k8s/kubernetes/cfg/kubelet   192.168.1.118:/home/k8s/kubernetes/cfg/kubelet</p><p>&amp;&amp;  scp /home/k8s/kubernetes/cfg/kubelet</p><p>[root@docker-1]scp /usr/lib/systemd/system/kubelet.service 192.168.1.118:/usr/lib/systemd/system/kubelet.service &amp;&amp;  scp  /usr/lib/systemd/system/kubelet.service 192.168.1.63:/usr/lib/systemd/system/kubelet.service</p><p>其中<font color=red>/home/k8s/kubernetes/cfg/kubelet</font>文件要修改为对应的IP,node1修改为<font color=blue>–hostname-override=192.168.1.118</font>、 node2修改为<font color=red>–hostname-override=192.168.1.63  </font>                  </p><p>  其中<font color=red>usr/lib/systemd/system/kubelet.service</font> 文件不需要修改</p><p>启动三台服务器的kubelet服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kubeletsystemctl restart kubelet</code></pre><p><strong>approve kubelet CSR请求</strong></p><p>查看CSR列表</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE    REQUESTOR           CONDITIONnode-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs   39m    kubelet-bootstrap   Pendingnode-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s   5m5s   kubelet-bootstrap   Pending<span class="token comment" spellcheck="true"># kubectl certificate approve node-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs</span>certificatesigningrequest.certificates.k8s.io/node-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs <span class="token comment" spellcheck="true"># kubectl certificate approve node-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s  </span>certificatesigningrequest.certificates.k8s.io/node-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s approved<span class="token punctuation">[</span><span class="token comment" spellcheck="true"># kubectl get csr</span>NAME                                                   AGE     REQUESTOR           CONDITIONnode-csr-An1VRgJ7FEMMF_uyy6iPjyF5ahuLx6tJMbk2SMthwLs   41m     kubelet-bootstrap   Approved,Issuednode-csr-dWPIyP_vD1w5gBS4iTZ6V5SJwbrdMx05YyybmbW3U5s   7m32s   kubelet-bootstrap   Approved,Issued</code></pre><blockquote><ul><li>Requesting User: 请求CSR的用户，kube-apiserver对它进行认证和授权</li><li>Subject: 请求签名的证书信息</li><li>证书的 CN 是system:node;kube-node2, Organization 是system:nodes,kube-apiserver的Node授权模式会授予该证书的相关权限；</li></ul></blockquote><p><strong>在master上查看集群状态</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get nodes</span>NAME            STATUS   ROLES    AGE     VERSION192.168.1.118   Ready    node     7d22h   v1.13.0192.168.1.119   Ready    master   8d      v1.13.0192.168.1.63    Ready    node     7d22h   v1.13.0</code></pre><p><b>先在master上部署kube-proxy组件</b></p><p>kube-proxy运行在所有node节点上，它监听apiserver中 service 和Endpoint的变化情况，创建路由规则来进行服务负载均衡。</p><p>创建kube-proxy配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#vim /home/k8s/kubernetes/cfg/kube-proxy</span>KUBE_PROXY_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--hostname-override=192.168.1.119 \--cluster-cidr=10.0.0.0/24 \--kubeconfig=/home/k8s/kubernetes/cfg/kube-proxy.kubeconfig"</span></code></pre><blockquote><ul><li>bindAddress：监听地址；</li><li>clientConnection.kubeconfig: 连接apiserver的kubeconfig文件；</li><li>clusterCIDR: kube-proxy根据-cluster-cidr判断集群内部和外部流量指定 –cluster-cidr 或 –masquerade-all 选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT；</li><li>hostnameOverride: 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 ipvs 规则；</li><li>mode: 使用ipvs模式；</li></ul></blockquote><p>创建kube-proxy systemd unit文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim /home/k8s/kubernetes/cfg/kube-proxy</span>KUBE_PROXY_OPTS<span class="token operator">=</span><span class="token string">"--logtostderr=true \--v=4 \--hostname-override=192.168.1.119 \--cluster-cidr=10.0.0.0/24 \--kubeconfig=/home/k8s/kubernetes/cfg/kube-proxy.kubeconfig"</span><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat /usr/lib/systemd/system/kube-proxy.service </span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>Description<span class="token operator">=</span>Kubernetes ProxyAfter<span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>EnvironmentFile<span class="token operator">=</span>-/home/k8s/kubernetes/cfg/kube-proxyExecStart<span class="token operator">=</span>/home/k8s/kubernetes/bin/kube-proxy <span class="token variable">$KUBE_PROXY_OPTS</span>Restart<span class="token operator">=</span>on-failure<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>WantedBy<span class="token operator">=</span>multi-user.target</code></pre><p>在node1和node2上部署kube-proxy服务</p><p>把<strong>master</strong>上<font color=blue>kube-proxy</font>配置文件和<font color=red>kube-proxy systemd unit</font>文件拷贝到node1和node2，其中/home/k8s/kubenetes/cfg/kube-proxy需要修改为相应的IP</p><p>最后启动服务</p><pre class=" language-bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token function">enable</span> kube-proxysystemctl restart kube-proxy<span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kube-proxy</span>● kube-proxy.service - Kubernetes Proxy   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/kube-proxy.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since 二 2019-04-30 00:46:30 CST<span class="token punctuation">;</span> 1 weeks 0 days ago Main PID: 51295 <span class="token punctuation">(</span>kube-proxy<span class="token punctuation">)</span>   Memory: 11.1M   CGroup: /system.slice/kube-proxy.service           ‣ 51295 /home/k8s/kubernetes/bin/kube-proxy --logtostderr<span class="token operator">=</span>true --v<span class="token operator">=</span>4 --hostname-override<span class="token operator">=</span>192.168.1.119 --cluster-cidr<span class="token operator">=</span>10.0.0.0/24 --kubeconfig<span class="token operator">=</span>/home/k8s/kubernetes/cfg/kube-proxy.kubeconfig5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.815793   51295 proxier.go:664<span class="token punctuation">]</span> Syncing iptables rules5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.834550   51295 iptables.go:327<span class="token punctuation">]</span> running iptables-save <span class="token punctuation">[</span>-t filter<span class="token punctuation">]</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.836358   51295 iptables.go:327<span class="token punctuation">]</span> running iptables-save <span class="token punctuation">[</span>-t nat<span class="token punctuation">]</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.839045   51295 proxier.go:1019<span class="token punctuation">]</span> Port <span class="token string">"nodePort for kube-system/kubernetes-dashboard:"</span> <span class="token punctuation">(</span>:49655/tcp<span class="token punctuation">)</span> was <span class="token function">open</span> before and is still needed5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.839157   51295 iptables.go:391<span class="token punctuation">]</span> running iptables-restore <span class="token punctuation">[</span>--noflush --counters<span class="token punctuation">]</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.844415   51295 healthcheck.go:235<span class="token punctuation">]</span> Not saving endpoints <span class="token keyword">for</span> unknown healthcheck <span class="token string">"default/nginx"</span>5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.844438   51295 proxier.go:641<span class="token punctuation">]</span> syncProxyRules took 28.670563ms5月 07 23:10:00 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:00.844451   51295 bounded_frequency_runner.go:221<span class="token punctuation">]</span> sync-runner: ran, next possible <span class="token keyword">in</span> 0s, periodic <span class="token keyword">in</span> 30s5月 07 23:10:01 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:01.729871   51295 config.go:141<span class="token punctuation">]</span> Calling handler.OnEndpointsUpdate5月 07 23:10:01 docker-1 kube-proxy<span class="token punctuation">[</span>51295<span class="token punctuation">]</span>: I0507 23:10:01.730171   51295 config.go:141<span class="token punctuation">]</span> Calling handler.OnEndpointsUpdate</code></pre><p>集群状态</p><p>打node或master节点的标签</p><pre class=" language-bash"><code class="language-bash">kubectl label node 192.168.1.119  node-role.kubernetes.io/master<span class="token operator">=</span><span class="token string">'master'</span>kubectl label node 192.168.1.118  node-role.kubernetes.io/node<span class="token operator">=</span><span class="token string">'node'</span>kubectl label node 192.168.1.63  node-role.kubernetes.io/node<span class="token operator">=</span><span class="token string">'node'</span><span class="token punctuation">[</span>root@docker-1 kubernetes<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get node,cs</span>NAME                 STATUS   ROLES    AGE     VERSIONnode/192.168.1.118   Ready    node     7d22h   v1.13.0node/192.168.1.119   Ready    master   8d      v1.13.0node/192.168.1.63    Ready    node     7d22h   v1.13.0NAME                                 STATUS    MESSAGE             ERRORcomponentstatus/scheduler            Healthy   ok                  componentstatus/controller-manager   Healthy   ok                  componentstatus/etcd-0               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-1               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   componentstatus/etcd-2               Healthy   <span class="token punctuation">{</span><span class="token string">"health"</span><span class="token keyword">:</span><span class="token string">"true"</span><span class="token punctuation">}</span>   </code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes,docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm-kubenetes</title>
      <link href="/2018/10/23/kubeadm-kubenetes/"/>
      <url>/2018/10/23/kubeadm-kubenetes/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysqldump</title>
      <link href="/2018/08/02/mysqldump/"/>
      <url>/2018/08/02/mysqldump/</url>
      
        <content type="html"><![CDATA[<p>mysqldump -uroot -phonjia@mariadb –single-transaction –master-data=2 –flush-logs -R -E lottery | gzip &gt; /backupmyql/lottery_<code>date &#39;+%m-%d-%Y&#39;</code>.sql.gz</p><a id="more"></a><p>参数解析：<br><strong>–single-transaction:</strong><br>This option sends a START TRANSACTION SQL statement to the server before dumping data.It is useful only with transaction tables such as InnoDB, because then it dumps the consistent state of the database at the time when BEGIN was issued without blocking any applications.</p><p>When using this option,you should keep in mind that only InnoDB tables are dumped in a consistent state. The single-transaction feature depends not only on the engine being transactional and capable of <strong>repeatable-read</strong>,but also on <strong>start transaction with consistent snapshot</strong>. The dump is not guaranteed to be consistent for other storage engines.For example, any TokuDB,MyISAM or MEMORY tables dumped while using this option may still change state.<br>While a –single-transaction dump is in process,to ensure a valid dump file(correct table contents and binary log coordinates),no other connection should use the following statements:ALTER TABLE,CREATE TABLE,DROP TABLE,RENAME TABLE,OR TRUNCATE TABLE.</p><p>While a –single-transaction dump is in process,to ensure a valid dump file(correct table contents and binary log coordinates),no other connection should use the following statements:ALTER TABLE,CREATE TABLE,DROP TABLE,RENAME TABLE,or TRUNCATE TABLE. A consistent read is not isolated from those statement,so use of them on a table to be dumped can cause the <strong>SELECT</strong> (performed by mysqldump to retrieve the table contents) to obtain incorrect contents or fail.</p><p>The –single-transaction option and the –lock-tables option are mutually exclusive because automatically turns off –lock-tables<br>TO dump large tables,you should combine the –single-transaction option with –quick</p><p><strong>–master-data[=#]:</strong><br>Causes the <strong>binary log</strong> position and filename to be appended to the output,useful dumping a master replication server to produce a dump file that can be used to set up another server as slave of the master.These are the master server coordinates from which the slave should start replicating after you load the dump file into the slave. If the option is set to 1(the default),will print it as a <strong>change master</strong>command;if set to 2,that command will be prefixed with a comment symbol.This –master-data option will turn –lock-all-tables on, unless <strong>–single-transaction</strong> is specified too.Before <strong>MariaDB 5.3</strong> this would tabke a global read lock for a short time at the beginning of the dump –see <strong>Enhancements for start transaction with consistent snapshot</strong> and  the <strong>–single-transaction *<em>option below. In all cases,any action on logs will happen at the exact moment of the dump. This option automatically turns *</em>–lock-tables</strong> off</p><p>In all cases,any action on logs happens at the exact moment of the dump.</p><p>it is also possible to set up a slave by dumping an existing slave of the master.To do this,use the following procedure on the existing slave:</p><p>1.Stop the slave’s SQL thread and get its current status:<br>mysql&gt; STOP SLAVE SQL_THREAD;<br>mysql&gt; SHOW SLAVE STATUS;</p><p>2.From the output of the SHOW SLAVE STATUS statement,the binary log coordinates of the master server from which the new slave should start replicating are the values of the Relay_Master_Log_File and Exec_Master_Log_Pos fields.Denote those values as file_name and file_pos.</p><p>3 Restart the slave:<br>mysql&gt; START SLAVE;</p><p>4 On the new slave,load the dump file:<br>shell&gt;mysql&lt;dumpfile</p><p>5 On the new slave,set the replication coordinates to those of the master server obtained earlier:<br>mysql&gt; CHANGE MASTER TO MASTER_LOG_FILE = ‘file_name’, MASTER_LOG_POS = file_pos;<br>The *<em>CHANGE MASTER *</em> TO statement might also need other parameters,such as MASTER_HOST to point the slave to the correct master server host.Add any such parameters necessary.</p><p><strong>-F, –flush-logs:</strong><br>Flush the MariaDB server log files before starting the dump.This option requires the RELOAD privilege.If you use this option in combination with the –databases= or –all-databases option,the logs are flushed for each database dumped.The exception is when using <strong>–lock-all-tables</strong> or <strong>–master-data</strong> In this case,the logs are flushed only once,corresponding to the moment all tables are locked. If you want your dump and the log flush to happen at the same exact moment,you should use <strong>–flush-logs</strong> together with either <strong>–lock-all-tables</strong> or <strong>–master-data</strong>.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysqldump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mha原理</title>
      <link href="/2018/07/11/mha%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/11/mha%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.kancloud.cn/devops-centos/centos-linux-devops/385181" target="_blank" rel="noopener">转载至：</a><br>MHA原理：<br>MHA(Master High Availability)目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本人youshimaton开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到0~30秒之内自动完成数据的故障切换操作，并且在进行故障切换的过程中，MHA能最大程度上保证数据库的一致性，以达到真正意义上的高可用。MHA由两部分组成：MHA Manager(管理节点)和MHA Node(数据节点). MHA Manager可以独立部署在一台独立的机器上管理多个Master-Slave集群，也可以部署在一台Slave上，当Master出现故障时，它可以自动将最新数据的slave提升为Master,然后将所有其它的Slave重新指向新的Master，整个故障转移对应用程序完全透明的。</p><p>在MHA自动故障切换的过程中，MHA试图从宕掉的主服务器上保存二进制日志，最大程度保证数据的不丢失，但这并不总是可行的。<br>例如:如果主服务器硬件故障或无法通过SSH访问，MHA没有办法保存二进制日志，只能进行故障转移而丢失了最新数据。mysql服务挂了，但是可以从服务器拷贝二进制。但如果硬件宕机或者SSH不能连接，不能获取到最新阿binlog日志，如果复制出现延迟，会丢失数据。<br>使用MySQL5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以和半同步复制结合起来，如果只有一个Slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其它所有Slave服务器上，保持数据一致性。<br>最新版0.56版本，增加了支持GTID的功能，建议在MySQL5.6及之后版本使用。MySQL5.5建议使用管理节点版本0.55，数据节点0.54</p><p>适用场景<br>目前MHA主要支持一主多从的架构，要搭建MHA，要求一个复制集群必须最少有3台数据库服务器，一主二从，即一台充当Master,一台充当备用Master,另一个台充当从库。出于成本考虑，淘宝在此基础上进行了改造，目前淘宝开发的TMHA已经支持一主一从。</p><p>MHA工作原理<br>1.从宕机崩溃的Master保存二进制日志事件(binlog event)。<br>2.识别含有最新更新的Slave.<br>3.应用差异的中继日志(relay log)到其它Slave.<br>4.应用从Master保存的二进制日志事件<br>5.提升一个Slave为新的Master<br>6.使其它的Slave连接新的Master进行复制<br>MHA的组成：</p><ol><li>Manager工具包情况如下:<blockquote><ul><li>masterha_check_ssh：检查MHA的SSH配置情况。</li><li>masterha_check_repl:检查MySQL复制情况。</li><li>masterha_manager；启动MHA</li><li>masterha_check_status:检测当前MHA运行状态</li><li>masterha_master_monitor:检测Master是否宕机</li><li>masterha_master_switch:控制故障转移(自动或手动)</li><li>masterha_conf_host:添加或删除配置的server信息</li></ul></blockquote></li></ol><p>2.Node工具包(通常由MHA Manager的脚本触发，无需人工操作)情况如下：</p><blockquote><ul><li>save_binary_log：保存和复制Master的binlog日志</li><li>apply_diff_relay_logs:识别差异的中级日志时间并将其应用到其它Slave.</li><li>filter_mysqlbinlog:去除不必要的ROOLBACK事件(已经废弃)</li><li>purge_relay_logs:清楚中继日志(不阻塞SQL线程)</li></ul></blockquote><p>重：为了尽可能的减少因为主库硬件损坏宕机造成的数据丢失，因此在配置MHA的同时建议必须配置MySQL5.5半同步复制。<br>拓展思想：为了保证数据一致性，MySQL复制中，常常会在Master上使用sync_binlog参数保证binlog持久化，保证数据一致性。但这种方式对磁盘I/O会造成10-20%的影响，但是还有另外一个思路，就是使用MySQL半同步复制来保证数据一致性，MySQL半同步复制是在从服务器的内存中处理数据并进行发聩，虽然也会造成性能影响，但是相对于Master造成的磁盘I/O的影响来说，反而是个更好的方法，据&lt;高性能MySQL&gt;第三版中10.9的测试，写入远程的内存(一台从库的反馈)比写入本地的磁盘(写入并刷新)要更快，使用半同步复制相比在主库上进行强持久化的性能有两倍的改善.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> master high availability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>master-slave0</title>
      <link href="/2018/07/11/master-slave0/"/>
      <url>/2018/07/11/master-slave0/</url>
      
        <content type="html"><![CDATA[<p>搭建一主两从的mysql5.7.22数据库架构(阿里云ECS云主机centos7.3系统)</p><p>192.168.1.102  DB1  master    写入，数据节点<br>192.168.1.103  DB2  slave1    读，数据节点<br>192.168.1.104  DB3  slave2    读，数据节点</p><p>三个数据库服务器上都关闭selinux,编辑/etc/selinux/config文件，使SELINUX=disabled,<br>阿里云的ECS云主机默认selinux和防火墙firewall已经设置了关闭。</p><a id="more"></a><p>设置主机名：</p><pre class=" language-bash"><code class="language-bash">登录192.168.1.102上：hostnamectl set-hostname DB01登录192.168.1.103上：hostnamectl set-hostname DB02登录192.168.1.104上：hostnamectl set-hostname DB03编辑三个主机的/etc/hosts文件<span class="token function">cat</span> <span class="token operator">>></span>/etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF192.168.1.102 DB01192.168.1.103 DB02192.168.1.104 DB03EOF</span></code></pre><p>设置三台机器相互之间的免密钥登录<br>登录到DB1上：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsassh-copy-id DB01ssh-copy-id DB02ssh-copy-id DB03登录到DB2上：ssh-keygen -t rsassh-copy-id DB01ssh-copy-id DB02ssh-copy-id DB03登录到DB3上：ssh-keygen -t rsassh-copy-id DB01ssh-copy-id DB02ssh-copy-id DB03</code></pre><p>同时连上DB01、DB02、DB03<br>安装前准备：<br>卸载centos7系统自带的mariadb,由于我们需要指定mysql数据库的数据存放目录，故不采用yum安装的方法。</p><pre class=" language-bash"><code class="language-bash">rpm -qa <span class="token operator">|</span><span class="token function">grep</span> mariadbrpm -e --nodeps mariadb-libs-5.5.52-1.el7.x86_64<span class="token comment" spellcheck="true"># 删除etc目录下数据库的配置文件my.cnf</span><span class="token function">rm</span> /etc/my.cnf</code></pre><p>检查mysql是否存在</p><pre class=" language-bash"><code class="language-bash">rpm -qa <span class="token operator">|</span><span class="token function">grep</span> mysql<span class="token function">cat</span> /etc/group  <span class="token operator">|</span><span class="token function">grep</span> mysql<span class="token function">cat</span> /etc/passwd <span class="token operator">|</span><span class="token function">grep</span> mysql<span class="token comment" spellcheck="true"># 如果不存在，创建数据库用户mysql</span><span class="token function">groupadd</span> -g 1001 mysql  <span class="token comment" spellcheck="true">#-g:用于指定GID，默认为使用当前组大的GID+1</span><span class="token function">useradd</span> -m -u 1001 -g mysql mysql <span class="token comment" spellcheck="true">#-m:创建用户的家目录  -g GROUP:指定新用户的主组，-u UID:指定新用户的主组</span></code></pre><p>三台云主机都下载mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/<span class="token function">wget</span> https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz<span class="token function">tar</span> -zxf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz<span class="token function">mv</span> mysql-5.7.22-linux-glibc2.12-x86_64 mysql/<span class="token function">chown</span> -R mysql:mysql mysql/<span class="token function">cd</span> /home/mysql <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> data<span class="token function">chown</span> -R mysql:mysql mysql/<span class="token function">cd</span> /usr/local/mysqlbin/mysql_install_db   --user<span class="token operator">=</span>mysql --basedir<span class="token operator">=</span>/usr/local/mysql --datadir<span class="token operator">=</span>/home/mysql/data/<span class="token function">cp</span> ./support-files/mysql.server   /etc/init.d/mysqld<span class="token function">chmod</span> a+x /etc/init.d/mysqld/etc/init.d/mysqld start<span class="token function">netstat</span> -lntp <span class="token operator">|</span><span class="token function">grep</span> mysqld<span class="token function">cd</span> /etc/profile.d/<span class="token function">vi</span> mysql.sh<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/usr/local/mysql/bin<span class="token function">source</span> mysql.sh</code></pre><p>获取root的初始密码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /root/.mysql_secret</code></pre><p>登录修改root密码(内网一般%变为192.168.1.%)：</p><pre class=" language-bash"><code class="language-bash">mysql -uroot -pmysql<span class="token operator">>></span>ALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> identified by <span class="token string">'TANGshupei1!'</span><span class="token punctuation">;</span>mysql<span class="token operator">>></span>GRANT ALL PRIVILEGES ON *.* TO <span class="token string">'root'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'TANGshupei1!'</span> WITH GRANT OPTION<span class="token punctuation">;</span>mysql<span class="token operator">>></span>FLUSH PRIVILEGES<span class="token punctuation">;</span>mysql<span class="token operator">>></span>exit<span class="token function">killall</span> mysqld/etc/init.d/mysqld restart<span class="token comment" spellcheck="true">#设置开机自启动</span><span class="token function">chkconfig</span> --add mysqld<span class="token function">chkconfig</span> --level 35 mysqld on<span class="token function">chkconfig</span> --list mysqld<span class="token function">service</span> mysqld status</code></pre><p>主从配置<br>登录DB01主库<br>mysql -uroot -p</p><p>创建replication用户并设置密码为replication</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>CREATE USER replication IDENTIFIED BY <span class="token string">'replication'</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>GRANT REPLICATION SLAVE ON *.* TO <span class="token string">'replication'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'replication'</span> <span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>exit</code></pre><p>修改DB01的/etc/my.cnf配置文件<br>对DB01 DB02 DB03的/etc/my.cnf配置文件进行修改<br>DB01 Master</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[mysql]default-character-set=utf8 [mysqld]server-id=001user=mysqlport = 3306 basedir=/usr/local/mysqldatadir=/home/mysql/data# Logsetting# relay-log=DB01-relay-bin# relay-log-index=DB01-relay-bin.index# read_only=1log-bin=mysql-bin   binlog-ignore-db=mysql sync_binlog = 1    max_binlog_size=1024Mmax_binlog_cache_size=4096Mbinlog_stmt_cache_size=1Mbinlog_checksum = none binlog_format = mixedbinlog_cache_size=4Mexpire_logs_days=30relay_log_purge=0skip-name-resolve# InnoDBSettinginnodb_buffer_pool_size=16384Minnodb_log_file_size=512Minnodb_log_buffer_size=16Minnodb_log_files_in_group=3innodb_flush_log_at_trx_commit=1innodb_stats_on_metadata=OFFinnodb_flush_method=O_DIRECTtable_open_cache=4096sort_buffer_size=2M# 允许最大连接数max_connections=800# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB lower_case_table_names=1max_allowed_packet=16MEOF</span></code></pre><p>重启DB01数据库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld restart<span class="token comment" spellcheck="true">#登录数据库查询master_log_file和master_log_position</span>mysql -uroot -ppassword:********<span class="token punctuation">(</span>root@192.168.1.102:3306<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">></span>show master status\G<span class="token punctuation">;</span>*************************** 1. row ***************************             File: mysql-bin.000004         Position: 1631     Binlog_Do_DB:  Binlog_Ignore_DB: Executed_Gtid_Set: 1 row <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.01 sec<span class="token punctuation">)</span>ERROR: No query specified</code></pre><p>记录下来：File文件名和Position的位置</p><p>配置DB02从库<br>修改/etc/my.cnf文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[mysql]default-character-set=utf8 [mysqld]server-id=002user=mysqlport = 3306 basedir=/usr/local/mysqldatadir=/home/mysql/data# Logsettingrelay-log=DB02-relay-binrelay-log-index=DB02-relay-bin.index#read_only=1log-bin=mysql-bin   binlog-ignore-db=mysql sync_binlog = 1    max_binlog_size=1024Mmax_binlog_cache_size=4096Mbinlog_stmt_cache_size=1Mbinlog_checksum = none binlog_format = mixedbinlog_cache_size=4Mexpire_logs_days=30relay_log_purge=0skip-name-resolve# InnoDBSettinginnodb_buffer_pool_size=16384Minnodb_log_file_size=512Minnodb_log_buffer_size=16Minnodb_log_files_in_group=3innodb_flush_log_at_trx_commit=1innodb_stats_on_metadata=OFFinnodb_flush_method=O_DIRECTtable_open_cache=4096sort_buffer_size=2M# 允许最大连接数max_connections=800# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB lower_case_table_names=1max_allowed_packet=16MEOF</span></code></pre><p>重启MySQL<br>service mysqld restart </p><p>登录DB02数据库</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>CHANGE MASTER TO master_host<span class="token operator">=</span><span class="token string">'192.168.1.102'</span>,master_port<span class="token operator">=</span>3306,master_user<span class="token operator">=</span><span class="token string">'replication'</span>,master_password<span class="token operator">=</span><span class="token string">'replication'</span>,master_log_file<span class="token operator">=</span><span class="token string">'mysql-bin.000004'</span>,master_log_pos<span class="token operator">=</span>1631<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>START SLAVE<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>SHOW SLAVE STATUS\G<span class="token punctuation">;</span></code></pre><p>配置DB03从库<br>修改/etc/my.cnf文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf <span class="token operator">&lt;&lt;</span><span class="token string">EOF[mysql]default-character-set=utf8 [mysqld]server-id=003user=mysqlport = 3306 basedir=/usr/local/mysqldatadir=/home/mysql/data# Logsettingrelay-log=DB03-relay-binrelay-log-index=DB03-relay-bin.index#read_only=1log-bin=mysql-bin   binlog-ignore-db=mysql sync_binlog = 1    max_binlog_size=1024Mmax_binlog_cache_size=4096Mbinlog_stmt_cache_size=1Mbinlog_checksum = none binlog_format = mixedbinlog_cache_size=4Mexpire_logs_days=30relay_log_purge=0skip-name-resolve# InnoDBSettinginnodb_buffer_pool_size=16384Minnodb_log_file_size=512Minnodb_log_buffer_size=16Minnodb_log_files_in_group=3innodb_flush_log_at_trx_commit=1innodb_stats_on_metadata=OFFinnodb_flush_method=O_DIRECTtable_open_cache=4096sort_buffer_size=2M# 允许最大连接数max_connections=800# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB lower_case_table_names=1max_allowed_packet=16MEOF</span></code></pre><p>重启MySQL</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld restart </code></pre><p>登录DB03数据库</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span>CHANGE MASTER TO master_host<span class="token operator">=</span><span class="token string">'192.168.1.102'</span>,master_port<span class="token operator">=</span>3306,master_user<span class="token operator">=</span><span class="token string">'replication'</span>,master_password<span class="token operator">=</span><span class="token string">'replication'</span>,master_log_file<span class="token operator">=</span><span class="token string">'mysql-bin.000002'</span>,master_log_pos<span class="token operator">=</span>2247<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>START SLAVE<span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span>SHOW SLAVE STATUS\G<span class="token punctuation">;</span></code></pre><p>补充：–master-data 和–single-transaction 在mysqldump中使用–master-data=2，会记录binlog文件和position的信息 。–single-transaction会将隔离级别设置成repeatable-commited</p><p>mysqldump -uroot -pTANGshupei1! –master-data=2 –single-transaction -R –triggers test_db1 &gt; test_db1.sql</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL一主两从配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>master-slave1</title>
      <link href="/2018/07/11/master-slave1/"/>
      <url>/2018/07/11/master-slave1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000008942618#articleHeader5" target="_blank" rel="noopener">转载至：</a></p><h2 id="MySQL主从复制及配置实现"><a href="#MySQL主从复制及配置实现" class="headerlink" title="MySQL主从复制及配置实现"></a>MySQL主从复制及配置实现</h2><h3 id="一-什么是MySQL主从复制"><a href="#一-什么是MySQL主从复制" class="headerlink" title="一 什么是MySQL主从复制"></a>一 什么是MySQL主从复制</h3><p>MySQL主从复制是其最重要的功能之一，主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器中。对于多级复制，数据库服务器即可充当主机，也可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。</p><h3 id="二-MySQL主从复制的类型"><a href="#二-MySQL主从复制的类型" class="headerlink" title="二 MySQL主从复制的类型"></a>二 MySQL主从复制的类型</h3><p>1 基于语句的复制<br>主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。<br>存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。。<br>2 基于行的复制<br>把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。<br>存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，因此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。<br>3 混合类型的复制：<br>MySQL默认使用基于语句的复制，当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择。<br>在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话(多台从服务器还要从主服务器上面同步数据)，单主模型的复制中主服务器势必会成为性能瓶颈。</p><a id="more"></a><h3 id="三-MySQL主从复制工作原理"><a href="#三-MySQL主从复制工作原理" class="headerlink" title="三 MySQL主从复制工作原理"></a>三 MySQL主从复制工作原理</h3><p>主服务器上面的任何修改都会保存在二进制日志Binary log里面，从服务器上面启动一个I/O thread (实际上就是一个主服务器的客户端进程)，连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log里面。从服务器上面开启一个SQL thread定时检查Realy log,如果发现有更改立即把更改的内容在本机上面执行一遍。</p><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。工作原理图如下：</p><p>实际上在老版本的MySQL主从复制中Slave端并不是两个进程完成的，而是由一个进程完成，但是后来发现这样做存在较大的风险和性能问题，主要如下：</p><p>首先，一个进程会使复制bin-log日志和解析日志并在自身执行的过程成为一个串行的过程，性能受到了一定的限制，异步复制的延迟也会比较长。另外，Slave端从Master端获取bin-log过来之后，需要接着解析日志内容，然后在自身执行，在这过程中，Master端可能又产生了大量变化并新增了大量的日志，如果在这阶段Master端的存储出现了无法修复的错误，那么在这个阶段所产生的所有变更都将永远无法找回，如果在Slave端的压力比较大的时候，这个过程的时间可能会比较长。<br>为了提高复制的性能并解决存在的风险，后面版本的MySQL将Slave端的复制动作交有两个进程完成，提出这个改进方案的人是Yahoo!的一位工程师”Jeremy Zawodny”。这样既解决了性能问题，又缩短了异步的延时时间，同时也减少了可能存在的数据丢失量。<br>当然，即使是换成了现在这样两个线程处理以后，同样也还是存在slave数据延时以及数据丢失的可能性的，毕竟这个复制是异步的，只要数据的更改不是在一个事务中，这些问题都是会存在的，如果要完全避免这些问题，就只能用MySQL的cluster来解决了。不过MySQL的cluster是内存数据库的解决方案，需要将所有数据都load到内存中，这样就对内存的要求就非常大了，对于一般的应用来说可实施性不是太大。<br>还有一点要提的是MySQL的复制过滤(Replication Filters),复制过滤可以让你只复制服务器中的一部分数据。有两种复制过滤，在master上过滤二进制日志中的事件，在slave上过滤中继日志中的事件。如下：</p><h3 id="四-MySQL主从复制的过程"><a href="#四-MySQL主从复制的过程" class="headerlink" title="四 MySQL主从复制的过程"></a>四 MySQL主从复制的过程</h3><p>MySQL主从复制的两种情况：同步复制和异步复制，实际复制架构中大部分为异步复制。<br>复制的基本过程如下：<br>1 Slave上面的IO进程连接上Master,并请求从指定日志文件的指定位置(或者从最开始的日志)之后的日志内容。<br>2 Master接收到来自Slave的IO进程的请求后，负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。<br>3 Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master’我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我’。<br>4 Slave的sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Mater端真实执行时候的那些可执行的内容，并在自身执行。</p><h3 id="五-MySQL主从复制的具体配置"><a href="#五-MySQL主从复制的具体配置" class="headerlink" title="五 MySQL主从复制的具体配置"></a>五 MySQL主从复制的具体配置</h3><p>复制通常用来创建主节点的副本，通过添加冗余节点来保证高可用性，当然复制也可以用于其他用途，例如在从节点上进行数据读、分析等等。在横向扩展的业务中，复制很容易实施，主要表现在利用主节点进行写操作，多个节点进行读操作，MySQL复制的异步是指：事务首先在主节点上提交，然后复制给从节点并在从节点上应用，这样意味着在同一个时间点主从上的数据可能不一致。异步复制的好处在于它比同步复制要快，如果对数据的一致性要求很高，还是采用同步复制较好。<br>最简单的复制模式就是一主一从的复制模式了，这样一个简单的架构只需要三个步骤即可完成：<br>(1) 建立一个主节点，开启binlog，设置服务器id;<br>(2) 建立一个从节点，设置服务器id;<br>(3) 将从节点连接到主节点上。</p><p>下面我们开始操作，以MySQL5.5为例，操作系统Ubuntu12.10,Master10.1.6.159 Slave 101.6.191</p><p>apt-get install mysql-server</p><p>Master机器<br>Master上面开启binlog日志，并且设置一个唯一的服务器id，在局域网内这个id必须唯一。二进制的binlog日志记录master上的所有数据库改变，这个日志会被复制到从节点上，并且在从节点上回放，修改my.cnf文件，在mysqld模块下修改如下内容：<br>[mysqld]<br>server-id = 1<br>log_bin = /var/log/mysql/mysql-bin.log</p><p>log_bin设置二进制日志所产生文件的基本名称，二进制日志由一些列文件组成，log_bin的值是可选项，如果没有为log_biin设置值，则默认值是：主机名-bin。如果随便修改主机名，则binlog日志的名称也会被改变的。server-id是用来唯一标识一个服务器的，每个服务器的server-id都不一样。这样slave连接到master后，会请求master将所有的binlog传递给它，然后将这些binlog在slave上回放，为了防止权限混乱，一般都是建立有一个单独用于复制的账户。<br>binlog是复制过程的关键，它记录了数据库的所有改变，通常即将执行完毕的语句会在binlog日志的末尾写入一条记录，binlog只记录改变数据库的语句，对于不改变数据库的语句则不进行记录。这种情况叫做基于语句的复制，前面提到过还有一种情况是基于行的复制，两种模式各有各的优缺点。</p><p>Slave机器<br>slave机器和master一样，需要一个唯一的server-id<br>[mysqld]<br>server-id = 2</p><p>连接Slave到Master,<br>在Master和Slave都配置好后，只需要把slave指向master,启动从库.</p><p>change master to master_host=’192.168.1.105’,master_port=3306,master_user=’replication’,master_password=’replication’;<br>start slave;</p><p>连接Slave到Master<br>接下来在master上做一些针对改变数据的操作，来观察slave的变化情况。在修改完my.cnf配置重启数据库后，就开始记录binlog了，可以在/var/log/mysql目录下看到一个mysql-bin.000001文件，而且还有一个mysql-bin.index文件，这个mysql-bin.index文件是什么？这个文件保存了所有的binlog文件列表，但是我们在配置文件中并没有设置该值，这个可以通过log_bin_index进行设置，如果没有设置该值，则默认值和log_bin一样。在master上执行show binlog events命令，可以看到第一个binlog文件的内容。<br>注意：上面的sql语句是从头开始复制第一个binlog，如果想从某个位置开始复制binlog，就需要在change master to时指定要开始的binlog文件名和语句在文件中的起点位置，参数如下：master_log_file和master_log_pos。</p><p>mysql&gt; show binlog events\G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>   Log_name: mysql-bin.000001<br>        Pos: 4<br> Event_type: Format_desc<br>  Server_id: 1<br>End_log_pos: 107<br>       Info: Server ver: 5.5.28-0ubuntu0.12.10.2-log, Binlog ver: 4<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>   Log_name: mysql-bin.000001<br>        Pos: 107<br> Event_type: Query<br>  Server_id: 1<br>End_log_pos: 181<br>       Info: create user rep<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 3. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>   Log_name: mysql-bin.000001<br>        Pos: 181<br> Event_type: Query<br>  Server_id: 1<br>End_log_pos: 316<br>       Info: grant replication slave on <em>.</em> to rep identified by ‘123456’<br>3 rows in set (0.00 sec)</p><blockquote><ul><li>Log_name是二进制日志文件的名称，一个事件不能横跨两个文件</li><li>Pos 这是该事件在文件中的开始位置</li><li>Event_type事件的类型，事件类型是给slave传递信息的基本方法，每个新的binlog都已Format_desc类型开始，以Rotate类型结束。</li><li>Server_id 创建该事件的服务器id</li><li>End_log_pos该事件的结束位置，也是下一个事件的开始位置，因此事件范围为Pos-End_log_pos-1</li><li>Info事件信息的可读文本，不同的事件有不同的信息</li></ul></blockquote><p>在master的test库中创建一个student表，并插入一条记录。<br>create table student(name var);<br>insert into rep values(‘guoguo’);<br>flush logs;</p><p>flush logs命令强制轮转日志，生成一个新的二进制日志，可以通过show binlog events in ‘xxx’ 来查看该二进制日志，可以通过show master status 查看当前正在写入的binlog文件，这样就会在slave上执行相应的改变操作。<br>上面就是最简单的主从复制模式，不过有时候随着时间的推进，binlog会变的非常庞大，如果新增加一台slave，从头开始复制master的binLog文件是非常耗时的，所以我们可以从一个指定的位置开始复制binlog日志，可以通过其它方法把以前的binLog文件进行复制，例如copy物理文件，在change master to 中有两个参数可以实现该功能，master_log_file和master_log_pos,通过这两个参数指定binlog文件及位置，我们可以从master复制也可以从slave上复制，假如从master上复制，具体操作如下：<br>(1) 为了防止在操作过程中数据更新，导致数据不一致，所以需要先刷新数据并锁定数据库:flush tables with read lock.</p><p>(2) 检查当前的binlog文件及其位置：show master status。</p><p>mysql&gt; show master status\G<br><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong><br>File: mysql-bin.000003<br>Position: 107<br>Binlog_Do_DB:<br>Binlog_Ignore_DB:<br>1 row in set (0.00 sec)</p><p>(3) 通过mysqldump命令创建数据库的逻辑备份：mysqldump –all-databases -hlocalhost -p &gt;back.sql.<br>(4) 有了master的逻辑备份后，对数据库进行解锁：unlock tables.<br>(5) 把back.sql复制到新的slave上，执行：mysql -hlocalhost -p把master的逻辑备份插入slave的数据库中。<br>(6) 现在可以把新的slave连接到master上了，只需要在change master to中多设置两个参数master_log_file=’mysql.bin.000003’和master_log_pos=’107’即可，然后启动slave:start slave,这样slave就可以接着107的位置进行复制了。</p><p>change master to master_host=’10.1.6.159’,master_port=3306,master_user=’rep’,master_password=’123456’,master_log_file=’mysql-bin.000003’,master_log_pos=’107’;<br>start slave;<br>有时候master并不能让你锁住表进行复制，因为可能跑一些不间断的服务，如果这时master已经有了一个slave，我们则可以通过这个slave进行再次扩展一个新的slave.原理在master上进行复制差不多，关键在于找到binlog的位置，你在复制的同时可能该slave也在和master进行同步，操作如下：<br>(1) 为了防止数据变动，还是需要停止slave的同步：stop slave.<br>(2) 然后刷新表，并用mysqldump逻辑备份数据库。<br>(3) 使用show slave status 查看slave的相关信息，记录下两个字段的值Relay_Master_Log_File和Exec_Master_Log_Pos，这个用来确定从后面哪里开始复制。<br>(4) 对slave解锁，把备份的逻辑库导入新的slave的数据库中，然后设置change master to,这一步和复制master 一样。</p><h3 id="六-深入了解MySQL主从配置"><a href="#六-深入了解MySQL主从配置" class="headerlink" title="六 深入了解MySQL主从配置"></a>六 深入了解MySQL主从配置</h3><p>1.一主多从<br>由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。在实际应用场景中，MySQL复制90%以上都是一个Master复制一个或者多个Slave的架构模式，主要用于读压力比较大的应用的数据库端廉价扩展解决方案。</p><p>在上图中，是我们开始时提到的一主多从的情况，这时主库既要负责写又要负责为几个从库提供二进制。这种情况将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从，或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。</p><p>2 主主复制<br>上图中，Master-Master复制的两台服务器，既是master,又是另一台服务器的slave，这样，任何一方所做的变更，都会通过复制应用到另一个方的数据库中。在这种复制架构中，各自上运行的不是同一个db，比如左边的是db1,右边是db2，db1的从在db2上，db2的从在db1上，两者互为主从，再辅助一些监控的服务还可以实现一定程度上的高可用。</p><p>2.1 主动-被动模式的Master-Master(Master-Master in Active-Passivee Mode)<br>上图中，这是由master-master结构变换而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用行的系统，它的不同的在于其中只有一个节点在提供读写服务，另外一个节点时刻准备着，当主节点一旦故障马上接替服务。比如通过corosync+pacemaker+drbd+MySQL就可以提供这样一组高可用服务，主备模式下再跟着slave服务器，主备模式下再跟着slave服务器，也可以实现读写分离。<br>2.2 带从服务器的Master-Master结构(Master-Master with Slaves)<br>这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。</p><p>MySQL-5.5支持半同步复制<br>早前的MySQL复制只能是基于异步来实现，从MySQL-5.5开始，支持半自动复制。在以前的异步(asynchronous)复制中，主库在执行完一些事务后，是不会管备库的进度的。如果备库处于落后，而更不幸的是主库此时又出现Crash(例如宕机)，这时备库中的数据就是不完整的。简而言之，在主库发生故障的时候，我们无法使用备库来继续提供数据一致的服务了，Semisynchronous中，仅仅保证事务的已经传递到备库上，但是并不确保已经在备库上执行完成了。<br>此外，还有一种情况会导致主备数据不一致。在某个session中，主库上提交一个事务后，会等待事务传递给至少一个备库，如果在这个等待过程中主库Crash,那么也可能备库和主库不一致，这是很致命的，如果主备网络故障或者备库挂了，主库在事务提交后等待10秒(rpl_semi_sync_master_timeout的默认值)后，就会继续，这时，主库就会变回原来的异步状态。</p><p>MySQL在加载并开启Semi-sync插件后，每一个事务需等待备库接收日志后才返回给客户端，如果做的是小事务，两台主机的延迟又较小，则Semi-sync可以实现在性能很小损失的情况下的零数据丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL主从原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-event</title>
      <link href="/2018/05/19/mysql-event/"/>
      <url>/2018/05/19/mysql-event/</url>
      
        <content type="html"><![CDATA[<p>Mysql定时任务&amp;存储过程<br>Mysql属于中小型数据库系统，它的事件调度器是在mysql5.1才开始引入的，事件调度器是在Mysql5.1中新增的另一个特色功能，可以作为定时任务调度器，取代部分原先只能用操作系统任务调度器(如linux的crontab)才能完成的定时功能。时间调度器是定时触发执行的，在这个角度上也可以称作”临时的触发器”。触发器只是针对某个表产生的事件执行一些语句，而事件调度器则是在某一个(间隔)时间执行一些语句。事件是由一个特定的线程来管理的，也就是所谓的”事件调度器”</p><p>查看开启调度器<br>查看event是否开启：SHOW VARIABLES LIKE ‘%event_sche%’;<br>将事件计划开启： SET GLOBAL event_scheduler = 1;<br>关闭事件任务： ALTER EVERNT e_test ON COMPLETION PRESERVE DISABLE;<br>开启事件任务： ALTER EVENT e_test ON COMPLETION PRESERVER ENABLE;<br>查看事件任务：SHOW EVENTS;</p><a id="more"></a><p>事件的优缺点<br>    1 一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。<br>    2 可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。<br>缺点：<br>    1 定时触发，不可以调用</p><p>创建事件<br>    一条create event 语句创建一个事件，每个事件由两部分组成，第一部分是事件调度(event schedule)，表示事件何时启动以及按什么频率启动，第二部分是事件动作(event action)，这是事件启动时执行的代码，事件的动作包含一条SQL语句，它可能是一个简单的INSERT 或者 update语句，也可以是一个存储过程或者benin..end语句块，这两种情况允许我们执行多条SQL。</p><pre><code>一个事件可以是活动(打开)的或停止(关闭)的，活动意味着事件调度器检查事件动作是否必须调用，停止意味着事件的声明存储在目录中，但调度器不会检查它是否应该调用。在一个事件创建之后，它立即变为活动的，一个活动的事件可以执行一次或者多次。</code></pre><p>创建语法如下：<br>CREATE<br>    [DEFINER = { user | CURRENT_USER}]<br>    EVENT<br>    [IF NOT EXISTS]<br>    event_name<br>    ON SCHEDULE schedule<br>    [ON COMPLETION [NOT] PRESERVER]<br>    [ENABLE | DISABLE |DISABLE ON SLAVE]<br>    [COMMENT ‘comment’]<br>    DO event_body;</p><p>schedule:<br>    AT timestamp [+ INTERVAL interval]…<br>    | EVERY interval<br>    [STARTS timestamp [+ INTERVAL interval]…]<br>    [ENDS timestamp [+ INTERVAL interval]…]<br>interval:<br>    quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK| SECOND |<br>    YEAR_MONTH| DAY_HOUR | DAY_MINUTE| DAY_SECOND|HOUR_MINUTE |HOUR_SECOND| MINUTE_SECOND}</p><p>名词解释：<br>    event_name:创建的event名字(唯一确定的)。<br>    ON SCHEDULE：计划任务<br>    schedule:决定event的执行时间和频率(注意时间一定要是将来的时间，过去的时间会出错)，有两种形式 AT 和 EVERY。<br>    [ON COMPLETION [NOT] PRESERVER]: 可选项，默认是ON COMPLETION NOT PRESERVER 即计划任务执行完毕后自动drop该事件；ON COMPLETION PRESERVER则不会drop掉。<br>    [COMMENT ‘comment’]:可选项，comment用来描述event；相当于注释：最大长度64个字节。<br>    [ENABLE | DISABLE]:设定event的状态，默认enable:表示系统尝试执行这个事件，DISABLE：关闭该事件，可以用alter修改。<br>    DO event_body:需要执行的sql语句(可以是复合语句)。CREATE EVENT在存储过程中使用时合法的。</p><p>开启关闭事件调度器：<br>MySQL事件调度器event_scheduler负责调用事件，它默认是关闭的。这个调度器不断地监视一个事件是否要调用，要创建事件，必须打开调度器。<br>mysql&gt; show variables like ‘%event_scheduler%’;</p><p>开启事件调度器：<br>可通过下面的任意一条命令来关闭事件调度器：<br>SET GLOBAL event_scheduler = OFF;<br>SET @@global.event_scheduler = OFF;<br>SET GLOBAL event_scheduler = 0;<br>SET @@global.evet_scheduler = 0;</p><p>通过配置文件my.cnf<br>在[mysqld]下增加<br>event_scheduler = 0 #或者OFF，DISABLED</p><p>查看调度器线程：<br>mysql&gt; show processlist;</p><p>创建事件2(每分钟启动事件)<br>create event test.event_minute<br>on schedule<br>every 1 minute<br>do insert into events_list values(‘event_now’, now());</p><p>查看事件执行结果<br>mysql&gt; select * from events_list;</p><p>注意：<br>默认创建事件存储在当前库中，也可显示指定事件创建在哪个库中<br>通过show events只能查看当前库中创建的事件<br>事件执行完即释放，如立即执行事件，执行完后，事件便自动删除，多次调用事件或等待执行事件可以看到。<br>如果两个事件需要在同一个时刻调用，mysql会确定调用他们的顺序，如果要指定顺序，需要确保一个事件至少在另一个事件1秒后执行。<br>对于递归调度的事件，结束日期不能在开始日期之前。<br>select可以包含在一个事件中，然而他的结果消失了，就好像没执行过。</p><p>查看事件<br>查看当前所在库的事件<br>mysql&gt; show events;</p><p>查看所有事件<br>mysql&gt;select * from mysql.event;</p><p>修改事件<br>一条alter event语句可以修改事件的定义和属性。我们可以让一个事件成为停止的或者再次让它活动，也可以修改一个事件的名字或者整个调度。然而当一个使用ON COMPLETION NOT COMPLETION NOT PRESERVER 属性定义的事件最后一次执行后，事件直接就不存在了，不能修改。<br>语法如下：<br>ALTER<br>    [DEFINER = { user | current_user}]<br>    EVENT event_name<br>    [ON SCHEDULE schedule]<br>    [ON COMPLETION [NOT] PERSERVER]<br>    [RENAME TO new_event_name]<br>    [ENABLE | DISABLE | DISABLE ON SLAVE]<br>    [COMMENT ‘comment’]<br>    [DO event_body]</p><p>例如：<br>修改上面例子3.3.3每分钟启动事件为每30秒启动<br>alter event test.event_minute<br>on schedule<br>every 30 second<br>do insert into events_list values(‘event_now’,now());</p><p>alter event test.event_minute<br>rename to test.event_second;</p><p>alter event test.event_second disable;<br>alter event test.event_second enable;</p><p>删除事件<br>如果一个事件不再需要，我们可以使用一条drop event语句删除它。使用这条语句我们不需要等到最后一次事件调用。</p><p>基本语法<br>drop event [IF EXISTS] event_name</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb-galera集群优缺点</title>
      <link href="/2018/05/19/mariadb-galera%E9%9B%86%E7%BE%A4%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2018/05/19/mariadb-galera%E9%9B%86%E7%BE%A4%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="MariaDB-Galera-Cluster集群优缺点"><a href="#MariaDB-Galera-Cluster集群优缺点" class="headerlink" title="MariaDB Galera Cluster集群优缺点"></a>MariaDB Galera Cluster集群优缺点</h2><p>MariaDB Galera Cluster 是一套在mysql innodb存储引擎上面实现multi-master及数据实时同步的系统架构，业务层面无需做读写分离工作，数据库读写压力都能按照既定的规则分发到 各个节点上去。在数据方面完全兼容 MariaDB 和 MySQL。</p><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p> (1).同步复制 Synchronous replication<br> (2).Active-active multi-master 拓扑逻辑<br> (3).可对集群中任一节点进行数据读写<br> (4).自动成员控制，故障节点自动从集群中移除<br> (5).自动节点加入<br> (6).真正并行的复制，基于行级<br> (7).直接客户端连接，原生的 MySQL 接口<br> (8).每个节点都包含完整的数据副本<br> (9).多台数据库中数据同步由 wsrep 接口实现</p><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h3><p> (1).目前的复制仅仅支持InnoDB存储引擎,任何写入其他引擎的表，包括mysql.*表将不会复制,但是DDL语句会被复制的,因此创建用户将会被复制,但是insert into mysql.user…将不会被复制的.<br> (2).DELETE操作不支持没有主键的表,没有主键的表在不同的节点顺序将不同,如果执行SELECT…LIMIT… 将出现不同的结果集.<br> (3).在多主环境下LOCK/UNLOCK TABLES不支持,以及锁函数GET_LOCK(), RELEASE_LOCK()…<br> (4).查询日志不能保存在表中。如果开启查询日志，只能保存到文件中。<br> (5).允许最大的事务大小由wsrep_max_ws_rows和wsrep_max_ws_size定义。任何大型操作将被拒绝。如大型的LOAD DATA操作。<br> (6).由于集群是乐观的并发控制，事务commit可能在该阶段中止。如果有两个事务向在集群中不同的节点向同一行写入并提交，失败的节点将中止。对 于集群级别的中止，集群返回死锁错误代码(Error: 1213 SQLSTATE: 40001 (ER_LOCK_DEADLOCK)).<br> (7).XA事务不支持，由于在提交上可能回滚。<br> (8).整个集群的写入吞吐量是由最弱的节点限制，如果有一个节点变得缓慢，那么整个集群将是缓慢的。为了稳定的高性能要求，所有的节点应使用统一的硬件。</p><a id="more"></a> <p>二、InnoDB的锁机制——行级锁定</p><p>不光InnoDB存储引擎，MySQL的分布式存储引擎NDB Cluster都使用行级锁定。InnoDB的行级锁定同样分为两种，一种是共享锁，一种是排它锁。</p><p>1、当一个事务需要给某份资源加锁的时候，主要情况有如下：<br>（1）如果遇到一个共享锁正锁定着资源，那么事务只能再加上一个共享锁，而不能加排它锁。<br>（2）如果遇到一个排他锁正锁定着资源，那么事务只能等待该锁定释放资源后他才能获得资源并添加自己的锁定。</p><p>2、InnoDB锁机制的实现与弊端</p><p>InnoDB锁机制是基于索引实现的，通过在指向数据记录的第一个索引键之前与最后一个索引键之后的空域空间（间隙或着说是范围）标记锁定信息实现，被称为间隙锁。</p><p>间隙锁的弊端：会在执行范围查询时，对范围内所有键值加锁，即使键值不存在，这会造成在加锁后无法插入锁定键值范围内的任何数据，影响性能。比如：</p><p>[sql] view plain copy<br>SELECT *<br>FROM user<br>WHERE user_id BETWEEM 1 AND 100<br>执行这个查询时，会对1-100范围内所有索引键值（1-100）加间隙锁，即使并不存在user_id为10的用户信息，所以在加锁后，要想插入一条user_id为10的用户信息是不可行的，这对于行级锁来说并不符合常理。InnoDB给出的解释是：为了防止幻读的出现。<br>当没有索引时或无法利用索引时，InnoDB会弃用行级锁，改用表级锁，并发处理性能降低。</p><p>另外，因为InnoDB的行级锁与事务处理特性，一定会产生死锁现象，对于如何降低死锁产生概率，我在第四部分InnoDB行级锁定优化建议中详述。 </p><p>四、InnoDB行级锁定优化建议<br>InnoDB的行级锁最大的优势就是增强了高并发的处理能力，缺点就是复杂性较高、易死锁，且基于索引实现有一定弊端。我们要做的就是扬长避短，合理利用InnoDB行级锁定，为此我们就应该做的：</p><p>1、尽可能让所有的数据检索都通过索引实现，因为InnoDB行级锁是基于索引实现的，没有索引或无法使用索引系统会改为使用表级锁。</p><p>2、合理设计索引，以缩小加锁范围，避免“间隙锁”造成不该锁定的键值被锁定。</p><p>3、尽量控制事务的大小，因为行级锁的复杂性会加大资源量以及锁定时间。</p><p>4、使用较低级别的事务隔离，以减少因实现事务隔离而付出的成本。</p><p>5、避免死锁，可以通过如下方式实现：</p><p>（1）类似的业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁。</p><p>（2）同一个事务中，尽量做到一次性锁定需要的所有资源。</p><p>（3）对于易产生死锁的业务部分，增大处理颗粒度，升级为表级锁以降低死锁产生的概率</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galera-cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb-galera-cluster-10.3</title>
      <link href="/2018/04/15/mariadb-galera-cluster-10-3/"/>
      <url>/2018/04/15/mariadb-galera-cluster-10-3/</url>
      
        <content type="html"><![CDATA[<h1 id="在centos7-4-1708部署mariadb-10-3-5-galera-cluster集群"><a href="#在centos7-4-1708部署mariadb-10-3-5-galera-cluster集群" class="headerlink" title="在centos7.4.1708部署mariadb-10.3.5 galera cluster集群"></a>在centos7.4.1708部署mariadb-10.3.5 galera cluster集群</h1><p>本人在阿里云ECS云主机上配置，cpu核数2  内存2G 带宽1M，3台阿里云主机所在的安全组要开放全部协议的所有端口（针对mariadb-galera-cluster集群中同步用到的端口来开放比较麻烦，涉及端口TCP 3306 4567 4568,4444,由于一些端口用的是tcp协议，一些端口用的UDP协议，所以建议这后面三个端口把tcp，udp都开放，如果你嫌麻烦，就索性开放所有协议所有端口）。</p><h2 id="1-ssh链接到三台云主机后，关闭SELinux-阿里云主机默认是已经关闭的-，通过配置文件来关闭-关闭防火墙，默认开启不启用。"><a href="#1-ssh链接到三台云主机后，关闭SELinux-阿里云主机默认是已经关闭的-，通过配置文件来关闭-关闭防火墙，默认开启不启用。" class="headerlink" title="1.ssh链接到三台云主机后，关闭SELinux(阿里云主机默认是已经关闭的)，通过配置文件来关闭,关闭防火墙，默认开启不启用。"></a>1.ssh链接到三台云主机后，关闭SELinux(阿里云主机默认是已经关闭的)，通过配置文件来关闭,关闭防火墙，默认开启不启用。</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sed</span> -i <span class="token string">"s/SELINUX=enforcing/SELINUX=disabled/g"</span> /etc/selinux/configsystemctl stop firewalld.servicesystemctl disable firewalld.serviceyum clean all</code></pre><a id="more"></a><h2 id="2-对三台云主机的-etc-hosts文件进行修改"><a href="#2-对三台云主机的-etc-hosts文件进行修改" class="headerlink" title="2.对三台云主机的/etc/hosts文件进行修改"></a>2.对三台云主机的/etc/hosts文件进行修改</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF47.75.71.94     node147.75.73.200    node247.75.74.157    node3EOF</span></code></pre><h3 id="在node1节点上测试ping"><a href="#在node1节点上测试ping" class="headerlink" title="在node1节点上测试ping"></a>在node1节点上测试ping</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">ping</span> -c 3 node2<span class="token function">ping</span> -c 3 node3</code></pre><h3 id="3-三节点都配置mariadb的yum源仓库，并安装软件包"><a href="#3-三节点都配置mariadb的yum源仓库，并安装软件包" class="headerlink" title="3.三节点都配置mariadb的yum源仓库，并安装软件包."></a>3.三节点都配置mariadb的yum源仓库，并安装软件包.</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span>/etc/yum.repos.d/mariadb.repos <span class="token operator">&lt;&lt;</span><span class="token string">EOFname = MariaDBbaseurl = http://yum.mariadb.org/10.3.5/centos74-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1EOF</span></code></pre><h3 id="安装软件包："><a href="#安装软件包：" class="headerlink" title="安装软件包："></a>安装软件包：</h3><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y MariaDB-server MariaDB-client galera</code></pre><h3 id="4-mariadb初始化三台节点（通过mysql-secure-installation命令配置密码）"><a href="#4-mariadb初始化三台节点（通过mysql-secure-installation命令配置密码）" class="headerlink" title="4.mariadb初始化三台节点（通过mysql-secure_installation命令配置密码）"></a>4.mariadb初始化三台节点（通过mysql-secure_installation命令配置密码）</h3><pre class=" language-bash"><code class="language-bash">systemctl start mariadbmysql_secure_installation（设置root密码为cntsp）mysql -uroot -pcntspgrant all privileges on *.* to root@<span class="token string">"%"</span> identified by <span class="token string">"cntsp"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#grant all privileges on *.* to sst_user@"%" identified by "cntsp";</span>flush privileges<span class="token punctuation">;</span>quitsystemctl stop mariadb  <span class="token punctuation">(</span>三台节点都stop<span class="token punctuation">)</span></code></pre><h3 id="5-配置galera"><a href="#5-配置galera" class="headerlink" title="5.配置galera"></a>5.配置galera</h3><p>node1节点配置在/etc/my.cnf.d/service.cnf中的galera块添加如下配置</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>galera<span class="token punctuation">]</span>wsrep_on<span class="token operator">=</span>ON wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address<span class="token operator">=</span><span class="token string">"gcomm://47.75.71.94,47.75.73.200,47.75.74.157"</span>wsrep_node_name<span class="token operator">=</span> node1wsrep_node_address<span class="token operator">=</span>47.75.71.94binlog_format<span class="token operator">=</span>rowdefault_storage_engine<span class="token operator">=</span>InnoDBwsrep_slave_threads<span class="token operator">=</span>1wsrep_sst_method<span class="token operator">=</span>rsync<span class="token comment" spellcheck="true">#wsrep_sst_auth=sst_user:cntsp</span></code></pre><p>node2节点配置在/etc/my.cnf.d/service.cnf中的galera块添加如下配置</p><pre class=" language-bash"><code class="language-bash">wsrep_on<span class="token operator">=</span>ON wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address<span class="token operator">=</span><span class="token string">"gcomm://47.75.71.94,47.75.73.200,47.75.74.157"</span>wsrep_node_name<span class="token operator">=</span> node2wsrep_node_address<span class="token operator">=</span>47.75.73.200binlog_format<span class="token operator">=</span>rowdefault_storage_engine<span class="token operator">=</span>InnoDBwsrep_slave_threads<span class="token operator">=</span>1wsrep_sst_method<span class="token operator">=</span>rsync<span class="token comment" spellcheck="true">#wsrep_sst_auth=sst_user:cntsp</span></code></pre><p>node3节点配置在/etc/my.cnf.d/service.cnf中的galera块添加如下配置</p><pre class=" language-bash"><code class="language-bash">wsrep_on<span class="token operator">=</span>ON wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address<span class="token operator">=</span><span class="token string">"gcomm://47.75.71.94,47.75.73.200,47.75.74.157"</span>wsrep_node_name<span class="token operator">=</span> node3wsrep_node_address<span class="token operator">=</span>47.75.74.157binlog_format<span class="token operator">=</span>rowdefault_storage_engine<span class="token operator">=</span>InnoDBwsrep_slave_threads<span class="token operator">=</span>1wsrep_sst_method<span class="token operator">=</span>rsync<span class="token comment" spellcheck="true">#wsrep_sst_auth=sst_user:cntsp</span></code></pre><h3 id="6-启动集群服务"><a href="#6-启动集群服务" class="headerlink" title="6.启动集群服务"></a>6.启动集群服务</h3><pre class=" language-bash"><code class="language-bash">在node1节点上执行：galera_new_cluster在node2、node3上依次执行：service mysql start初次启动要等大概15分钟，（我理解的是因为要做SST全量备份）<span class="token punctuation">(</span>20分钟后查看3306端口和4567端口是否起来<span class="token punctuation">)</span><span class="token function">netstat</span> -lntp</code></pre><h3 id="7-验证集群状态"><a href="#7-验证集群状态" class="headerlink" title="7.验证集群状态"></a>7.验证集群状态</h3><p>进入node1</p><pre class=" language-bash"><code class="language-bash">mysql -uroot -pcntspshow status like <span class="token string">'wsrep_ready'</span><span class="token punctuation">;</span>show status like <span class="token string">'wsrep_cluster_size'</span><span class="token punctuation">;</span>show status like <span class="token string">'wsrep%'</span><span class="token punctuation">;</span>在node1上创建数据库，看看node2 node3是否同步（已经验证过了）create database test1<span class="token punctuation">;</span></code></pre><h3 id="8-模拟脑裂后的处理"><a href="#8-模拟脑裂后的处理" class="headerlink" title="8.模拟脑裂后的处理"></a>8.模拟脑裂后的处理</h3><p>下面模拟在网络抖动发生丢包的情况下，两个节点失联导致脑裂。在node2和node3两个节点上分别执行：(这个centos7是用的firewalld防火墙)</p><pre class=" language-bash"><code class="language-bash">iptables -A INPUT -p tcp --sport 4567 -j DROPiptables -A INPUT -p tcp --dport 4567 -j DROP</code></pre><p>以上命令用来禁止wsrep全同步复制4567端口通信</p><h3 id="9-因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）"><a href="#9-因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）" class="headerlink" title="9.因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）"></a>9.因故障需要对集群的两个节点进行停机检查，重启服务后是否能同步数据（已经验证过了）</h3><h3 id="10-异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）"><a href="#10-异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）" class="headerlink" title="10.异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）"></a>10.异常处理：当机房突然停电，所有galera主机都非正常关机，来电后开机，回导致galera集群服务无法正常启动。如果处理？（未验证）</h3><pre class=" language-bash"><code class="language-bash">第1步：开启galera集群的群主主机的mariadb服务。第2步：开启galera集群的成员主机的mariadb服务。异常处理：galera集群的群主主机和成员主机的mysql服务无法启动，如何处理？解决方法一：第1步、删除garlera群主主机的/var/lib/mysql/grastate.dat状态文件/bin/galera_new_cluster启动服务。启动正常。登录并查看wsrep状态。第2步：删除galera成员主机中的/var/lib/mysql/grastate.dat状态文件systemctl restart mariadb重启服务。启动正常。登录并查看wsrep状态。解决方法二：第1步、修改garlera群主主机的/var/lib/mysql/grastate.dat状态文件中的0为1/bin/galera_new_cluster启动服务。启动正常。登录并查看wsrep状态。第2步：修改galera成员主机中的/var/lib/mysql/grastate.dat状态文件中的0为1systemctl restart mariadb重启服务。启动正常。登录并查看wsrep状态。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mariadb </tag>
            
            <tag> galera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb-galera-cluster</title>
      <link href="/2018/03/22/mariadb-galera-cluster/"/>
      <url>/2018/03/22/mariadb-galera-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="How-To-Create-a-Galera-Cluster-with-MariaDB-10-2-on-Aliyun-ECS-CentOS-Linux-release-7-2-1511-Core"><a href="#How-To-Create-a-Galera-Cluster-with-MariaDB-10-2-on-Aliyun-ECS-CentOS-Linux-release-7-2-1511-Core" class="headerlink" title="How To Create a Galera Cluster with MariaDB 10.2 on Aliyun ECS (CentOS Linux release 7.2.1511 (Core))"></a>How To Create a Galera Cluster with MariaDB 10.2 on Aliyun ECS (CentOS Linux release 7.2.1511 (Core))</h2><p>Aliyun ECS of Node (47.75.71.94、47.75.74.157、47.75.73.200)</p><h3 id="1-Check-the-SELINUX-the-default-of-ECS-is-the-disable-SELINUX"><a href="#1-Check-the-SELINUX-the-default-of-ECS-is-the-disable-SELINUX" class="headerlink" title="1) Check the SELINUX.(the default of ECS is the disable SELINUX )"></a>1) Check the SELINUX.(the default of ECS is the disable SELINUX )</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span>getenforceDisabled<span class="token operator">>></span><span class="token punctuation">(</span>if the results is enforcing or permissive,you need to change it to Disabled.<span class="token punctuation">)</span><span class="token operator">>></span>sed -i <span class="token string">'s#SELINUX=enforcing#SELINUX=disabled#g'</span> /etc/selinux/config</code></pre><h3 id="2-Disable-Firewall-or-open-required-ports-each-node"><a href="#2-Disable-Firewall-or-open-required-ports-each-node" class="headerlink" title="2) Disable Firewall or open required ports(each node)"></a>2) Disable Firewall or open required ports(each node)</h3><p>You can disable the firewall for now and enable it later and open the required ports or You can open the required ports.</p><h3 id="i-if-you-decieded-to-total-disable-firewall-for-now-use-below-statement"><a href="#i-if-you-decieded-to-total-disable-firewall-for-now-use-below-statement" class="headerlink" title="i)if you decieded to total disable firewall for now , use below statement"></a>i)if you decieded to total disable firewall for now , use below statement</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> systemctl stop    firewalld.service<span class="token operator">>></span> systemctl disable firewalld.service</code></pre><h4 id="ii-if-you-have-decieded-to-keep-the-firewall-enabled-then-you-have-to-run-below-commands-to-open-required-ports"><a href="#ii-if-you-have-decieded-to-keep-the-firewall-enabled-then-you-have-to-run-below-commands-to-open-required-ports" class="headerlink" title="ii)if you have decieded to keep the firewall enabled,then you have to run below commands to open required ports."></a>ii)if you have decieded to keep the firewall enabled,then you have to run below commands to open required ports.</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>3306/tcp --permanent<span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>4567/tcp --permanent<span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>4568/tcp --permanent<span class="token operator">>></span> firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>4444/tcp --permanent</code></pre><a id="more"></a><h3 id="3-Install-MariaDB-10-2-on-Each-Node"><a href="#3-Install-MariaDB-10-2-on-Each-Node" class="headerlink" title="3) Install MariaDB 10.2 on Each Node"></a>3) Install MariaDB 10.2 on Each Node</h3><p>first of all you need to install MariaDB 10.2 on each of the node.</p><h4 id="i-Check-the-Linux-Version"><a href="#i-Check-the-Linux-Version" class="headerlink" title="i)Check the Linux Version:"></a>i)Check the Linux Version:</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">cat</span> /etc/redhat-releaseCentOS Linux release 7.2.1511 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span></code></pre><h4 id="ii-Create-or-Edit-mariadb-repo-each-node"><a href="#ii-Create-or-Edit-mariadb-repo-each-node" class="headerlink" title="ii)Create or Edit mariadb.repo (each node):"></a>ii)Create or Edit mariadb.repo (each node):</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span>Create mariadb.repo <span class="token function">file</span> <span class="token keyword">in</span> /etc/yum.repos.d/<span class="token operator">>></span> <span class="token function">cat</span> <span class="token operator">>></span>/etc/yum.repos.d/mariadb.repo <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">>></span> <span class="token punctuation">[</span>mariadb<span class="token punctuation">]</span><span class="token operator">>></span> name <span class="token operator">=</span> MariaDB<span class="token operator">>></span> baseurl <span class="token operator">=</span> http://yum.mariadb.org/10.2/centos7-amd64<span class="token operator">>></span> gpgkey<span class="token operator">=</span>https://yum.mariadb.org/RPM-GPG-KEY-MariaDB<span class="token operator">>></span> gpgcheck<span class="token operator">=</span>1<span class="token operator">>></span> EOF</code></pre><h4 id="iii-Install-MariaDB-server-and-MariaDB-client-each-node"><a href="#iii-Install-MariaDB-server-and-MariaDB-client-each-node" class="headerlink" title="iii)Install MariaDB server and MariaDB client (each node)"></a>iii)Install MariaDB server and MariaDB client (each node)</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> yum <span class="token function">install</span> -y MariaDB-server MariaDB-client </code></pre><h4 id="iv-Start-MariaDB-service-each-node"><a href="#iv-Start-MariaDB-service-each-node" class="headerlink" title="iv)Start MariaDB service (each node)"></a>iv)Start MariaDB service (each node)</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> systemctl start mariadb.service</code></pre><h4 id="v-Run-Secure-Installation-each-node"><a href="#v-Run-Secure-Installation-each-node" class="headerlink" title="v) Run Secure Installation(each node)"></a>v) Run Secure Installation(each node)</h4><p>run the secure installation by using below statment to configure root password and other features.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> mysql_secure_installation</code></pre><h4 id="vi-Login-to-mariadb-by-using-root-each-node"><a href="#vi-Login-to-mariadb-by-using-root-each-node" class="headerlink" title="vi)Login to mariadb by using root.(each node)"></a>vi)Login to mariadb by using root.(each node)</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> mysql -uroot -p<span class="token operator">>></span> password：cntsp</code></pre><h4 id="vii-Stop-mariadb-service"><a href="#vii-Stop-mariadb-service" class="headerlink" title="vii)Stop mariadb service"></a>vii)Stop mariadb service</h4><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> systemctl stop mariadb.service</code></pre><h3 id="4-Make-changes-to-etc-my-cnf-d-server-cnf-file-each-one"><a href="#4-Make-changes-to-etc-my-cnf-d-server-cnf-file-each-one" class="headerlink" title="4) Make changes to /etc/my.cnf.d/server.cnf  file (each one)."></a>4) Make changes to /etc/my.cnf.d/server.cnf  file (each one).</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">cat</span> <span class="token operator">></span>/etc/my.cnf.d/server.cnf <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">>></span> <span class="token punctuation">[</span>galera<span class="token punctuation">]</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#Mandatory settings</span><span class="token operator">>></span> wsrep_on<span class="token operator">=</span>ON<span class="token operator">>></span> wsrep_cluster_address<span class="token operator">=</span>gcomm://mariadb-a1,mariadb-a2,mariadb-a3<span class="token operator">>></span> wsrep_node_address<span class="token operator">=</span>This Node IP<span class="token operator">>></span> wsrep_node_incoming_address<span class="token operator">=</span>This Node IP<span class="token operator">>></span> <span class="token comment" spellcheck="true"># wsrep_sst_donor =</span><span class="token operator">>></span> binlog_format<span class="token operator">=</span>row<span class="token operator">>></span> default_storage_engine<span class="token operator">=</span>InnoDB<span class="token operator">>></span> innodb_autoinc_lock_mode<span class="token operator">=</span>2<span class="token operator">>></span> innodb_buffer_pool_size<span class="token operator">=</span>122M<span class="token operator">>></span> wsrep_provider<span class="token operator">=</span>/usr/lib64/galera/libgalera_smm.so<span class="token operator">>></span> wsrep_cluster_name<span class="token operator">=</span><span class="token string">"YourClusterName"</span><span class="token operator">>></span> wsrep_slave_threads<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_certify_nonPK<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_max_ws_rows<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_max_ws_size<span class="token operator">=</span>2147483647<span class="token operator">>></span> wsrep_debug<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_convert_LOCK_to_trx<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_retry_autocommit<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_auto_increment_control<span class="token operator">=</span>1<span class="token operator">>></span> wsrep_drupal_282555_workaround<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_causal_reads<span class="token operator">=</span>0<span class="token operator">>></span> wsrep_notify_cmd<span class="token operator">=</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># Allow server to accept connections on all interfaces.</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#</span><span class="token operator">>></span> bind-address<span class="token operator">=</span>0.0.0.0<span class="token operator">>></span> <span class="token comment" spellcheck="true"># Optional setting</span><span class="token operator">>></span> wsrep_slave_threads<span class="token operator">=</span>1<span class="token operator">>></span> innodb_flush_log_at_trx_commit<span class="token operator">=</span>0<span class="token operator">>></span> <span class="token comment" spellcheck="true"># this is only for embedded server</span><span class="token operator">>></span> <span class="token punctuation">[</span>embedded<span class="token punctuation">]</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># This group is only read by MariaDB servers, not by MySQL.</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># If you use the same .cnf file for MySQL and MariaDB,</span><span class="token operator">>></span> <span class="token comment" spellcheck="true"># you can put MariaDB-only options here</span><span class="token operator">>></span> <span class="token punctuation">[</span>mariadb<span class="token punctuation">]</span><span class="token operator">>></span>EOF</code></pre><h3 id="5-Start-Service-on-first-node"><a href="#5-Start-Service-on-first-node" class="headerlink" title="5)Start Service on first node:"></a>5)Start Service on first node:</h3><p>To start the mariadb service on first Node, you will be using below command.DON’T USE SYSTEMCTL start mriadb.service or service mysql start</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> /usr/bin/galera_new_cluster</code></pre><p>service should start successfully.Once the mariadb service is started on first node,you can check the cluster information by connecting to mariadb.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> mysql -uroot -p<span class="token operator">>></span> password:cntsp<span class="token operator">>></span> MariaDB<span class="token operator">>></span> show status like <span class="token string">'wsrep_cluster_size%'</span><span class="token punctuation">;</span><span class="token operator">>></span> you should see the output as shown below.<span class="token operator">>></span> -------------------------<span class="token operator">>></span> Variable_name       Value<span class="token operator">>></span> -------------------------<span class="token operator">>></span> wsrep_cluster_size    1<span class="token operator">>></span> -------------------------</code></pre><h3 id="6-Join-2nd-and-3third-node"><a href="#6-Join-2nd-and-3third-node" class="headerlink" title="6)Join 2nd and 3third node"></a>6)Join 2nd and 3third node</h3><p>You are all set to join other nodes to Galera Cluster. Connect to second node and then start MariaDB service by using below statment.</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span> <span class="token function">sudo</span> systemctl start mariadb.service</code></pre><p>if the command line has some error,<br>like:Job for mariadb.service failed because a fatal signal was delivered to the control process. See “systemctl status mariadb.service” and “journalctl -xe” for details.<br>journalctl -xe<br>WSREP: Failed to prepare for incremental state transfer: Local state UUID (00000000-0000-0000-0000-000000000000) does not match group state UUID (a25a4592-2c4<br>repeat the commands on all the nodes.Once the mariadb service is started on all the Nodes, you can check Galera cluster size again to make sure all the nodes are part of cluster by running below statment.<br>mysql -uroot -p -e “SHOW STATUS LIKE ‘wsrep_cluster_size’”</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mariadb集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-firewall</title>
      <link href="/2017/07/10/centos7-firewall/"/>
      <url>/2017/07/10/centos7-firewall/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7系统上firewalld的坑"><a href="#centos7系统上firewalld的坑" class="headerlink" title="centos7系统上firewalld的坑"></a>centos7系统上firewalld的坑</h1><p>事故：线上环境中部署的是docker(事先不知道容器的ip地址转发依赖于防火墙)容器，并使用rancher(docker web管理工具)管理的，当自己由于部署zabbix_agentd把防火墙关闭时，容器里的resin服务都不可以访问了<br>处理过程：立即启动防火墙，然后在rancher web管理界面重启容器</p><h1 id="在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd-command-或firewall-config-gui-来动态的管理kernel-netfilter的临时或永久的接口规则，并实时生效而无需重启服务"><a href="#在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd-command-或firewall-config-gui-来动态的管理kernel-netfilter的临时或永久的接口规则，并实时生效而无需重启服务" class="headerlink" title="在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd(command)或firewall-config(gui)来动态的管理kernel netfilter的临时或永久的接口规则，并实时生效而无需重启服务"></a>在CentOS7中，引入Firewalld，防火墙守护firewalld服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持ipv4与ipv6，并支持网桥，采用firewall-cmd(command)或firewall-config(gui)来动态的管理kernel netfilter的临时或永久的接口规则，并实时生效而无需重启服务</h1><a id="more"></a><h2 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h2><p>Firewall 能将不同的网络连接归类到不同的信任级别，Zone提供了一下几个级别</p><blockquote><ul><li>drop:丢弃所有进入的包，而不给出任何响应</li><li>block:拒绝所有外部发起的连接，允许内部发起的连接</li><li>public:允许指定的进入连接</li><li>external:同上，对伪装的进入连接，一般用于路由转发</li><li>dmz:允许受限制的进入连接</li><li>work:允许受信任的计算机被限制的进入连接，类似workgroup</li><li>home:同上，类似homegroup</li><li>internal:同上，范围针对所有互联网用户</li><li>trusted:信任所有连接</li></ul></blockquote><h2 id="过滤规则"><a href="#过滤规则" class="headerlink" title="过滤规则"></a>过滤规则</h2><blockquote><ul><li>source:根据源地址过滤</li><li>interface:根据网卡过滤</li><li>service:根据服务名过滤</li><li>port:根据端口过滤</li><li>icmp-block:icmp报文过滤，按照icmp类型配置</li><li>masquerade:ip地址伪装</li><li>forward-port:端口转发</li><li>rule:自定义规则<br>其中，过滤规则的优先级遵循如下顺序</li></ul><p>1.source<br>2.interface<br>3.firewalld.conf</p></blockquote><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><pre class=" language-bash"><code class="language-bash">systemctl start   firewalld    <span class="token comment" spellcheck="true">#启动</span>systemctl <span class="token function">enable</span>  firewalld    <span class="token comment" spellcheck="true">#开机启动</span>systemctl stop    firewalld    <span class="token comment" spellcheck="true">#关闭</span>systemctl disable firewalld    <span class="token comment" spellcheck="true">#取消开机启动</span></code></pre><p>具体的规则管理，可以使用firewall-cmd，具体的使用方法可以</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --help--zone<span class="token operator">=</span>NAME       <span class="token comment" spellcheck="true">#指定 zone</span>--permanent       <span class="token comment" spellcheck="true">#永久修改，--reload 后生效</span>--timeout<span class="token operator">=</span>seconds <span class="token comment" spellcheck="true">#持续效果，到期后自动移除，用于调试，不能与--permanent 同时使用</span></code></pre><h2 id="1-查看规则"><a href="#1-查看规则" class="headerlink" title="1 查看规则"></a>1 查看规则</h2><p>查看运行状态</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --state</code></pre><p>查看已被激活的Zone信息</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-active-zonepublic   interfaces:eth0 eth1</code></pre><p>查看指定级别的接口</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-interfaceseth0</code></pre><p>查看指定级别的所有信息，譬如public</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-allpublic <span class="token punctuation">(</span>default,active<span class="token punctuation">)</span>  interfaces：eth0  sources:  ports:  masquerade:no  forward-ports:  icmp-blocks:  rich rules:</code></pre><p>查看所有级别被允许的信息</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-service</code></pre><p>查看重启后所有Zones级别中被允许的服务，即永久放行的服务</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-service --permanent</code></pre><h2 id="2-管理规则"><a href="#2-管理规则" class="headerlink" title="2 管理规则"></a>2 管理规则</h2><pre class=" language-bash"><code class="language-bash">firewall-cmd --panic-on          <span class="token comment" spellcheck="true">#丢弃</span>firewall-cmd --panic-off         <span class="token comment" spellcheck="true">#取消丢弃</span>firewall-cmd --reload            <span class="token comment" spellcheck="true">#更新规则，不重启服务</span>firewall-cmd --complete-reload   <span class="token comment" spellcheck="true">#更新规则，重启服务</span></code></pre><p>添加某接口至某信任等级，譬如添加eth0至public，永久修改</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>public --add-interface<span class="token operator">=</span>eth0 --permanent</code></pre><p>设置public为默认的信任级别</p><h3 id="a-管理端口"><a href="#a-管理端口" class="headerlink" title="a 管理端口"></a>a 管理端口</h3><p>列出dmz 级别的被允许的进入端口</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>dmz --list-ports</code></pre><p>允许tcp端口8080至dmz级别</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>dmz --add-port<span class="token operator">=</span>8080/tcp</code></pre><p>允许某范围的udp端口至public级别，并永久生效</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>10050-10051/udp --permanent</code></pre><h3 id="b-网卡接口"><a href="#b-网卡接口" class="headerlink" title="b 网卡接口"></a>b 网卡接口</h3><p>列出public zone所有网卡</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-interfaces</code></pre><p>将eth0添加至public zone,永久</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --permanent --add-interface<span class="token operator">=</span>eth0</code></pre><p>eth0存在与public zone，将该网卡添加至work zone，并将之从public zone中删除</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>work --permanent --change-interface<span class="token operator">=</span>eth0</code></pre><p>删除public zone中的eth0，永久</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --permanent --remove-interface<span class="token operator">=</span>eth0</code></pre><h3 id="c-管理服务"><a href="#c-管理服务" class="headerlink" title="c 管理服务"></a>c 管理服务</h3><p>添加smtp服务至work zone</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>work --add-service<span class="token operator">=</span>smtp</code></pre><p>移除work zone中的smtp服务</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>work --remove-service<span class="token operator">=</span>smtp</code></pre><h3 id="d-配置external-zone中的ip地址伪装"><a href="#d-配置external-zone中的ip地址伪装" class="headerlink" title="d 配置external zone中的ip地址伪装"></a>d 配置external zone中的ip地址伪装</h3><p>查看</p><pre class=" language-bash"><code class="language-bash">firewall-cmd  --zone<span class="token operator">=</span>external --query-masquerade</code></pre><p>打开伪装</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>external --add-masquerade</code></pre><p>关闭伪装</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>external --remove-masquerade</code></pre><h3 id="e-配置public-zone的端口转发"><a href="#e-配置public-zone的端口转发" class="headerlink" title="e 配置public zone的端口转发"></a>e 配置public zone的端口转发</h3><p>打开端口转发，则需要先</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-forward-port<span class="token operator">=</span>port<span class="token operator">=</span>22:proto<span class="token operator">=</span>tcp:toport<span class="token operator">=</span>3753</code></pre><p>转发22端口数据至另一个ip相同端口上</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-forward-port<span class="token operator">=</span>port<span class="token operator">=</span>22:proto<span class="token operator">=</span>tcp:toaddr<span class="token operator">=</span>192.168.1.100</code></pre><p>转发 22 端口数据至另一 ip 的 2055 端口上</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-forward-port<span class="token operator">=</span>port<span class="token operator">=</span>22:proto<span class="token operator">=</span>tcp:toport<span class="token operator">=</span>2055:toaddr<span class="token operator">=</span>192.168.1.100</code></pre><h3 id="f-配置public-zone的icmp"><a href="#f-配置public-zone的icmp" class="headerlink" title="f 配置public zone的icmp"></a>f 配置public zone的icmp</h3><p>查看所有支持的icmp类型</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --get-icmptypesdestination-unreachable echo-reply echo-request parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded</code></pre><p>列出</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --list-icmp-blocks</code></pre><p>添加echo-request屏蔽</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-icmp-block<span class="token operator">=</span>echo-request <span class="token punctuation">[</span>--timeout<span class="token operator">=</span>seconds<span class="token punctuation">]</span></code></pre><p>移除 echo-reply 屏蔽</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --remove-icmp-block<span class="token operator">=</span>echo-reply</code></pre><h3 id="g-IP封禁"><a href="#g-IP封禁" class="headerlink" title="g IP封禁"></a>g IP封禁</h3><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --add-rich-rule<span class="token operator">=</span><span class="token string">"rule family='ipv4' source address='222.222.222.222' reject"</span></code></pre><p>当然，我们仍然可以通过 ipset 来封禁 ip<br>封禁 ip</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --zone<span class="token operator">=</span>public --new-ipset<span class="token operator">=</span>blacklist --type<span class="token operator">=</span>hash:ipfirewall-cmd --permanent --zone<span class="token operator">=</span>public --ipset<span class="token operator">=</span>blacklist --add-entry<span class="token operator">=</span>222.222.222.222</code></pre><p>封禁网段</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --zone<span class="token operator">=</span>public --new-ipset<span class="token operator">=</span>blacklist --type<span class="token operator">=</span>hash:netfirewall-cmd --permanent --zone<span class="token operator">=</span>public --ipset<span class="token operator">=</span>blacklist --add-entry<span class="token operator">=</span>222.222.222.0/24</code></pre><p>倒入 ipset 规则</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --permanent --zone<span class="token operator">=</span>public --new-ipset-from-file<span class="token operator">=</span>/path/blacklist.xml``<span class="token variable"><span class="token variable">`</span> <span class="token function">bash</span>然后封禁 blacklist<span class="token variable">`</span></span>`` <span class="token function">bash</span>firewall-cmd --permanent --zone<span class="token operator">=</span>public --add-rich-rule<span class="token operator">=</span><span class="token string">'rule source ipset=blacklist drop'</span></code></pre><p>重新载入以生效</p><pre class=" language-bash"><code class="language-bash">firewall-cmd --reload</code></pre><p><a href="https://havee.me/linux/2015-01/using-firewalls-on-centos-7.html" target="_blank" rel="noopener">文章转载至：</a></p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firewall </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
